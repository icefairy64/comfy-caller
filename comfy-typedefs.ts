import { ComfyNodeTypedInputRef, ComfyNode } from "./comfy-graph.ts"
import type { ComfyNodeTypedSourceRef } from "./comfy-graph.ts"

type MappedSources<TInputs> = {
	[K in keyof TInputs]: TInputs[K] extends (ComfyNodeTypedInputRef<infer T> | undefined) ? T | ComfyNodeTypedSourceRef<T> : never
}

const Symbol_ComfyValueType_MODEL = Symbol()
type ComfyValueType_MODEL = typeof Symbol_ComfyValueType_MODEL
const Symbol_ComfyValueType_CONDITIONING = Symbol()
type ComfyValueType_CONDITIONING = typeof Symbol_ComfyValueType_CONDITIONING
const Symbol_ComfyValueType_LATENT = Symbol()
type ComfyValueType_LATENT = typeof Symbol_ComfyValueType_LATENT
const Symbol_ComfyValueType_CLIP = Symbol()
type ComfyValueType_CLIP = typeof Symbol_ComfyValueType_CLIP
const Symbol_ComfyValueType_VAE = Symbol()
type ComfyValueType_VAE = typeof Symbol_ComfyValueType_VAE
const Symbol_ComfyValueType_IMAGE = Symbol()
type ComfyValueType_IMAGE = typeof Symbol_ComfyValueType_IMAGE
const Symbol_ComfyValueType_MASK = Symbol()
type ComfyValueType_MASK = typeof Symbol_ComfyValueType_MASK
const Symbol_ComfyValueType_P = Symbol()
type ComfyValueType_P = typeof Symbol_ComfyValueType_P
const Symbol_ComfyValueType_E = Symbol()
type ComfyValueType_E = typeof Symbol_ComfyValueType_E
const Symbol_ComfyValueType_COMBO = Symbol()
type ComfyValueType_COMBO = typeof Symbol_ComfyValueType_COMBO
const Symbol_ComfyValueType_CLIP_VISION = Symbol()
type ComfyValueType_CLIP_VISION = typeof Symbol_ComfyValueType_CLIP_VISION
const Symbol_ComfyValueType_STYLE_MODEL = Symbol()
type ComfyValueType_STYLE_MODEL = typeof Symbol_ComfyValueType_STYLE_MODEL
const Symbol_ComfyValueType_CLIP_VISION_OUTPUT = Symbol()
type ComfyValueType_CLIP_VISION_OUTPUT = typeof Symbol_ComfyValueType_CLIP_VISION_OUTPUT
const Symbol_ComfyValueType_CONTROL_NET = Symbol()
type ComfyValueType_CONTROL_NET = typeof Symbol_ComfyValueType_CONTROL_NET
const Symbol_ComfyValueType_GLIGEN = Symbol()
type ComfyValueType_GLIGEN = typeof Symbol_ComfyValueType_GLIGEN
const Symbol_ComfyValueType_LATENT_OPERATION = Symbol()
type ComfyValueType_LATENT_OPERATION = typeof Symbol_ComfyValueType_LATENT_OPERATION
const Symbol_ComfyValueType_UPSCALE_MODEL = Symbol()
type ComfyValueType_UPSCALE_MODEL = typeof Symbol_ComfyValueType_UPSCALE_MODEL
const Symbol_ComfyValueType_SAMPLER = Symbol()
type ComfyValueType_SAMPLER = typeof Symbol_ComfyValueType_SAMPLER
const Symbol_ComfyValueType_SIGMAS = Symbol()
type ComfyValueType_SIGMAS = typeof Symbol_ComfyValueType_SIGMAS
const Symbol_ComfyValueType_NOISE = Symbol()
type ComfyValueType_NOISE = typeof Symbol_ComfyValueType_NOISE
const Symbol_ComfyValueType_GUIDER = Symbol()
type ComfyValueType_GUIDER = typeof Symbol_ComfyValueType_GUIDER
const Symbol_ComfyValueType_SVG = Symbol()
type ComfyValueType_SVG = typeof Symbol_ComfyValueType_SVG
const Symbol_ComfyValueType_U = Symbol()
type ComfyValueType_U = typeof Symbol_ComfyValueType_U
const Symbol_ComfyValueType_LORA_MODEL = Symbol()
type ComfyValueType_LORA_MODEL = typeof Symbol_ComfyValueType_LORA_MODEL
const Symbol_ComfyValueType_LOSS_MAP = Symbol()
type ComfyValueType_LOSS_MAP = typeof Symbol_ComfyValueType_LOSS_MAP
const Symbol_ComfyValueType_PHOTOMAKER = Symbol()
type ComfyValueType_PHOTOMAKER = typeof Symbol_ComfyValueType_PHOTOMAKER
const Symbol_ComfyValueType_WEBCAM = Symbol()
type ComfyValueType_WEBCAM = typeof Symbol_ComfyValueType_WEBCAM
const Symbol_ComfyValueType_PROMPT = Symbol()
type ComfyValueType_PROMPT = typeof Symbol_ComfyValueType_PROMPT
const Symbol_ComfyValueType_EXTRA_PNGINFO = Symbol()
type ComfyValueType_EXTRA_PNGINFO = typeof Symbol_ComfyValueType_EXTRA_PNGINFO
const Symbol_ComfyValueType_HOOKS = Symbol()
type ComfyValueType_HOOKS = typeof Symbol_ComfyValueType_HOOKS
const Symbol_ComfyValueType_HOOK_KEYFRAMES = Symbol()
type ComfyValueType_HOOK_KEYFRAMES = typeof Symbol_ComfyValueType_HOOK_KEYFRAMES
const Symbol_ComfyValueType_FLOATS = Symbol()
type ComfyValueType_FLOATS = typeof Symbol_ComfyValueType_FLOATS
const Symbol_ComfyValueType_TIMESTEPS_RANGE = Symbol()
type ComfyValueType_TIMESTEPS_RANGE = typeof Symbol_ComfyValueType_TIMESTEPS_RANGE
const Symbol_ComfyValueType_LOAD_3D = Symbol()
type ComfyValueType_LOAD_3D = typeof Symbol_ComfyValueType_LOAD_3D
const Symbol_ComfyValueType_LOAD_3D_ANIMATION = Symbol()
type ComfyValueType_LOAD_3D_ANIMATION = typeof Symbol_ComfyValueType_LOAD_3D_ANIMATION
const Symbol_ComfyValueType_LOAD3D_CAMERA = Symbol()
type ComfyValueType_LOAD3D_CAMERA = typeof Symbol_ComfyValueType_LOAD3D_CAMERA
const Symbol_ComfyValueType_VIDEO = Symbol()
type ComfyValueType_VIDEO = typeof Symbol_ComfyValueType_VIDEO
const Symbol_ComfyValueType_AUDIO = Symbol()
type ComfyValueType_AUDIO = typeof Symbol_ComfyValueType_AUDIO
const Symbol_ComfyValueType_WAN_CAMERA_EMBEDDING = Symbol()
type ComfyValueType_WAN_CAMERA_EMBEDDING = typeof Symbol_ComfyValueType_WAN_CAMERA_EMBEDDING
const Symbol_ComfyValueType_AUDIO_ENCODER_OUTPUT = Symbol()
type ComfyValueType_AUDIO_ENCODER_OUTPUT = typeof Symbol_ComfyValueType_AUDIO_ENCODER_OUTPUT
const Symbol_ComfyValueType_VOXEL = Symbol()
type ComfyValueType_VOXEL = typeof Symbol_ComfyValueType_VOXEL
const Symbol_ComfyValueType_MESH = Symbol()
type ComfyValueType_MESH = typeof Symbol_ComfyValueType_MESH
const Symbol_ComfyValueType_$STAR = Symbol()
type ComfyValueType_$STAR = typeof Symbol_ComfyValueType_$STAR
const Symbol_ComfyValueType_MODEL_PATCH = Symbol()
type ComfyValueType_MODEL_PATCH = typeof Symbol_ComfyValueType_MODEL_PATCH
const Symbol_ComfyValueType_CLIPSEGMODEL = Symbol()
type ComfyValueType_CLIPSEGMODEL = typeof Symbol_ComfyValueType_CLIPSEGMODEL
const Symbol_ComfyValueType_BBOX = Symbol()
type ComfyValueType_BBOX = typeof Symbol_ComfyValueType_BBOX
const Symbol_ComfyValueType_S = Symbol()
type ComfyValueType_S = typeof Symbol_ComfyValueType_S
const Symbol_ComfyValueType_INDEXES = Symbol()
type ComfyValueType_INDEXES = typeof Symbol_ComfyValueType_INDEXES
const Symbol_ComfyValueType_CAMERACTRL_POSES = Symbol()
type ComfyValueType_CAMERACTRL_POSES = typeof Symbol_ComfyValueType_CAMERACTRL_POSES
const Symbol_ComfyValueType_NORMALIZED_AMPLITUDE = Symbol()
type ComfyValueType_NORMALIZED_AMPLITUDE = typeof Symbol_ComfyValueType_NORMALIZED_AMPLITUDE
const Symbol_ComfyValueType_SELECTEDDITBLOCKS = Symbol()
type ComfyValueType_SELECTEDDITBLOCKS = typeof Symbol_ComfyValueType_SELECTEDDITBLOCKS
const Symbol_ComfyValueType_CN_WEIGHTS_EXTRAS = Symbol()
type ComfyValueType_CN_WEIGHTS_EXTRAS = typeof Symbol_ComfyValueType_CN_WEIGHTS_EXTRAS
const Symbol_ComfyValueType_ACNAUTOSIZE = Symbol()
type ComfyValueType_ACNAUTOSIZE = typeof Symbol_ComfyValueType_ACNAUTOSIZE
const Symbol_ComfyValueType_TIMER = Symbol()
type ComfyValueType_TIMER = typeof Symbol_ComfyValueType_TIMER
const Symbol_ComfyValueType_TRACKING = Symbol()
type ComfyValueType_TRACKING = typeof Symbol_ComfyValueType_TRACKING
const Symbol_ComfyValueType_WANVAE = Symbol()
type ComfyValueType_WANVAE = typeof Symbol_ComfyValueType_WANVAE
const Symbol_ComfyValueType_WANTEXTENCODER = Symbol()
type ComfyValueType_WANTEXTENCODER = typeof Symbol_ComfyValueType_WANTEXTENCODER
const Symbol_ComfyValueType_WANVIDEOMODEL = Symbol()
type ComfyValueType_WANVIDEOMODEL = typeof Symbol_ComfyValueType_WANVIDEOMODEL
const Symbol_ComfyValueType_WANVIDIMAGE_CLIPEMBEDS = Symbol()
type ComfyValueType_WANVIDIMAGE_CLIPEMBEDS = typeof Symbol_ComfyValueType_WANVIDIMAGE_CLIPEMBEDS
const Symbol_ComfyValueType_WANVIDIMAGE_EMBEDS = Symbol()
type ComfyValueType_WANVIDIMAGE_EMBEDS = typeof Symbol_ComfyValueType_WANVIDIMAGE_EMBEDS
const Symbol_ComfyValueType_ADD_COND_LATENTS = Symbol()
type ComfyValueType_ADD_COND_LATENTS = typeof Symbol_ComfyValueType_ADD_COND_LATENTS
const Symbol_ComfyValueType_WANVIDEOTEXTEMBEDS = Symbol()
type ComfyValueType_WANVIDEOTEXTEMBEDS = typeof Symbol_ComfyValueType_WANVIDEOTEXTEMBEDS
const Symbol_ComfyValueType_BLOCKSWAPARGS = Symbol()
type ComfyValueType_BLOCKSWAPARGS = typeof Symbol_ComfyValueType_BLOCKSWAPARGS
const Symbol_ComfyValueType_WANVIDEOPROMPTEXTENDER_ARGS = Symbol()
type ComfyValueType_WANVIDEOPROMPTEXTENDER_ARGS = typeof Symbol_ComfyValueType_WANVIDEOPROMPTEXTENDER_ARGS
const Symbol_ComfyValueType_MTVCRAFTERMOTION = Symbol()
type ComfyValueType_MTVCRAFTERMOTION = typeof Symbol_ComfyValueType_MTVCRAFTERMOTION
const Symbol_ComfyValueType_CAMERAPOSES = Symbol()
type ComfyValueType_CAMERAPOSES = typeof Symbol_ComfyValueType_CAMERAPOSES
const Symbol_ComfyValueType_CACHEARGS = Symbol()
type ComfyValueType_CACHEARGS = typeof Symbol_ComfyValueType_CACHEARGS
const Symbol_ComfyValueType_SLGARGS = Symbol()
type ComfyValueType_SLGARGS = typeof Symbol_ComfyValueType_SLGARGS
const Symbol_ComfyValueType_EXPERIMENTALARGS = Symbol()
type ComfyValueType_EXPERIMENTALARGS = typeof Symbol_ComfyValueType_EXPERIMENTALARGS
const Symbol_ComfyValueType_UNIANIMATE_POSE = Symbol()
type ComfyValueType_UNIANIMATE_POSE = typeof Symbol_ComfyValueType_UNIANIMATE_POSE
const Symbol_ComfyValueType_WAV2VECMODEL = Symbol()
type ComfyValueType_WAV2VECMODEL = typeof Symbol_ComfyValueType_WAV2VECMODEL
const Symbol_ComfyValueType_FANTASYTALKINGMODEL = Symbol()
type ComfyValueType_FANTASYTALKINGMODEL = typeof Symbol_ComfyValueType_FANTASYTALKINGMODEL
const Symbol_ComfyValueType_WANCOMPILEARGS = Symbol()
type ComfyValueType_WANCOMPILEARGS = typeof Symbol_ComfyValueType_WANCOMPILEARGS
const Symbol_ComfyValueType_WANVIDEOCONTROLNET = Symbol()
type ComfyValueType_WANVIDEOCONTROLNET = typeof Symbol_ComfyValueType_WANVIDEOCONTROLNET
const Symbol_ComfyValueType_WANVIDLORA = Symbol()
type ComfyValueType_WANVIDLORA = typeof Symbol_ComfyValueType_WANVIDLORA
const Symbol_ComfyValueType_VRAM_MANAGEMENTARGS = Symbol()
type ComfyValueType_VRAM_MANAGEMENTARGS = typeof Symbol_ComfyValueType_VRAM_MANAGEMENTARGS
const Symbol_ComfyValueType_VACEPATH = Symbol()
type ComfyValueType_VACEPATH = typeof Symbol_ComfyValueType_VACEPATH
const Symbol_ComfyValueType_MULTITALKMODEL = Symbol()
type ComfyValueType_MULTITALKMODEL = typeof Symbol_ComfyValueType_MULTITALKMODEL
const Symbol_ComfyValueType_FANTASYPORTRAITMODEL = Symbol()
type ComfyValueType_FANTASYPORTRAITMODEL = typeof Symbol_ComfyValueType_FANTASYPORTRAITMODEL
const Symbol_ComfyValueType_SELECTEDBLOCKS = Symbol()
type ComfyValueType_SELECTEDBLOCKS = typeof Symbol_ComfyValueType_SELECTEDBLOCKS
const Symbol_ComfyValueType_POSE_KEYPOINT = Symbol()
type ComfyValueType_POSE_KEYPOINT = typeof Symbol_ComfyValueType_POSE_KEYPOINT
const Symbol_ComfyValueType_QWENMODEL = Symbol()
type ComfyValueType_QWENMODEL = typeof Symbol_ComfyValueType_QWENMODEL
const Symbol_ComfyValueType_NLFMODEL = Symbol()
type ComfyValueType_NLFMODEL = typeof Symbol_ComfyValueType_NLFMODEL
const Symbol_ComfyValueType_NLFPRED = Symbol()
type ComfyValueType_NLFPRED = typeof Symbol_ComfyValueType_NLFPRED
const Symbol_ComfyValueType_VQVAE = Symbol()
type ComfyValueType_VQVAE = typeof Symbol_ComfyValueType_VQVAE
const Symbol_ComfyValueType_FETAARGS = Symbol()
type ComfyValueType_FETAARGS = typeof Symbol_ComfyValueType_FETAARGS
const Symbol_ComfyValueType_WANVIDCONTEXT = Symbol()
type ComfyValueType_WANVIDCONTEXT = typeof Symbol_ComfyValueType_WANVIDCONTEXT
const Symbol_ComfyValueType_FLOWEDITARGS = Symbol()
type ComfyValueType_FLOWEDITARGS = typeof Symbol_ComfyValueType_FLOWEDITARGS
const Symbol_ComfyValueType_LOOPARGS = Symbol()
type ComfyValueType_LOOPARGS = typeof Symbol_ComfyValueType_LOOPARGS
const Symbol_ComfyValueType_FANTASYTALKING_EMBEDS = Symbol()
type ComfyValueType_FANTASYTALKING_EMBEDS = typeof Symbol_ComfyValueType_FANTASYTALKING_EMBEDS
const Symbol_ComfyValueType_UNI3C_EMBEDS = Symbol()
type ComfyValueType_UNI3C_EMBEDS = typeof Symbol_ComfyValueType_UNI3C_EMBEDS
const Symbol_ComfyValueType_MULTITALK_EMBEDS = Symbol()
type ComfyValueType_MULTITALK_EMBEDS = typeof Symbol_ComfyValueType_MULTITALK_EMBEDS
const Symbol_ComfyValueType_FREEINITARGS = Symbol()
type ComfyValueType_FREEINITARGS = typeof Symbol_ComfyValueType_FREEINITARGS
const Symbol_ComfyValueType_SAMPLER_ARGS = Symbol()
type ComfyValueType_SAMPLER_ARGS = typeof Symbol_ComfyValueType_SAMPLER_ARGS
const Symbol_ComfyValueType_LYNXRESAMPLER = Symbol()
type ComfyValueType_LYNXRESAMPLER = typeof Symbol_ComfyValueType_LYNXRESAMPLER
const Symbol_ComfyValueType_LYNXIP = Symbol()
type ComfyValueType_LYNXIP = typeof Symbol_ComfyValueType_LYNXIP
const Symbol_ComfyValueType_VHS_BatchManager = Symbol()
type ComfyValueType_VHS_BatchManager = typeof Symbol_ComfyValueType_VHS_BatchManager
const Symbol_ComfyValueType_VHS_AUDIO = Symbol()
type ComfyValueType_VHS_AUDIO = typeof Symbol_ComfyValueType_VHS_AUDIO
const Symbol_ComfyValueType_VHS_FILENAMES = Symbol()
type ComfyValueType_VHS_FILENAMES = typeof Symbol_ComfyValueType_VHS_FILENAMES
const Symbol_ComfyValueType_VHS_VIDEOINFO = Symbol()
type ComfyValueType_VHS_VIDEOINFO = typeof Symbol_ComfyValueType_VHS_VIDEOINFO
const Symbol_ComfyValueType_MULTIGPUDEVICE = Symbol()
type ComfyValueType_MULTIGPUDEVICE = typeof Symbol_ComfyValueType_MULTIGPUDEVICE

export class KSampler extends ComfyNode {
	classType: string = "KSampler"

	sockets: {
		inputs: Required<KSamplerInputs>
		outputs: {
			/** The denoised latent.*/
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"seed": new ComfyNodeTypedInputRef<number>(this, "seed"),
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"cfg": new ComfyNodeTypedInputRef<number>(this, "cfg"),
				"sampler_name": new ComfyNodeTypedInputRef<string>(this, "sampler_name"),
				"scheduler": new ComfyNodeTypedInputRef<string>(this, "scheduler"),
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"latent_image": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latent_image"),
				"denoise": new ComfyNodeTypedInputRef<number>(this, "denoise"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<KSamplerInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["seed"] === "object") {
			this.sockets.inputs["seed"].connectTo(sources["seed"])
		} else {
			this.sockets.inputs["seed"].value = sources["seed"]
		}

		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["cfg"] === "object") {
			this.sockets.inputs["cfg"].connectTo(sources["cfg"])
		} else {
			this.sockets.inputs["cfg"].value = sources["cfg"]
		}

		if (typeof sources["sampler_name"] === "object") {
			this.sockets.inputs["sampler_name"].connectTo(sources["sampler_name"])
		} else {
			this.sockets.inputs["sampler_name"].value = sources["sampler_name"]
		}

		if (typeof sources["scheduler"] === "object") {
			this.sockets.inputs["scheduler"].connectTo(sources["scheduler"])
		} else {
			this.sockets.inputs["scheduler"].value = sources["scheduler"]
		}

		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["latent_image"] === "object") {
			this.sockets.inputs["latent_image"].connectTo(sources["latent_image"])
		} else {
			this.sockets.inputs["latent_image"].value = sources["latent_image"]
		}

		if (typeof sources["denoise"] === "object") {
			this.sockets.inputs["denoise"].connectTo(sources["denoise"])
		} else {
			this.sockets.inputs["denoise"].value = sources["denoise"]
		}

	}
}

type KSamplerInputs = {
			/** The model used for denoising the input latent.*/
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** The random seed used for creating the noise.*/
			"seed": ComfyNodeTypedInputRef<number>
			/** The number of steps used in the denoising process.*/
			"steps": ComfyNodeTypedInputRef<number>
			/** The Classifier-Free Guidance scale balances creativity and adherence to the prompt. Higher values result in images more closely matching the prompt however too high values will negatively impact quality.*/
			"cfg": ComfyNodeTypedInputRef<number>
			/** The algorithm used when sampling, this can affect the quality, speed, and style of the generated output.*/
			"sampler_name": ComfyNodeTypedInputRef<string>
			/** The scheduler controls how noise is gradually removed to form the image.*/
			"scheduler": ComfyNodeTypedInputRef<string>
			/** The conditioning describing the attributes you want to include in the image.*/
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			/** The conditioning describing the attributes you want to exclude from the image.*/
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			/** The latent image to denoise.*/
			"latent_image": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** The amount of denoising applied, lower values will maintain the structure of the initial image allowing for image to image sampling.*/
			"denoise": ComfyNodeTypedInputRef<number>
}


export class CheckpointLoaderSimple extends ComfyNode {
	classType: string = "CheckpointLoaderSimple"

	sockets: {
		inputs: Required<CheckpointLoaderSimpleInputs>
		outputs: {
			/** The model used for denoising latents.*/
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
			/** The CLIP model used for encoding text prompts.*/
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
			/** The VAE model used for encoding and decoding images to and from latent space.*/
			VAE: ComfyNodeTypedSourceRef<ComfyValueType_VAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"ckpt_name": new ComfyNodeTypedInputRef<string>(this, "ckpt_name"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"VAE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CheckpointLoaderSimpleInputs>) {
		if (typeof sources["ckpt_name"] === "object") {
			this.sockets.inputs["ckpt_name"].connectTo(sources["ckpt_name"])
		} else {
			this.sockets.inputs["ckpt_name"].value = sources["ckpt_name"]
		}

	}
}

type CheckpointLoaderSimpleInputs = {
			/** The name of the checkpoint (model) to load.*/
			"ckpt_name": ComfyNodeTypedInputRef<string>
}


export class CLIPTextEncode extends ComfyNode {
	classType: string = "CLIPTextEncode"

	sockets: {
		inputs: Required<CLIPTextEncodeInputs>
		outputs: {
			/** A conditioning containing the embedded text used to guide the diffusion model.*/
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"text": new ComfyNodeTypedInputRef<string>(this, "text"),
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPTextEncodeInputs>) {
		if (typeof sources["text"] === "object") {
			this.sockets.inputs["text"].connectTo(sources["text"])
		} else {
			this.sockets.inputs["text"].value = sources["text"]
		}

		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

	}
}

type CLIPTextEncodeInputs = {
			/** The text to be encoded.*/
			"text": ComfyNodeTypedInputRef<string>
			/** The CLIP model used for encoding the text.*/
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
}


export class CLIPSetLastLayer extends ComfyNode {
	classType: string = "CLIPSetLastLayer"

	sockets: {
		inputs: Required<CLIPSetLastLayerInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"stop_at_clip_layer": new ComfyNodeTypedInputRef<number>(this, "stop_at_clip_layer"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPSetLastLayerInputs>) {
		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["stop_at_clip_layer"] === "object") {
			this.sockets.inputs["stop_at_clip_layer"].connectTo(sources["stop_at_clip_layer"])
		} else {
			this.sockets.inputs["stop_at_clip_layer"].value = sources["stop_at_clip_layer"]
		}

	}
}

type CLIPSetLastLayerInputs = {
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"stop_at_clip_layer": ComfyNodeTypedInputRef<number>
}


export class VAEDecode extends ComfyNode {
	classType: string = "VAEDecode"

	sockets: {
		inputs: Required<VAEDecodeInputs>
		outputs: {
			/** The decoded image.*/
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VAEDecodeInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

	}
}

type VAEDecodeInputs = {
			/** The latent to be decoded.*/
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** The VAE model used for decoding the latent.*/
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
}


export class VAEEncode extends ComfyNode {
	classType: string = "VAEEncode"

	sockets: {
		inputs: Required<VAEEncodeInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"pixels": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "pixels"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VAEEncodeInputs>) {
		if (typeof sources["pixels"] === "object") {
			this.sockets.inputs["pixels"].connectTo(sources["pixels"])
		} else {
			this.sockets.inputs["pixels"].value = sources["pixels"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

	}
}

type VAEEncodeInputs = {
			"pixels": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
}


export class VAEEncodeForInpaint extends ComfyNode {
	classType: string = "VAEEncodeForInpaint"

	sockets: {
		inputs: Required<VAEEncodeForInpaintInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"pixels": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "pixels"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"grow_mask_by": new ComfyNodeTypedInputRef<number>(this, "grow_mask_by"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VAEEncodeForInpaintInputs>) {
		if (typeof sources["pixels"] === "object") {
			this.sockets.inputs["pixels"].connectTo(sources["pixels"])
		} else {
			this.sockets.inputs["pixels"].value = sources["pixels"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["grow_mask_by"] === "object") {
			this.sockets.inputs["grow_mask_by"].connectTo(sources["grow_mask_by"])
		} else {
			this.sockets.inputs["grow_mask_by"].value = sources["grow_mask_by"]
		}

	}
}

type VAEEncodeForInpaintInputs = {
			"pixels": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"grow_mask_by": ComfyNodeTypedInputRef<number>
}


export class VAELoader extends ComfyNode {
	classType: string = "VAELoader"

	sockets: {
		inputs: Required<VAELoaderInputs>
		outputs: {
			VAE: ComfyNodeTypedSourceRef<ComfyValueType_VAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vae_name": new ComfyNodeTypedInputRef<string>(this, "vae_name"),
			},
			outputs: Object.create(Object.prototype, {
				"VAE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VAELoaderInputs>) {
		if (typeof sources["vae_name"] === "object") {
			this.sockets.inputs["vae_name"].connectTo(sources["vae_name"])
		} else {
			this.sockets.inputs["vae_name"].value = sources["vae_name"]
		}

	}
}

type VAELoaderInputs = {
			"vae_name": ComfyNodeTypedInputRef<string>
}


export class EmptyLatentImage extends ComfyNode {
	classType: string = "EmptyLatentImage"

	sockets: {
		inputs: Required<EmptyLatentImageInputs>
		outputs: {
			/** The empty latent image batch.*/
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<EmptyLatentImageInputs>) {
		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

	}
}

type EmptyLatentImageInputs = {
			/** The width of the latent images in pixels.*/
			"width": ComfyNodeTypedInputRef<number>
			/** The height of the latent images in pixels.*/
			"height": ComfyNodeTypedInputRef<number>
			/** The number of latent images in the batch.*/
			"batch_size": ComfyNodeTypedInputRef<number>
}


export class LatentUpscale extends ComfyNode {
	classType: string = "LatentUpscale"

	sockets: {
		inputs: Required<LatentUpscaleInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"upscale_method": new ComfyNodeTypedInputRef<string>(this, "upscale_method"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"crop": new ComfyNodeTypedInputRef<string>(this, "crop"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentUpscaleInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["upscale_method"] === "object") {
			this.sockets.inputs["upscale_method"].connectTo(sources["upscale_method"])
		} else {
			this.sockets.inputs["upscale_method"].value = sources["upscale_method"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["crop"] === "object") {
			this.sockets.inputs["crop"].connectTo(sources["crop"])
		} else {
			this.sockets.inputs["crop"].value = sources["crop"]
		}

	}
}

type LatentUpscaleInputs = {
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"upscale_method": ComfyNodeTypedInputRef<string>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"crop": ComfyNodeTypedInputRef<string>
}


export class LatentUpscaleBy extends ComfyNode {
	classType: string = "LatentUpscaleBy"

	sockets: {
		inputs: Required<LatentUpscaleByInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"upscale_method": new ComfyNodeTypedInputRef<string>(this, "upscale_method"),
				"scale_by": new ComfyNodeTypedInputRef<number>(this, "scale_by"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentUpscaleByInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["upscale_method"] === "object") {
			this.sockets.inputs["upscale_method"].connectTo(sources["upscale_method"])
		} else {
			this.sockets.inputs["upscale_method"].value = sources["upscale_method"]
		}

		if (typeof sources["scale_by"] === "object") {
			this.sockets.inputs["scale_by"].connectTo(sources["scale_by"])
		} else {
			this.sockets.inputs["scale_by"].value = sources["scale_by"]
		}

	}
}

type LatentUpscaleByInputs = {
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"upscale_method": ComfyNodeTypedInputRef<string>
			"scale_by": ComfyNodeTypedInputRef<number>
}


export class LatentFromBatch extends ComfyNode {
	classType: string = "LatentFromBatch"

	sockets: {
		inputs: Required<LatentFromBatchInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"batch_index": new ComfyNodeTypedInputRef<number>(this, "batch_index"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentFromBatchInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["batch_index"] === "object") {
			this.sockets.inputs["batch_index"].connectTo(sources["batch_index"])
		} else {
			this.sockets.inputs["batch_index"].value = sources["batch_index"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

	}
}

type LatentFromBatchInputs = {
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"batch_index": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
}


export class RepeatLatentBatch extends ComfyNode {
	classType: string = "RepeatLatentBatch"

	sockets: {
		inputs: Required<RepeatLatentBatchInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"amount": new ComfyNodeTypedInputRef<number>(this, "amount"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<RepeatLatentBatchInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["amount"] === "object") {
			this.sockets.inputs["amount"].connectTo(sources["amount"])
		} else {
			this.sockets.inputs["amount"].value = sources["amount"]
		}

	}
}

type RepeatLatentBatchInputs = {
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"amount": ComfyNodeTypedInputRef<number>
}


export class SaveImage extends ComfyNode {
	classType: string = "SaveImage"

	sockets: {
		inputs: Required<SaveImageInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_E>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<SaveImageInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type SaveImageInputs = {
			/** The images to save.*/
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** The prefix for the file to save. This may include formatting information such as %date:yyyy-MM-dd% or %Empty Latent Image.width% to include values from nodes.*/
			"filename_prefix": ComfyNodeTypedInputRef<string>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_E>
}


export class PreviewImage extends ComfyNode {
	classType: string = "PreviewImage"

	sockets: {
		inputs: Required<PreviewImageInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_E>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<PreviewImageInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type PreviewImageInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_E>
}


export class LoadImage extends ComfyNode {
	classType: string = "LoadImage"

	sockets: {
		inputs: Required<LoadImageInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<string>(this, "image"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoadImageInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

	}
}

type LoadImageInputs = {
			"image": ComfyNodeTypedInputRef<string>
}


export class LoadImageMask extends ComfyNode {
	classType: string = "LoadImageMask"

	sockets: {
		inputs: Required<LoadImageMaskInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<string>(this, "image"),
				"channel": new ComfyNodeTypedInputRef<string>(this, "channel"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoadImageMaskInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["channel"] === "object") {
			this.sockets.inputs["channel"].connectTo(sources["channel"])
		} else {
			this.sockets.inputs["channel"].value = sources["channel"]
		}

	}
}

type LoadImageMaskInputs = {
			"image": ComfyNodeTypedInputRef<string>
			"channel": ComfyNodeTypedInputRef<string>
}


export class LoadImageOutput extends ComfyNode {
	classType: string = "LoadImageOutput"

	sockets: {
		inputs: Required<LoadImageOutputInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "image"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoadImageOutputInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

	}
}

type LoadImageOutputInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class ImageScale extends ComfyNode {
	classType: string = "ImageScale"

	sockets: {
		inputs: Required<ImageScaleInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"upscale_method": new ComfyNodeTypedInputRef<string>(this, "upscale_method"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"crop": new ComfyNodeTypedInputRef<string>(this, "crop"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageScaleInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["upscale_method"] === "object") {
			this.sockets.inputs["upscale_method"].connectTo(sources["upscale_method"])
		} else {
			this.sockets.inputs["upscale_method"].value = sources["upscale_method"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["crop"] === "object") {
			this.sockets.inputs["crop"].connectTo(sources["crop"])
		} else {
			this.sockets.inputs["crop"].value = sources["crop"]
		}

	}
}

type ImageScaleInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"upscale_method": ComfyNodeTypedInputRef<string>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"crop": ComfyNodeTypedInputRef<string>
}


export class ImageScaleBy extends ComfyNode {
	classType: string = "ImageScaleBy"

	sockets: {
		inputs: Required<ImageScaleByInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"upscale_method": new ComfyNodeTypedInputRef<string>(this, "upscale_method"),
				"scale_by": new ComfyNodeTypedInputRef<number>(this, "scale_by"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageScaleByInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["upscale_method"] === "object") {
			this.sockets.inputs["upscale_method"].connectTo(sources["upscale_method"])
		} else {
			this.sockets.inputs["upscale_method"].value = sources["upscale_method"]
		}

		if (typeof sources["scale_by"] === "object") {
			this.sockets.inputs["scale_by"].connectTo(sources["scale_by"])
		} else {
			this.sockets.inputs["scale_by"].value = sources["scale_by"]
		}

	}
}

type ImageScaleByInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"upscale_method": ComfyNodeTypedInputRef<string>
			"scale_by": ComfyNodeTypedInputRef<number>
}


export class ImageInvert extends ComfyNode {
	classType: string = "ImageInvert"

	sockets: {
		inputs: Required<ImageInvertInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageInvertInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

	}
}

type ImageInvertInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class ImageBatch extends ComfyNode {
	classType: string = "ImageBatch"

	sockets: {
		inputs: Required<ImageBatchInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image1": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image1"),
				"image2": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image2"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageBatchInputs>) {
		if (typeof sources["image1"] === "object") {
			this.sockets.inputs["image1"].connectTo(sources["image1"])
		} else {
			this.sockets.inputs["image1"].value = sources["image1"]
		}

		if (typeof sources["image2"] === "object") {
			this.sockets.inputs["image2"].connectTo(sources["image2"])
		} else {
			this.sockets.inputs["image2"].value = sources["image2"]
		}

	}
}

type ImageBatchInputs = {
			"image1": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"image2": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class ImagePadForOutpaint extends ComfyNode {
	classType: string = "ImagePadForOutpaint"

	sockets: {
		inputs: Required<ImagePadForOutpaintInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"left": new ComfyNodeTypedInputRef<number>(this, "left"),
				"top": new ComfyNodeTypedInputRef<number>(this, "top"),
				"right": new ComfyNodeTypedInputRef<number>(this, "right"),
				"bottom": new ComfyNodeTypedInputRef<number>(this, "bottom"),
				"feathering": new ComfyNodeTypedInputRef<number>(this, "feathering"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImagePadForOutpaintInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["left"] === "object") {
			this.sockets.inputs["left"].connectTo(sources["left"])
		} else {
			this.sockets.inputs["left"].value = sources["left"]
		}

		if (typeof sources["top"] === "object") {
			this.sockets.inputs["top"].connectTo(sources["top"])
		} else {
			this.sockets.inputs["top"].value = sources["top"]
		}

		if (typeof sources["right"] === "object") {
			this.sockets.inputs["right"].connectTo(sources["right"])
		} else {
			this.sockets.inputs["right"].value = sources["right"]
		}

		if (typeof sources["bottom"] === "object") {
			this.sockets.inputs["bottom"].connectTo(sources["bottom"])
		} else {
			this.sockets.inputs["bottom"].value = sources["bottom"]
		}

		if (typeof sources["feathering"] === "object") {
			this.sockets.inputs["feathering"].connectTo(sources["feathering"])
		} else {
			this.sockets.inputs["feathering"].value = sources["feathering"]
		}

	}
}

type ImagePadForOutpaintInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"left": ComfyNodeTypedInputRef<number>
			"top": ComfyNodeTypedInputRef<number>
			"right": ComfyNodeTypedInputRef<number>
			"bottom": ComfyNodeTypedInputRef<number>
			"feathering": ComfyNodeTypedInputRef<number>
}


export class EmptyImage extends ComfyNode {
	classType: string = "EmptyImage"

	sockets: {
		inputs: Required<EmptyImageInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"color": new ComfyNodeTypedInputRef<number>(this, "color"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<EmptyImageInputs>) {
		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (typeof sources["color"] === "object") {
			this.sockets.inputs["color"].connectTo(sources["color"])
		} else {
			this.sockets.inputs["color"].value = sources["color"]
		}

	}
}

type EmptyImageInputs = {
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"color": ComfyNodeTypedInputRef<number>
}


export class ConditioningAverage extends ComfyNode {
	classType: string = "ConditioningAverage"

	sockets: {
		inputs: Required<ConditioningAverageInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning_to": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning_to"),
				"conditioning_from": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning_from"),
				"conditioning_to_strength": new ComfyNodeTypedInputRef<number>(this, "conditioning_to_strength"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ConditioningAverageInputs>) {
		if (typeof sources["conditioning_to"] === "object") {
			this.sockets.inputs["conditioning_to"].connectTo(sources["conditioning_to"])
		} else {
			this.sockets.inputs["conditioning_to"].value = sources["conditioning_to"]
		}

		if (typeof sources["conditioning_from"] === "object") {
			this.sockets.inputs["conditioning_from"].connectTo(sources["conditioning_from"])
		} else {
			this.sockets.inputs["conditioning_from"].value = sources["conditioning_from"]
		}

		if (typeof sources["conditioning_to_strength"] === "object") {
			this.sockets.inputs["conditioning_to_strength"].connectTo(sources["conditioning_to_strength"])
		} else {
			this.sockets.inputs["conditioning_to_strength"].value = sources["conditioning_to_strength"]
		}

	}
}

type ConditioningAverageInputs = {
			"conditioning_to": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"conditioning_from": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"conditioning_to_strength": ComfyNodeTypedInputRef<number>
}


export class ConditioningCombine extends ComfyNode {
	classType: string = "ConditioningCombine"

	sockets: {
		inputs: Required<ConditioningCombineInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning_1": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning_1"),
				"conditioning_2": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning_2"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ConditioningCombineInputs>) {
		if (typeof sources["conditioning_1"] === "object") {
			this.sockets.inputs["conditioning_1"].connectTo(sources["conditioning_1"])
		} else {
			this.sockets.inputs["conditioning_1"].value = sources["conditioning_1"]
		}

		if (typeof sources["conditioning_2"] === "object") {
			this.sockets.inputs["conditioning_2"].connectTo(sources["conditioning_2"])
		} else {
			this.sockets.inputs["conditioning_2"].value = sources["conditioning_2"]
		}

	}
}

type ConditioningCombineInputs = {
			"conditioning_1": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"conditioning_2": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
}


export class ConditioningConcat extends ComfyNode {
	classType: string = "ConditioningConcat"

	sockets: {
		inputs: Required<ConditioningConcatInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning_to": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning_to"),
				"conditioning_from": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning_from"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ConditioningConcatInputs>) {
		if (typeof sources["conditioning_to"] === "object") {
			this.sockets.inputs["conditioning_to"].connectTo(sources["conditioning_to"])
		} else {
			this.sockets.inputs["conditioning_to"].value = sources["conditioning_to"]
		}

		if (typeof sources["conditioning_from"] === "object") {
			this.sockets.inputs["conditioning_from"].connectTo(sources["conditioning_from"])
		} else {
			this.sockets.inputs["conditioning_from"].value = sources["conditioning_from"]
		}

	}
}

type ConditioningConcatInputs = {
			"conditioning_to": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"conditioning_from": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
}


export class ConditioningSetArea extends ComfyNode {
	classType: string = "ConditioningSetArea"

	sockets: {
		inputs: Required<ConditioningSetAreaInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"x": new ComfyNodeTypedInputRef<number>(this, "x"),
				"y": new ComfyNodeTypedInputRef<number>(this, "y"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ConditioningSetAreaInputs>) {
		if (typeof sources["conditioning"] === "object") {
			this.sockets.inputs["conditioning"].connectTo(sources["conditioning"])
		} else {
			this.sockets.inputs["conditioning"].value = sources["conditioning"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["x"] === "object") {
			this.sockets.inputs["x"].connectTo(sources["x"])
		} else {
			this.sockets.inputs["x"].value = sources["x"]
		}

		if (typeof sources["y"] === "object") {
			this.sockets.inputs["y"].connectTo(sources["y"])
		} else {
			this.sockets.inputs["y"].value = sources["y"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

	}
}

type ConditioningSetAreaInputs = {
			"conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"x": ComfyNodeTypedInputRef<number>
			"y": ComfyNodeTypedInputRef<number>
			"strength": ComfyNodeTypedInputRef<number>
}


export class ConditioningSetAreaPercentage extends ComfyNode {
	classType: string = "ConditioningSetAreaPercentage"

	sockets: {
		inputs: Required<ConditioningSetAreaPercentageInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"x": new ComfyNodeTypedInputRef<number>(this, "x"),
				"y": new ComfyNodeTypedInputRef<number>(this, "y"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ConditioningSetAreaPercentageInputs>) {
		if (typeof sources["conditioning"] === "object") {
			this.sockets.inputs["conditioning"].connectTo(sources["conditioning"])
		} else {
			this.sockets.inputs["conditioning"].value = sources["conditioning"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["x"] === "object") {
			this.sockets.inputs["x"].connectTo(sources["x"])
		} else {
			this.sockets.inputs["x"].value = sources["x"]
		}

		if (typeof sources["y"] === "object") {
			this.sockets.inputs["y"].connectTo(sources["y"])
		} else {
			this.sockets.inputs["y"].value = sources["y"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

	}
}

type ConditioningSetAreaPercentageInputs = {
			"conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"x": ComfyNodeTypedInputRef<number>
			"y": ComfyNodeTypedInputRef<number>
			"strength": ComfyNodeTypedInputRef<number>
}


export class ConditioningSetAreaStrength extends ComfyNode {
	classType: string = "ConditioningSetAreaStrength"

	sockets: {
		inputs: Required<ConditioningSetAreaStrengthInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ConditioningSetAreaStrengthInputs>) {
		if (typeof sources["conditioning"] === "object") {
			this.sockets.inputs["conditioning"].connectTo(sources["conditioning"])
		} else {
			this.sockets.inputs["conditioning"].value = sources["conditioning"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

	}
}

type ConditioningSetAreaStrengthInputs = {
			"conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"strength": ComfyNodeTypedInputRef<number>
}


export class ConditioningSetMask extends ComfyNode {
	classType: string = "ConditioningSetMask"

	sockets: {
		inputs: Required<ConditioningSetMaskInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"set_cond_area": new ComfyNodeTypedInputRef<string>(this, "set_cond_area"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ConditioningSetMaskInputs>) {
		if (typeof sources["conditioning"] === "object") {
			this.sockets.inputs["conditioning"].connectTo(sources["conditioning"])
		} else {
			this.sockets.inputs["conditioning"].value = sources["conditioning"]
		}

		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (typeof sources["set_cond_area"] === "object") {
			this.sockets.inputs["set_cond_area"].connectTo(sources["set_cond_area"])
		} else {
			this.sockets.inputs["set_cond_area"].value = sources["set_cond_area"]
		}

	}
}

type ConditioningSetMaskInputs = {
			"conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"strength": ComfyNodeTypedInputRef<number>
			"set_cond_area": ComfyNodeTypedInputRef<string>
}


export class KSamplerAdvanced extends ComfyNode {
	classType: string = "KSamplerAdvanced"

	sockets: {
		inputs: Required<KSamplerAdvancedInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"add_noise": new ComfyNodeTypedInputRef<string>(this, "add_noise"),
				"noise_seed": new ComfyNodeTypedInputRef<number>(this, "noise_seed"),
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"cfg": new ComfyNodeTypedInputRef<number>(this, "cfg"),
				"sampler_name": new ComfyNodeTypedInputRef<string>(this, "sampler_name"),
				"scheduler": new ComfyNodeTypedInputRef<string>(this, "scheduler"),
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"latent_image": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latent_image"),
				"start_at_step": new ComfyNodeTypedInputRef<number>(this, "start_at_step"),
				"end_at_step": new ComfyNodeTypedInputRef<number>(this, "end_at_step"),
				"return_with_leftover_noise": new ComfyNodeTypedInputRef<string>(this, "return_with_leftover_noise"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<KSamplerAdvancedInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["add_noise"] === "object") {
			this.sockets.inputs["add_noise"].connectTo(sources["add_noise"])
		} else {
			this.sockets.inputs["add_noise"].value = sources["add_noise"]
		}

		if (typeof sources["noise_seed"] === "object") {
			this.sockets.inputs["noise_seed"].connectTo(sources["noise_seed"])
		} else {
			this.sockets.inputs["noise_seed"].value = sources["noise_seed"]
		}

		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["cfg"] === "object") {
			this.sockets.inputs["cfg"].connectTo(sources["cfg"])
		} else {
			this.sockets.inputs["cfg"].value = sources["cfg"]
		}

		if (typeof sources["sampler_name"] === "object") {
			this.sockets.inputs["sampler_name"].connectTo(sources["sampler_name"])
		} else {
			this.sockets.inputs["sampler_name"].value = sources["sampler_name"]
		}

		if (typeof sources["scheduler"] === "object") {
			this.sockets.inputs["scheduler"].connectTo(sources["scheduler"])
		} else {
			this.sockets.inputs["scheduler"].value = sources["scheduler"]
		}

		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["latent_image"] === "object") {
			this.sockets.inputs["latent_image"].connectTo(sources["latent_image"])
		} else {
			this.sockets.inputs["latent_image"].value = sources["latent_image"]
		}

		if (typeof sources["start_at_step"] === "object") {
			this.sockets.inputs["start_at_step"].connectTo(sources["start_at_step"])
		} else {
			this.sockets.inputs["start_at_step"].value = sources["start_at_step"]
		}

		if (typeof sources["end_at_step"] === "object") {
			this.sockets.inputs["end_at_step"].connectTo(sources["end_at_step"])
		} else {
			this.sockets.inputs["end_at_step"].value = sources["end_at_step"]
		}

		if (typeof sources["return_with_leftover_noise"] === "object") {
			this.sockets.inputs["return_with_leftover_noise"].connectTo(sources["return_with_leftover_noise"])
		} else {
			this.sockets.inputs["return_with_leftover_noise"].value = sources["return_with_leftover_noise"]
		}

	}
}

type KSamplerAdvancedInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"add_noise": ComfyNodeTypedInputRef<string>
			"noise_seed": ComfyNodeTypedInputRef<number>
			"steps": ComfyNodeTypedInputRef<number>
			"cfg": ComfyNodeTypedInputRef<number>
			"sampler_name": ComfyNodeTypedInputRef<string>
			"scheduler": ComfyNodeTypedInputRef<string>
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"latent_image": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"start_at_step": ComfyNodeTypedInputRef<number>
			"end_at_step": ComfyNodeTypedInputRef<number>
			"return_with_leftover_noise": ComfyNodeTypedInputRef<string>
}


export class SetLatentNoiseMask extends ComfyNode {
	classType: string = "SetLatentNoiseMask"

	sockets: {
		inputs: Required<SetLatentNoiseMaskInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SetLatentNoiseMaskInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

	}
}

type SetLatentNoiseMaskInputs = {
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class LatentComposite extends ComfyNode {
	classType: string = "LatentComposite"

	sockets: {
		inputs: Required<LatentCompositeInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples_to": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples_to"),
				"samples_from": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples_from"),
				"x": new ComfyNodeTypedInputRef<number>(this, "x"),
				"y": new ComfyNodeTypedInputRef<number>(this, "y"),
				"feather": new ComfyNodeTypedInputRef<number>(this, "feather"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentCompositeInputs>) {
		if (typeof sources["samples_to"] === "object") {
			this.sockets.inputs["samples_to"].connectTo(sources["samples_to"])
		} else {
			this.sockets.inputs["samples_to"].value = sources["samples_to"]
		}

		if (typeof sources["samples_from"] === "object") {
			this.sockets.inputs["samples_from"].connectTo(sources["samples_from"])
		} else {
			this.sockets.inputs["samples_from"].value = sources["samples_from"]
		}

		if (typeof sources["x"] === "object") {
			this.sockets.inputs["x"].connectTo(sources["x"])
		} else {
			this.sockets.inputs["x"].value = sources["x"]
		}

		if (typeof sources["y"] === "object") {
			this.sockets.inputs["y"].connectTo(sources["y"])
		} else {
			this.sockets.inputs["y"].value = sources["y"]
		}

		if (typeof sources["feather"] === "object") {
			this.sockets.inputs["feather"].connectTo(sources["feather"])
		} else {
			this.sockets.inputs["feather"].value = sources["feather"]
		}

	}
}

type LatentCompositeInputs = {
			"samples_to": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"samples_from": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"x": ComfyNodeTypedInputRef<number>
			"y": ComfyNodeTypedInputRef<number>
			"feather": ComfyNodeTypedInputRef<number>
}


export class LatentBlend extends ComfyNode {
	classType: string = "LatentBlend"

	sockets: {
		inputs: Required<LatentBlendInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples1": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples1"),
				"samples2": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples2"),
				"blend_factor": new ComfyNodeTypedInputRef<number>(this, "blend_factor"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentBlendInputs>) {
		if (typeof sources["samples1"] === "object") {
			this.sockets.inputs["samples1"].connectTo(sources["samples1"])
		} else {
			this.sockets.inputs["samples1"].value = sources["samples1"]
		}

		if (typeof sources["samples2"] === "object") {
			this.sockets.inputs["samples2"].connectTo(sources["samples2"])
		} else {
			this.sockets.inputs["samples2"].value = sources["samples2"]
		}

		if (typeof sources["blend_factor"] === "object") {
			this.sockets.inputs["blend_factor"].connectTo(sources["blend_factor"])
		} else {
			this.sockets.inputs["blend_factor"].value = sources["blend_factor"]
		}

	}
}

type LatentBlendInputs = {
			"samples1": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"samples2": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"blend_factor": ComfyNodeTypedInputRef<number>
}


export class LatentRotate extends ComfyNode {
	classType: string = "LatentRotate"

	sockets: {
		inputs: Required<LatentRotateInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"rotation": new ComfyNodeTypedInputRef<string>(this, "rotation"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentRotateInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["rotation"] === "object") {
			this.sockets.inputs["rotation"].connectTo(sources["rotation"])
		} else {
			this.sockets.inputs["rotation"].value = sources["rotation"]
		}

	}
}

type LatentRotateInputs = {
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"rotation": ComfyNodeTypedInputRef<string>
}


export class LatentFlip extends ComfyNode {
	classType: string = "LatentFlip"

	sockets: {
		inputs: Required<LatentFlipInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"flip_method": new ComfyNodeTypedInputRef<string>(this, "flip_method"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentFlipInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["flip_method"] === "object") {
			this.sockets.inputs["flip_method"].connectTo(sources["flip_method"])
		} else {
			this.sockets.inputs["flip_method"].value = sources["flip_method"]
		}

	}
}

type LatentFlipInputs = {
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"flip_method": ComfyNodeTypedInputRef<string>
}


export class LatentCrop extends ComfyNode {
	classType: string = "LatentCrop"

	sockets: {
		inputs: Required<LatentCropInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"x": new ComfyNodeTypedInputRef<number>(this, "x"),
				"y": new ComfyNodeTypedInputRef<number>(this, "y"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentCropInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["x"] === "object") {
			this.sockets.inputs["x"].connectTo(sources["x"])
		} else {
			this.sockets.inputs["x"].value = sources["x"]
		}

		if (typeof sources["y"] === "object") {
			this.sockets.inputs["y"].connectTo(sources["y"])
		} else {
			this.sockets.inputs["y"].value = sources["y"]
		}

	}
}

type LatentCropInputs = {
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"x": ComfyNodeTypedInputRef<number>
			"y": ComfyNodeTypedInputRef<number>
}


export class LoraLoader extends ComfyNode {
	classType: string = "LoraLoader"

	sockets: {
		inputs: Required<LoraLoaderInputs>
		outputs: {
			/** The modified diffusion model.*/
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
			/** The modified CLIP model.*/
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"lora_name": new ComfyNodeTypedInputRef<string>(this, "lora_name"),
				"strength_model": new ComfyNodeTypedInputRef<number>(this, "strength_model"),
				"strength_clip": new ComfyNodeTypedInputRef<number>(this, "strength_clip"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoraLoaderInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["lora_name"] === "object") {
			this.sockets.inputs["lora_name"].connectTo(sources["lora_name"])
		} else {
			this.sockets.inputs["lora_name"].value = sources["lora_name"]
		}

		if (typeof sources["strength_model"] === "object") {
			this.sockets.inputs["strength_model"].connectTo(sources["strength_model"])
		} else {
			this.sockets.inputs["strength_model"].value = sources["strength_model"]
		}

		if (typeof sources["strength_clip"] === "object") {
			this.sockets.inputs["strength_clip"].connectTo(sources["strength_clip"])
		} else {
			this.sockets.inputs["strength_clip"].value = sources["strength_clip"]
		}

	}
}

type LoraLoaderInputs = {
			/** The diffusion model the LoRA will be applied to.*/
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** The CLIP model the LoRA will be applied to.*/
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			/** The name of the LoRA.*/
			"lora_name": ComfyNodeTypedInputRef<string>
			/** How strongly to modify the diffusion model. This value can be negative.*/
			"strength_model": ComfyNodeTypedInputRef<number>
			/** How strongly to modify the CLIP model. This value can be negative.*/
			"strength_clip": ComfyNodeTypedInputRef<number>
}


export class CLIPLoader extends ComfyNode {
	classType: string = "CLIPLoader"

	sockets: {
		inputs: Required<CLIPLoaderInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name": new ComfyNodeTypedInputRef<string>(this, "clip_name"),
				"type": new ComfyNodeTypedInputRef<string>(this, "type"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPLoaderInputs>) {
		if (typeof sources["clip_name"] === "object") {
			this.sockets.inputs["clip_name"].connectTo(sources["clip_name"])
		} else {
			this.sockets.inputs["clip_name"].value = sources["clip_name"]
		}

		if (typeof sources["type"] === "object") {
			this.sockets.inputs["type"].connectTo(sources["type"])
		} else {
			this.sockets.inputs["type"].value = sources["type"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type CLIPLoaderInputs = {
			"clip_name": ComfyNodeTypedInputRef<string>
			"type": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
}


export class UNETLoader extends ComfyNode {
	classType: string = "UNETLoader"

	sockets: {
		inputs: Required<UNETLoaderInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"unet_name": new ComfyNodeTypedInputRef<string>(this, "unet_name"),
				"weight_dtype": new ComfyNodeTypedInputRef<string>(this, "weight_dtype"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<UNETLoaderInputs>) {
		if (typeof sources["unet_name"] === "object") {
			this.sockets.inputs["unet_name"].connectTo(sources["unet_name"])
		} else {
			this.sockets.inputs["unet_name"].value = sources["unet_name"]
		}

		if (typeof sources["weight_dtype"] === "object") {
			this.sockets.inputs["weight_dtype"].connectTo(sources["weight_dtype"])
		} else {
			this.sockets.inputs["weight_dtype"].value = sources["weight_dtype"]
		}

	}
}

type UNETLoaderInputs = {
			"unet_name": ComfyNodeTypedInputRef<string>
			"weight_dtype": ComfyNodeTypedInputRef<string>
}


export class DualCLIPLoader extends ComfyNode {
	classType: string = "DualCLIPLoader"

	sockets: {
		inputs: Required<DualCLIPLoaderInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<string>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<string>(this, "clip_name2"),
				"type": new ComfyNodeTypedInputRef<string>(this, "type"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DualCLIPLoaderInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["type"] === "object") {
			this.sockets.inputs["type"].connectTo(sources["type"])
		} else {
			this.sockets.inputs["type"].value = sources["type"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type DualCLIPLoaderInputs = {
			"clip_name1": ComfyNodeTypedInputRef<string>
			"clip_name2": ComfyNodeTypedInputRef<string>
			"type": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
}


export class CLIPVisionEncode extends ComfyNode {
	classType: string = "CLIPVisionEncode"

	sockets: {
		inputs: Required<CLIPVisionEncodeInputs>
		outputs: {
			CLIP_VISION_OUTPUT: ComfyNodeTypedSourceRef<ComfyValueType_CLIP_VISION_OUTPUT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_vision": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>(this, "clip_vision"),
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"crop": new ComfyNodeTypedInputRef<string>(this, "crop"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP_VISION_OUTPUT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPVisionEncodeInputs>) {
		if (typeof sources["clip_vision"] === "object") {
			this.sockets.inputs["clip_vision"].connectTo(sources["clip_vision"])
		} else {
			this.sockets.inputs["clip_vision"].value = sources["clip_vision"]
		}

		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["crop"] === "object") {
			this.sockets.inputs["crop"].connectTo(sources["crop"])
		} else {
			this.sockets.inputs["crop"].value = sources["crop"]
		}

	}
}

type CLIPVisionEncodeInputs = {
			"clip_vision": ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"crop": ComfyNodeTypedInputRef<string>
}


export class StyleModelApply extends ComfyNode {
	classType: string = "StyleModelApply"

	sockets: {
		inputs: Required<StyleModelApplyInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning"),
				"style_model": new ComfyNodeTypedInputRef<ComfyValueType_STYLE_MODEL>(this, "style_model"),
				"clip_vision_output": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>(this, "clip_vision_output"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"strength_type": new ComfyNodeTypedInputRef<string>(this, "strength_type"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<StyleModelApplyInputs>) {
		if (typeof sources["conditioning"] === "object") {
			this.sockets.inputs["conditioning"].connectTo(sources["conditioning"])
		} else {
			this.sockets.inputs["conditioning"].value = sources["conditioning"]
		}

		if (typeof sources["style_model"] === "object") {
			this.sockets.inputs["style_model"].connectTo(sources["style_model"])
		} else {
			this.sockets.inputs["style_model"].value = sources["style_model"]
		}

		if (typeof sources["clip_vision_output"] === "object") {
			this.sockets.inputs["clip_vision_output"].connectTo(sources["clip_vision_output"])
		} else {
			this.sockets.inputs["clip_vision_output"].value = sources["clip_vision_output"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (typeof sources["strength_type"] === "object") {
			this.sockets.inputs["strength_type"].connectTo(sources["strength_type"])
		} else {
			this.sockets.inputs["strength_type"].value = sources["strength_type"]
		}

	}
}

type StyleModelApplyInputs = {
			"conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"style_model": ComfyNodeTypedInputRef<ComfyValueType_STYLE_MODEL>
			"clip_vision_output": ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>
			"strength": ComfyNodeTypedInputRef<number>
			"strength_type": ComfyNodeTypedInputRef<string>
}


export class unCLIPConditioning extends ComfyNode {
	classType: string = "unCLIPConditioning"

	sockets: {
		inputs: Required<unCLIPConditioningInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning"),
				"clip_vision_output": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>(this, "clip_vision_output"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"noise_augmentation": new ComfyNodeTypedInputRef<number>(this, "noise_augmentation"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<unCLIPConditioningInputs>) {
		if (typeof sources["conditioning"] === "object") {
			this.sockets.inputs["conditioning"].connectTo(sources["conditioning"])
		} else {
			this.sockets.inputs["conditioning"].value = sources["conditioning"]
		}

		if (typeof sources["clip_vision_output"] === "object") {
			this.sockets.inputs["clip_vision_output"].connectTo(sources["clip_vision_output"])
		} else {
			this.sockets.inputs["clip_vision_output"].value = sources["clip_vision_output"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (typeof sources["noise_augmentation"] === "object") {
			this.sockets.inputs["noise_augmentation"].connectTo(sources["noise_augmentation"])
		} else {
			this.sockets.inputs["noise_augmentation"].value = sources["noise_augmentation"]
		}

	}
}

type unCLIPConditioningInputs = {
			"conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"clip_vision_output": ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>
			"strength": ComfyNodeTypedInputRef<number>
			"noise_augmentation": ComfyNodeTypedInputRef<number>
}


export class ControlNetApply extends ComfyNode {
	classType: string = "ControlNetApply"

	sockets: {
		inputs: Required<ControlNetApplyInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning"),
				"control_net": new ComfyNodeTypedInputRef<ComfyValueType_CONTROL_NET>(this, "control_net"),
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ControlNetApplyInputs>) {
		if (typeof sources["conditioning"] === "object") {
			this.sockets.inputs["conditioning"].connectTo(sources["conditioning"])
		} else {
			this.sockets.inputs["conditioning"].value = sources["conditioning"]
		}

		if (typeof sources["control_net"] === "object") {
			this.sockets.inputs["control_net"].connectTo(sources["control_net"])
		} else {
			this.sockets.inputs["control_net"].value = sources["control_net"]
		}

		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

	}
}

type ControlNetApplyInputs = {
			"conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"control_net": ComfyNodeTypedInputRef<ComfyValueType_CONTROL_NET>
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"strength": ComfyNodeTypedInputRef<number>
}


export class ControlNetApplyAdvanced extends ComfyNode {
	classType: string = "ControlNetApplyAdvanced"

	sockets: {
		inputs: Required<ControlNetApplyAdvancedInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"control_net": new ComfyNodeTypedInputRef<ComfyValueType_CONTROL_NET>(this, "control_net"),
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ControlNetApplyAdvancedInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["control_net"] === "object") {
			this.sockets.inputs["control_net"].connectTo(sources["control_net"])
		} else {
			this.sockets.inputs["control_net"].value = sources["control_net"]
		}

		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

		if (sources["vae"] !== undefined) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}
		}

	}
}

type ControlNetApplyAdvancedInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"control_net": ComfyNodeTypedInputRef<ComfyValueType_CONTROL_NET>
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"strength": ComfyNodeTypedInputRef<number>
			"start_percent": ComfyNodeTypedInputRef<number>
			"end_percent": ComfyNodeTypedInputRef<number>
			"vae"?: ComfyNodeTypedInputRef<ComfyValueType_VAE>
}


export class ControlNetLoader extends ComfyNode {
	classType: string = "ControlNetLoader"

	sockets: {
		inputs: Required<ControlNetLoaderInputs>
		outputs: {
			CONTROL_NET: ComfyNodeTypedSourceRef<ComfyValueType_CONTROL_NET>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"control_net_name": new ComfyNodeTypedInputRef<void>(this, "control_net_name"),
			},
			outputs: Object.create(Object.prototype, {
				"CONTROL_NET": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ControlNetLoaderInputs>) {
		if (typeof sources["control_net_name"] === "object") {
			this.sockets.inputs["control_net_name"].connectTo(sources["control_net_name"])
		} else {
			this.sockets.inputs["control_net_name"].value = sources["control_net_name"]
		}

	}
}

type ControlNetLoaderInputs = {
			"control_net_name": ComfyNodeTypedInputRef<void>
}


export class DiffControlNetLoader extends ComfyNode {
	classType: string = "DiffControlNetLoader"

	sockets: {
		inputs: Required<DiffControlNetLoaderInputs>
		outputs: {
			CONTROL_NET: ComfyNodeTypedSourceRef<ComfyValueType_CONTROL_NET>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"control_net_name": new ComfyNodeTypedInputRef<void>(this, "control_net_name"),
			},
			outputs: Object.create(Object.prototype, {
				"CONTROL_NET": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DiffControlNetLoaderInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["control_net_name"] === "object") {
			this.sockets.inputs["control_net_name"].connectTo(sources["control_net_name"])
		} else {
			this.sockets.inputs["control_net_name"].value = sources["control_net_name"]
		}

	}
}

type DiffControlNetLoaderInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"control_net_name": ComfyNodeTypedInputRef<void>
}


export class StyleModelLoader extends ComfyNode {
	classType: string = "StyleModelLoader"

	sockets: {
		inputs: Required<StyleModelLoaderInputs>
		outputs: {
			STYLE_MODEL: ComfyNodeTypedSourceRef<ComfyValueType_STYLE_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"style_model_name": new ComfyNodeTypedInputRef<void>(this, "style_model_name"),
			},
			outputs: Object.create(Object.prototype, {
				"STYLE_MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<StyleModelLoaderInputs>) {
		if (typeof sources["style_model_name"] === "object") {
			this.sockets.inputs["style_model_name"].connectTo(sources["style_model_name"])
		} else {
			this.sockets.inputs["style_model_name"].value = sources["style_model_name"]
		}

	}
}

type StyleModelLoaderInputs = {
			"style_model_name": ComfyNodeTypedInputRef<void>
}


export class CLIPVisionLoader extends ComfyNode {
	classType: string = "CLIPVisionLoader"

	sockets: {
		inputs: Required<CLIPVisionLoaderInputs>
		outputs: {
			CLIP_VISION: ComfyNodeTypedSourceRef<ComfyValueType_CLIP_VISION>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name": new ComfyNodeTypedInputRef<string>(this, "clip_name"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP_VISION": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPVisionLoaderInputs>) {
		if (typeof sources["clip_name"] === "object") {
			this.sockets.inputs["clip_name"].connectTo(sources["clip_name"])
		} else {
			this.sockets.inputs["clip_name"].value = sources["clip_name"]
		}

	}
}

type CLIPVisionLoaderInputs = {
			"clip_name": ComfyNodeTypedInputRef<string>
}


export class VAEDecodeTiled extends ComfyNode {
	classType: string = "VAEDecodeTiled"

	sockets: {
		inputs: Required<VAEDecodeTiledInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"tile_size": new ComfyNodeTypedInputRef<number>(this, "tile_size"),
				"overlap": new ComfyNodeTypedInputRef<number>(this, "overlap"),
				"temporal_size": new ComfyNodeTypedInputRef<number>(this, "temporal_size"),
				"temporal_overlap": new ComfyNodeTypedInputRef<number>(this, "temporal_overlap"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VAEDecodeTiledInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["tile_size"] === "object") {
			this.sockets.inputs["tile_size"].connectTo(sources["tile_size"])
		} else {
			this.sockets.inputs["tile_size"].value = sources["tile_size"]
		}

		if (typeof sources["overlap"] === "object") {
			this.sockets.inputs["overlap"].connectTo(sources["overlap"])
		} else {
			this.sockets.inputs["overlap"].value = sources["overlap"]
		}

		if (typeof sources["temporal_size"] === "object") {
			this.sockets.inputs["temporal_size"].connectTo(sources["temporal_size"])
		} else {
			this.sockets.inputs["temporal_size"].value = sources["temporal_size"]
		}

		if (typeof sources["temporal_overlap"] === "object") {
			this.sockets.inputs["temporal_overlap"].connectTo(sources["temporal_overlap"])
		} else {
			this.sockets.inputs["temporal_overlap"].value = sources["temporal_overlap"]
		}

	}
}

type VAEDecodeTiledInputs = {
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"tile_size": ComfyNodeTypedInputRef<number>
			"overlap": ComfyNodeTypedInputRef<number>
			/** Only used for video VAEs: Amount of frames to decode at a time.*/
			"temporal_size": ComfyNodeTypedInputRef<number>
			/** Only used for video VAEs: Amount of frames to overlap.*/
			"temporal_overlap": ComfyNodeTypedInputRef<number>
}


export class VAEEncodeTiled extends ComfyNode {
	classType: string = "VAEEncodeTiled"

	sockets: {
		inputs: Required<VAEEncodeTiledInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"pixels": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "pixels"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"tile_size": new ComfyNodeTypedInputRef<number>(this, "tile_size"),
				"overlap": new ComfyNodeTypedInputRef<number>(this, "overlap"),
				"temporal_size": new ComfyNodeTypedInputRef<number>(this, "temporal_size"),
				"temporal_overlap": new ComfyNodeTypedInputRef<number>(this, "temporal_overlap"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VAEEncodeTiledInputs>) {
		if (typeof sources["pixels"] === "object") {
			this.sockets.inputs["pixels"].connectTo(sources["pixels"])
		} else {
			this.sockets.inputs["pixels"].value = sources["pixels"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["tile_size"] === "object") {
			this.sockets.inputs["tile_size"].connectTo(sources["tile_size"])
		} else {
			this.sockets.inputs["tile_size"].value = sources["tile_size"]
		}

		if (typeof sources["overlap"] === "object") {
			this.sockets.inputs["overlap"].connectTo(sources["overlap"])
		} else {
			this.sockets.inputs["overlap"].value = sources["overlap"]
		}

		if (typeof sources["temporal_size"] === "object") {
			this.sockets.inputs["temporal_size"].connectTo(sources["temporal_size"])
		} else {
			this.sockets.inputs["temporal_size"].value = sources["temporal_size"]
		}

		if (typeof sources["temporal_overlap"] === "object") {
			this.sockets.inputs["temporal_overlap"].connectTo(sources["temporal_overlap"])
		} else {
			this.sockets.inputs["temporal_overlap"].value = sources["temporal_overlap"]
		}

	}
}

type VAEEncodeTiledInputs = {
			"pixels": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"tile_size": ComfyNodeTypedInputRef<number>
			"overlap": ComfyNodeTypedInputRef<number>
			/** Only used for video VAEs: Amount of frames to encode at a time.*/
			"temporal_size": ComfyNodeTypedInputRef<number>
			/** Only used for video VAEs: Amount of frames to overlap.*/
			"temporal_overlap": ComfyNodeTypedInputRef<number>
}


export class unCLIPCheckpointLoader extends ComfyNode {
	classType: string = "unCLIPCheckpointLoader"

	sockets: {
		inputs: Required<unCLIPCheckpointLoaderInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
			VAE: ComfyNodeTypedSourceRef<ComfyValueType_VAE>
			CLIP_VISION: ComfyNodeTypedSourceRef<ComfyValueType_CLIP_VISION>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"ckpt_name": new ComfyNodeTypedInputRef<string>(this, "ckpt_name"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"VAE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"CLIP_VISION": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<unCLIPCheckpointLoaderInputs>) {
		if (typeof sources["ckpt_name"] === "object") {
			this.sockets.inputs["ckpt_name"].connectTo(sources["ckpt_name"])
		} else {
			this.sockets.inputs["ckpt_name"].value = sources["ckpt_name"]
		}

	}
}

type unCLIPCheckpointLoaderInputs = {
			"ckpt_name": ComfyNodeTypedInputRef<string>
}


export class GLIGENLoader extends ComfyNode {
	classType: string = "GLIGENLoader"

	sockets: {
		inputs: Required<GLIGENLoaderInputs>
		outputs: {
			GLIGEN: ComfyNodeTypedSourceRef<ComfyValueType_GLIGEN>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"gligen_name": new ComfyNodeTypedInputRef<void>(this, "gligen_name"),
			},
			outputs: Object.create(Object.prototype, {
				"GLIGEN": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<GLIGENLoaderInputs>) {
		if (typeof sources["gligen_name"] === "object") {
			this.sockets.inputs["gligen_name"].connectTo(sources["gligen_name"])
		} else {
			this.sockets.inputs["gligen_name"].value = sources["gligen_name"]
		}

	}
}

type GLIGENLoaderInputs = {
			"gligen_name": ComfyNodeTypedInputRef<void>
}


export class GLIGENTextBoxApply extends ComfyNode {
	classType: string = "GLIGENTextBoxApply"

	sockets: {
		inputs: Required<GLIGENTextBoxApplyInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning_to": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning_to"),
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"gligen_textbox_model": new ComfyNodeTypedInputRef<ComfyValueType_GLIGEN>(this, "gligen_textbox_model"),
				"text": new ComfyNodeTypedInputRef<string>(this, "text"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"x": new ComfyNodeTypedInputRef<number>(this, "x"),
				"y": new ComfyNodeTypedInputRef<number>(this, "y"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<GLIGENTextBoxApplyInputs>) {
		if (typeof sources["conditioning_to"] === "object") {
			this.sockets.inputs["conditioning_to"].connectTo(sources["conditioning_to"])
		} else {
			this.sockets.inputs["conditioning_to"].value = sources["conditioning_to"]
		}

		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["gligen_textbox_model"] === "object") {
			this.sockets.inputs["gligen_textbox_model"].connectTo(sources["gligen_textbox_model"])
		} else {
			this.sockets.inputs["gligen_textbox_model"].value = sources["gligen_textbox_model"]
		}

		if (typeof sources["text"] === "object") {
			this.sockets.inputs["text"].connectTo(sources["text"])
		} else {
			this.sockets.inputs["text"].value = sources["text"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["x"] === "object") {
			this.sockets.inputs["x"].connectTo(sources["x"])
		} else {
			this.sockets.inputs["x"].value = sources["x"]
		}

		if (typeof sources["y"] === "object") {
			this.sockets.inputs["y"].connectTo(sources["y"])
		} else {
			this.sockets.inputs["y"].value = sources["y"]
		}

	}
}

type GLIGENTextBoxApplyInputs = {
			"conditioning_to": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"gligen_textbox_model": ComfyNodeTypedInputRef<ComfyValueType_GLIGEN>
			"text": ComfyNodeTypedInputRef<string>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"x": ComfyNodeTypedInputRef<number>
			"y": ComfyNodeTypedInputRef<number>
}


export class InpaintModelConditioning extends ComfyNode {
	classType: string = "InpaintModelConditioning"

	sockets: {
		inputs: Required<InpaintModelConditioningInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"pixels": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "pixels"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"noise_mask": new ComfyNodeTypedInputRef<boolean>(this, "noise_mask"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<InpaintModelConditioningInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["pixels"] === "object") {
			this.sockets.inputs["pixels"].connectTo(sources["pixels"])
		} else {
			this.sockets.inputs["pixels"].value = sources["pixels"]
		}

		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["noise_mask"] === "object") {
			this.sockets.inputs["noise_mask"].connectTo(sources["noise_mask"])
		} else {
			this.sockets.inputs["noise_mask"].value = sources["noise_mask"]
		}

	}
}

type InpaintModelConditioningInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"pixels": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			/** Add a noise mask to the latent so sampling will only happen within the mask. Might improve results or completely break things depending on the model.*/
			"noise_mask": ComfyNodeTypedInputRef<boolean>
}


export class CheckpointLoader extends ComfyNode {
	classType: string = "CheckpointLoader"

	sockets: {
		inputs: Required<CheckpointLoaderInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
			VAE: ComfyNodeTypedSourceRef<ComfyValueType_VAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"config_name": new ComfyNodeTypedInputRef<void>(this, "config_name"),
				"ckpt_name": new ComfyNodeTypedInputRef<string>(this, "ckpt_name"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"VAE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CheckpointLoaderInputs>) {
		if (typeof sources["config_name"] === "object") {
			this.sockets.inputs["config_name"].connectTo(sources["config_name"])
		} else {
			this.sockets.inputs["config_name"].value = sources["config_name"]
		}

		if (typeof sources["ckpt_name"] === "object") {
			this.sockets.inputs["ckpt_name"].connectTo(sources["ckpt_name"])
		} else {
			this.sockets.inputs["ckpt_name"].value = sources["ckpt_name"]
		}

	}
}

type CheckpointLoaderInputs = {
			"config_name": ComfyNodeTypedInputRef<void>
			"ckpt_name": ComfyNodeTypedInputRef<string>
}


export class DiffusersLoader extends ComfyNode {
	classType: string = "DiffusersLoader"

	sockets: {
		inputs: Required<DiffusersLoaderInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
			VAE: ComfyNodeTypedSourceRef<ComfyValueType_VAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_path": new ComfyNodeTypedInputRef<void>(this, "model_path"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"VAE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DiffusersLoaderInputs>) {
		if (typeof sources["model_path"] === "object") {
			this.sockets.inputs["model_path"].connectTo(sources["model_path"])
		} else {
			this.sockets.inputs["model_path"].value = sources["model_path"]
		}

	}
}

type DiffusersLoaderInputs = {
			"model_path": ComfyNodeTypedInputRef<void>
}


export class LoadLatent extends ComfyNode {
	classType: string = "LoadLatent"

	sockets: {
		inputs: Required<LoadLatentInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"latent": new ComfyNodeTypedInputRef<string>(this, "latent"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoadLatentInputs>) {
		if (typeof sources["latent"] === "object") {
			this.sockets.inputs["latent"].connectTo(sources["latent"])
		} else {
			this.sockets.inputs["latent"].value = sources["latent"]
		}

	}
}

type LoadLatentInputs = {
			"latent": ComfyNodeTypedInputRef<string>
}


export class SaveLatent extends ComfyNode {
	classType: string = "SaveLatent"

	sockets: {
		inputs: Required<SaveLatentInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_E>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<SaveLatentInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type SaveLatentInputs = {
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"filename_prefix": ComfyNodeTypedInputRef<string>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_E>
}


export class ConditioningZeroOut extends ComfyNode {
	classType: string = "ConditioningZeroOut"

	sockets: {
		inputs: Required<ConditioningZeroOutInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ConditioningZeroOutInputs>) {
		if (typeof sources["conditioning"] === "object") {
			this.sockets.inputs["conditioning"].connectTo(sources["conditioning"])
		} else {
			this.sockets.inputs["conditioning"].value = sources["conditioning"]
		}

	}
}

type ConditioningZeroOutInputs = {
			"conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
}


export class ConditioningSetTimestepRange extends ComfyNode {
	classType: string = "ConditioningSetTimestepRange"

	sockets: {
		inputs: Required<ConditioningSetTimestepRangeInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning"),
				"start": new ComfyNodeTypedInputRef<number>(this, "start"),
				"end": new ComfyNodeTypedInputRef<number>(this, "end"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ConditioningSetTimestepRangeInputs>) {
		if (typeof sources["conditioning"] === "object") {
			this.sockets.inputs["conditioning"].connectTo(sources["conditioning"])
		} else {
			this.sockets.inputs["conditioning"].value = sources["conditioning"]
		}

		if (typeof sources["start"] === "object") {
			this.sockets.inputs["start"].connectTo(sources["start"])
		} else {
			this.sockets.inputs["start"].value = sources["start"]
		}

		if (typeof sources["end"] === "object") {
			this.sockets.inputs["end"].connectTo(sources["end"])
		} else {
			this.sockets.inputs["end"].value = sources["end"]
		}

	}
}

type ConditioningSetTimestepRangeInputs = {
			"conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"start": ComfyNodeTypedInputRef<number>
			"end": ComfyNodeTypedInputRef<number>
}


export class LoraLoaderModelOnly extends ComfyNode {
	classType: string = "LoraLoaderModelOnly"

	sockets: {
		inputs: Required<LoraLoaderModelOnlyInputs>
		outputs: {
			/** The modified diffusion model.*/
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"lora_name": new ComfyNodeTypedInputRef<string>(this, "lora_name"),
				"strength_model": new ComfyNodeTypedInputRef<number>(this, "strength_model"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoraLoaderModelOnlyInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["lora_name"] === "object") {
			this.sockets.inputs["lora_name"].connectTo(sources["lora_name"])
		} else {
			this.sockets.inputs["lora_name"].value = sources["lora_name"]
		}

		if (typeof sources["strength_model"] === "object") {
			this.sockets.inputs["strength_model"].connectTo(sources["strength_model"])
		} else {
			this.sockets.inputs["strength_model"].value = sources["strength_model"]
		}

	}
}

type LoraLoaderModelOnlyInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"lora_name": ComfyNodeTypedInputRef<string>
			"strength_model": ComfyNodeTypedInputRef<number>
}


export class LatentAdd extends ComfyNode {
	classType: string = "LatentAdd"

	sockets: {
		inputs: Required<LatentAddInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples1": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples1"),
				"samples2": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples2"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentAddInputs>) {
		if (typeof sources["samples1"] === "object") {
			this.sockets.inputs["samples1"].connectTo(sources["samples1"])
		} else {
			this.sockets.inputs["samples1"].value = sources["samples1"]
		}

		if (typeof sources["samples2"] === "object") {
			this.sockets.inputs["samples2"].connectTo(sources["samples2"])
		} else {
			this.sockets.inputs["samples2"].value = sources["samples2"]
		}

	}
}

type LatentAddInputs = {
			"samples1": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"samples2": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class LatentSubtract extends ComfyNode {
	classType: string = "LatentSubtract"

	sockets: {
		inputs: Required<LatentSubtractInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples1": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples1"),
				"samples2": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples2"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentSubtractInputs>) {
		if (typeof sources["samples1"] === "object") {
			this.sockets.inputs["samples1"].connectTo(sources["samples1"])
		} else {
			this.sockets.inputs["samples1"].value = sources["samples1"]
		}

		if (typeof sources["samples2"] === "object") {
			this.sockets.inputs["samples2"].connectTo(sources["samples2"])
		} else {
			this.sockets.inputs["samples2"].value = sources["samples2"]
		}

	}
}

type LatentSubtractInputs = {
			"samples1": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"samples2": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class LatentMultiply extends ComfyNode {
	classType: string = "LatentMultiply"

	sockets: {
		inputs: Required<LatentMultiplyInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"multiplier": new ComfyNodeTypedInputRef<number>(this, "multiplier"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentMultiplyInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["multiplier"] === "object") {
			this.sockets.inputs["multiplier"].connectTo(sources["multiplier"])
		} else {
			this.sockets.inputs["multiplier"].value = sources["multiplier"]
		}

	}
}

type LatentMultiplyInputs = {
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"multiplier": ComfyNodeTypedInputRef<number>
}


export class LatentInterpolate extends ComfyNode {
	classType: string = "LatentInterpolate"

	sockets: {
		inputs: Required<LatentInterpolateInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples1": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples1"),
				"samples2": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples2"),
				"ratio": new ComfyNodeTypedInputRef<number>(this, "ratio"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentInterpolateInputs>) {
		if (typeof sources["samples1"] === "object") {
			this.sockets.inputs["samples1"].connectTo(sources["samples1"])
		} else {
			this.sockets.inputs["samples1"].value = sources["samples1"]
		}

		if (typeof sources["samples2"] === "object") {
			this.sockets.inputs["samples2"].connectTo(sources["samples2"])
		} else {
			this.sockets.inputs["samples2"].value = sources["samples2"]
		}

		if (typeof sources["ratio"] === "object") {
			this.sockets.inputs["ratio"].connectTo(sources["ratio"])
		} else {
			this.sockets.inputs["ratio"].value = sources["ratio"]
		}

	}
}

type LatentInterpolateInputs = {
			"samples1": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"samples2": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"ratio": ComfyNodeTypedInputRef<number>
}


export class LatentConcat extends ComfyNode {
	classType: string = "LatentConcat"

	sockets: {
		inputs: Required<LatentConcatInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples1": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples1"),
				"samples2": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples2"),
				"dim": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "dim"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentConcatInputs>) {
		if (typeof sources["samples1"] === "object") {
			this.sockets.inputs["samples1"].connectTo(sources["samples1"])
		} else {
			this.sockets.inputs["samples1"].value = sources["samples1"]
		}

		if (typeof sources["samples2"] === "object") {
			this.sockets.inputs["samples2"].connectTo(sources["samples2"])
		} else {
			this.sockets.inputs["samples2"].value = sources["samples2"]
		}

		if (typeof sources["dim"] === "object") {
			this.sockets.inputs["dim"].connectTo(sources["dim"])
		} else {
			this.sockets.inputs["dim"].value = sources["dim"]
		}

	}
}

type LatentConcatInputs = {
			"samples1": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"samples2": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"dim": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class LatentCut extends ComfyNode {
	classType: string = "LatentCut"

	sockets: {
		inputs: Required<LatentCutInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"dim": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "dim"),
				"index": new ComfyNodeTypedInputRef<number>(this, "index"),
				"amount": new ComfyNodeTypedInputRef<number>(this, "amount"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentCutInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["dim"] === "object") {
			this.sockets.inputs["dim"].connectTo(sources["dim"])
		} else {
			this.sockets.inputs["dim"].value = sources["dim"]
		}

		if (typeof sources["index"] === "object") {
			this.sockets.inputs["index"].connectTo(sources["index"])
		} else {
			this.sockets.inputs["index"].value = sources["index"]
		}

		if (typeof sources["amount"] === "object") {
			this.sockets.inputs["amount"].connectTo(sources["amount"])
		} else {
			this.sockets.inputs["amount"].value = sources["amount"]
		}

	}
}

type LatentCutInputs = {
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"dim": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"index": ComfyNodeTypedInputRef<number>
			"amount": ComfyNodeTypedInputRef<number>
}


export class LatentBatch extends ComfyNode {
	classType: string = "LatentBatch"

	sockets: {
		inputs: Required<LatentBatchInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples1": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples1"),
				"samples2": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples2"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentBatchInputs>) {
		if (typeof sources["samples1"] === "object") {
			this.sockets.inputs["samples1"].connectTo(sources["samples1"])
		} else {
			this.sockets.inputs["samples1"].value = sources["samples1"]
		}

		if (typeof sources["samples2"] === "object") {
			this.sockets.inputs["samples2"].connectTo(sources["samples2"])
		} else {
			this.sockets.inputs["samples2"].value = sources["samples2"]
		}

	}
}

type LatentBatchInputs = {
			"samples1": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"samples2": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class LatentBatchSeedBehavior extends ComfyNode {
	classType: string = "LatentBatchSeedBehavior"

	sockets: {
		inputs: Required<LatentBatchSeedBehaviorInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"seed_behavior": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "seed_behavior"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentBatchSeedBehaviorInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["seed_behavior"] === "object") {
			this.sockets.inputs["seed_behavior"].connectTo(sources["seed_behavior"])
		} else {
			this.sockets.inputs["seed_behavior"].value = sources["seed_behavior"]
		}

	}
}

type LatentBatchSeedBehaviorInputs = {
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"seed_behavior": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class LatentApplyOperation extends ComfyNode {
	classType: string = "LatentApplyOperation"

	sockets: {
		inputs: Required<LatentApplyOperationInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"operation": new ComfyNodeTypedInputRef<ComfyValueType_LATENT_OPERATION>(this, "operation"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentApplyOperationInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["operation"] === "object") {
			this.sockets.inputs["operation"].connectTo(sources["operation"])
		} else {
			this.sockets.inputs["operation"].value = sources["operation"]
		}

	}
}

type LatentApplyOperationInputs = {
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"operation": ComfyNodeTypedInputRef<ComfyValueType_LATENT_OPERATION>
}


export class LatentApplyOperationCFG extends ComfyNode {
	classType: string = "LatentApplyOperationCFG"

	sockets: {
		inputs: Required<LatentApplyOperationCFGInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"operation": new ComfyNodeTypedInputRef<ComfyValueType_LATENT_OPERATION>(this, "operation"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentApplyOperationCFGInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["operation"] === "object") {
			this.sockets.inputs["operation"].connectTo(sources["operation"])
		} else {
			this.sockets.inputs["operation"].value = sources["operation"]
		}

	}
}

type LatentApplyOperationCFGInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"operation": ComfyNodeTypedInputRef<ComfyValueType_LATENT_OPERATION>
}


export class LatentOperationTonemapReinhard extends ComfyNode {
	classType: string = "LatentOperationTonemapReinhard"

	sockets: {
		inputs: Required<LatentOperationTonemapReinhardInputs>
		outputs: {
			LATENT_OPERATION: ComfyNodeTypedSourceRef<ComfyValueType_LATENT_OPERATION>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"multiplier": new ComfyNodeTypedInputRef<number>(this, "multiplier"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT_OPERATION": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentOperationTonemapReinhardInputs>) {
		if (typeof sources["multiplier"] === "object") {
			this.sockets.inputs["multiplier"].connectTo(sources["multiplier"])
		} else {
			this.sockets.inputs["multiplier"].value = sources["multiplier"]
		}

	}
}

type LatentOperationTonemapReinhardInputs = {
			"multiplier": ComfyNodeTypedInputRef<number>
}


export class LatentOperationSharpen extends ComfyNode {
	classType: string = "LatentOperationSharpen"

	sockets: {
		inputs: Required<LatentOperationSharpenInputs>
		outputs: {
			LATENT_OPERATION: ComfyNodeTypedSourceRef<ComfyValueType_LATENT_OPERATION>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"sharpen_radius": new ComfyNodeTypedInputRef<number>(this, "sharpen_radius"),
				"sigma": new ComfyNodeTypedInputRef<number>(this, "sigma"),
				"alpha": new ComfyNodeTypedInputRef<number>(this, "alpha"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT_OPERATION": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentOperationSharpenInputs>) {
		if (typeof sources["sharpen_radius"] === "object") {
			this.sockets.inputs["sharpen_radius"].connectTo(sources["sharpen_radius"])
		} else {
			this.sockets.inputs["sharpen_radius"].value = sources["sharpen_radius"]
		}

		if (typeof sources["sigma"] === "object") {
			this.sockets.inputs["sigma"].connectTo(sources["sigma"])
		} else {
			this.sockets.inputs["sigma"].value = sources["sigma"]
		}

		if (typeof sources["alpha"] === "object") {
			this.sockets.inputs["alpha"].connectTo(sources["alpha"])
		} else {
			this.sockets.inputs["alpha"].value = sources["alpha"]
		}

	}
}

type LatentOperationSharpenInputs = {
			"sharpen_radius": ComfyNodeTypedInputRef<number>
			"sigma": ComfyNodeTypedInputRef<number>
			"alpha": ComfyNodeTypedInputRef<number>
}


export class HypernetworkLoader extends ComfyNode {
	classType: string = "HypernetworkLoader"

	sockets: {
		inputs: Required<HypernetworkLoaderInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"hypernetwork_name": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "hypernetwork_name"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<HypernetworkLoaderInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["hypernetwork_name"] === "object") {
			this.sockets.inputs["hypernetwork_name"].connectTo(sources["hypernetwork_name"])
		} else {
			this.sockets.inputs["hypernetwork_name"].value = sources["hypernetwork_name"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

	}
}

type HypernetworkLoaderInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"hypernetwork_name": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"strength": ComfyNodeTypedInputRef<number>
}


export class UpscaleModelLoader extends ComfyNode {
	classType: string = "UpscaleModelLoader"

	sockets: {
		inputs: Required<UpscaleModelLoaderInputs>
		outputs: {
			UPSCALE_MODEL: ComfyNodeTypedSourceRef<ComfyValueType_UPSCALE_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_name": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "model_name"),
			},
			outputs: Object.create(Object.prototype, {
				"UPSCALE_MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<UpscaleModelLoaderInputs>) {
		if (typeof sources["model_name"] === "object") {
			this.sockets.inputs["model_name"].connectTo(sources["model_name"])
		} else {
			this.sockets.inputs["model_name"].value = sources["model_name"]
		}

	}
}

type UpscaleModelLoaderInputs = {
			"model_name": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class ImageUpscaleWithModel extends ComfyNode {
	classType: string = "ImageUpscaleWithModel"

	sockets: {
		inputs: Required<ImageUpscaleWithModelInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"upscale_model": new ComfyNodeTypedInputRef<ComfyValueType_UPSCALE_MODEL>(this, "upscale_model"),
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageUpscaleWithModelInputs>) {
		if (typeof sources["upscale_model"] === "object") {
			this.sockets.inputs["upscale_model"].connectTo(sources["upscale_model"])
		} else {
			this.sockets.inputs["upscale_model"].value = sources["upscale_model"]
		}

		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

	}
}

type ImageUpscaleWithModelInputs = {
			"upscale_model": ComfyNodeTypedInputRef<ComfyValueType_UPSCALE_MODEL>
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class ImageBlend extends ComfyNode {
	classType: string = "ImageBlend"

	sockets: {
		inputs: Required<ImageBlendInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image1": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image1"),
				"image2": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image2"),
				"blend_factor": new ComfyNodeTypedInputRef<number>(this, "blend_factor"),
				"blend_mode": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "blend_mode"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageBlendInputs>) {
		if (typeof sources["image1"] === "object") {
			this.sockets.inputs["image1"].connectTo(sources["image1"])
		} else {
			this.sockets.inputs["image1"].value = sources["image1"]
		}

		if (typeof sources["image2"] === "object") {
			this.sockets.inputs["image2"].connectTo(sources["image2"])
		} else {
			this.sockets.inputs["image2"].value = sources["image2"]
		}

		if (typeof sources["blend_factor"] === "object") {
			this.sockets.inputs["blend_factor"].connectTo(sources["blend_factor"])
		} else {
			this.sockets.inputs["blend_factor"].value = sources["blend_factor"]
		}

		if (typeof sources["blend_mode"] === "object") {
			this.sockets.inputs["blend_mode"].connectTo(sources["blend_mode"])
		} else {
			this.sockets.inputs["blend_mode"].value = sources["blend_mode"]
		}

	}
}

type ImageBlendInputs = {
			"image1": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"image2": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"blend_factor": ComfyNodeTypedInputRef<number>
			"blend_mode": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class ImageBlur extends ComfyNode {
	classType: string = "ImageBlur"

	sockets: {
		inputs: Required<ImageBlurInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"blur_radius": new ComfyNodeTypedInputRef<number>(this, "blur_radius"),
				"sigma": new ComfyNodeTypedInputRef<number>(this, "sigma"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageBlurInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["blur_radius"] === "object") {
			this.sockets.inputs["blur_radius"].connectTo(sources["blur_radius"])
		} else {
			this.sockets.inputs["blur_radius"].value = sources["blur_radius"]
		}

		if (typeof sources["sigma"] === "object") {
			this.sockets.inputs["sigma"].connectTo(sources["sigma"])
		} else {
			this.sockets.inputs["sigma"].value = sources["sigma"]
		}

	}
}

type ImageBlurInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"blur_radius": ComfyNodeTypedInputRef<number>
			"sigma": ComfyNodeTypedInputRef<number>
}


export class ImageQuantize extends ComfyNode {
	classType: string = "ImageQuantize"

	sockets: {
		inputs: Required<ImageQuantizeInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"colors": new ComfyNodeTypedInputRef<number>(this, "colors"),
				"dither": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "dither"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageQuantizeInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["colors"] === "object") {
			this.sockets.inputs["colors"].connectTo(sources["colors"])
		} else {
			this.sockets.inputs["colors"].value = sources["colors"]
		}

		if (typeof sources["dither"] === "object") {
			this.sockets.inputs["dither"].connectTo(sources["dither"])
		} else {
			this.sockets.inputs["dither"].value = sources["dither"]
		}

	}
}

type ImageQuantizeInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"colors": ComfyNodeTypedInputRef<number>
			"dither": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class ImageSharpen extends ComfyNode {
	classType: string = "ImageSharpen"

	sockets: {
		inputs: Required<ImageSharpenInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"sharpen_radius": new ComfyNodeTypedInputRef<number>(this, "sharpen_radius"),
				"sigma": new ComfyNodeTypedInputRef<number>(this, "sigma"),
				"alpha": new ComfyNodeTypedInputRef<number>(this, "alpha"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageSharpenInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["sharpen_radius"] === "object") {
			this.sockets.inputs["sharpen_radius"].connectTo(sources["sharpen_radius"])
		} else {
			this.sockets.inputs["sharpen_radius"].value = sources["sharpen_radius"]
		}

		if (typeof sources["sigma"] === "object") {
			this.sockets.inputs["sigma"].connectTo(sources["sigma"])
		} else {
			this.sockets.inputs["sigma"].value = sources["sigma"]
		}

		if (typeof sources["alpha"] === "object") {
			this.sockets.inputs["alpha"].connectTo(sources["alpha"])
		} else {
			this.sockets.inputs["alpha"].value = sources["alpha"]
		}

	}
}

type ImageSharpenInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"sharpen_radius": ComfyNodeTypedInputRef<number>
			"sigma": ComfyNodeTypedInputRef<number>
			"alpha": ComfyNodeTypedInputRef<number>
}


export class ImageScaleToTotalPixels extends ComfyNode {
	classType: string = "ImageScaleToTotalPixels"

	sockets: {
		inputs: Required<ImageScaleToTotalPixelsInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"upscale_method": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "upscale_method"),
				"megapixels": new ComfyNodeTypedInputRef<number>(this, "megapixels"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageScaleToTotalPixelsInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["upscale_method"] === "object") {
			this.sockets.inputs["upscale_method"].connectTo(sources["upscale_method"])
		} else {
			this.sockets.inputs["upscale_method"].value = sources["upscale_method"]
		}

		if (typeof sources["megapixels"] === "object") {
			this.sockets.inputs["megapixels"].connectTo(sources["megapixels"])
		} else {
			this.sockets.inputs["megapixels"].value = sources["megapixels"]
		}

	}
}

type ImageScaleToTotalPixelsInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"upscale_method": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"megapixels": ComfyNodeTypedInputRef<number>
}


export class LatentCompositeMasked extends ComfyNode {
	classType: string = "LatentCompositeMasked"

	sockets: {
		inputs: Required<LatentCompositeMaskedInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"destination": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "destination"),
				"source": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "source"),
				"x": new ComfyNodeTypedInputRef<number>(this, "x"),
				"y": new ComfyNodeTypedInputRef<number>(this, "y"),
				"resize_source": new ComfyNodeTypedInputRef<boolean>(this, "resize_source"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LatentCompositeMaskedInputs>) {
		if (typeof sources["destination"] === "object") {
			this.sockets.inputs["destination"].connectTo(sources["destination"])
		} else {
			this.sockets.inputs["destination"].value = sources["destination"]
		}

		if (typeof sources["source"] === "object") {
			this.sockets.inputs["source"].connectTo(sources["source"])
		} else {
			this.sockets.inputs["source"].value = sources["source"]
		}

		if (typeof sources["x"] === "object") {
			this.sockets.inputs["x"].connectTo(sources["x"])
		} else {
			this.sockets.inputs["x"].value = sources["x"]
		}

		if (typeof sources["y"] === "object") {
			this.sockets.inputs["y"].connectTo(sources["y"])
		} else {
			this.sockets.inputs["y"].value = sources["y"]
		}

		if (typeof sources["resize_source"] === "object") {
			this.sockets.inputs["resize_source"].connectTo(sources["resize_source"])
		} else {
			this.sockets.inputs["resize_source"].value = sources["resize_source"]
		}

		if (sources["mask"] !== undefined) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}
		}

	}
}

type LatentCompositeMaskedInputs = {
			"destination": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"source": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"x": ComfyNodeTypedInputRef<number>
			"y": ComfyNodeTypedInputRef<number>
			"resize_source": ComfyNodeTypedInputRef<boolean>
			"mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class ImageCompositeMasked extends ComfyNode {
	classType: string = "ImageCompositeMasked"

	sockets: {
		inputs: Required<ImageCompositeMaskedInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"destination": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "destination"),
				"source": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "source"),
				"x": new ComfyNodeTypedInputRef<number>(this, "x"),
				"y": new ComfyNodeTypedInputRef<number>(this, "y"),
				"resize_source": new ComfyNodeTypedInputRef<boolean>(this, "resize_source"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageCompositeMaskedInputs>) {
		if (typeof sources["destination"] === "object") {
			this.sockets.inputs["destination"].connectTo(sources["destination"])
		} else {
			this.sockets.inputs["destination"].value = sources["destination"]
		}

		if (typeof sources["source"] === "object") {
			this.sockets.inputs["source"].connectTo(sources["source"])
		} else {
			this.sockets.inputs["source"].value = sources["source"]
		}

		if (typeof sources["x"] === "object") {
			this.sockets.inputs["x"].connectTo(sources["x"])
		} else {
			this.sockets.inputs["x"].value = sources["x"]
		}

		if (typeof sources["y"] === "object") {
			this.sockets.inputs["y"].connectTo(sources["y"])
		} else {
			this.sockets.inputs["y"].value = sources["y"]
		}

		if (typeof sources["resize_source"] === "object") {
			this.sockets.inputs["resize_source"].connectTo(sources["resize_source"])
		} else {
			this.sockets.inputs["resize_source"].value = sources["resize_source"]
		}

		if (sources["mask"] !== undefined) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}
		}

	}
}

type ImageCompositeMaskedInputs = {
			"destination": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"source": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"x": ComfyNodeTypedInputRef<number>
			"y": ComfyNodeTypedInputRef<number>
			"resize_source": ComfyNodeTypedInputRef<boolean>
			"mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class MaskToImage extends ComfyNode {
	classType: string = "MaskToImage"

	sockets: {
		inputs: Required<MaskToImageInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<MaskToImageInputs>) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

	}
}

type MaskToImageInputs = {
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class ImageToMask extends ComfyNode {
	classType: string = "ImageToMask"

	sockets: {
		inputs: Required<ImageToMaskInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"channel": new ComfyNodeTypedInputRef<string>(this, "channel"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageToMaskInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["channel"] === "object") {
			this.sockets.inputs["channel"].connectTo(sources["channel"])
		} else {
			this.sockets.inputs["channel"].value = sources["channel"]
		}

	}
}

type ImageToMaskInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"channel": ComfyNodeTypedInputRef<string>
}


export class ImageColorToMask extends ComfyNode {
	classType: string = "ImageColorToMask"

	sockets: {
		inputs: Required<ImageColorToMaskInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"color": new ComfyNodeTypedInputRef<number>(this, "color"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageColorToMaskInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["color"] === "object") {
			this.sockets.inputs["color"].connectTo(sources["color"])
		} else {
			this.sockets.inputs["color"].value = sources["color"]
		}

	}
}

type ImageColorToMaskInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"color": ComfyNodeTypedInputRef<number>
}


export class SolidMask extends ComfyNode {
	classType: string = "SolidMask"

	sockets: {
		inputs: Required<SolidMaskInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"value": new ComfyNodeTypedInputRef<number>(this, "value"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SolidMaskInputs>) {
		if (typeof sources["value"] === "object") {
			this.sockets.inputs["value"].connectTo(sources["value"])
		} else {
			this.sockets.inputs["value"].value = sources["value"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

	}
}

type SolidMaskInputs = {
			"value": ComfyNodeTypedInputRef<number>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
}


export class InvertMask extends ComfyNode {
	classType: string = "InvertMask"

	sockets: {
		inputs: Required<InvertMaskInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<InvertMaskInputs>) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

	}
}

type InvertMaskInputs = {
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class CropMask extends ComfyNode {
	classType: string = "CropMask"

	sockets: {
		inputs: Required<CropMaskInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"x": new ComfyNodeTypedInputRef<number>(this, "x"),
				"y": new ComfyNodeTypedInputRef<number>(this, "y"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CropMaskInputs>) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["x"] === "object") {
			this.sockets.inputs["x"].connectTo(sources["x"])
		} else {
			this.sockets.inputs["x"].value = sources["x"]
		}

		if (typeof sources["y"] === "object") {
			this.sockets.inputs["y"].connectTo(sources["y"])
		} else {
			this.sockets.inputs["y"].value = sources["y"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

	}
}

type CropMaskInputs = {
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"x": ComfyNodeTypedInputRef<number>
			"y": ComfyNodeTypedInputRef<number>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
}


export class MaskComposite extends ComfyNode {
	classType: string = "MaskComposite"

	sockets: {
		inputs: Required<MaskCompositeInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"destination": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "destination"),
				"source": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "source"),
				"x": new ComfyNodeTypedInputRef<number>(this, "x"),
				"y": new ComfyNodeTypedInputRef<number>(this, "y"),
				"operation": new ComfyNodeTypedInputRef<string>(this, "operation"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<MaskCompositeInputs>) {
		if (typeof sources["destination"] === "object") {
			this.sockets.inputs["destination"].connectTo(sources["destination"])
		} else {
			this.sockets.inputs["destination"].value = sources["destination"]
		}

		if (typeof sources["source"] === "object") {
			this.sockets.inputs["source"].connectTo(sources["source"])
		} else {
			this.sockets.inputs["source"].value = sources["source"]
		}

		if (typeof sources["x"] === "object") {
			this.sockets.inputs["x"].connectTo(sources["x"])
		} else {
			this.sockets.inputs["x"].value = sources["x"]
		}

		if (typeof sources["y"] === "object") {
			this.sockets.inputs["y"].connectTo(sources["y"])
		} else {
			this.sockets.inputs["y"].value = sources["y"]
		}

		if (typeof sources["operation"] === "object") {
			this.sockets.inputs["operation"].connectTo(sources["operation"])
		} else {
			this.sockets.inputs["operation"].value = sources["operation"]
		}

	}
}

type MaskCompositeInputs = {
			"destination": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"source": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"x": ComfyNodeTypedInputRef<number>
			"y": ComfyNodeTypedInputRef<number>
			"operation": ComfyNodeTypedInputRef<string>
}


export class FeatherMask extends ComfyNode {
	classType: string = "FeatherMask"

	sockets: {
		inputs: Required<FeatherMaskInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"left": new ComfyNodeTypedInputRef<number>(this, "left"),
				"top": new ComfyNodeTypedInputRef<number>(this, "top"),
				"right": new ComfyNodeTypedInputRef<number>(this, "right"),
				"bottom": new ComfyNodeTypedInputRef<number>(this, "bottom"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<FeatherMaskInputs>) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["left"] === "object") {
			this.sockets.inputs["left"].connectTo(sources["left"])
		} else {
			this.sockets.inputs["left"].value = sources["left"]
		}

		if (typeof sources["top"] === "object") {
			this.sockets.inputs["top"].connectTo(sources["top"])
		} else {
			this.sockets.inputs["top"].value = sources["top"]
		}

		if (typeof sources["right"] === "object") {
			this.sockets.inputs["right"].connectTo(sources["right"])
		} else {
			this.sockets.inputs["right"].value = sources["right"]
		}

		if (typeof sources["bottom"] === "object") {
			this.sockets.inputs["bottom"].connectTo(sources["bottom"])
		} else {
			this.sockets.inputs["bottom"].value = sources["bottom"]
		}

	}
}

type FeatherMaskInputs = {
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"left": ComfyNodeTypedInputRef<number>
			"top": ComfyNodeTypedInputRef<number>
			"right": ComfyNodeTypedInputRef<number>
			"bottom": ComfyNodeTypedInputRef<number>
}


export class GrowMask extends ComfyNode {
	classType: string = "GrowMask"

	sockets: {
		inputs: Required<GrowMaskInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"expand": new ComfyNodeTypedInputRef<number>(this, "expand"),
				"tapered_corners": new ComfyNodeTypedInputRef<boolean>(this, "tapered_corners"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<GrowMaskInputs>) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["expand"] === "object") {
			this.sockets.inputs["expand"].connectTo(sources["expand"])
		} else {
			this.sockets.inputs["expand"].value = sources["expand"]
		}

		if (typeof sources["tapered_corners"] === "object") {
			this.sockets.inputs["tapered_corners"].connectTo(sources["tapered_corners"])
		} else {
			this.sockets.inputs["tapered_corners"].value = sources["tapered_corners"]
		}

	}
}

type GrowMaskInputs = {
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"expand": ComfyNodeTypedInputRef<number>
			"tapered_corners": ComfyNodeTypedInputRef<boolean>
}


export class ThresholdMask extends ComfyNode {
	classType: string = "ThresholdMask"

	sockets: {
		inputs: Required<ThresholdMaskInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"value": new ComfyNodeTypedInputRef<number>(this, "value"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ThresholdMaskInputs>) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["value"] === "object") {
			this.sockets.inputs["value"].connectTo(sources["value"])
		} else {
			this.sockets.inputs["value"].value = sources["value"]
		}

	}
}

type ThresholdMaskInputs = {
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"value": ComfyNodeTypedInputRef<number>
}


export class MaskPreview extends ComfyNode {
	classType: string = "MaskPreview"

	sockets: {
		inputs: Required<MaskPreviewInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_E>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<MaskPreviewInputs>) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type MaskPreviewInputs = {
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_E>
}


export class PorterDuffImageComposite extends ComfyNode {
	classType: string = "PorterDuffImageComposite"

	sockets: {
		inputs: Required<PorterDuffImageCompositeInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"source": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "source"),
				"source_alpha": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "source_alpha"),
				"destination": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "destination"),
				"destination_alpha": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "destination_alpha"),
				"mode": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "mode"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PorterDuffImageCompositeInputs>) {
		if (typeof sources["source"] === "object") {
			this.sockets.inputs["source"].connectTo(sources["source"])
		} else {
			this.sockets.inputs["source"].value = sources["source"]
		}

		if (typeof sources["source_alpha"] === "object") {
			this.sockets.inputs["source_alpha"].connectTo(sources["source_alpha"])
		} else {
			this.sockets.inputs["source_alpha"].value = sources["source_alpha"]
		}

		if (typeof sources["destination"] === "object") {
			this.sockets.inputs["destination"].connectTo(sources["destination"])
		} else {
			this.sockets.inputs["destination"].value = sources["destination"]
		}

		if (typeof sources["destination_alpha"] === "object") {
			this.sockets.inputs["destination_alpha"].connectTo(sources["destination_alpha"])
		} else {
			this.sockets.inputs["destination_alpha"].value = sources["destination_alpha"]
		}

		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}

	}
}

type PorterDuffImageCompositeInputs = {
			"source": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"source_alpha": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"destination": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"destination_alpha": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"mode": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class SplitImageWithAlpha extends ComfyNode {
	classType: string = "SplitImageWithAlpha"

	sockets: {
		inputs: Required<SplitImageWithAlphaInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SplitImageWithAlphaInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

	}
}

type SplitImageWithAlphaInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class JoinImageWithAlpha extends ComfyNode {
	classType: string = "JoinImageWithAlpha"

	sockets: {
		inputs: Required<JoinImageWithAlphaInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"alpha": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "alpha"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<JoinImageWithAlphaInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["alpha"] === "object") {
			this.sockets.inputs["alpha"].connectTo(sources["alpha"])
		} else {
			this.sockets.inputs["alpha"].value = sources["alpha"]
		}

	}
}

type JoinImageWithAlphaInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"alpha": ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class RebatchLatents extends ComfyNode {
	classType: string = "RebatchLatents"

	sockets: {
		inputs: Required<RebatchLatentsInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latents"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<RebatchLatentsInputs>) {
		if (typeof sources["latents"] === "object") {
			this.sockets.inputs["latents"].connectTo(sources["latents"])
		} else {
			this.sockets.inputs["latents"].value = sources["latents"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

	}
}

type RebatchLatentsInputs = {
			"latents": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"batch_size": ComfyNodeTypedInputRef<number>
}


export class RebatchImages extends ComfyNode {
	classType: string = "RebatchImages"

	sockets: {
		inputs: Required<RebatchImagesInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<RebatchImagesInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

	}
}

type RebatchImagesInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"batch_size": ComfyNodeTypedInputRef<number>
}


export class ModelMergeSimple extends ComfyNode {
	classType: string = "ModelMergeSimple"

	sockets: {
		inputs: Required<ModelMergeSimpleInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model1": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model1"),
				"model2": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model2"),
				"ratio": new ComfyNodeTypedInputRef<number>(this, "ratio"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelMergeSimpleInputs>) {
		if (typeof sources["model1"] === "object") {
			this.sockets.inputs["model1"].connectTo(sources["model1"])
		} else {
			this.sockets.inputs["model1"].value = sources["model1"]
		}

		if (typeof sources["model2"] === "object") {
			this.sockets.inputs["model2"].connectTo(sources["model2"])
		} else {
			this.sockets.inputs["model2"].value = sources["model2"]
		}

		if (typeof sources["ratio"] === "object") {
			this.sockets.inputs["ratio"].connectTo(sources["ratio"])
		} else {
			this.sockets.inputs["ratio"].value = sources["ratio"]
		}

	}
}

type ModelMergeSimpleInputs = {
			"model1": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model2": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"ratio": ComfyNodeTypedInputRef<number>
}


export class ModelMergeBlocks extends ComfyNode {
	classType: string = "ModelMergeBlocks"

	sockets: {
		inputs: Required<ModelMergeBlocksInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model1": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model1"),
				"model2": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model2"),
				"input": new ComfyNodeTypedInputRef<number>(this, "input"),
				"middle": new ComfyNodeTypedInputRef<number>(this, "middle"),
				"out": new ComfyNodeTypedInputRef<number>(this, "out"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelMergeBlocksInputs>) {
		if (typeof sources["model1"] === "object") {
			this.sockets.inputs["model1"].connectTo(sources["model1"])
		} else {
			this.sockets.inputs["model1"].value = sources["model1"]
		}

		if (typeof sources["model2"] === "object") {
			this.sockets.inputs["model2"].connectTo(sources["model2"])
		} else {
			this.sockets.inputs["model2"].value = sources["model2"]
		}

		if (typeof sources["input"] === "object") {
			this.sockets.inputs["input"].connectTo(sources["input"])
		} else {
			this.sockets.inputs["input"].value = sources["input"]
		}

		if (typeof sources["middle"] === "object") {
			this.sockets.inputs["middle"].connectTo(sources["middle"])
		} else {
			this.sockets.inputs["middle"].value = sources["middle"]
		}

		if (typeof sources["out"] === "object") {
			this.sockets.inputs["out"].connectTo(sources["out"])
		} else {
			this.sockets.inputs["out"].value = sources["out"]
		}

	}
}

type ModelMergeBlocksInputs = {
			"model1": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model2": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"input": ComfyNodeTypedInputRef<number>
			"middle": ComfyNodeTypedInputRef<number>
			"out": ComfyNodeTypedInputRef<number>
}


export class ModelMergeSubtract extends ComfyNode {
	classType: string = "ModelMergeSubtract"

	sockets: {
		inputs: Required<ModelMergeSubtractInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model1": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model1"),
				"model2": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model2"),
				"multiplier": new ComfyNodeTypedInputRef<number>(this, "multiplier"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelMergeSubtractInputs>) {
		if (typeof sources["model1"] === "object") {
			this.sockets.inputs["model1"].connectTo(sources["model1"])
		} else {
			this.sockets.inputs["model1"].value = sources["model1"]
		}

		if (typeof sources["model2"] === "object") {
			this.sockets.inputs["model2"].connectTo(sources["model2"])
		} else {
			this.sockets.inputs["model2"].value = sources["model2"]
		}

		if (typeof sources["multiplier"] === "object") {
			this.sockets.inputs["multiplier"].connectTo(sources["multiplier"])
		} else {
			this.sockets.inputs["multiplier"].value = sources["multiplier"]
		}

	}
}

type ModelMergeSubtractInputs = {
			"model1": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model2": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"multiplier": ComfyNodeTypedInputRef<number>
}


export class ModelMergeAdd extends ComfyNode {
	classType: string = "ModelMergeAdd"

	sockets: {
		inputs: Required<ModelMergeAddInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model1": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model1"),
				"model2": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model2"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelMergeAddInputs>) {
		if (typeof sources["model1"] === "object") {
			this.sockets.inputs["model1"].connectTo(sources["model1"])
		} else {
			this.sockets.inputs["model1"].value = sources["model1"]
		}

		if (typeof sources["model2"] === "object") {
			this.sockets.inputs["model2"].connectTo(sources["model2"])
		} else {
			this.sockets.inputs["model2"].value = sources["model2"]
		}

	}
}

type ModelMergeAddInputs = {
			"model1": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model2": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
}


export class CheckpointSave extends ComfyNode {
	classType: string = "CheckpointSave"

	sockets: {
		inputs: Required<CheckpointSaveInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_E>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<CheckpointSaveInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type CheckpointSaveInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"filename_prefix": ComfyNodeTypedInputRef<string>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_E>
}


export class CLIPMergeSimple extends ComfyNode {
	classType: string = "CLIPMergeSimple"

	sockets: {
		inputs: Required<CLIPMergeSimpleInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip1": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip1"),
				"clip2": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip2"),
				"ratio": new ComfyNodeTypedInputRef<number>(this, "ratio"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPMergeSimpleInputs>) {
		if (typeof sources["clip1"] === "object") {
			this.sockets.inputs["clip1"].connectTo(sources["clip1"])
		} else {
			this.sockets.inputs["clip1"].value = sources["clip1"]
		}

		if (typeof sources["clip2"] === "object") {
			this.sockets.inputs["clip2"].connectTo(sources["clip2"])
		} else {
			this.sockets.inputs["clip2"].value = sources["clip2"]
		}

		if (typeof sources["ratio"] === "object") {
			this.sockets.inputs["ratio"].connectTo(sources["ratio"])
		} else {
			this.sockets.inputs["ratio"].value = sources["ratio"]
		}

	}
}

type CLIPMergeSimpleInputs = {
			"clip1": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"clip2": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"ratio": ComfyNodeTypedInputRef<number>
}


export class CLIPMergeSubtract extends ComfyNode {
	classType: string = "CLIPMergeSubtract"

	sockets: {
		inputs: Required<CLIPMergeSubtractInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip1": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip1"),
				"clip2": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip2"),
				"multiplier": new ComfyNodeTypedInputRef<number>(this, "multiplier"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPMergeSubtractInputs>) {
		if (typeof sources["clip1"] === "object") {
			this.sockets.inputs["clip1"].connectTo(sources["clip1"])
		} else {
			this.sockets.inputs["clip1"].value = sources["clip1"]
		}

		if (typeof sources["clip2"] === "object") {
			this.sockets.inputs["clip2"].connectTo(sources["clip2"])
		} else {
			this.sockets.inputs["clip2"].value = sources["clip2"]
		}

		if (typeof sources["multiplier"] === "object") {
			this.sockets.inputs["multiplier"].connectTo(sources["multiplier"])
		} else {
			this.sockets.inputs["multiplier"].value = sources["multiplier"]
		}

	}
}

type CLIPMergeSubtractInputs = {
			"clip1": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"clip2": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"multiplier": ComfyNodeTypedInputRef<number>
}


export class CLIPMergeAdd extends ComfyNode {
	classType: string = "CLIPMergeAdd"

	sockets: {
		inputs: Required<CLIPMergeAddInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip1": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip1"),
				"clip2": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip2"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPMergeAddInputs>) {
		if (typeof sources["clip1"] === "object") {
			this.sockets.inputs["clip1"].connectTo(sources["clip1"])
		} else {
			this.sockets.inputs["clip1"].value = sources["clip1"]
		}

		if (typeof sources["clip2"] === "object") {
			this.sockets.inputs["clip2"].connectTo(sources["clip2"])
		} else {
			this.sockets.inputs["clip2"].value = sources["clip2"]
		}

	}
}

type CLIPMergeAddInputs = {
			"clip1": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"clip2": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
}


export class CLIPSave extends ComfyNode {
	classType: string = "CLIPSave"

	sockets: {
		inputs: Required<CLIPSaveInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_E>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<CLIPSaveInputs>) {
		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type CLIPSaveInputs = {
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"filename_prefix": ComfyNodeTypedInputRef<string>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_E>
}


export class VAESave extends ComfyNode {
	classType: string = "VAESave"

	sockets: {
		inputs: Required<VAESaveInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_E>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<VAESaveInputs>) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type VAESaveInputs = {
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"filename_prefix": ComfyNodeTypedInputRef<string>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_E>
}


export class ModelSave extends ComfyNode {
	classType: string = "ModelSave"

	sockets: {
		inputs: Required<ModelSaveInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_E>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<ModelSaveInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type ModelSaveInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"filename_prefix": ComfyNodeTypedInputRef<string>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_E>
}


export class TomePatchModel extends ComfyNode {
	classType: string = "TomePatchModel"

	sockets: {
		inputs: Required<TomePatchModelInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"ratio": new ComfyNodeTypedInputRef<number>(this, "ratio"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TomePatchModelInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["ratio"] === "object") {
			this.sockets.inputs["ratio"].connectTo(sources["ratio"])
		} else {
			this.sockets.inputs["ratio"].value = sources["ratio"]
		}

	}
}

type TomePatchModelInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"ratio": ComfyNodeTypedInputRef<number>
}


export class CLIPTextEncodeSDXLRefiner extends ComfyNode {
	classType: string = "CLIPTextEncodeSDXLRefiner"

	sockets: {
		inputs: Required<CLIPTextEncodeSDXLRefinerInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"ascore": new ComfyNodeTypedInputRef<number>(this, "ascore"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"text": new ComfyNodeTypedInputRef<string>(this, "text"),
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPTextEncodeSDXLRefinerInputs>) {
		if (typeof sources["ascore"] === "object") {
			this.sockets.inputs["ascore"].connectTo(sources["ascore"])
		} else {
			this.sockets.inputs["ascore"].value = sources["ascore"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["text"] === "object") {
			this.sockets.inputs["text"].connectTo(sources["text"])
		} else {
			this.sockets.inputs["text"].value = sources["text"]
		}

		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

	}
}

type CLIPTextEncodeSDXLRefinerInputs = {
			"ascore": ComfyNodeTypedInputRef<number>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"text": ComfyNodeTypedInputRef<string>
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
}


export class CLIPTextEncodeSDXL extends ComfyNode {
	classType: string = "CLIPTextEncodeSDXL"

	sockets: {
		inputs: Required<CLIPTextEncodeSDXLInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"crop_w": new ComfyNodeTypedInputRef<number>(this, "crop_w"),
				"crop_h": new ComfyNodeTypedInputRef<number>(this, "crop_h"),
				"target_width": new ComfyNodeTypedInputRef<number>(this, "target_width"),
				"target_height": new ComfyNodeTypedInputRef<number>(this, "target_height"),
				"text_g": new ComfyNodeTypedInputRef<string>(this, "text_g"),
				"text_l": new ComfyNodeTypedInputRef<string>(this, "text_l"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPTextEncodeSDXLInputs>) {
		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["crop_w"] === "object") {
			this.sockets.inputs["crop_w"].connectTo(sources["crop_w"])
		} else {
			this.sockets.inputs["crop_w"].value = sources["crop_w"]
		}

		if (typeof sources["crop_h"] === "object") {
			this.sockets.inputs["crop_h"].connectTo(sources["crop_h"])
		} else {
			this.sockets.inputs["crop_h"].value = sources["crop_h"]
		}

		if (typeof sources["target_width"] === "object") {
			this.sockets.inputs["target_width"].connectTo(sources["target_width"])
		} else {
			this.sockets.inputs["target_width"].value = sources["target_width"]
		}

		if (typeof sources["target_height"] === "object") {
			this.sockets.inputs["target_height"].connectTo(sources["target_height"])
		} else {
			this.sockets.inputs["target_height"].value = sources["target_height"]
		}

		if (typeof sources["text_g"] === "object") {
			this.sockets.inputs["text_g"].connectTo(sources["text_g"])
		} else {
			this.sockets.inputs["text_g"].value = sources["text_g"]
		}

		if (typeof sources["text_l"] === "object") {
			this.sockets.inputs["text_l"].connectTo(sources["text_l"])
		} else {
			this.sockets.inputs["text_l"].value = sources["text_l"]
		}

	}
}

type CLIPTextEncodeSDXLInputs = {
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"crop_w": ComfyNodeTypedInputRef<number>
			"crop_h": ComfyNodeTypedInputRef<number>
			"target_width": ComfyNodeTypedInputRef<number>
			"target_height": ComfyNodeTypedInputRef<number>
			"text_g": ComfyNodeTypedInputRef<string>
			"text_l": ComfyNodeTypedInputRef<string>
}


export class Canny extends ComfyNode {
	classType: string = "Canny"

	sockets: {
		inputs: Required<CannyInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"low_threshold": new ComfyNodeTypedInputRef<number>(this, "low_threshold"),
				"high_threshold": new ComfyNodeTypedInputRef<number>(this, "high_threshold"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CannyInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["low_threshold"] === "object") {
			this.sockets.inputs["low_threshold"].connectTo(sources["low_threshold"])
		} else {
			this.sockets.inputs["low_threshold"].value = sources["low_threshold"]
		}

		if (typeof sources["high_threshold"] === "object") {
			this.sockets.inputs["high_threshold"].connectTo(sources["high_threshold"])
		} else {
			this.sockets.inputs["high_threshold"].value = sources["high_threshold"]
		}

	}
}

type CannyInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"low_threshold": ComfyNodeTypedInputRef<number>
			"high_threshold": ComfyNodeTypedInputRef<number>
}


export class FreeU extends ComfyNode {
	classType: string = "FreeU"

	sockets: {
		inputs: Required<FreeUInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"b1": new ComfyNodeTypedInputRef<number>(this, "b1"),
				"b2": new ComfyNodeTypedInputRef<number>(this, "b2"),
				"s1": new ComfyNodeTypedInputRef<number>(this, "s1"),
				"s2": new ComfyNodeTypedInputRef<number>(this, "s2"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<FreeUInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["b1"] === "object") {
			this.sockets.inputs["b1"].connectTo(sources["b1"])
		} else {
			this.sockets.inputs["b1"].value = sources["b1"]
		}

		if (typeof sources["b2"] === "object") {
			this.sockets.inputs["b2"].connectTo(sources["b2"])
		} else {
			this.sockets.inputs["b2"].value = sources["b2"]
		}

		if (typeof sources["s1"] === "object") {
			this.sockets.inputs["s1"].connectTo(sources["s1"])
		} else {
			this.sockets.inputs["s1"].value = sources["s1"]
		}

		if (typeof sources["s2"] === "object") {
			this.sockets.inputs["s2"].connectTo(sources["s2"])
		} else {
			this.sockets.inputs["s2"].value = sources["s2"]
		}

	}
}

type FreeUInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"b1": ComfyNodeTypedInputRef<number>
			"b2": ComfyNodeTypedInputRef<number>
			"s1": ComfyNodeTypedInputRef<number>
			"s2": ComfyNodeTypedInputRef<number>
}


export class FreeU_V2 extends ComfyNode {
	classType: string = "FreeU_V2"

	sockets: {
		inputs: Required<FreeU_V2Inputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"b1": new ComfyNodeTypedInputRef<number>(this, "b1"),
				"b2": new ComfyNodeTypedInputRef<number>(this, "b2"),
				"s1": new ComfyNodeTypedInputRef<number>(this, "s1"),
				"s2": new ComfyNodeTypedInputRef<number>(this, "s2"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<FreeU_V2Inputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["b1"] === "object") {
			this.sockets.inputs["b1"].connectTo(sources["b1"])
		} else {
			this.sockets.inputs["b1"].value = sources["b1"]
		}

		if (typeof sources["b2"] === "object") {
			this.sockets.inputs["b2"].connectTo(sources["b2"])
		} else {
			this.sockets.inputs["b2"].value = sources["b2"]
		}

		if (typeof sources["s1"] === "object") {
			this.sockets.inputs["s1"].connectTo(sources["s1"])
		} else {
			this.sockets.inputs["s1"].value = sources["s1"]
		}

		if (typeof sources["s2"] === "object") {
			this.sockets.inputs["s2"].connectTo(sources["s2"])
		} else {
			this.sockets.inputs["s2"].value = sources["s2"]
		}

	}
}

type FreeU_V2Inputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"b1": ComfyNodeTypedInputRef<number>
			"b2": ComfyNodeTypedInputRef<number>
			"s1": ComfyNodeTypedInputRef<number>
			"s2": ComfyNodeTypedInputRef<number>
}


export class SamplerCustom extends ComfyNode {
	classType: string = "SamplerCustom"

	sockets: {
		inputs: Required<SamplerCustomInputs>
		outputs: {
			output: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
			denoised_output: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"add_noise": new ComfyNodeTypedInputRef<boolean>(this, "add_noise"),
				"noise_seed": new ComfyNodeTypedInputRef<number>(this, "noise_seed"),
				"cfg": new ComfyNodeTypedInputRef<number>(this, "cfg"),
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"sampler": new ComfyNodeTypedInputRef<ComfyValueType_SAMPLER>(this, "sampler"),
				"sigmas": new ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>(this, "sigmas"),
				"latent_image": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latent_image"),
			},
			outputs: Object.create(Object.prototype, {
				"output": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"denoised_output": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SamplerCustomInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["add_noise"] === "object") {
			this.sockets.inputs["add_noise"].connectTo(sources["add_noise"])
		} else {
			this.sockets.inputs["add_noise"].value = sources["add_noise"]
		}

		if (typeof sources["noise_seed"] === "object") {
			this.sockets.inputs["noise_seed"].connectTo(sources["noise_seed"])
		} else {
			this.sockets.inputs["noise_seed"].value = sources["noise_seed"]
		}

		if (typeof sources["cfg"] === "object") {
			this.sockets.inputs["cfg"].connectTo(sources["cfg"])
		} else {
			this.sockets.inputs["cfg"].value = sources["cfg"]
		}

		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["sampler"] === "object") {
			this.sockets.inputs["sampler"].connectTo(sources["sampler"])
		} else {
			this.sockets.inputs["sampler"].value = sources["sampler"]
		}

		if (typeof sources["sigmas"] === "object") {
			this.sockets.inputs["sigmas"].connectTo(sources["sigmas"])
		} else {
			this.sockets.inputs["sigmas"].value = sources["sigmas"]
		}

		if (typeof sources["latent_image"] === "object") {
			this.sockets.inputs["latent_image"].connectTo(sources["latent_image"])
		} else {
			this.sockets.inputs["latent_image"].value = sources["latent_image"]
		}

	}
}

type SamplerCustomInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"add_noise": ComfyNodeTypedInputRef<boolean>
			"noise_seed": ComfyNodeTypedInputRef<number>
			"cfg": ComfyNodeTypedInputRef<number>
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"sampler": ComfyNodeTypedInputRef<ComfyValueType_SAMPLER>
			"sigmas": ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>
			"latent_image": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class BasicScheduler extends ComfyNode {
	classType: string = "BasicScheduler"

	sockets: {
		inputs: Required<BasicSchedulerInputs>
		outputs: {
			SIGMAS: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"scheduler": new ComfyNodeTypedInputRef<string>(this, "scheduler"),
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"denoise": new ComfyNodeTypedInputRef<number>(this, "denoise"),
			},
			outputs: Object.create(Object.prototype, {
				"SIGMAS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<BasicSchedulerInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["scheduler"] === "object") {
			this.sockets.inputs["scheduler"].connectTo(sources["scheduler"])
		} else {
			this.sockets.inputs["scheduler"].value = sources["scheduler"]
		}

		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["denoise"] === "object") {
			this.sockets.inputs["denoise"].connectTo(sources["denoise"])
		} else {
			this.sockets.inputs["denoise"].value = sources["denoise"]
		}

	}
}

type BasicSchedulerInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"scheduler": ComfyNodeTypedInputRef<string>
			"steps": ComfyNodeTypedInputRef<number>
			"denoise": ComfyNodeTypedInputRef<number>
}


export class KarrasScheduler extends ComfyNode {
	classType: string = "KarrasScheduler"

	sockets: {
		inputs: Required<KarrasSchedulerInputs>
		outputs: {
			SIGMAS: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"sigma_max": new ComfyNodeTypedInputRef<number>(this, "sigma_max"),
				"sigma_min": new ComfyNodeTypedInputRef<number>(this, "sigma_min"),
				"rho": new ComfyNodeTypedInputRef<number>(this, "rho"),
			},
			outputs: Object.create(Object.prototype, {
				"SIGMAS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<KarrasSchedulerInputs>) {
		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["sigma_max"] === "object") {
			this.sockets.inputs["sigma_max"].connectTo(sources["sigma_max"])
		} else {
			this.sockets.inputs["sigma_max"].value = sources["sigma_max"]
		}

		if (typeof sources["sigma_min"] === "object") {
			this.sockets.inputs["sigma_min"].connectTo(sources["sigma_min"])
		} else {
			this.sockets.inputs["sigma_min"].value = sources["sigma_min"]
		}

		if (typeof sources["rho"] === "object") {
			this.sockets.inputs["rho"].connectTo(sources["rho"])
		} else {
			this.sockets.inputs["rho"].value = sources["rho"]
		}

	}
}

type KarrasSchedulerInputs = {
			"steps": ComfyNodeTypedInputRef<number>
			"sigma_max": ComfyNodeTypedInputRef<number>
			"sigma_min": ComfyNodeTypedInputRef<number>
			"rho": ComfyNodeTypedInputRef<number>
}


export class ExponentialScheduler extends ComfyNode {
	classType: string = "ExponentialScheduler"

	sockets: {
		inputs: Required<ExponentialSchedulerInputs>
		outputs: {
			SIGMAS: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"sigma_max": new ComfyNodeTypedInputRef<number>(this, "sigma_max"),
				"sigma_min": new ComfyNodeTypedInputRef<number>(this, "sigma_min"),
			},
			outputs: Object.create(Object.prototype, {
				"SIGMAS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ExponentialSchedulerInputs>) {
		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["sigma_max"] === "object") {
			this.sockets.inputs["sigma_max"].connectTo(sources["sigma_max"])
		} else {
			this.sockets.inputs["sigma_max"].value = sources["sigma_max"]
		}

		if (typeof sources["sigma_min"] === "object") {
			this.sockets.inputs["sigma_min"].connectTo(sources["sigma_min"])
		} else {
			this.sockets.inputs["sigma_min"].value = sources["sigma_min"]
		}

	}
}

type ExponentialSchedulerInputs = {
			"steps": ComfyNodeTypedInputRef<number>
			"sigma_max": ComfyNodeTypedInputRef<number>
			"sigma_min": ComfyNodeTypedInputRef<number>
}


export class PolyexponentialScheduler extends ComfyNode {
	classType: string = "PolyexponentialScheduler"

	sockets: {
		inputs: Required<PolyexponentialSchedulerInputs>
		outputs: {
			SIGMAS: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"sigma_max": new ComfyNodeTypedInputRef<number>(this, "sigma_max"),
				"sigma_min": new ComfyNodeTypedInputRef<number>(this, "sigma_min"),
				"rho": new ComfyNodeTypedInputRef<number>(this, "rho"),
			},
			outputs: Object.create(Object.prototype, {
				"SIGMAS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PolyexponentialSchedulerInputs>) {
		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["sigma_max"] === "object") {
			this.sockets.inputs["sigma_max"].connectTo(sources["sigma_max"])
		} else {
			this.sockets.inputs["sigma_max"].value = sources["sigma_max"]
		}

		if (typeof sources["sigma_min"] === "object") {
			this.sockets.inputs["sigma_min"].connectTo(sources["sigma_min"])
		} else {
			this.sockets.inputs["sigma_min"].value = sources["sigma_min"]
		}

		if (typeof sources["rho"] === "object") {
			this.sockets.inputs["rho"].connectTo(sources["rho"])
		} else {
			this.sockets.inputs["rho"].value = sources["rho"]
		}

	}
}

type PolyexponentialSchedulerInputs = {
			"steps": ComfyNodeTypedInputRef<number>
			"sigma_max": ComfyNodeTypedInputRef<number>
			"sigma_min": ComfyNodeTypedInputRef<number>
			"rho": ComfyNodeTypedInputRef<number>
}


export class LaplaceScheduler extends ComfyNode {
	classType: string = "LaplaceScheduler"

	sockets: {
		inputs: Required<LaplaceSchedulerInputs>
		outputs: {
			SIGMAS: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"sigma_max": new ComfyNodeTypedInputRef<number>(this, "sigma_max"),
				"sigma_min": new ComfyNodeTypedInputRef<number>(this, "sigma_min"),
				"mu": new ComfyNodeTypedInputRef<number>(this, "mu"),
				"beta": new ComfyNodeTypedInputRef<number>(this, "beta"),
			},
			outputs: Object.create(Object.prototype, {
				"SIGMAS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LaplaceSchedulerInputs>) {
		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["sigma_max"] === "object") {
			this.sockets.inputs["sigma_max"].connectTo(sources["sigma_max"])
		} else {
			this.sockets.inputs["sigma_max"].value = sources["sigma_max"]
		}

		if (typeof sources["sigma_min"] === "object") {
			this.sockets.inputs["sigma_min"].connectTo(sources["sigma_min"])
		} else {
			this.sockets.inputs["sigma_min"].value = sources["sigma_min"]
		}

		if (typeof sources["mu"] === "object") {
			this.sockets.inputs["mu"].connectTo(sources["mu"])
		} else {
			this.sockets.inputs["mu"].value = sources["mu"]
		}

		if (typeof sources["beta"] === "object") {
			this.sockets.inputs["beta"].connectTo(sources["beta"])
		} else {
			this.sockets.inputs["beta"].value = sources["beta"]
		}

	}
}

type LaplaceSchedulerInputs = {
			"steps": ComfyNodeTypedInputRef<number>
			"sigma_max": ComfyNodeTypedInputRef<number>
			"sigma_min": ComfyNodeTypedInputRef<number>
			"mu": ComfyNodeTypedInputRef<number>
			"beta": ComfyNodeTypedInputRef<number>
}


export class VPScheduler extends ComfyNode {
	classType: string = "VPScheduler"

	sockets: {
		inputs: Required<VPSchedulerInputs>
		outputs: {
			SIGMAS: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"beta_d": new ComfyNodeTypedInputRef<number>(this, "beta_d"),
				"beta_min": new ComfyNodeTypedInputRef<number>(this, "beta_min"),
				"eps_s": new ComfyNodeTypedInputRef<number>(this, "eps_s"),
			},
			outputs: Object.create(Object.prototype, {
				"SIGMAS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VPSchedulerInputs>) {
		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["beta_d"] === "object") {
			this.sockets.inputs["beta_d"].connectTo(sources["beta_d"])
		} else {
			this.sockets.inputs["beta_d"].value = sources["beta_d"]
		}

		if (typeof sources["beta_min"] === "object") {
			this.sockets.inputs["beta_min"].connectTo(sources["beta_min"])
		} else {
			this.sockets.inputs["beta_min"].value = sources["beta_min"]
		}

		if (typeof sources["eps_s"] === "object") {
			this.sockets.inputs["eps_s"].connectTo(sources["eps_s"])
		} else {
			this.sockets.inputs["eps_s"].value = sources["eps_s"]
		}

	}
}

type VPSchedulerInputs = {
			"steps": ComfyNodeTypedInputRef<number>
			"beta_d": ComfyNodeTypedInputRef<number>
			"beta_min": ComfyNodeTypedInputRef<number>
			"eps_s": ComfyNodeTypedInputRef<number>
}


export class BetaSamplingScheduler extends ComfyNode {
	classType: string = "BetaSamplingScheduler"

	sockets: {
		inputs: Required<BetaSamplingSchedulerInputs>
		outputs: {
			SIGMAS: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"alpha": new ComfyNodeTypedInputRef<number>(this, "alpha"),
				"beta": new ComfyNodeTypedInputRef<number>(this, "beta"),
			},
			outputs: Object.create(Object.prototype, {
				"SIGMAS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<BetaSamplingSchedulerInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["alpha"] === "object") {
			this.sockets.inputs["alpha"].connectTo(sources["alpha"])
		} else {
			this.sockets.inputs["alpha"].value = sources["alpha"]
		}

		if (typeof sources["beta"] === "object") {
			this.sockets.inputs["beta"].connectTo(sources["beta"])
		} else {
			this.sockets.inputs["beta"].value = sources["beta"]
		}

	}
}

type BetaSamplingSchedulerInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"steps": ComfyNodeTypedInputRef<number>
			"alpha": ComfyNodeTypedInputRef<number>
			"beta": ComfyNodeTypedInputRef<number>
}


export class SDTurboScheduler extends ComfyNode {
	classType: string = "SDTurboScheduler"

	sockets: {
		inputs: Required<SDTurboSchedulerInputs>
		outputs: {
			SIGMAS: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"denoise": new ComfyNodeTypedInputRef<number>(this, "denoise"),
			},
			outputs: Object.create(Object.prototype, {
				"SIGMAS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SDTurboSchedulerInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["denoise"] === "object") {
			this.sockets.inputs["denoise"].connectTo(sources["denoise"])
		} else {
			this.sockets.inputs["denoise"].value = sources["denoise"]
		}

	}
}

type SDTurboSchedulerInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"steps": ComfyNodeTypedInputRef<number>
			"denoise": ComfyNodeTypedInputRef<number>
}


export class KSamplerSelect extends ComfyNode {
	classType: string = "KSamplerSelect"

	sockets: {
		inputs: Required<KSamplerSelectInputs>
		outputs: {
			SAMPLER: ComfyNodeTypedSourceRef<ComfyValueType_SAMPLER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"sampler_name": new ComfyNodeTypedInputRef<string>(this, "sampler_name"),
			},
			outputs: Object.create(Object.prototype, {
				"SAMPLER": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<KSamplerSelectInputs>) {
		if (typeof sources["sampler_name"] === "object") {
			this.sockets.inputs["sampler_name"].connectTo(sources["sampler_name"])
		} else {
			this.sockets.inputs["sampler_name"].value = sources["sampler_name"]
		}

	}
}

type KSamplerSelectInputs = {
			"sampler_name": ComfyNodeTypedInputRef<string>
}


export class SamplerEulerAncestral extends ComfyNode {
	classType: string = "SamplerEulerAncestral"

	sockets: {
		inputs: Required<SamplerEulerAncestralInputs>
		outputs: {
			SAMPLER: ComfyNodeTypedSourceRef<ComfyValueType_SAMPLER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"eta": new ComfyNodeTypedInputRef<number>(this, "eta"),
				"s_noise": new ComfyNodeTypedInputRef<number>(this, "s_noise"),
			},
			outputs: Object.create(Object.prototype, {
				"SAMPLER": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SamplerEulerAncestralInputs>) {
		if (typeof sources["eta"] === "object") {
			this.sockets.inputs["eta"].connectTo(sources["eta"])
		} else {
			this.sockets.inputs["eta"].value = sources["eta"]
		}

		if (typeof sources["s_noise"] === "object") {
			this.sockets.inputs["s_noise"].connectTo(sources["s_noise"])
		} else {
			this.sockets.inputs["s_noise"].value = sources["s_noise"]
		}

	}
}

type SamplerEulerAncestralInputs = {
			"eta": ComfyNodeTypedInputRef<number>
			"s_noise": ComfyNodeTypedInputRef<number>
}


export class SamplerEulerAncestralCFGPP extends ComfyNode {
	classType: string = "SamplerEulerAncestralCFGPP"

	sockets: {
		inputs: Required<SamplerEulerAncestralCFGPPInputs>
		outputs: {
			SAMPLER: ComfyNodeTypedSourceRef<ComfyValueType_SAMPLER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"eta": new ComfyNodeTypedInputRef<number>(this, "eta"),
				"s_noise": new ComfyNodeTypedInputRef<number>(this, "s_noise"),
			},
			outputs: Object.create(Object.prototype, {
				"SAMPLER": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SamplerEulerAncestralCFGPPInputs>) {
		if (typeof sources["eta"] === "object") {
			this.sockets.inputs["eta"].connectTo(sources["eta"])
		} else {
			this.sockets.inputs["eta"].value = sources["eta"]
		}

		if (typeof sources["s_noise"] === "object") {
			this.sockets.inputs["s_noise"].connectTo(sources["s_noise"])
		} else {
			this.sockets.inputs["s_noise"].value = sources["s_noise"]
		}

	}
}

type SamplerEulerAncestralCFGPPInputs = {
			"eta": ComfyNodeTypedInputRef<number>
			"s_noise": ComfyNodeTypedInputRef<number>
}


export class SamplerLMS extends ComfyNode {
	classType: string = "SamplerLMS"

	sockets: {
		inputs: Required<SamplerLMSInputs>
		outputs: {
			SAMPLER: ComfyNodeTypedSourceRef<ComfyValueType_SAMPLER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"order": new ComfyNodeTypedInputRef<number>(this, "order"),
			},
			outputs: Object.create(Object.prototype, {
				"SAMPLER": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SamplerLMSInputs>) {
		if (typeof sources["order"] === "object") {
			this.sockets.inputs["order"].connectTo(sources["order"])
		} else {
			this.sockets.inputs["order"].value = sources["order"]
		}

	}
}

type SamplerLMSInputs = {
			"order": ComfyNodeTypedInputRef<number>
}


export class SamplerDPMPP_3M_SDE extends ComfyNode {
	classType: string = "SamplerDPMPP_3M_SDE"

	sockets: {
		inputs: Required<SamplerDPMPP_3M_SDEInputs>
		outputs: {
			SAMPLER: ComfyNodeTypedSourceRef<ComfyValueType_SAMPLER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"eta": new ComfyNodeTypedInputRef<number>(this, "eta"),
				"s_noise": new ComfyNodeTypedInputRef<number>(this, "s_noise"),
				"noise_device": new ComfyNodeTypedInputRef<string>(this, "noise_device"),
			},
			outputs: Object.create(Object.prototype, {
				"SAMPLER": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SamplerDPMPP_3M_SDEInputs>) {
		if (typeof sources["eta"] === "object") {
			this.sockets.inputs["eta"].connectTo(sources["eta"])
		} else {
			this.sockets.inputs["eta"].value = sources["eta"]
		}

		if (typeof sources["s_noise"] === "object") {
			this.sockets.inputs["s_noise"].connectTo(sources["s_noise"])
		} else {
			this.sockets.inputs["s_noise"].value = sources["s_noise"]
		}

		if (typeof sources["noise_device"] === "object") {
			this.sockets.inputs["noise_device"].connectTo(sources["noise_device"])
		} else {
			this.sockets.inputs["noise_device"].value = sources["noise_device"]
		}

	}
}

type SamplerDPMPP_3M_SDEInputs = {
			"eta": ComfyNodeTypedInputRef<number>
			"s_noise": ComfyNodeTypedInputRef<number>
			"noise_device": ComfyNodeTypedInputRef<string>
}


export class SamplerDPMPP_2M_SDE extends ComfyNode {
	classType: string = "SamplerDPMPP_2M_SDE"

	sockets: {
		inputs: Required<SamplerDPMPP_2M_SDEInputs>
		outputs: {
			SAMPLER: ComfyNodeTypedSourceRef<ComfyValueType_SAMPLER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"solver_type": new ComfyNodeTypedInputRef<string>(this, "solver_type"),
				"eta": new ComfyNodeTypedInputRef<number>(this, "eta"),
				"s_noise": new ComfyNodeTypedInputRef<number>(this, "s_noise"),
				"noise_device": new ComfyNodeTypedInputRef<string>(this, "noise_device"),
			},
			outputs: Object.create(Object.prototype, {
				"SAMPLER": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SamplerDPMPP_2M_SDEInputs>) {
		if (typeof sources["solver_type"] === "object") {
			this.sockets.inputs["solver_type"].connectTo(sources["solver_type"])
		} else {
			this.sockets.inputs["solver_type"].value = sources["solver_type"]
		}

		if (typeof sources["eta"] === "object") {
			this.sockets.inputs["eta"].connectTo(sources["eta"])
		} else {
			this.sockets.inputs["eta"].value = sources["eta"]
		}

		if (typeof sources["s_noise"] === "object") {
			this.sockets.inputs["s_noise"].connectTo(sources["s_noise"])
		} else {
			this.sockets.inputs["s_noise"].value = sources["s_noise"]
		}

		if (typeof sources["noise_device"] === "object") {
			this.sockets.inputs["noise_device"].connectTo(sources["noise_device"])
		} else {
			this.sockets.inputs["noise_device"].value = sources["noise_device"]
		}

	}
}

type SamplerDPMPP_2M_SDEInputs = {
			"solver_type": ComfyNodeTypedInputRef<string>
			"eta": ComfyNodeTypedInputRef<number>
			"s_noise": ComfyNodeTypedInputRef<number>
			"noise_device": ComfyNodeTypedInputRef<string>
}


export class SamplerDPMPP_SDE extends ComfyNode {
	classType: string = "SamplerDPMPP_SDE"

	sockets: {
		inputs: Required<SamplerDPMPP_SDEInputs>
		outputs: {
			SAMPLER: ComfyNodeTypedSourceRef<ComfyValueType_SAMPLER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"eta": new ComfyNodeTypedInputRef<number>(this, "eta"),
				"s_noise": new ComfyNodeTypedInputRef<number>(this, "s_noise"),
				"r": new ComfyNodeTypedInputRef<number>(this, "r"),
				"noise_device": new ComfyNodeTypedInputRef<string>(this, "noise_device"),
			},
			outputs: Object.create(Object.prototype, {
				"SAMPLER": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SamplerDPMPP_SDEInputs>) {
		if (typeof sources["eta"] === "object") {
			this.sockets.inputs["eta"].connectTo(sources["eta"])
		} else {
			this.sockets.inputs["eta"].value = sources["eta"]
		}

		if (typeof sources["s_noise"] === "object") {
			this.sockets.inputs["s_noise"].connectTo(sources["s_noise"])
		} else {
			this.sockets.inputs["s_noise"].value = sources["s_noise"]
		}

		if (typeof sources["r"] === "object") {
			this.sockets.inputs["r"].connectTo(sources["r"])
		} else {
			this.sockets.inputs["r"].value = sources["r"]
		}

		if (typeof sources["noise_device"] === "object") {
			this.sockets.inputs["noise_device"].connectTo(sources["noise_device"])
		} else {
			this.sockets.inputs["noise_device"].value = sources["noise_device"]
		}

	}
}

type SamplerDPMPP_SDEInputs = {
			"eta": ComfyNodeTypedInputRef<number>
			"s_noise": ComfyNodeTypedInputRef<number>
			"r": ComfyNodeTypedInputRef<number>
			"noise_device": ComfyNodeTypedInputRef<string>
}


export class SamplerDPMPP_2S_Ancestral extends ComfyNode {
	classType: string = "SamplerDPMPP_2S_Ancestral"

	sockets: {
		inputs: Required<SamplerDPMPP_2S_AncestralInputs>
		outputs: {
			SAMPLER: ComfyNodeTypedSourceRef<ComfyValueType_SAMPLER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"eta": new ComfyNodeTypedInputRef<number>(this, "eta"),
				"s_noise": new ComfyNodeTypedInputRef<number>(this, "s_noise"),
			},
			outputs: Object.create(Object.prototype, {
				"SAMPLER": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SamplerDPMPP_2S_AncestralInputs>) {
		if (typeof sources["eta"] === "object") {
			this.sockets.inputs["eta"].connectTo(sources["eta"])
		} else {
			this.sockets.inputs["eta"].value = sources["eta"]
		}

		if (typeof sources["s_noise"] === "object") {
			this.sockets.inputs["s_noise"].connectTo(sources["s_noise"])
		} else {
			this.sockets.inputs["s_noise"].value = sources["s_noise"]
		}

	}
}

type SamplerDPMPP_2S_AncestralInputs = {
			"eta": ComfyNodeTypedInputRef<number>
			"s_noise": ComfyNodeTypedInputRef<number>
}


export class SamplerDPMAdaptative extends ComfyNode {
	classType: string = "SamplerDPMAdaptative"

	sockets: {
		inputs: Required<SamplerDPMAdaptativeInputs>
		outputs: {
			SAMPLER: ComfyNodeTypedSourceRef<ComfyValueType_SAMPLER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"order": new ComfyNodeTypedInputRef<number>(this, "order"),
				"rtol": new ComfyNodeTypedInputRef<number>(this, "rtol"),
				"atol": new ComfyNodeTypedInputRef<number>(this, "atol"),
				"h_init": new ComfyNodeTypedInputRef<number>(this, "h_init"),
				"pcoeff": new ComfyNodeTypedInputRef<number>(this, "pcoeff"),
				"icoeff": new ComfyNodeTypedInputRef<number>(this, "icoeff"),
				"dcoeff": new ComfyNodeTypedInputRef<number>(this, "dcoeff"),
				"accept_safety": new ComfyNodeTypedInputRef<number>(this, "accept_safety"),
				"eta": new ComfyNodeTypedInputRef<number>(this, "eta"),
				"s_noise": new ComfyNodeTypedInputRef<number>(this, "s_noise"),
			},
			outputs: Object.create(Object.prototype, {
				"SAMPLER": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SamplerDPMAdaptativeInputs>) {
		if (typeof sources["order"] === "object") {
			this.sockets.inputs["order"].connectTo(sources["order"])
		} else {
			this.sockets.inputs["order"].value = sources["order"]
		}

		if (typeof sources["rtol"] === "object") {
			this.sockets.inputs["rtol"].connectTo(sources["rtol"])
		} else {
			this.sockets.inputs["rtol"].value = sources["rtol"]
		}

		if (typeof sources["atol"] === "object") {
			this.sockets.inputs["atol"].connectTo(sources["atol"])
		} else {
			this.sockets.inputs["atol"].value = sources["atol"]
		}

		if (typeof sources["h_init"] === "object") {
			this.sockets.inputs["h_init"].connectTo(sources["h_init"])
		} else {
			this.sockets.inputs["h_init"].value = sources["h_init"]
		}

		if (typeof sources["pcoeff"] === "object") {
			this.sockets.inputs["pcoeff"].connectTo(sources["pcoeff"])
		} else {
			this.sockets.inputs["pcoeff"].value = sources["pcoeff"]
		}

		if (typeof sources["icoeff"] === "object") {
			this.sockets.inputs["icoeff"].connectTo(sources["icoeff"])
		} else {
			this.sockets.inputs["icoeff"].value = sources["icoeff"]
		}

		if (typeof sources["dcoeff"] === "object") {
			this.sockets.inputs["dcoeff"].connectTo(sources["dcoeff"])
		} else {
			this.sockets.inputs["dcoeff"].value = sources["dcoeff"]
		}

		if (typeof sources["accept_safety"] === "object") {
			this.sockets.inputs["accept_safety"].connectTo(sources["accept_safety"])
		} else {
			this.sockets.inputs["accept_safety"].value = sources["accept_safety"]
		}

		if (typeof sources["eta"] === "object") {
			this.sockets.inputs["eta"].connectTo(sources["eta"])
		} else {
			this.sockets.inputs["eta"].value = sources["eta"]
		}

		if (typeof sources["s_noise"] === "object") {
			this.sockets.inputs["s_noise"].connectTo(sources["s_noise"])
		} else {
			this.sockets.inputs["s_noise"].value = sources["s_noise"]
		}

	}
}

type SamplerDPMAdaptativeInputs = {
			"order": ComfyNodeTypedInputRef<number>
			"rtol": ComfyNodeTypedInputRef<number>
			"atol": ComfyNodeTypedInputRef<number>
			"h_init": ComfyNodeTypedInputRef<number>
			"pcoeff": ComfyNodeTypedInputRef<number>
			"icoeff": ComfyNodeTypedInputRef<number>
			"dcoeff": ComfyNodeTypedInputRef<number>
			"accept_safety": ComfyNodeTypedInputRef<number>
			"eta": ComfyNodeTypedInputRef<number>
			"s_noise": ComfyNodeTypedInputRef<number>
}


export class SamplerER_SDE extends ComfyNode {
	classType: string = "SamplerER_SDE"

	sockets: {
		inputs: Required<SamplerER_SDEInputs>
		outputs: {
			SAMPLER: ComfyNodeTypedSourceRef<ComfyValueType_SAMPLER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"solver_type": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "solver_type"),
				"max_stage": new ComfyNodeTypedInputRef<number>(this, "max_stage"),
				"eta": new ComfyNodeTypedInputRef<number>(this, "eta"),
				"s_noise": new ComfyNodeTypedInputRef<number>(this, "s_noise"),
			},
			outputs: Object.create(Object.prototype, {
				"SAMPLER": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SamplerER_SDEInputs>) {
		if (typeof sources["solver_type"] === "object") {
			this.sockets.inputs["solver_type"].connectTo(sources["solver_type"])
		} else {
			this.sockets.inputs["solver_type"].value = sources["solver_type"]
		}

		if (typeof sources["max_stage"] === "object") {
			this.sockets.inputs["max_stage"].connectTo(sources["max_stage"])
		} else {
			this.sockets.inputs["max_stage"].value = sources["max_stage"]
		}

		if (typeof sources["eta"] === "object") {
			this.sockets.inputs["eta"].connectTo(sources["eta"])
		} else {
			this.sockets.inputs["eta"].value = sources["eta"]
		}

		if (typeof sources["s_noise"] === "object") {
			this.sockets.inputs["s_noise"].connectTo(sources["s_noise"])
		} else {
			this.sockets.inputs["s_noise"].value = sources["s_noise"]
		}

	}
}

type SamplerER_SDEInputs = {
			"solver_type": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"max_stage": ComfyNodeTypedInputRef<number>
			/** Stochastic strength of reverse-time SDE.
When eta=0, it reduces to deterministic ODE. This setting doesn't apply to ER-SDE solver type.*/
			"eta": ComfyNodeTypedInputRef<number>
			"s_noise": ComfyNodeTypedInputRef<number>
}


export class SamplerSASolver extends ComfyNode {
	classType: string = "SamplerSASolver"

	sockets: {
		inputs: Required<SamplerSASolverInputs>
		outputs: {
			SAMPLER: ComfyNodeTypedSourceRef<ComfyValueType_SAMPLER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"eta": new ComfyNodeTypedInputRef<number>(this, "eta"),
				"sde_start_percent": new ComfyNodeTypedInputRef<number>(this, "sde_start_percent"),
				"sde_end_percent": new ComfyNodeTypedInputRef<number>(this, "sde_end_percent"),
				"s_noise": new ComfyNodeTypedInputRef<number>(this, "s_noise"),
				"predictor_order": new ComfyNodeTypedInputRef<number>(this, "predictor_order"),
				"corrector_order": new ComfyNodeTypedInputRef<number>(this, "corrector_order"),
				"use_pece": new ComfyNodeTypedInputRef<boolean>(this, "use_pece"),
				"simple_order_2": new ComfyNodeTypedInputRef<boolean>(this, "simple_order_2"),
			},
			outputs: Object.create(Object.prototype, {
				"SAMPLER": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SamplerSASolverInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["eta"] === "object") {
			this.sockets.inputs["eta"].connectTo(sources["eta"])
		} else {
			this.sockets.inputs["eta"].value = sources["eta"]
		}

		if (typeof sources["sde_start_percent"] === "object") {
			this.sockets.inputs["sde_start_percent"].connectTo(sources["sde_start_percent"])
		} else {
			this.sockets.inputs["sde_start_percent"].value = sources["sde_start_percent"]
		}

		if (typeof sources["sde_end_percent"] === "object") {
			this.sockets.inputs["sde_end_percent"].connectTo(sources["sde_end_percent"])
		} else {
			this.sockets.inputs["sde_end_percent"].value = sources["sde_end_percent"]
		}

		if (typeof sources["s_noise"] === "object") {
			this.sockets.inputs["s_noise"].connectTo(sources["s_noise"])
		} else {
			this.sockets.inputs["s_noise"].value = sources["s_noise"]
		}

		if (typeof sources["predictor_order"] === "object") {
			this.sockets.inputs["predictor_order"].connectTo(sources["predictor_order"])
		} else {
			this.sockets.inputs["predictor_order"].value = sources["predictor_order"]
		}

		if (typeof sources["corrector_order"] === "object") {
			this.sockets.inputs["corrector_order"].connectTo(sources["corrector_order"])
		} else {
			this.sockets.inputs["corrector_order"].value = sources["corrector_order"]
		}

		if (typeof sources["use_pece"] === "object") {
			this.sockets.inputs["use_pece"].connectTo(sources["use_pece"])
		} else {
			this.sockets.inputs["use_pece"].value = sources["use_pece"]
		}

		if (typeof sources["simple_order_2"] === "object") {
			this.sockets.inputs["simple_order_2"].connectTo(sources["simple_order_2"])
		} else {
			this.sockets.inputs["simple_order_2"].value = sources["simple_order_2"]
		}

	}
}

type SamplerSASolverInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"eta": ComfyNodeTypedInputRef<number>
			"sde_start_percent": ComfyNodeTypedInputRef<number>
			"sde_end_percent": ComfyNodeTypedInputRef<number>
			"s_noise": ComfyNodeTypedInputRef<number>
			"predictor_order": ComfyNodeTypedInputRef<number>
			"corrector_order": ComfyNodeTypedInputRef<number>
			"use_pece": ComfyNodeTypedInputRef<boolean>
			"simple_order_2": ComfyNodeTypedInputRef<boolean>
}


export class SplitSigmas extends ComfyNode {
	classType: string = "SplitSigmas"

	sockets: {
		inputs: Required<SplitSigmasInputs>
		outputs: {
			high_sigmas: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
			low_sigmas: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"sigmas": new ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>(this, "sigmas"),
				"step": new ComfyNodeTypedInputRef<number>(this, "step"),
			},
			outputs: Object.create(Object.prototype, {
				"high_sigmas": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"low_sigmas": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SplitSigmasInputs>) {
		if (typeof sources["sigmas"] === "object") {
			this.sockets.inputs["sigmas"].connectTo(sources["sigmas"])
		} else {
			this.sockets.inputs["sigmas"].value = sources["sigmas"]
		}

		if (typeof sources["step"] === "object") {
			this.sockets.inputs["step"].connectTo(sources["step"])
		} else {
			this.sockets.inputs["step"].value = sources["step"]
		}

	}
}

type SplitSigmasInputs = {
			"sigmas": ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>
			"step": ComfyNodeTypedInputRef<number>
}


export class SplitSigmasDenoise extends ComfyNode {
	classType: string = "SplitSigmasDenoise"

	sockets: {
		inputs: Required<SplitSigmasDenoiseInputs>
		outputs: {
			high_sigmas: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
			low_sigmas: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"sigmas": new ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>(this, "sigmas"),
				"denoise": new ComfyNodeTypedInputRef<number>(this, "denoise"),
			},
			outputs: Object.create(Object.prototype, {
				"high_sigmas": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"low_sigmas": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SplitSigmasDenoiseInputs>) {
		if (typeof sources["sigmas"] === "object") {
			this.sockets.inputs["sigmas"].connectTo(sources["sigmas"])
		} else {
			this.sockets.inputs["sigmas"].value = sources["sigmas"]
		}

		if (typeof sources["denoise"] === "object") {
			this.sockets.inputs["denoise"].connectTo(sources["denoise"])
		} else {
			this.sockets.inputs["denoise"].value = sources["denoise"]
		}

	}
}

type SplitSigmasDenoiseInputs = {
			"sigmas": ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>
			"denoise": ComfyNodeTypedInputRef<number>
}


export class FlipSigmas extends ComfyNode {
	classType: string = "FlipSigmas"

	sockets: {
		inputs: Required<FlipSigmasInputs>
		outputs: {
			SIGMAS: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"sigmas": new ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>(this, "sigmas"),
			},
			outputs: Object.create(Object.prototype, {
				"SIGMAS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<FlipSigmasInputs>) {
		if (typeof sources["sigmas"] === "object") {
			this.sockets.inputs["sigmas"].connectTo(sources["sigmas"])
		} else {
			this.sockets.inputs["sigmas"].value = sources["sigmas"]
		}

	}
}

type FlipSigmasInputs = {
			"sigmas": ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>
}


export class SetFirstSigma extends ComfyNode {
	classType: string = "SetFirstSigma"

	sockets: {
		inputs: Required<SetFirstSigmaInputs>
		outputs: {
			SIGMAS: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"sigmas": new ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>(this, "sigmas"),
				"sigma": new ComfyNodeTypedInputRef<number>(this, "sigma"),
			},
			outputs: Object.create(Object.prototype, {
				"SIGMAS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SetFirstSigmaInputs>) {
		if (typeof sources["sigmas"] === "object") {
			this.sockets.inputs["sigmas"].connectTo(sources["sigmas"])
		} else {
			this.sockets.inputs["sigmas"].value = sources["sigmas"]
		}

		if (typeof sources["sigma"] === "object") {
			this.sockets.inputs["sigma"].connectTo(sources["sigma"])
		} else {
			this.sockets.inputs["sigma"].value = sources["sigma"]
		}

	}
}

type SetFirstSigmaInputs = {
			"sigmas": ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>
			"sigma": ComfyNodeTypedInputRef<number>
}


export class ExtendIntermediateSigmas extends ComfyNode {
	classType: string = "ExtendIntermediateSigmas"

	sockets: {
		inputs: Required<ExtendIntermediateSigmasInputs>
		outputs: {
			SIGMAS: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"sigmas": new ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>(this, "sigmas"),
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"start_at_sigma": new ComfyNodeTypedInputRef<number>(this, "start_at_sigma"),
				"end_at_sigma": new ComfyNodeTypedInputRef<number>(this, "end_at_sigma"),
				"spacing": new ComfyNodeTypedInputRef<string>(this, "spacing"),
			},
			outputs: Object.create(Object.prototype, {
				"SIGMAS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ExtendIntermediateSigmasInputs>) {
		if (typeof sources["sigmas"] === "object") {
			this.sockets.inputs["sigmas"].connectTo(sources["sigmas"])
		} else {
			this.sockets.inputs["sigmas"].value = sources["sigmas"]
		}

		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["start_at_sigma"] === "object") {
			this.sockets.inputs["start_at_sigma"].connectTo(sources["start_at_sigma"])
		} else {
			this.sockets.inputs["start_at_sigma"].value = sources["start_at_sigma"]
		}

		if (typeof sources["end_at_sigma"] === "object") {
			this.sockets.inputs["end_at_sigma"].connectTo(sources["end_at_sigma"])
		} else {
			this.sockets.inputs["end_at_sigma"].value = sources["end_at_sigma"]
		}

		if (typeof sources["spacing"] === "object") {
			this.sockets.inputs["spacing"].connectTo(sources["spacing"])
		} else {
			this.sockets.inputs["spacing"].value = sources["spacing"]
		}

	}
}

type ExtendIntermediateSigmasInputs = {
			"sigmas": ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>
			"steps": ComfyNodeTypedInputRef<number>
			"start_at_sigma": ComfyNodeTypedInputRef<number>
			"end_at_sigma": ComfyNodeTypedInputRef<number>
			"spacing": ComfyNodeTypedInputRef<string>
}


export class SamplingPercentToSigma extends ComfyNode {
	classType: string = "SamplingPercentToSigma"

	sockets: {
		inputs: Required<SamplingPercentToSigmaInputs>
		outputs: {
			sigma_value: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"sampling_percent": new ComfyNodeTypedInputRef<number>(this, "sampling_percent"),
				"return_actual_sigma": new ComfyNodeTypedInputRef<boolean>(this, "return_actual_sigma"),
			},
			outputs: Object.create(Object.prototype, {
				"sigma_value": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SamplingPercentToSigmaInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["sampling_percent"] === "object") {
			this.sockets.inputs["sampling_percent"].connectTo(sources["sampling_percent"])
		} else {
			this.sockets.inputs["sampling_percent"].value = sources["sampling_percent"]
		}

		if (typeof sources["return_actual_sigma"] === "object") {
			this.sockets.inputs["return_actual_sigma"].connectTo(sources["return_actual_sigma"])
		} else {
			this.sockets.inputs["return_actual_sigma"].value = sources["return_actual_sigma"]
		}

	}
}

type SamplingPercentToSigmaInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"sampling_percent": ComfyNodeTypedInputRef<number>
			/** Return the actual sigma value instead of the value used for interval checks.
This only affects results at 0.0 and 1.0.*/
			"return_actual_sigma": ComfyNodeTypedInputRef<boolean>
}


export class CFGGuider extends ComfyNode {
	classType: string = "CFGGuider"

	sockets: {
		inputs: Required<CFGGuiderInputs>
		outputs: {
			GUIDER: ComfyNodeTypedSourceRef<ComfyValueType_GUIDER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"cfg": new ComfyNodeTypedInputRef<number>(this, "cfg"),
			},
			outputs: Object.create(Object.prototype, {
				"GUIDER": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CFGGuiderInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["cfg"] === "object") {
			this.sockets.inputs["cfg"].connectTo(sources["cfg"])
		} else {
			this.sockets.inputs["cfg"].value = sources["cfg"]
		}

	}
}

type CFGGuiderInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"cfg": ComfyNodeTypedInputRef<number>
}


export class DualCFGGuider extends ComfyNode {
	classType: string = "DualCFGGuider"

	sockets: {
		inputs: Required<DualCFGGuiderInputs>
		outputs: {
			GUIDER: ComfyNodeTypedSourceRef<ComfyValueType_GUIDER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"cond1": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "cond1"),
				"cond2": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "cond2"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"cfg_conds": new ComfyNodeTypedInputRef<number>(this, "cfg_conds"),
				"cfg_cond2_negative": new ComfyNodeTypedInputRef<number>(this, "cfg_cond2_negative"),
				"style": new ComfyNodeTypedInputRef<string>(this, "style"),
			},
			outputs: Object.create(Object.prototype, {
				"GUIDER": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DualCFGGuiderInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["cond1"] === "object") {
			this.sockets.inputs["cond1"].connectTo(sources["cond1"])
		} else {
			this.sockets.inputs["cond1"].value = sources["cond1"]
		}

		if (typeof sources["cond2"] === "object") {
			this.sockets.inputs["cond2"].connectTo(sources["cond2"])
		} else {
			this.sockets.inputs["cond2"].value = sources["cond2"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["cfg_conds"] === "object") {
			this.sockets.inputs["cfg_conds"].connectTo(sources["cfg_conds"])
		} else {
			this.sockets.inputs["cfg_conds"].value = sources["cfg_conds"]
		}

		if (typeof sources["cfg_cond2_negative"] === "object") {
			this.sockets.inputs["cfg_cond2_negative"].connectTo(sources["cfg_cond2_negative"])
		} else {
			this.sockets.inputs["cfg_cond2_negative"].value = sources["cfg_cond2_negative"]
		}

		if (typeof sources["style"] === "object") {
			this.sockets.inputs["style"].connectTo(sources["style"])
		} else {
			this.sockets.inputs["style"].value = sources["style"]
		}

	}
}

type DualCFGGuiderInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"cond1": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"cond2": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"cfg_conds": ComfyNodeTypedInputRef<number>
			"cfg_cond2_negative": ComfyNodeTypedInputRef<number>
			"style": ComfyNodeTypedInputRef<string>
}


export class BasicGuider extends ComfyNode {
	classType: string = "BasicGuider"

	sockets: {
		inputs: Required<BasicGuiderInputs>
		outputs: {
			GUIDER: ComfyNodeTypedSourceRef<ComfyValueType_GUIDER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning"),
			},
			outputs: Object.create(Object.prototype, {
				"GUIDER": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<BasicGuiderInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["conditioning"] === "object") {
			this.sockets.inputs["conditioning"].connectTo(sources["conditioning"])
		} else {
			this.sockets.inputs["conditioning"].value = sources["conditioning"]
		}

	}
}

type BasicGuiderInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
}


export class RandomNoise extends ComfyNode {
	classType: string = "RandomNoise"

	sockets: {
		inputs: Required<RandomNoiseInputs>
		outputs: {
			NOISE: ComfyNodeTypedSourceRef<ComfyValueType_NOISE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"noise_seed": new ComfyNodeTypedInputRef<number>(this, "noise_seed"),
			},
			outputs: Object.create(Object.prototype, {
				"NOISE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<RandomNoiseInputs>) {
		if (typeof sources["noise_seed"] === "object") {
			this.sockets.inputs["noise_seed"].connectTo(sources["noise_seed"])
		} else {
			this.sockets.inputs["noise_seed"].value = sources["noise_seed"]
		}

	}
}

type RandomNoiseInputs = {
			"noise_seed": ComfyNodeTypedInputRef<number>
}


export class DisableNoise extends ComfyNode {
	classType: string = "DisableNoise"

	sockets: {
		inputs: Required<DisableNoiseInputs>
		outputs: {
			NOISE: ComfyNodeTypedSourceRef<ComfyValueType_NOISE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
			},
			outputs: Object.create(Object.prototype, {
				"NOISE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DisableNoiseInputs>) {
	}
}

type DisableNoiseInputs = {
}


export class AddNoise extends ComfyNode {
	classType: string = "AddNoise"

	sockets: {
		inputs: Required<AddNoiseInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"noise": new ComfyNodeTypedInputRef<ComfyValueType_NOISE>(this, "noise"),
				"sigmas": new ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>(this, "sigmas"),
				"latent_image": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latent_image"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<AddNoiseInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["noise"] === "object") {
			this.sockets.inputs["noise"].connectTo(sources["noise"])
		} else {
			this.sockets.inputs["noise"].value = sources["noise"]
		}

		if (typeof sources["sigmas"] === "object") {
			this.sockets.inputs["sigmas"].connectTo(sources["sigmas"])
		} else {
			this.sockets.inputs["sigmas"].value = sources["sigmas"]
		}

		if (typeof sources["latent_image"] === "object") {
			this.sockets.inputs["latent_image"].connectTo(sources["latent_image"])
		} else {
			this.sockets.inputs["latent_image"].value = sources["latent_image"]
		}

	}
}

type AddNoiseInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"noise": ComfyNodeTypedInputRef<ComfyValueType_NOISE>
			"sigmas": ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>
			"latent_image": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class SamplerCustomAdvanced extends ComfyNode {
	classType: string = "SamplerCustomAdvanced"

	sockets: {
		inputs: Required<SamplerCustomAdvancedInputs>
		outputs: {
			output: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
			denoised_output: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"noise": new ComfyNodeTypedInputRef<ComfyValueType_NOISE>(this, "noise"),
				"guider": new ComfyNodeTypedInputRef<ComfyValueType_GUIDER>(this, "guider"),
				"sampler": new ComfyNodeTypedInputRef<ComfyValueType_SAMPLER>(this, "sampler"),
				"sigmas": new ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>(this, "sigmas"),
				"latent_image": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latent_image"),
			},
			outputs: Object.create(Object.prototype, {
				"output": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"denoised_output": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SamplerCustomAdvancedInputs>) {
		if (typeof sources["noise"] === "object") {
			this.sockets.inputs["noise"].connectTo(sources["noise"])
		} else {
			this.sockets.inputs["noise"].value = sources["noise"]
		}

		if (typeof sources["guider"] === "object") {
			this.sockets.inputs["guider"].connectTo(sources["guider"])
		} else {
			this.sockets.inputs["guider"].value = sources["guider"]
		}

		if (typeof sources["sampler"] === "object") {
			this.sockets.inputs["sampler"].connectTo(sources["sampler"])
		} else {
			this.sockets.inputs["sampler"].value = sources["sampler"]
		}

		if (typeof sources["sigmas"] === "object") {
			this.sockets.inputs["sigmas"].connectTo(sources["sigmas"])
		} else {
			this.sockets.inputs["sigmas"].value = sources["sigmas"]
		}

		if (typeof sources["latent_image"] === "object") {
			this.sockets.inputs["latent_image"].connectTo(sources["latent_image"])
		} else {
			this.sockets.inputs["latent_image"].value = sources["latent_image"]
		}

	}
}

type SamplerCustomAdvancedInputs = {
			"noise": ComfyNodeTypedInputRef<ComfyValueType_NOISE>
			"guider": ComfyNodeTypedInputRef<ComfyValueType_GUIDER>
			"sampler": ComfyNodeTypedInputRef<ComfyValueType_SAMPLER>
			"sigmas": ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>
			"latent_image": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class HyperTile extends ComfyNode {
	classType: string = "HyperTile"

	sockets: {
		inputs: Required<HyperTileInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"tile_size": new ComfyNodeTypedInputRef<number>(this, "tile_size"),
				"swap_size": new ComfyNodeTypedInputRef<number>(this, "swap_size"),
				"max_depth": new ComfyNodeTypedInputRef<number>(this, "max_depth"),
				"scale_depth": new ComfyNodeTypedInputRef<boolean>(this, "scale_depth"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<HyperTileInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["tile_size"] === "object") {
			this.sockets.inputs["tile_size"].connectTo(sources["tile_size"])
		} else {
			this.sockets.inputs["tile_size"].value = sources["tile_size"]
		}

		if (typeof sources["swap_size"] === "object") {
			this.sockets.inputs["swap_size"].connectTo(sources["swap_size"])
		} else {
			this.sockets.inputs["swap_size"].value = sources["swap_size"]
		}

		if (typeof sources["max_depth"] === "object") {
			this.sockets.inputs["max_depth"].connectTo(sources["max_depth"])
		} else {
			this.sockets.inputs["max_depth"].value = sources["max_depth"]
		}

		if (typeof sources["scale_depth"] === "object") {
			this.sockets.inputs["scale_depth"].connectTo(sources["scale_depth"])
		} else {
			this.sockets.inputs["scale_depth"].value = sources["scale_depth"]
		}

	}
}

type HyperTileInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"tile_size": ComfyNodeTypedInputRef<number>
			"swap_size": ComfyNodeTypedInputRef<number>
			"max_depth": ComfyNodeTypedInputRef<number>
			"scale_depth": ComfyNodeTypedInputRef<boolean>
}


export class ModelSamplingDiscrete extends ComfyNode {
	classType: string = "ModelSamplingDiscrete"

	sockets: {
		inputs: Required<ModelSamplingDiscreteInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"sampling": new ComfyNodeTypedInputRef<string>(this, "sampling"),
				"zsnr": new ComfyNodeTypedInputRef<boolean>(this, "zsnr"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelSamplingDiscreteInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["sampling"] === "object") {
			this.sockets.inputs["sampling"].connectTo(sources["sampling"])
		} else {
			this.sockets.inputs["sampling"].value = sources["sampling"]
		}

		if (typeof sources["zsnr"] === "object") {
			this.sockets.inputs["zsnr"].connectTo(sources["zsnr"])
		} else {
			this.sockets.inputs["zsnr"].value = sources["zsnr"]
		}

	}
}

type ModelSamplingDiscreteInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"sampling": ComfyNodeTypedInputRef<string>
			"zsnr": ComfyNodeTypedInputRef<boolean>
}


export class ModelSamplingContinuousEDM extends ComfyNode {
	classType: string = "ModelSamplingContinuousEDM"

	sockets: {
		inputs: Required<ModelSamplingContinuousEDMInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"sampling": new ComfyNodeTypedInputRef<string>(this, "sampling"),
				"sigma_max": new ComfyNodeTypedInputRef<number>(this, "sigma_max"),
				"sigma_min": new ComfyNodeTypedInputRef<number>(this, "sigma_min"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelSamplingContinuousEDMInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["sampling"] === "object") {
			this.sockets.inputs["sampling"].connectTo(sources["sampling"])
		} else {
			this.sockets.inputs["sampling"].value = sources["sampling"]
		}

		if (typeof sources["sigma_max"] === "object") {
			this.sockets.inputs["sigma_max"].connectTo(sources["sigma_max"])
		} else {
			this.sockets.inputs["sigma_max"].value = sources["sigma_max"]
		}

		if (typeof sources["sigma_min"] === "object") {
			this.sockets.inputs["sigma_min"].connectTo(sources["sigma_min"])
		} else {
			this.sockets.inputs["sigma_min"].value = sources["sigma_min"]
		}

	}
}

type ModelSamplingContinuousEDMInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"sampling": ComfyNodeTypedInputRef<string>
			"sigma_max": ComfyNodeTypedInputRef<number>
			"sigma_min": ComfyNodeTypedInputRef<number>
}


export class ModelSamplingContinuousV extends ComfyNode {
	classType: string = "ModelSamplingContinuousV"

	sockets: {
		inputs: Required<ModelSamplingContinuousVInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"sampling": new ComfyNodeTypedInputRef<string>(this, "sampling"),
				"sigma_max": new ComfyNodeTypedInputRef<number>(this, "sigma_max"),
				"sigma_min": new ComfyNodeTypedInputRef<number>(this, "sigma_min"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelSamplingContinuousVInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["sampling"] === "object") {
			this.sockets.inputs["sampling"].connectTo(sources["sampling"])
		} else {
			this.sockets.inputs["sampling"].value = sources["sampling"]
		}

		if (typeof sources["sigma_max"] === "object") {
			this.sockets.inputs["sigma_max"].connectTo(sources["sigma_max"])
		} else {
			this.sockets.inputs["sigma_max"].value = sources["sigma_max"]
		}

		if (typeof sources["sigma_min"] === "object") {
			this.sockets.inputs["sigma_min"].connectTo(sources["sigma_min"])
		} else {
			this.sockets.inputs["sigma_min"].value = sources["sigma_min"]
		}

	}
}

type ModelSamplingContinuousVInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"sampling": ComfyNodeTypedInputRef<string>
			"sigma_max": ComfyNodeTypedInputRef<number>
			"sigma_min": ComfyNodeTypedInputRef<number>
}


export class ModelSamplingStableCascade extends ComfyNode {
	classType: string = "ModelSamplingStableCascade"

	sockets: {
		inputs: Required<ModelSamplingStableCascadeInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"shift": new ComfyNodeTypedInputRef<number>(this, "shift"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelSamplingStableCascadeInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["shift"] === "object") {
			this.sockets.inputs["shift"].connectTo(sources["shift"])
		} else {
			this.sockets.inputs["shift"].value = sources["shift"]
		}

	}
}

type ModelSamplingStableCascadeInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"shift": ComfyNodeTypedInputRef<number>
}


export class ModelSamplingSD3 extends ComfyNode {
	classType: string = "ModelSamplingSD3"

	sockets: {
		inputs: Required<ModelSamplingSD3Inputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"shift": new ComfyNodeTypedInputRef<number>(this, "shift"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelSamplingSD3Inputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["shift"] === "object") {
			this.sockets.inputs["shift"].connectTo(sources["shift"])
		} else {
			this.sockets.inputs["shift"].value = sources["shift"]
		}

	}
}

type ModelSamplingSD3Inputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"shift": ComfyNodeTypedInputRef<number>
}


export class ModelSamplingAuraFlow extends ComfyNode {
	classType: string = "ModelSamplingAuraFlow"

	sockets: {
		inputs: Required<ModelSamplingAuraFlowInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"shift": new ComfyNodeTypedInputRef<number>(this, "shift"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelSamplingAuraFlowInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["shift"] === "object") {
			this.sockets.inputs["shift"].connectTo(sources["shift"])
		} else {
			this.sockets.inputs["shift"].value = sources["shift"]
		}

	}
}

type ModelSamplingAuraFlowInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"shift": ComfyNodeTypedInputRef<number>
}


export class ModelSamplingFlux extends ComfyNode {
	classType: string = "ModelSamplingFlux"

	sockets: {
		inputs: Required<ModelSamplingFluxInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"max_shift": new ComfyNodeTypedInputRef<number>(this, "max_shift"),
				"base_shift": new ComfyNodeTypedInputRef<number>(this, "base_shift"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelSamplingFluxInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["max_shift"] === "object") {
			this.sockets.inputs["max_shift"].connectTo(sources["max_shift"])
		} else {
			this.sockets.inputs["max_shift"].value = sources["max_shift"]
		}

		if (typeof sources["base_shift"] === "object") {
			this.sockets.inputs["base_shift"].connectTo(sources["base_shift"])
		} else {
			this.sockets.inputs["base_shift"].value = sources["base_shift"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

	}
}

type ModelSamplingFluxInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"max_shift": ComfyNodeTypedInputRef<number>
			"base_shift": ComfyNodeTypedInputRef<number>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
}


export class RescaleCFG extends ComfyNode {
	classType: string = "RescaleCFG"

	sockets: {
		inputs: Required<RescaleCFGInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"multiplier": new ComfyNodeTypedInputRef<number>(this, "multiplier"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<RescaleCFGInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["multiplier"] === "object") {
			this.sockets.inputs["multiplier"].connectTo(sources["multiplier"])
		} else {
			this.sockets.inputs["multiplier"].value = sources["multiplier"]
		}

	}
}

type RescaleCFGInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"multiplier": ComfyNodeTypedInputRef<number>
}


export class ModelComputeDtype extends ComfyNode {
	classType: string = "ModelComputeDtype"

	sockets: {
		inputs: Required<ModelComputeDtypeInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"dtype": new ComfyNodeTypedInputRef<string>(this, "dtype"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelComputeDtypeInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["dtype"] === "object") {
			this.sockets.inputs["dtype"].connectTo(sources["dtype"])
		} else {
			this.sockets.inputs["dtype"].value = sources["dtype"]
		}

	}
}

type ModelComputeDtypeInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"dtype": ComfyNodeTypedInputRef<string>
}


export class PatchModelAddDownscale extends ComfyNode {
	classType: string = "PatchModelAddDownscale"

	sockets: {
		inputs: Required<PatchModelAddDownscaleInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"block_number": new ComfyNodeTypedInputRef<number>(this, "block_number"),
				"downscale_factor": new ComfyNodeTypedInputRef<number>(this, "downscale_factor"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
				"downscale_after_skip": new ComfyNodeTypedInputRef<boolean>(this, "downscale_after_skip"),
				"downscale_method": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "downscale_method"),
				"upscale_method": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "upscale_method"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PatchModelAddDownscaleInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["block_number"] === "object") {
			this.sockets.inputs["block_number"].connectTo(sources["block_number"])
		} else {
			this.sockets.inputs["block_number"].value = sources["block_number"]
		}

		if (typeof sources["downscale_factor"] === "object") {
			this.sockets.inputs["downscale_factor"].connectTo(sources["downscale_factor"])
		} else {
			this.sockets.inputs["downscale_factor"].value = sources["downscale_factor"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

		if (typeof sources["downscale_after_skip"] === "object") {
			this.sockets.inputs["downscale_after_skip"].connectTo(sources["downscale_after_skip"])
		} else {
			this.sockets.inputs["downscale_after_skip"].value = sources["downscale_after_skip"]
		}

		if (typeof sources["downscale_method"] === "object") {
			this.sockets.inputs["downscale_method"].connectTo(sources["downscale_method"])
		} else {
			this.sockets.inputs["downscale_method"].value = sources["downscale_method"]
		}

		if (typeof sources["upscale_method"] === "object") {
			this.sockets.inputs["upscale_method"].connectTo(sources["upscale_method"])
		} else {
			this.sockets.inputs["upscale_method"].value = sources["upscale_method"]
		}

	}
}

type PatchModelAddDownscaleInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"block_number": ComfyNodeTypedInputRef<number>
			"downscale_factor": ComfyNodeTypedInputRef<number>
			"start_percent": ComfyNodeTypedInputRef<number>
			"end_percent": ComfyNodeTypedInputRef<number>
			"downscale_after_skip": ComfyNodeTypedInputRef<boolean>
			"downscale_method": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"upscale_method": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class ImageCrop extends ComfyNode {
	classType: string = "ImageCrop"

	sockets: {
		inputs: Required<ImageCropInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"x": new ComfyNodeTypedInputRef<number>(this, "x"),
				"y": new ComfyNodeTypedInputRef<number>(this, "y"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageCropInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["x"] === "object") {
			this.sockets.inputs["x"].connectTo(sources["x"])
		} else {
			this.sockets.inputs["x"].value = sources["x"]
		}

		if (typeof sources["y"] === "object") {
			this.sockets.inputs["y"].connectTo(sources["y"])
		} else {
			this.sockets.inputs["y"].value = sources["y"]
		}

	}
}

type ImageCropInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"x": ComfyNodeTypedInputRef<number>
			"y": ComfyNodeTypedInputRef<number>
}


export class RepeatImageBatch extends ComfyNode {
	classType: string = "RepeatImageBatch"

	sockets: {
		inputs: Required<RepeatImageBatchInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"amount": new ComfyNodeTypedInputRef<number>(this, "amount"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<RepeatImageBatchInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["amount"] === "object") {
			this.sockets.inputs["amount"].connectTo(sources["amount"])
		} else {
			this.sockets.inputs["amount"].value = sources["amount"]
		}

	}
}

type RepeatImageBatchInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"amount": ComfyNodeTypedInputRef<number>
}


export class ImageFromBatch extends ComfyNode {
	classType: string = "ImageFromBatch"

	sockets: {
		inputs: Required<ImageFromBatchInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"batch_index": new ComfyNodeTypedInputRef<number>(this, "batch_index"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageFromBatchInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["batch_index"] === "object") {
			this.sockets.inputs["batch_index"].connectTo(sources["batch_index"])
		} else {
			this.sockets.inputs["batch_index"].value = sources["batch_index"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

	}
}

type ImageFromBatchInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"batch_index": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
}


export class ImageAddNoise extends ComfyNode {
	classType: string = "ImageAddNoise"

	sockets: {
		inputs: Required<ImageAddNoiseInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"seed": new ComfyNodeTypedInputRef<number>(this, "seed"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageAddNoiseInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["seed"] === "object") {
			this.sockets.inputs["seed"].connectTo(sources["seed"])
		} else {
			this.sockets.inputs["seed"].value = sources["seed"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

	}
}

type ImageAddNoiseInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** The random seed used for creating the noise.*/
			"seed": ComfyNodeTypedInputRef<number>
			"strength": ComfyNodeTypedInputRef<number>
}


export class SaveAnimatedWEBP extends ComfyNode {
	classType: string = "SaveAnimatedWEBP"

	sockets: {
		inputs: Required<SaveAnimatedWEBPInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"fps": new ComfyNodeTypedInputRef<number>(this, "fps"),
				"lossless": new ComfyNodeTypedInputRef<boolean>(this, "lossless"),
				"quality": new ComfyNodeTypedInputRef<number>(this, "quality"),
				"method": new ComfyNodeTypedInputRef<string>(this, "method"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_E>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<SaveAnimatedWEBPInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (typeof sources["fps"] === "object") {
			this.sockets.inputs["fps"].connectTo(sources["fps"])
		} else {
			this.sockets.inputs["fps"].value = sources["fps"]
		}

		if (typeof sources["lossless"] === "object") {
			this.sockets.inputs["lossless"].connectTo(sources["lossless"])
		} else {
			this.sockets.inputs["lossless"].value = sources["lossless"]
		}

		if (typeof sources["quality"] === "object") {
			this.sockets.inputs["quality"].connectTo(sources["quality"])
		} else {
			this.sockets.inputs["quality"].value = sources["quality"]
		}

		if (typeof sources["method"] === "object") {
			this.sockets.inputs["method"].connectTo(sources["method"])
		} else {
			this.sockets.inputs["method"].value = sources["method"]
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type SaveAnimatedWEBPInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"filename_prefix": ComfyNodeTypedInputRef<string>
			"fps": ComfyNodeTypedInputRef<number>
			"lossless": ComfyNodeTypedInputRef<boolean>
			"quality": ComfyNodeTypedInputRef<number>
			"method": ComfyNodeTypedInputRef<string>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_E>
}


export class SaveAnimatedPNG extends ComfyNode {
	classType: string = "SaveAnimatedPNG"

	sockets: {
		inputs: Required<SaveAnimatedPNGInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"fps": new ComfyNodeTypedInputRef<number>(this, "fps"),
				"compress_level": new ComfyNodeTypedInputRef<number>(this, "compress_level"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_E>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<SaveAnimatedPNGInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (typeof sources["fps"] === "object") {
			this.sockets.inputs["fps"].connectTo(sources["fps"])
		} else {
			this.sockets.inputs["fps"].value = sources["fps"]
		}

		if (typeof sources["compress_level"] === "object") {
			this.sockets.inputs["compress_level"].connectTo(sources["compress_level"])
		} else {
			this.sockets.inputs["compress_level"].value = sources["compress_level"]
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type SaveAnimatedPNGInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"filename_prefix": ComfyNodeTypedInputRef<string>
			"fps": ComfyNodeTypedInputRef<number>
			"compress_level": ComfyNodeTypedInputRef<number>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_E>
}


export class SaveSVGNode extends ComfyNode {
	classType: string = "SaveSVGNode"

	sockets: {
		inputs: Required<SaveSVGNodeInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"svg": new ComfyNodeTypedInputRef<ComfyValueType_SVG>(this, "svg"),
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_E>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<SaveSVGNodeInputs>) {
		if (typeof sources["svg"] === "object") {
			this.sockets.inputs["svg"].connectTo(sources["svg"])
		} else {
			this.sockets.inputs["svg"].value = sources["svg"]
		}

		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type SaveSVGNodeInputs = {
			"svg": ComfyNodeTypedInputRef<ComfyValueType_SVG>
			/** The prefix for the file to save. This may include formatting information such as %date:yyyy-MM-dd% or %Empty Latent Image.width% to include values from nodes.*/
			"filename_prefix": ComfyNodeTypedInputRef<string>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_E>
}


export class ImageStitch extends ComfyNode {
	classType: string = "ImageStitch"

	sockets: {
		inputs: Required<ImageStitchInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image1": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image1"),
				"direction": new ComfyNodeTypedInputRef<string>(this, "direction"),
				"match_image_size": new ComfyNodeTypedInputRef<boolean>(this, "match_image_size"),
				"spacing_width": new ComfyNodeTypedInputRef<number>(this, "spacing_width"),
				"spacing_color": new ComfyNodeTypedInputRef<string>(this, "spacing_color"),
				"image2": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image2"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageStitchInputs>) {
		if (typeof sources["image1"] === "object") {
			this.sockets.inputs["image1"].connectTo(sources["image1"])
		} else {
			this.sockets.inputs["image1"].value = sources["image1"]
		}

		if (typeof sources["direction"] === "object") {
			this.sockets.inputs["direction"].connectTo(sources["direction"])
		} else {
			this.sockets.inputs["direction"].value = sources["direction"]
		}

		if (typeof sources["match_image_size"] === "object") {
			this.sockets.inputs["match_image_size"].connectTo(sources["match_image_size"])
		} else {
			this.sockets.inputs["match_image_size"].value = sources["match_image_size"]
		}

		if (typeof sources["spacing_width"] === "object") {
			this.sockets.inputs["spacing_width"].connectTo(sources["spacing_width"])
		} else {
			this.sockets.inputs["spacing_width"].value = sources["spacing_width"]
		}

		if (typeof sources["spacing_color"] === "object") {
			this.sockets.inputs["spacing_color"].connectTo(sources["spacing_color"])
		} else {
			this.sockets.inputs["spacing_color"].value = sources["spacing_color"]
		}

		if (sources["image2"] !== undefined) {
		if (typeof sources["image2"] === "object") {
			this.sockets.inputs["image2"].connectTo(sources["image2"])
		} else {
			this.sockets.inputs["image2"].value = sources["image2"]
		}
		}

	}
}

type ImageStitchInputs = {
			"image1": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"direction": ComfyNodeTypedInputRef<string>
			"match_image_size": ComfyNodeTypedInputRef<boolean>
			"spacing_width": ComfyNodeTypedInputRef<number>
			"spacing_color": ComfyNodeTypedInputRef<string>
			"image2"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class ResizeAndPadImage extends ComfyNode {
	classType: string = "ResizeAndPadImage"

	sockets: {
		inputs: Required<ResizeAndPadImageInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"target_width": new ComfyNodeTypedInputRef<number>(this, "target_width"),
				"target_height": new ComfyNodeTypedInputRef<number>(this, "target_height"),
				"padding_color": new ComfyNodeTypedInputRef<string>(this, "padding_color"),
				"interpolation": new ComfyNodeTypedInputRef<string>(this, "interpolation"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ResizeAndPadImageInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["target_width"] === "object") {
			this.sockets.inputs["target_width"].connectTo(sources["target_width"])
		} else {
			this.sockets.inputs["target_width"].value = sources["target_width"]
		}

		if (typeof sources["target_height"] === "object") {
			this.sockets.inputs["target_height"].connectTo(sources["target_height"])
		} else {
			this.sockets.inputs["target_height"].value = sources["target_height"]
		}

		if (typeof sources["padding_color"] === "object") {
			this.sockets.inputs["padding_color"].connectTo(sources["padding_color"])
		} else {
			this.sockets.inputs["padding_color"].value = sources["padding_color"]
		}

		if (typeof sources["interpolation"] === "object") {
			this.sockets.inputs["interpolation"].connectTo(sources["interpolation"])
		} else {
			this.sockets.inputs["interpolation"].value = sources["interpolation"]
		}

	}
}

type ResizeAndPadImageInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"target_width": ComfyNodeTypedInputRef<number>
			"target_height": ComfyNodeTypedInputRef<number>
			"padding_color": ComfyNodeTypedInputRef<string>
			"interpolation": ComfyNodeTypedInputRef<string>
}


export class GetImageSize extends ComfyNode {
	classType: string = "GetImageSize"

	sockets: {
		inputs: Required<GetImageSizeInputs>
		outputs: {
			width: ComfyNodeTypedSourceRef<number>
			height: ComfyNodeTypedSourceRef<number>
			batch_size: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"unique_id": new ComfyNodeTypedInputRef<ComfyValueType_U>(this, "unique_id"),
			},
			outputs: Object.create(Object.prototype, {
				"width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"batch_size": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<GetImageSizeInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (sources["unique_id"] !== undefined) {
		if (typeof sources["unique_id"] === "object") {
			this.sockets.inputs["unique_id"].connectTo(sources["unique_id"])
		} else {
			this.sockets.inputs["unique_id"].value = sources["unique_id"]
		}
		}

	}
}

type GetImageSizeInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"unique_id"?: ComfyNodeTypedInputRef<ComfyValueType_U>
}


export class ImageRotate extends ComfyNode {
	classType: string = "ImageRotate"

	sockets: {
		inputs: Required<ImageRotateInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"rotation": new ComfyNodeTypedInputRef<string>(this, "rotation"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageRotateInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["rotation"] === "object") {
			this.sockets.inputs["rotation"].connectTo(sources["rotation"])
		} else {
			this.sockets.inputs["rotation"].value = sources["rotation"]
		}

	}
}

type ImageRotateInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"rotation": ComfyNodeTypedInputRef<string>
}


export class ImageFlip extends ComfyNode {
	classType: string = "ImageFlip"

	sockets: {
		inputs: Required<ImageFlipInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"flip_method": new ComfyNodeTypedInputRef<string>(this, "flip_method"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageFlipInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["flip_method"] === "object") {
			this.sockets.inputs["flip_method"].connectTo(sources["flip_method"])
		} else {
			this.sockets.inputs["flip_method"].value = sources["flip_method"]
		}

	}
}

type ImageFlipInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"flip_method": ComfyNodeTypedInputRef<string>
}


export class ImageScaleToMaxDimension extends ComfyNode {
	classType: string = "ImageScaleToMaxDimension"

	sockets: {
		inputs: Required<ImageScaleToMaxDimensionInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"upscale_method": new ComfyNodeTypedInputRef<string>(this, "upscale_method"),
				"largest_size": new ComfyNodeTypedInputRef<number>(this, "largest_size"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageScaleToMaxDimensionInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["upscale_method"] === "object") {
			this.sockets.inputs["upscale_method"].connectTo(sources["upscale_method"])
		} else {
			this.sockets.inputs["upscale_method"].value = sources["upscale_method"]
		}

		if (typeof sources["largest_size"] === "object") {
			this.sockets.inputs["largest_size"].connectTo(sources["largest_size"])
		} else {
			this.sockets.inputs["largest_size"].value = sources["largest_size"]
		}

	}
}

type ImageScaleToMaxDimensionInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"upscale_method": ComfyNodeTypedInputRef<string>
			"largest_size": ComfyNodeTypedInputRef<number>
}


export class ImageOnlyCheckpointLoader extends ComfyNode {
	classType: string = "ImageOnlyCheckpointLoader"

	sockets: {
		inputs: Required<ImageOnlyCheckpointLoaderInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
			CLIP_VISION: ComfyNodeTypedSourceRef<ComfyValueType_CLIP_VISION>
			VAE: ComfyNodeTypedSourceRef<ComfyValueType_VAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"ckpt_name": new ComfyNodeTypedInputRef<string>(this, "ckpt_name"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"CLIP_VISION": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"VAE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageOnlyCheckpointLoaderInputs>) {
		if (typeof sources["ckpt_name"] === "object") {
			this.sockets.inputs["ckpt_name"].connectTo(sources["ckpt_name"])
		} else {
			this.sockets.inputs["ckpt_name"].value = sources["ckpt_name"]
		}

	}
}

type ImageOnlyCheckpointLoaderInputs = {
			"ckpt_name": ComfyNodeTypedInputRef<string>
}


export class SVD_img2vid_Conditioning extends ComfyNode {
	classType: string = "SVD_img2vid_Conditioning"

	sockets: {
		inputs: Required<SVD_img2vid_ConditioningInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_vision": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>(this, "clip_vision"),
				"init_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "init_image"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"video_frames": new ComfyNodeTypedInputRef<number>(this, "video_frames"),
				"motion_bucket_id": new ComfyNodeTypedInputRef<number>(this, "motion_bucket_id"),
				"fps": new ComfyNodeTypedInputRef<number>(this, "fps"),
				"augmentation_level": new ComfyNodeTypedInputRef<number>(this, "augmentation_level"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SVD_img2vid_ConditioningInputs>) {
		if (typeof sources["clip_vision"] === "object") {
			this.sockets.inputs["clip_vision"].connectTo(sources["clip_vision"])
		} else {
			this.sockets.inputs["clip_vision"].value = sources["clip_vision"]
		}

		if (typeof sources["init_image"] === "object") {
			this.sockets.inputs["init_image"].connectTo(sources["init_image"])
		} else {
			this.sockets.inputs["init_image"].value = sources["init_image"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["video_frames"] === "object") {
			this.sockets.inputs["video_frames"].connectTo(sources["video_frames"])
		} else {
			this.sockets.inputs["video_frames"].value = sources["video_frames"]
		}

		if (typeof sources["motion_bucket_id"] === "object") {
			this.sockets.inputs["motion_bucket_id"].connectTo(sources["motion_bucket_id"])
		} else {
			this.sockets.inputs["motion_bucket_id"].value = sources["motion_bucket_id"]
		}

		if (typeof sources["fps"] === "object") {
			this.sockets.inputs["fps"].connectTo(sources["fps"])
		} else {
			this.sockets.inputs["fps"].value = sources["fps"]
		}

		if (typeof sources["augmentation_level"] === "object") {
			this.sockets.inputs["augmentation_level"].connectTo(sources["augmentation_level"])
		} else {
			this.sockets.inputs["augmentation_level"].value = sources["augmentation_level"]
		}

	}
}

type SVD_img2vid_ConditioningInputs = {
			"clip_vision": ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>
			"init_image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"video_frames": ComfyNodeTypedInputRef<number>
			"motion_bucket_id": ComfyNodeTypedInputRef<number>
			"fps": ComfyNodeTypedInputRef<number>
			"augmentation_level": ComfyNodeTypedInputRef<number>
}


export class VideoLinearCFGGuidance extends ComfyNode {
	classType: string = "VideoLinearCFGGuidance"

	sockets: {
		inputs: Required<VideoLinearCFGGuidanceInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"min_cfg": new ComfyNodeTypedInputRef<number>(this, "min_cfg"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VideoLinearCFGGuidanceInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["min_cfg"] === "object") {
			this.sockets.inputs["min_cfg"].connectTo(sources["min_cfg"])
		} else {
			this.sockets.inputs["min_cfg"].value = sources["min_cfg"]
		}

	}
}

type VideoLinearCFGGuidanceInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"min_cfg": ComfyNodeTypedInputRef<number>
}


export class VideoTriangleCFGGuidance extends ComfyNode {
	classType: string = "VideoTriangleCFGGuidance"

	sockets: {
		inputs: Required<VideoTriangleCFGGuidanceInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"min_cfg": new ComfyNodeTypedInputRef<number>(this, "min_cfg"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VideoTriangleCFGGuidanceInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["min_cfg"] === "object") {
			this.sockets.inputs["min_cfg"].connectTo(sources["min_cfg"])
		} else {
			this.sockets.inputs["min_cfg"].value = sources["min_cfg"]
		}

	}
}

type VideoTriangleCFGGuidanceInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"min_cfg": ComfyNodeTypedInputRef<number>
}


export class ImageOnlyCheckpointSave extends ComfyNode {
	classType: string = "ImageOnlyCheckpointSave"

	sockets: {
		inputs: Required<ImageOnlyCheckpointSaveInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"clip_vision": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>(this, "clip_vision"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_E>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<ImageOnlyCheckpointSaveInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["clip_vision"] === "object") {
			this.sockets.inputs["clip_vision"].connectTo(sources["clip_vision"])
		} else {
			this.sockets.inputs["clip_vision"].value = sources["clip_vision"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type ImageOnlyCheckpointSaveInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"clip_vision": ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"filename_prefix": ComfyNodeTypedInputRef<string>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_E>
}


export class ConditioningSetAreaPercentageVideo extends ComfyNode {
	classType: string = "ConditioningSetAreaPercentageVideo"

	sockets: {
		inputs: Required<ConditioningSetAreaPercentageVideoInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"temporal": new ComfyNodeTypedInputRef<number>(this, "temporal"),
				"x": new ComfyNodeTypedInputRef<number>(this, "x"),
				"y": new ComfyNodeTypedInputRef<number>(this, "y"),
				"z": new ComfyNodeTypedInputRef<number>(this, "z"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ConditioningSetAreaPercentageVideoInputs>) {
		if (typeof sources["conditioning"] === "object") {
			this.sockets.inputs["conditioning"].connectTo(sources["conditioning"])
		} else {
			this.sockets.inputs["conditioning"].value = sources["conditioning"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["temporal"] === "object") {
			this.sockets.inputs["temporal"].connectTo(sources["temporal"])
		} else {
			this.sockets.inputs["temporal"].value = sources["temporal"]
		}

		if (typeof sources["x"] === "object") {
			this.sockets.inputs["x"].connectTo(sources["x"])
		} else {
			this.sockets.inputs["x"].value = sources["x"]
		}

		if (typeof sources["y"] === "object") {
			this.sockets.inputs["y"].connectTo(sources["y"])
		} else {
			this.sockets.inputs["y"].value = sources["y"]
		}

		if (typeof sources["z"] === "object") {
			this.sockets.inputs["z"].connectTo(sources["z"])
		} else {
			this.sockets.inputs["z"].value = sources["z"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

	}
}

type ConditioningSetAreaPercentageVideoInputs = {
			"conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"temporal": ComfyNodeTypedInputRef<number>
			"x": ComfyNodeTypedInputRef<number>
			"y": ComfyNodeTypedInputRef<number>
			"z": ComfyNodeTypedInputRef<number>
			"strength": ComfyNodeTypedInputRef<number>
}


export class TrainLoraNode extends ComfyNode {
	classType: string = "TrainLoraNode"

	sockets: {
		inputs: Required<TrainLoraNodeInputs>
		outputs: {
			model_with_lora: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
			lora: ComfyNodeTypedSourceRef<ComfyValueType_LORA_MODEL>
			loss: ComfyNodeTypedSourceRef<ComfyValueType_LOSS_MAP>
			steps: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latents"),
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"grad_accumulation_steps": new ComfyNodeTypedInputRef<number>(this, "grad_accumulation_steps"),
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"learning_rate": new ComfyNodeTypedInputRef<number>(this, "learning_rate"),
				"rank": new ComfyNodeTypedInputRef<number>(this, "rank"),
				"optimizer": new ComfyNodeTypedInputRef<string>(this, "optimizer"),
				"loss_function": new ComfyNodeTypedInputRef<string>(this, "loss_function"),
				"seed": new ComfyNodeTypedInputRef<number>(this, "seed"),
				"training_dtype": new ComfyNodeTypedInputRef<string>(this, "training_dtype"),
				"lora_dtype": new ComfyNodeTypedInputRef<string>(this, "lora_dtype"),
				"algorithm": new ComfyNodeTypedInputRef<string>(this, "algorithm"),
				"gradient_checkpointing": new ComfyNodeTypedInputRef<boolean>(this, "gradient_checkpointing"),
				"existing_lora": new ComfyNodeTypedInputRef<string>(this, "existing_lora"),
			},
			outputs: Object.create(Object.prototype, {
				"model_with_lora": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"lora": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"loss": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"steps": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TrainLoraNodeInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["latents"] === "object") {
			this.sockets.inputs["latents"].connectTo(sources["latents"])
		} else {
			this.sockets.inputs["latents"].value = sources["latents"]
		}

		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (typeof sources["grad_accumulation_steps"] === "object") {
			this.sockets.inputs["grad_accumulation_steps"].connectTo(sources["grad_accumulation_steps"])
		} else {
			this.sockets.inputs["grad_accumulation_steps"].value = sources["grad_accumulation_steps"]
		}

		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["learning_rate"] === "object") {
			this.sockets.inputs["learning_rate"].connectTo(sources["learning_rate"])
		} else {
			this.sockets.inputs["learning_rate"].value = sources["learning_rate"]
		}

		if (typeof sources["rank"] === "object") {
			this.sockets.inputs["rank"].connectTo(sources["rank"])
		} else {
			this.sockets.inputs["rank"].value = sources["rank"]
		}

		if (typeof sources["optimizer"] === "object") {
			this.sockets.inputs["optimizer"].connectTo(sources["optimizer"])
		} else {
			this.sockets.inputs["optimizer"].value = sources["optimizer"]
		}

		if (typeof sources["loss_function"] === "object") {
			this.sockets.inputs["loss_function"].connectTo(sources["loss_function"])
		} else {
			this.sockets.inputs["loss_function"].value = sources["loss_function"]
		}

		if (typeof sources["seed"] === "object") {
			this.sockets.inputs["seed"].connectTo(sources["seed"])
		} else {
			this.sockets.inputs["seed"].value = sources["seed"]
		}

		if (typeof sources["training_dtype"] === "object") {
			this.sockets.inputs["training_dtype"].connectTo(sources["training_dtype"])
		} else {
			this.sockets.inputs["training_dtype"].value = sources["training_dtype"]
		}

		if (typeof sources["lora_dtype"] === "object") {
			this.sockets.inputs["lora_dtype"].connectTo(sources["lora_dtype"])
		} else {
			this.sockets.inputs["lora_dtype"].value = sources["lora_dtype"]
		}

		if (typeof sources["algorithm"] === "object") {
			this.sockets.inputs["algorithm"].connectTo(sources["algorithm"])
		} else {
			this.sockets.inputs["algorithm"].value = sources["algorithm"]
		}

		if (typeof sources["gradient_checkpointing"] === "object") {
			this.sockets.inputs["gradient_checkpointing"].connectTo(sources["gradient_checkpointing"])
		} else {
			this.sockets.inputs["gradient_checkpointing"].value = sources["gradient_checkpointing"]
		}

		if (typeof sources["existing_lora"] === "object") {
			this.sockets.inputs["existing_lora"].connectTo(sources["existing_lora"])
		} else {
			this.sockets.inputs["existing_lora"].value = sources["existing_lora"]
		}

	}
}

type TrainLoraNodeInputs = {
			/** The model to train the LoRA on.*/
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** The Latents to use for training, serve as dataset/input of the model.*/
			"latents": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** The positive conditioning to use for training.*/
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			/** The batch size to use for training.*/
			"batch_size": ComfyNodeTypedInputRef<number>
			/** The number of gradient accumulation steps to use for training.*/
			"grad_accumulation_steps": ComfyNodeTypedInputRef<number>
			/** The number of steps to train the LoRA for.*/
			"steps": ComfyNodeTypedInputRef<number>
			/** The learning rate to use for training.*/
			"learning_rate": ComfyNodeTypedInputRef<number>
			/** The rank of the LoRA layers.*/
			"rank": ComfyNodeTypedInputRef<number>
			/** The optimizer to use for training.*/
			"optimizer": ComfyNodeTypedInputRef<string>
			/** The loss function to use for training.*/
			"loss_function": ComfyNodeTypedInputRef<string>
			/** The seed to use for training (used in generator for LoRA weight initialization and noise sampling)*/
			"seed": ComfyNodeTypedInputRef<number>
			/** The dtype to use for training.*/
			"training_dtype": ComfyNodeTypedInputRef<string>
			/** The dtype to use for lora.*/
			"lora_dtype": ComfyNodeTypedInputRef<string>
			/** The algorithm to use for training.*/
			"algorithm": ComfyNodeTypedInputRef<string>
			/** Use gradient checkpointing for training.*/
			"gradient_checkpointing": ComfyNodeTypedInputRef<boolean>
			/** The existing LoRA to append to. Set to None for new LoRA.*/
			"existing_lora": ComfyNodeTypedInputRef<string>
}


export class SaveLoRANode extends ComfyNode {
	classType: string = "SaveLoRANode"

	sockets: {
		inputs: Required<SaveLoRANodeInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"lora": new ComfyNodeTypedInputRef<ComfyValueType_LORA_MODEL>(this, "lora"),
				"prefix": new ComfyNodeTypedInputRef<string>(this, "prefix"),
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<SaveLoRANodeInputs>) {
		if (typeof sources["lora"] === "object") {
			this.sockets.inputs["lora"].connectTo(sources["lora"])
		} else {
			this.sockets.inputs["lora"].value = sources["lora"]
		}

		if (typeof sources["prefix"] === "object") {
			this.sockets.inputs["prefix"].connectTo(sources["prefix"])
		} else {
			this.sockets.inputs["prefix"].value = sources["prefix"]
		}

		if (sources["steps"] !== undefined) {
		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}
		}

	}
}

type SaveLoRANodeInputs = {
			/** The LoRA model to save. Do not use the model with LoRA layers.*/
			"lora": ComfyNodeTypedInputRef<ComfyValueType_LORA_MODEL>
			/** The prefix to use for the saved LoRA file.*/
			"prefix": ComfyNodeTypedInputRef<string>
			/** Optional: The number of steps to LoRA has been trained for, used to name the saved file.*/
			"steps"?: ComfyNodeTypedInputRef<number>
}


export class LoraModelLoader extends ComfyNode {
	classType: string = "LoraModelLoader"

	sockets: {
		inputs: Required<LoraModelLoaderInputs>
		outputs: {
			/** The modified diffusion model.*/
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"lora": new ComfyNodeTypedInputRef<ComfyValueType_LORA_MODEL>(this, "lora"),
				"strength_model": new ComfyNodeTypedInputRef<number>(this, "strength_model"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoraModelLoaderInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["lora"] === "object") {
			this.sockets.inputs["lora"].connectTo(sources["lora"])
		} else {
			this.sockets.inputs["lora"].value = sources["lora"]
		}

		if (typeof sources["strength_model"] === "object") {
			this.sockets.inputs["strength_model"].connectTo(sources["strength_model"])
		} else {
			this.sockets.inputs["strength_model"].value = sources["strength_model"]
		}

	}
}

type LoraModelLoaderInputs = {
			/** The diffusion model the LoRA will be applied to.*/
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** The LoRA model to apply to the diffusion model.*/
			"lora": ComfyNodeTypedInputRef<ComfyValueType_LORA_MODEL>
			/** How strongly to modify the diffusion model. This value can be negative.*/
			"strength_model": ComfyNodeTypedInputRef<number>
}


export class LoadImageSetFromFolderNode extends ComfyNode {
	classType: string = "LoadImageSetFromFolderNode"

	sockets: {
		inputs: Required<LoadImageSetFromFolderNodeInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"folder": new ComfyNodeTypedInputRef<string>(this, "folder"),
				"resize_method": new ComfyNodeTypedInputRef<string>(this, "resize_method"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoadImageSetFromFolderNodeInputs>) {
		if (typeof sources["folder"] === "object") {
			this.sockets.inputs["folder"].connectTo(sources["folder"])
		} else {
			this.sockets.inputs["folder"].value = sources["folder"]
		}

		if (sources["resize_method"] !== undefined) {
		if (typeof sources["resize_method"] === "object") {
			this.sockets.inputs["resize_method"].connectTo(sources["resize_method"])
		} else {
			this.sockets.inputs["resize_method"].value = sources["resize_method"]
		}
		}

	}
}

type LoadImageSetFromFolderNodeInputs = {
			/** The folder to load images from.*/
			"folder": ComfyNodeTypedInputRef<string>
			"resize_method"?: ComfyNodeTypedInputRef<string>
}


export class LoadImageTextSetFromFolderNode extends ComfyNode {
	classType: string = "LoadImageTextSetFromFolderNode"

	sockets: {
		inputs: Required<LoadImageTextSetFromFolderNodeInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"folder": new ComfyNodeTypedInputRef<string>(this, "folder"),
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"resize_method": new ComfyNodeTypedInputRef<string>(this, "resize_method"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoadImageTextSetFromFolderNodeInputs>) {
		if (typeof sources["folder"] === "object") {
			this.sockets.inputs["folder"].connectTo(sources["folder"])
		} else {
			this.sockets.inputs["folder"].value = sources["folder"]
		}

		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (sources["resize_method"] !== undefined) {
		if (typeof sources["resize_method"] === "object") {
			this.sockets.inputs["resize_method"].connectTo(sources["resize_method"])
		} else {
			this.sockets.inputs["resize_method"].value = sources["resize_method"]
		}
		}

		if (sources["width"] !== undefined) {
		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}
		}

		if (sources["height"] !== undefined) {
		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}
		}

	}
}

type LoadImageTextSetFromFolderNodeInputs = {
			/** The folder to load images from.*/
			"folder": ComfyNodeTypedInputRef<string>
			/** The CLIP model used for encoding the text.*/
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"resize_method"?: ComfyNodeTypedInputRef<string>
			/** The width to resize the images to. -1 means use the original width.*/
			"width"?: ComfyNodeTypedInputRef<number>
			/** The height to resize the images to. -1 means use the original height.*/
			"height"?: ComfyNodeTypedInputRef<number>
}


export class LossGraphNode extends ComfyNode {
	classType: string = "LossGraphNode"

	sockets: {
		inputs: Required<LossGraphNodeInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"loss": new ComfyNodeTypedInputRef<ComfyValueType_LOSS_MAP>(this, "loss"),
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_E>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<LossGraphNodeInputs>) {
		if (typeof sources["loss"] === "object") {
			this.sockets.inputs["loss"].connectTo(sources["loss"])
		} else {
			this.sockets.inputs["loss"].value = sources["loss"]
		}

		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type LossGraphNodeInputs = {
			"loss": ComfyNodeTypedInputRef<ComfyValueType_LOSS_MAP>
			"filename_prefix": ComfyNodeTypedInputRef<string>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_E>
}


export class SelfAttentionGuidance extends ComfyNode {
	classType: string = "SelfAttentionGuidance"

	sockets: {
		inputs: Required<SelfAttentionGuidanceInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"scale": new ComfyNodeTypedInputRef<number>(this, "scale"),
				"blur_sigma": new ComfyNodeTypedInputRef<number>(this, "blur_sigma"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SelfAttentionGuidanceInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["scale"] === "object") {
			this.sockets.inputs["scale"].connectTo(sources["scale"])
		} else {
			this.sockets.inputs["scale"].value = sources["scale"]
		}

		if (typeof sources["blur_sigma"] === "object") {
			this.sockets.inputs["blur_sigma"].connectTo(sources["blur_sigma"])
		} else {
			this.sockets.inputs["blur_sigma"].value = sources["blur_sigma"]
		}

	}
}

type SelfAttentionGuidanceInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"scale": ComfyNodeTypedInputRef<number>
			"blur_sigma": ComfyNodeTypedInputRef<number>
}


export class PerpNeg extends ComfyNode {
	classType: string = "PerpNeg"

	sockets: {
		inputs: Required<PerpNegInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"empty_conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "empty_conditioning"),
				"neg_scale": new ComfyNodeTypedInputRef<number>(this, "neg_scale"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PerpNegInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["empty_conditioning"] === "object") {
			this.sockets.inputs["empty_conditioning"].connectTo(sources["empty_conditioning"])
		} else {
			this.sockets.inputs["empty_conditioning"].value = sources["empty_conditioning"]
		}

		if (typeof sources["neg_scale"] === "object") {
			this.sockets.inputs["neg_scale"].connectTo(sources["neg_scale"])
		} else {
			this.sockets.inputs["neg_scale"].value = sources["neg_scale"]
		}

	}
}

type PerpNegInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"empty_conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"neg_scale": ComfyNodeTypedInputRef<number>
}


export class PerpNegGuider extends ComfyNode {
	classType: string = "PerpNegGuider"

	sockets: {
		inputs: Required<PerpNegGuiderInputs>
		outputs: {
			GUIDER: ComfyNodeTypedSourceRef<ComfyValueType_GUIDER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"empty_conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "empty_conditioning"),
				"cfg": new ComfyNodeTypedInputRef<number>(this, "cfg"),
				"neg_scale": new ComfyNodeTypedInputRef<number>(this, "neg_scale"),
			},
			outputs: Object.create(Object.prototype, {
				"GUIDER": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PerpNegGuiderInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["empty_conditioning"] === "object") {
			this.sockets.inputs["empty_conditioning"].connectTo(sources["empty_conditioning"])
		} else {
			this.sockets.inputs["empty_conditioning"].value = sources["empty_conditioning"]
		}

		if (typeof sources["cfg"] === "object") {
			this.sockets.inputs["cfg"].connectTo(sources["cfg"])
		} else {
			this.sockets.inputs["cfg"].value = sources["cfg"]
		}

		if (typeof sources["neg_scale"] === "object") {
			this.sockets.inputs["neg_scale"].connectTo(sources["neg_scale"])
		} else {
			this.sockets.inputs["neg_scale"].value = sources["neg_scale"]
		}

	}
}

type PerpNegGuiderInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"empty_conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"cfg": ComfyNodeTypedInputRef<number>
			"neg_scale": ComfyNodeTypedInputRef<number>
}


export class StableZero123_Conditioning extends ComfyNode {
	classType: string = "StableZero123_Conditioning"

	sockets: {
		inputs: Required<StableZero123_ConditioningInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_vision": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>(this, "clip_vision"),
				"init_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "init_image"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"elevation": new ComfyNodeTypedInputRef<number>(this, "elevation"),
				"azimuth": new ComfyNodeTypedInputRef<number>(this, "azimuth"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<StableZero123_ConditioningInputs>) {
		if (typeof sources["clip_vision"] === "object") {
			this.sockets.inputs["clip_vision"].connectTo(sources["clip_vision"])
		} else {
			this.sockets.inputs["clip_vision"].value = sources["clip_vision"]
		}

		if (typeof sources["init_image"] === "object") {
			this.sockets.inputs["init_image"].connectTo(sources["init_image"])
		} else {
			this.sockets.inputs["init_image"].value = sources["init_image"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (typeof sources["elevation"] === "object") {
			this.sockets.inputs["elevation"].connectTo(sources["elevation"])
		} else {
			this.sockets.inputs["elevation"].value = sources["elevation"]
		}

		if (typeof sources["azimuth"] === "object") {
			this.sockets.inputs["azimuth"].connectTo(sources["azimuth"])
		} else {
			this.sockets.inputs["azimuth"].value = sources["azimuth"]
		}

	}
}

type StableZero123_ConditioningInputs = {
			"clip_vision": ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>
			"init_image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"elevation": ComfyNodeTypedInputRef<number>
			"azimuth": ComfyNodeTypedInputRef<number>
}


export class StableZero123_Conditioning_Batched extends ComfyNode {
	classType: string = "StableZero123_Conditioning_Batched"

	sockets: {
		inputs: Required<StableZero123_Conditioning_BatchedInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_vision": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>(this, "clip_vision"),
				"init_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "init_image"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"elevation": new ComfyNodeTypedInputRef<number>(this, "elevation"),
				"azimuth": new ComfyNodeTypedInputRef<number>(this, "azimuth"),
				"elevation_batch_increment": new ComfyNodeTypedInputRef<number>(this, "elevation_batch_increment"),
				"azimuth_batch_increment": new ComfyNodeTypedInputRef<number>(this, "azimuth_batch_increment"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<StableZero123_Conditioning_BatchedInputs>) {
		if (typeof sources["clip_vision"] === "object") {
			this.sockets.inputs["clip_vision"].connectTo(sources["clip_vision"])
		} else {
			this.sockets.inputs["clip_vision"].value = sources["clip_vision"]
		}

		if (typeof sources["init_image"] === "object") {
			this.sockets.inputs["init_image"].connectTo(sources["init_image"])
		} else {
			this.sockets.inputs["init_image"].value = sources["init_image"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (typeof sources["elevation"] === "object") {
			this.sockets.inputs["elevation"].connectTo(sources["elevation"])
		} else {
			this.sockets.inputs["elevation"].value = sources["elevation"]
		}

		if (typeof sources["azimuth"] === "object") {
			this.sockets.inputs["azimuth"].connectTo(sources["azimuth"])
		} else {
			this.sockets.inputs["azimuth"].value = sources["azimuth"]
		}

		if (typeof sources["elevation_batch_increment"] === "object") {
			this.sockets.inputs["elevation_batch_increment"].connectTo(sources["elevation_batch_increment"])
		} else {
			this.sockets.inputs["elevation_batch_increment"].value = sources["elevation_batch_increment"]
		}

		if (typeof sources["azimuth_batch_increment"] === "object") {
			this.sockets.inputs["azimuth_batch_increment"].connectTo(sources["azimuth_batch_increment"])
		} else {
			this.sockets.inputs["azimuth_batch_increment"].value = sources["azimuth_batch_increment"]
		}

	}
}

type StableZero123_Conditioning_BatchedInputs = {
			"clip_vision": ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>
			"init_image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"elevation": ComfyNodeTypedInputRef<number>
			"azimuth": ComfyNodeTypedInputRef<number>
			"elevation_batch_increment": ComfyNodeTypedInputRef<number>
			"azimuth_batch_increment": ComfyNodeTypedInputRef<number>
}


export class SV3D_Conditioning extends ComfyNode {
	classType: string = "SV3D_Conditioning"

	sockets: {
		inputs: Required<SV3D_ConditioningInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_vision": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>(this, "clip_vision"),
				"init_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "init_image"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"video_frames": new ComfyNodeTypedInputRef<number>(this, "video_frames"),
				"elevation": new ComfyNodeTypedInputRef<number>(this, "elevation"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SV3D_ConditioningInputs>) {
		if (typeof sources["clip_vision"] === "object") {
			this.sockets.inputs["clip_vision"].connectTo(sources["clip_vision"])
		} else {
			this.sockets.inputs["clip_vision"].value = sources["clip_vision"]
		}

		if (typeof sources["init_image"] === "object") {
			this.sockets.inputs["init_image"].connectTo(sources["init_image"])
		} else {
			this.sockets.inputs["init_image"].value = sources["init_image"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["video_frames"] === "object") {
			this.sockets.inputs["video_frames"].connectTo(sources["video_frames"])
		} else {
			this.sockets.inputs["video_frames"].value = sources["video_frames"]
		}

		if (typeof sources["elevation"] === "object") {
			this.sockets.inputs["elevation"].connectTo(sources["elevation"])
		} else {
			this.sockets.inputs["elevation"].value = sources["elevation"]
		}

	}
}

type SV3D_ConditioningInputs = {
			"clip_vision": ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>
			"init_image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"video_frames": ComfyNodeTypedInputRef<number>
			"elevation": ComfyNodeTypedInputRef<number>
}


export class SD_4XUpscale_Conditioning extends ComfyNode {
	classType: string = "SD_4XUpscale_Conditioning"

	sockets: {
		inputs: Required<SD_4XUpscale_ConditioningInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"scale_ratio": new ComfyNodeTypedInputRef<number>(this, "scale_ratio"),
				"noise_augmentation": new ComfyNodeTypedInputRef<number>(this, "noise_augmentation"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SD_4XUpscale_ConditioningInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["scale_ratio"] === "object") {
			this.sockets.inputs["scale_ratio"].connectTo(sources["scale_ratio"])
		} else {
			this.sockets.inputs["scale_ratio"].value = sources["scale_ratio"]
		}

		if (typeof sources["noise_augmentation"] === "object") {
			this.sockets.inputs["noise_augmentation"].connectTo(sources["noise_augmentation"])
		} else {
			this.sockets.inputs["noise_augmentation"].value = sources["noise_augmentation"]
		}

	}
}

type SD_4XUpscale_ConditioningInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"scale_ratio": ComfyNodeTypedInputRef<number>
			"noise_augmentation": ComfyNodeTypedInputRef<number>
}


export class PhotoMakerLoader extends ComfyNode {
	classType: string = "PhotoMakerLoader"

	sockets: {
		inputs: Required<PhotoMakerLoaderInputs>
		outputs: {
			PHOTOMAKER: ComfyNodeTypedSourceRef<ComfyValueType_PHOTOMAKER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"photomaker_model_name": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "photomaker_model_name"),
			},
			outputs: Object.create(Object.prototype, {
				"PHOTOMAKER": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PhotoMakerLoaderInputs>) {
		if (typeof sources["photomaker_model_name"] === "object") {
			this.sockets.inputs["photomaker_model_name"].connectTo(sources["photomaker_model_name"])
		} else {
			this.sockets.inputs["photomaker_model_name"].value = sources["photomaker_model_name"]
		}

	}
}

type PhotoMakerLoaderInputs = {
			"photomaker_model_name": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class PhotoMakerEncode extends ComfyNode {
	classType: string = "PhotoMakerEncode"

	sockets: {
		inputs: Required<PhotoMakerEncodeInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"photomaker": new ComfyNodeTypedInputRef<ComfyValueType_PHOTOMAKER>(this, "photomaker"),
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"text": new ComfyNodeTypedInputRef<string>(this, "text"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PhotoMakerEncodeInputs>) {
		if (typeof sources["photomaker"] === "object") {
			this.sockets.inputs["photomaker"].connectTo(sources["photomaker"])
		} else {
			this.sockets.inputs["photomaker"].value = sources["photomaker"]
		}

		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["text"] === "object") {
			this.sockets.inputs["text"].connectTo(sources["text"])
		} else {
			this.sockets.inputs["text"].value = sources["text"]
		}

	}
}

type PhotoMakerEncodeInputs = {
			"photomaker": ComfyNodeTypedInputRef<ComfyValueType_PHOTOMAKER>
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"text": ComfyNodeTypedInputRef<string>
}


export class CLIPTextEncodePixArtAlpha extends ComfyNode {
	classType: string = "CLIPTextEncodePixArtAlpha"

	sockets: {
		inputs: Required<CLIPTextEncodePixArtAlphaInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"text": new ComfyNodeTypedInputRef<string>(this, "text"),
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPTextEncodePixArtAlphaInputs>) {
		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["text"] === "object") {
			this.sockets.inputs["text"].connectTo(sources["text"])
		} else {
			this.sockets.inputs["text"].value = sources["text"]
		}

		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

	}
}

type CLIPTextEncodePixArtAlphaInputs = {
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"text": ComfyNodeTypedInputRef<string>
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
}


export class CLIPTextEncodeControlnet extends ComfyNode {
	classType: string = "CLIPTextEncodeControlnet"

	sockets: {
		inputs: Required<CLIPTextEncodeControlnetInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning"),
				"text": new ComfyNodeTypedInputRef<string>(this, "text"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPTextEncodeControlnetInputs>) {
		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["conditioning"] === "object") {
			this.sockets.inputs["conditioning"].connectTo(sources["conditioning"])
		} else {
			this.sockets.inputs["conditioning"].value = sources["conditioning"]
		}

		if (typeof sources["text"] === "object") {
			this.sockets.inputs["text"].connectTo(sources["text"])
		} else {
			this.sockets.inputs["text"].value = sources["text"]
		}

	}
}

type CLIPTextEncodeControlnetInputs = {
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"text": ComfyNodeTypedInputRef<string>
}


export class T5TokenizerOptions extends ComfyNode {
	classType: string = "T5TokenizerOptions"

	sockets: {
		inputs: Required<T5TokenizerOptionsInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"min_padding": new ComfyNodeTypedInputRef<number>(this, "min_padding"),
				"min_length": new ComfyNodeTypedInputRef<number>(this, "min_length"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<T5TokenizerOptionsInputs>) {
		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["min_padding"] === "object") {
			this.sockets.inputs["min_padding"].connectTo(sources["min_padding"])
		} else {
			this.sockets.inputs["min_padding"].value = sources["min_padding"]
		}

		if (typeof sources["min_length"] === "object") {
			this.sockets.inputs["min_length"].connectTo(sources["min_length"])
		} else {
			this.sockets.inputs["min_length"].value = sources["min_length"]
		}

	}
}

type T5TokenizerOptionsInputs = {
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"min_padding": ComfyNodeTypedInputRef<number>
			"min_length": ComfyNodeTypedInputRef<number>
}


export class Morphology extends ComfyNode {
	classType: string = "Morphology"

	sockets: {
		inputs: Required<MorphologyInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"operation": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "operation"),
				"kernel_size": new ComfyNodeTypedInputRef<number>(this, "kernel_size"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<MorphologyInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["operation"] === "object") {
			this.sockets.inputs["operation"].connectTo(sources["operation"])
		} else {
			this.sockets.inputs["operation"].value = sources["operation"]
		}

		if (typeof sources["kernel_size"] === "object") {
			this.sockets.inputs["kernel_size"].connectTo(sources["kernel_size"])
		} else {
			this.sockets.inputs["kernel_size"].value = sources["kernel_size"]
		}

	}
}

type MorphologyInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"operation": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"kernel_size": ComfyNodeTypedInputRef<number>
}


export class ImageRGBToYUV extends ComfyNode {
	classType: string = "ImageRGBToYUV"

	sockets: {
		inputs: Required<ImageRGBToYUVInputs>
		outputs: {
			Y: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			U: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			V: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
			},
			outputs: Object.create(Object.prototype, {
				"Y": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"U": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"V": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageRGBToYUVInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

	}
}

type ImageRGBToYUVInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class ImageYUVToRGB extends ComfyNode {
	classType: string = "ImageYUVToRGB"

	sockets: {
		inputs: Required<ImageYUVToRGBInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"Y": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "Y"),
				"U": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "U"),
				"V": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "V"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageYUVToRGBInputs>) {
		if (typeof sources["Y"] === "object") {
			this.sockets.inputs["Y"].connectTo(sources["Y"])
		} else {
			this.sockets.inputs["Y"].value = sources["Y"]
		}

		if (typeof sources["U"] === "object") {
			this.sockets.inputs["U"].connectTo(sources["U"])
		} else {
			this.sockets.inputs["U"].value = sources["U"]
		}

		if (typeof sources["V"] === "object") {
			this.sockets.inputs["V"].connectTo(sources["V"])
		} else {
			this.sockets.inputs["V"].value = sources["V"]
		}

	}
}

type ImageYUVToRGBInputs = {
			"Y": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"U": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"V": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class StableCascade_EmptyLatentImage extends ComfyNode {
	classType: string = "StableCascade_EmptyLatentImage"

	sockets: {
		inputs: Required<StableCascade_EmptyLatentImageInputs>
		outputs: {
			stage_c: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
			stage_b: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"compression": new ComfyNodeTypedInputRef<number>(this, "compression"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
			},
			outputs: Object.create(Object.prototype, {
				"stage_c": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"stage_b": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<StableCascade_EmptyLatentImageInputs>) {
		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["compression"] === "object") {
			this.sockets.inputs["compression"].connectTo(sources["compression"])
		} else {
			this.sockets.inputs["compression"].value = sources["compression"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

	}
}

type StableCascade_EmptyLatentImageInputs = {
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"compression": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
}


export class StableCascade_StageB_Conditioning extends ComfyNode {
	classType: string = "StableCascade_StageB_Conditioning"

	sockets: {
		inputs: Required<StableCascade_StageB_ConditioningInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning"),
				"stage_c": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "stage_c"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<StableCascade_StageB_ConditioningInputs>) {
		if (typeof sources["conditioning"] === "object") {
			this.sockets.inputs["conditioning"].connectTo(sources["conditioning"])
		} else {
			this.sockets.inputs["conditioning"].value = sources["conditioning"]
		}

		if (typeof sources["stage_c"] === "object") {
			this.sockets.inputs["stage_c"].connectTo(sources["stage_c"])
		} else {
			this.sockets.inputs["stage_c"].value = sources["stage_c"]
		}

	}
}

type StableCascade_StageB_ConditioningInputs = {
			"conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"stage_c": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class StableCascade_StageC_VAEEncode extends ComfyNode {
	classType: string = "StableCascade_StageC_VAEEncode"

	sockets: {
		inputs: Required<StableCascade_StageC_VAEEncodeInputs>
		outputs: {
			stage_c: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
			stage_b: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"compression": new ComfyNodeTypedInputRef<number>(this, "compression"),
			},
			outputs: Object.create(Object.prototype, {
				"stage_c": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"stage_b": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<StableCascade_StageC_VAEEncodeInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["compression"] === "object") {
			this.sockets.inputs["compression"].connectTo(sources["compression"])
		} else {
			this.sockets.inputs["compression"].value = sources["compression"]
		}

	}
}

type StableCascade_StageC_VAEEncodeInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"compression": ComfyNodeTypedInputRef<number>
}


export class StableCascade_SuperResolutionControlnet extends ComfyNode {
	classType: string = "StableCascade_SuperResolutionControlnet"

	sockets: {
		inputs: Required<StableCascade_SuperResolutionControlnetInputs>
		outputs: {
			controlnet_input: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			stage_c: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
			stage_b: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
			},
			outputs: Object.create(Object.prototype, {
				"controlnet_input": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"stage_c": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"stage_b": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<StableCascade_SuperResolutionControlnetInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

	}
}

type StableCascade_SuperResolutionControlnetInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
}


export class DifferentialDiffusion extends ComfyNode {
	classType: string = "DifferentialDiffusion"

	sockets: {
		inputs: Required<DifferentialDiffusionInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DifferentialDiffusionInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (sources["strength"] !== undefined) {
		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}
		}

	}
}

type DifferentialDiffusionInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"strength"?: ComfyNodeTypedInputRef<number>
}


export class InstructPixToPixConditioning extends ComfyNode {
	classType: string = "InstructPixToPixConditioning"

	sockets: {
		inputs: Required<InstructPixToPixConditioningInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"pixels": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "pixels"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<InstructPixToPixConditioningInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["pixels"] === "object") {
			this.sockets.inputs["pixels"].connectTo(sources["pixels"])
		} else {
			this.sockets.inputs["pixels"].value = sources["pixels"]
		}

	}
}

type InstructPixToPixConditioningInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"pixels": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class ModelMergeSD1 extends ComfyNode {
	classType: string = "ModelMergeSD1"

	sockets: {
		inputs: Required<ModelMergeSD1Inputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model1": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model1"),
				"model2": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model2"),
				"time_embed.": new ComfyNodeTypedInputRef<number>(this, "time_embed."),
				"label_emb.": new ComfyNodeTypedInputRef<number>(this, "label_emb."),
				"input_blocks.0.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.0."),
				"input_blocks.1.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.1."),
				"input_blocks.2.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.2."),
				"input_blocks.3.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.3."),
				"input_blocks.4.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.4."),
				"input_blocks.5.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.5."),
				"input_blocks.6.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.6."),
				"input_blocks.7.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.7."),
				"input_blocks.8.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.8."),
				"input_blocks.9.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.9."),
				"input_blocks.10.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.10."),
				"input_blocks.11.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.11."),
				"middle_block.0.": new ComfyNodeTypedInputRef<number>(this, "middle_block.0."),
				"middle_block.1.": new ComfyNodeTypedInputRef<number>(this, "middle_block.1."),
				"middle_block.2.": new ComfyNodeTypedInputRef<number>(this, "middle_block.2."),
				"output_blocks.0.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.0."),
				"output_blocks.1.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.1."),
				"output_blocks.2.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.2."),
				"output_blocks.3.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.3."),
				"output_blocks.4.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.4."),
				"output_blocks.5.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.5."),
				"output_blocks.6.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.6."),
				"output_blocks.7.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.7."),
				"output_blocks.8.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.8."),
				"output_blocks.9.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.9."),
				"output_blocks.10.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.10."),
				"output_blocks.11.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.11."),
				"out.": new ComfyNodeTypedInputRef<number>(this, "out."),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelMergeSD1Inputs>) {
		if (typeof sources["model1"] === "object") {
			this.sockets.inputs["model1"].connectTo(sources["model1"])
		} else {
			this.sockets.inputs["model1"].value = sources["model1"]
		}

		if (typeof sources["model2"] === "object") {
			this.sockets.inputs["model2"].connectTo(sources["model2"])
		} else {
			this.sockets.inputs["model2"].value = sources["model2"]
		}

		if (typeof sources["time_embed."] === "object") {
			this.sockets.inputs["time_embed."].connectTo(sources["time_embed."])
		} else {
			this.sockets.inputs["time_embed."].value = sources["time_embed."]
		}

		if (typeof sources["label_emb."] === "object") {
			this.sockets.inputs["label_emb."].connectTo(sources["label_emb."])
		} else {
			this.sockets.inputs["label_emb."].value = sources["label_emb."]
		}

		if (typeof sources["input_blocks.0."] === "object") {
			this.sockets.inputs["input_blocks.0."].connectTo(sources["input_blocks.0."])
		} else {
			this.sockets.inputs["input_blocks.0."].value = sources["input_blocks.0."]
		}

		if (typeof sources["input_blocks.1."] === "object") {
			this.sockets.inputs["input_blocks.1."].connectTo(sources["input_blocks.1."])
		} else {
			this.sockets.inputs["input_blocks.1."].value = sources["input_blocks.1."]
		}

		if (typeof sources["input_blocks.2."] === "object") {
			this.sockets.inputs["input_blocks.2."].connectTo(sources["input_blocks.2."])
		} else {
			this.sockets.inputs["input_blocks.2."].value = sources["input_blocks.2."]
		}

		if (typeof sources["input_blocks.3."] === "object") {
			this.sockets.inputs["input_blocks.3."].connectTo(sources["input_blocks.3."])
		} else {
			this.sockets.inputs["input_blocks.3."].value = sources["input_blocks.3."]
		}

		if (typeof sources["input_blocks.4."] === "object") {
			this.sockets.inputs["input_blocks.4."].connectTo(sources["input_blocks.4."])
		} else {
			this.sockets.inputs["input_blocks.4."].value = sources["input_blocks.4."]
		}

		if (typeof sources["input_blocks.5."] === "object") {
			this.sockets.inputs["input_blocks.5."].connectTo(sources["input_blocks.5."])
		} else {
			this.sockets.inputs["input_blocks.5."].value = sources["input_blocks.5."]
		}

		if (typeof sources["input_blocks.6."] === "object") {
			this.sockets.inputs["input_blocks.6."].connectTo(sources["input_blocks.6."])
		} else {
			this.sockets.inputs["input_blocks.6."].value = sources["input_blocks.6."]
		}

		if (typeof sources["input_blocks.7."] === "object") {
			this.sockets.inputs["input_blocks.7."].connectTo(sources["input_blocks.7."])
		} else {
			this.sockets.inputs["input_blocks.7."].value = sources["input_blocks.7."]
		}

		if (typeof sources["input_blocks.8."] === "object") {
			this.sockets.inputs["input_blocks.8."].connectTo(sources["input_blocks.8."])
		} else {
			this.sockets.inputs["input_blocks.8."].value = sources["input_blocks.8."]
		}

		if (typeof sources["input_blocks.9."] === "object") {
			this.sockets.inputs["input_blocks.9."].connectTo(sources["input_blocks.9."])
		} else {
			this.sockets.inputs["input_blocks.9."].value = sources["input_blocks.9."]
		}

		if (typeof sources["input_blocks.10."] === "object") {
			this.sockets.inputs["input_blocks.10."].connectTo(sources["input_blocks.10."])
		} else {
			this.sockets.inputs["input_blocks.10."].value = sources["input_blocks.10."]
		}

		if (typeof sources["input_blocks.11."] === "object") {
			this.sockets.inputs["input_blocks.11."].connectTo(sources["input_blocks.11."])
		} else {
			this.sockets.inputs["input_blocks.11."].value = sources["input_blocks.11."]
		}

		if (typeof sources["middle_block.0."] === "object") {
			this.sockets.inputs["middle_block.0."].connectTo(sources["middle_block.0."])
		} else {
			this.sockets.inputs["middle_block.0."].value = sources["middle_block.0."]
		}

		if (typeof sources["middle_block.1."] === "object") {
			this.sockets.inputs["middle_block.1."].connectTo(sources["middle_block.1."])
		} else {
			this.sockets.inputs["middle_block.1."].value = sources["middle_block.1."]
		}

		if (typeof sources["middle_block.2."] === "object") {
			this.sockets.inputs["middle_block.2."].connectTo(sources["middle_block.2."])
		} else {
			this.sockets.inputs["middle_block.2."].value = sources["middle_block.2."]
		}

		if (typeof sources["output_blocks.0."] === "object") {
			this.sockets.inputs["output_blocks.0."].connectTo(sources["output_blocks.0."])
		} else {
			this.sockets.inputs["output_blocks.0."].value = sources["output_blocks.0."]
		}

		if (typeof sources["output_blocks.1."] === "object") {
			this.sockets.inputs["output_blocks.1."].connectTo(sources["output_blocks.1."])
		} else {
			this.sockets.inputs["output_blocks.1."].value = sources["output_blocks.1."]
		}

		if (typeof sources["output_blocks.2."] === "object") {
			this.sockets.inputs["output_blocks.2."].connectTo(sources["output_blocks.2."])
		} else {
			this.sockets.inputs["output_blocks.2."].value = sources["output_blocks.2."]
		}

		if (typeof sources["output_blocks.3."] === "object") {
			this.sockets.inputs["output_blocks.3."].connectTo(sources["output_blocks.3."])
		} else {
			this.sockets.inputs["output_blocks.3."].value = sources["output_blocks.3."]
		}

		if (typeof sources["output_blocks.4."] === "object") {
			this.sockets.inputs["output_blocks.4."].connectTo(sources["output_blocks.4."])
		} else {
			this.sockets.inputs["output_blocks.4."].value = sources["output_blocks.4."]
		}

		if (typeof sources["output_blocks.5."] === "object") {
			this.sockets.inputs["output_blocks.5."].connectTo(sources["output_blocks.5."])
		} else {
			this.sockets.inputs["output_blocks.5."].value = sources["output_blocks.5."]
		}

		if (typeof sources["output_blocks.6."] === "object") {
			this.sockets.inputs["output_blocks.6."].connectTo(sources["output_blocks.6."])
		} else {
			this.sockets.inputs["output_blocks.6."].value = sources["output_blocks.6."]
		}

		if (typeof sources["output_blocks.7."] === "object") {
			this.sockets.inputs["output_blocks.7."].connectTo(sources["output_blocks.7."])
		} else {
			this.sockets.inputs["output_blocks.7."].value = sources["output_blocks.7."]
		}

		if (typeof sources["output_blocks.8."] === "object") {
			this.sockets.inputs["output_blocks.8."].connectTo(sources["output_blocks.8."])
		} else {
			this.sockets.inputs["output_blocks.8."].value = sources["output_blocks.8."]
		}

		if (typeof sources["output_blocks.9."] === "object") {
			this.sockets.inputs["output_blocks.9."].connectTo(sources["output_blocks.9."])
		} else {
			this.sockets.inputs["output_blocks.9."].value = sources["output_blocks.9."]
		}

		if (typeof sources["output_blocks.10."] === "object") {
			this.sockets.inputs["output_blocks.10."].connectTo(sources["output_blocks.10."])
		} else {
			this.sockets.inputs["output_blocks.10."].value = sources["output_blocks.10."]
		}

		if (typeof sources["output_blocks.11."] === "object") {
			this.sockets.inputs["output_blocks.11."].connectTo(sources["output_blocks.11."])
		} else {
			this.sockets.inputs["output_blocks.11."].value = sources["output_blocks.11."]
		}

		if (typeof sources["out."] === "object") {
			this.sockets.inputs["out."].connectTo(sources["out."])
		} else {
			this.sockets.inputs["out."].value = sources["out."]
		}

	}
}

type ModelMergeSD1Inputs = {
			"model1": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model2": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"time_embed.": ComfyNodeTypedInputRef<number>
			"label_emb.": ComfyNodeTypedInputRef<number>
			"input_blocks.0.": ComfyNodeTypedInputRef<number>
			"input_blocks.1.": ComfyNodeTypedInputRef<number>
			"input_blocks.2.": ComfyNodeTypedInputRef<number>
			"input_blocks.3.": ComfyNodeTypedInputRef<number>
			"input_blocks.4.": ComfyNodeTypedInputRef<number>
			"input_blocks.5.": ComfyNodeTypedInputRef<number>
			"input_blocks.6.": ComfyNodeTypedInputRef<number>
			"input_blocks.7.": ComfyNodeTypedInputRef<number>
			"input_blocks.8.": ComfyNodeTypedInputRef<number>
			"input_blocks.9.": ComfyNodeTypedInputRef<number>
			"input_blocks.10.": ComfyNodeTypedInputRef<number>
			"input_blocks.11.": ComfyNodeTypedInputRef<number>
			"middle_block.0.": ComfyNodeTypedInputRef<number>
			"middle_block.1.": ComfyNodeTypedInputRef<number>
			"middle_block.2.": ComfyNodeTypedInputRef<number>
			"output_blocks.0.": ComfyNodeTypedInputRef<number>
			"output_blocks.1.": ComfyNodeTypedInputRef<number>
			"output_blocks.2.": ComfyNodeTypedInputRef<number>
			"output_blocks.3.": ComfyNodeTypedInputRef<number>
			"output_blocks.4.": ComfyNodeTypedInputRef<number>
			"output_blocks.5.": ComfyNodeTypedInputRef<number>
			"output_blocks.6.": ComfyNodeTypedInputRef<number>
			"output_blocks.7.": ComfyNodeTypedInputRef<number>
			"output_blocks.8.": ComfyNodeTypedInputRef<number>
			"output_blocks.9.": ComfyNodeTypedInputRef<number>
			"output_blocks.10.": ComfyNodeTypedInputRef<number>
			"output_blocks.11.": ComfyNodeTypedInputRef<number>
			"out.": ComfyNodeTypedInputRef<number>
}


export class ModelMergeSD2 extends ComfyNode {
	classType: string = "ModelMergeSD2"

	sockets: {
		inputs: Required<ModelMergeSD2Inputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model1": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model1"),
				"model2": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model2"),
				"time_embed.": new ComfyNodeTypedInputRef<number>(this, "time_embed."),
				"label_emb.": new ComfyNodeTypedInputRef<number>(this, "label_emb."),
				"input_blocks.0.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.0."),
				"input_blocks.1.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.1."),
				"input_blocks.2.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.2."),
				"input_blocks.3.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.3."),
				"input_blocks.4.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.4."),
				"input_blocks.5.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.5."),
				"input_blocks.6.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.6."),
				"input_blocks.7.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.7."),
				"input_blocks.8.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.8."),
				"input_blocks.9.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.9."),
				"input_blocks.10.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.10."),
				"input_blocks.11.": new ComfyNodeTypedInputRef<number>(this, "input_blocks.11."),
				"middle_block.0.": new ComfyNodeTypedInputRef<number>(this, "middle_block.0."),
				"middle_block.1.": new ComfyNodeTypedInputRef<number>(this, "middle_block.1."),
				"middle_block.2.": new ComfyNodeTypedInputRef<number>(this, "middle_block.2."),
				"output_blocks.0.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.0."),
				"output_blocks.1.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.1."),
				"output_blocks.2.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.2."),
				"output_blocks.3.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.3."),
				"output_blocks.4.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.4."),
				"output_blocks.5.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.5."),
				"output_blocks.6.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.6."),
				"output_blocks.7.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.7."),
				"output_blocks.8.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.8."),
				"output_blocks.9.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.9."),
				"output_blocks.10.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.10."),
				"output_blocks.11.": new ComfyNodeTypedInputRef<number>(this, "output_blocks.11."),
				"out.": new ComfyNodeTypedInputRef<number>(this, "out."),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelMergeSD2Inputs>) {
		if (typeof sources["model1"] === "object") {
			this.sockets.inputs["model1"].connectTo(sources["model1"])
		} else {
			this.sockets.inputs["model1"].value = sources["model1"]
		}

		if (typeof sources["model2"] === "object") {
			this.sockets.inputs["model2"].connectTo(sources["model2"])
		} else {
			this.sockets.inputs["model2"].value = sources["model2"]
		}

		if (typeof sources["time_embed."] === "object") {
			this.sockets.inputs["time_embed."].connectTo(sources["time_embed."])
		} else {
			this.sockets.inputs["time_embed."].value = sources["time_embed."]
		}

		if (typeof sources["label_emb."] === "object") {
			this.sockets.inputs["label_emb."].connectTo(sources["label_emb."])
		} else {
			this.sockets.inputs["label_emb."].value = sources["label_emb."]
		}

		if (typeof sources["input_blocks.0."] === "object") {
			this.sockets.inputs["input_blocks.0."].connectTo(sources["input_blocks.0."])
		} else {
			this.sockets.inputs["input_blocks.0."].value = sources["input_blocks.0."]
		}

		if (typeof sources["input_blocks.1."] === "object") {
			this.sockets.inputs["input_blocks.1."].connectTo(sources["input_blocks.1."])
		} else {
			this.sockets.inputs["input_blocks.1."].value = sources["input_blocks.1."]
		}

		if (typeof sources["input_blocks.2."] === "object") {
			this.sockets.inputs["input_blocks.2."].connectTo(sources["input_blocks.2."])
		} else {
			this.sockets.inputs["input_blocks.2."].value = sources["input_blocks.2."]
		}

		if (typeof sources["input_blocks.3."] === "object") {
			this.sockets.inputs["input_blocks.3."].connectTo(sources["input_blocks.3."])
		} else {
			this.sockets.inputs["input_blocks.3."].value = sources["input_blocks.3."]
		}

		if (typeof sources["input_blocks.4."] === "object") {
			this.sockets.inputs["input_blocks.4."].connectTo(sources["input_blocks.4."])
		} else {
			this.sockets.inputs["input_blocks.4."].value = sources["input_blocks.4."]
		}

		if (typeof sources["input_blocks.5."] === "object") {
			this.sockets.inputs["input_blocks.5."].connectTo(sources["input_blocks.5."])
		} else {
			this.sockets.inputs["input_blocks.5."].value = sources["input_blocks.5."]
		}

		if (typeof sources["input_blocks.6."] === "object") {
			this.sockets.inputs["input_blocks.6."].connectTo(sources["input_blocks.6."])
		} else {
			this.sockets.inputs["input_blocks.6."].value = sources["input_blocks.6."]
		}

		if (typeof sources["input_blocks.7."] === "object") {
			this.sockets.inputs["input_blocks.7."].connectTo(sources["input_blocks.7."])
		} else {
			this.sockets.inputs["input_blocks.7."].value = sources["input_blocks.7."]
		}

		if (typeof sources["input_blocks.8."] === "object") {
			this.sockets.inputs["input_blocks.8."].connectTo(sources["input_blocks.8."])
		} else {
			this.sockets.inputs["input_blocks.8."].value = sources["input_blocks.8."]
		}

		if (typeof sources["input_blocks.9."] === "object") {
			this.sockets.inputs["input_blocks.9."].connectTo(sources["input_blocks.9."])
		} else {
			this.sockets.inputs["input_blocks.9."].value = sources["input_blocks.9."]
		}

		if (typeof sources["input_blocks.10."] === "object") {
			this.sockets.inputs["input_blocks.10."].connectTo(sources["input_blocks.10."])
		} else {
			this.sockets.inputs["input_blocks.10."].value = sources["input_blocks.10."]
		}

		if (typeof sources["input_blocks.11."] === "object") {
			this.sockets.inputs["input_blocks.11."].connectTo(sources["input_blocks.11."])
		} else {
			this.sockets.inputs["input_blocks.11."].value = sources["input_blocks.11."]
		}

		if (typeof sources["middle_block.0."] === "object") {
			this.sockets.inputs["middle_block.0."].connectTo(sources["middle_block.0."])
		} else {
			this.sockets.inputs["middle_block.0."].value = sources["middle_block.0."]
		}

		if (typeof sources["middle_block.1."] === "object") {
			this.sockets.inputs["middle_block.1."].connectTo(sources["middle_block.1."])
		} else {
			this.sockets.inputs["middle_block.1."].value = sources["middle_block.1."]
		}

		if (typeof sources["middle_block.2."] === "object") {
			this.sockets.inputs["middle_block.2."].connectTo(sources["middle_block.2."])
		} else {
			this.sockets.inputs["middle_block.2."].value = sources["middle_block.2."]
		}

		if (typeof sources["output_blocks.0."] === "object") {
			this.sockets.inputs["output_blocks.0."].connectTo(sources["output_blocks.0."])
		} else {
			this.sockets.inputs["output_blocks.0."].value = sources["output_blocks.0."]
		}

		if (typeof sources["output_blocks.1."] === "object") {
			this.sockets.inputs["output_blocks.1."].connectTo(sources["output_blocks.1."])
		} else {
			this.sockets.inputs["output_blocks.1."].value = sources["output_blocks.1."]
		}

		if (typeof sources["output_blocks.2."] === "object") {
			this.sockets.inputs["output_blocks.2."].connectTo(sources["output_blocks.2."])
		} else {
			this.sockets.inputs["output_blocks.2."].value = sources["output_blocks.2."]
		}

		if (typeof sources["output_blocks.3."] === "object") {
			this.sockets.inputs["output_blocks.3."].connectTo(sources["output_blocks.3."])
		} else {
			this.sockets.inputs["output_blocks.3."].value = sources["output_blocks.3."]
		}

		if (typeof sources["output_blocks.4."] === "object") {
			this.sockets.inputs["output_blocks.4."].connectTo(sources["output_blocks.4."])
		} else {
			this.sockets.inputs["output_blocks.4."].value = sources["output_blocks.4."]
		}

		if (typeof sources["output_blocks.5."] === "object") {
			this.sockets.inputs["output_blocks.5."].connectTo(sources["output_blocks.5."])
		} else {
			this.sockets.inputs["output_blocks.5."].value = sources["output_blocks.5."]
		}

		if (typeof sources["output_blocks.6."] === "object") {
			this.sockets.inputs["output_blocks.6."].connectTo(sources["output_blocks.6."])
		} else {
			this.sockets.inputs["output_blocks.6."].value = sources["output_blocks.6."]
		}

		if (typeof sources["output_blocks.7."] === "object") {
			this.sockets.inputs["output_blocks.7."].connectTo(sources["output_blocks.7."])
		} else {
			this.sockets.inputs["output_blocks.7."].value = sources["output_blocks.7."]
		}

		if (typeof sources["output_blocks.8."] === "object") {
			this.sockets.inputs["output_blocks.8."].connectTo(sources["output_blocks.8."])
		} else {
			this.sockets.inputs["output_blocks.8."].value = sources["output_blocks.8."]
		}

		if (typeof sources["output_blocks.9."] === "object") {
			this.sockets.inputs["output_blocks.9."].connectTo(sources["output_blocks.9."])
		} else {
			this.sockets.inputs["output_blocks.9."].value = sources["output_blocks.9."]
		}

		if (typeof sources["output_blocks.10."] === "object") {
			this.sockets.inputs["output_blocks.10."].connectTo(sources["output_blocks.10."])
		} else {
			this.sockets.inputs["output_blocks.10."].value = sources["output_blocks.10."]
		}

		if (typeof sources["output_blocks.11."] === "object") {
			this.sockets.inputs["output_blocks.11."].connectTo(sources["output_blocks.11."])
		} else {
			this.sockets.inputs["output_blocks.11."].value = sources["output_blocks.11."]
		}

		if (typeof sources["out."] === "object") {
			this.sockets.inputs["out."].connectTo(sources["out."])
		} else {
			this.sockets.inputs["out."].value = sources["out."]
		}

	}
}

type ModelMergeSD2Inputs = {
			"model1": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model2": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"time_embed.": ComfyNodeTypedInputRef<number>
			"label_emb.": ComfyNodeTypedInputRef<number>
			"input_blocks.0.": ComfyNodeTypedInputRef<number>
			"input_blocks.1.": ComfyNodeTypedInputRef<number>
			"input_blocks.2.": ComfyNodeTypedInputRef<number>
			"input_blocks.3.": ComfyNodeTypedInputRef<number>
			"input_blocks.4.": ComfyNodeTypedInputRef<number>
			"input_blocks.5.": ComfyNodeTypedInputRef<number>
			"input_blocks.6.": ComfyNodeTypedInputRef<number>
			"input_blocks.7.": ComfyNodeTypedInputRef<number>
			"input_blocks.8.": ComfyNodeTypedInputRef<number>
			"input_blocks.9.": ComfyNodeTypedInputRef<number>
			"input_blocks.10.": ComfyNodeTypedInputRef<number>
			"input_blocks.11.": ComfyNodeTypedInputRef<number>
			"middle_block.0.": ComfyNodeTypedInputRef<number>
			"middle_block.1.": ComfyNodeTypedInputRef<number>
			"middle_block.2.": ComfyNodeTypedInputRef<number>
			"output_blocks.0.": ComfyNodeTypedInputRef<number>
			"output_blocks.1.": ComfyNodeTypedInputRef<number>
			"output_blocks.2.": ComfyNodeTypedInputRef<number>
			"output_blocks.3.": ComfyNodeTypedInputRef<number>
			"output_blocks.4.": ComfyNodeTypedInputRef<number>
			"output_blocks.5.": ComfyNodeTypedInputRef<number>
			"output_blocks.6.": ComfyNodeTypedInputRef<number>
			"output_blocks.7.": ComfyNodeTypedInputRef<number>
			"output_blocks.8.": ComfyNodeTypedInputRef<number>
			"output_blocks.9.": ComfyNodeTypedInputRef<number>
			"output_blocks.10.": ComfyNodeTypedInputRef<number>
			"output_blocks.11.": ComfyNodeTypedInputRef<number>
			"out.": ComfyNodeTypedInputRef<number>
}


export class ModelMergeSDXL extends ComfyNode {
	classType: string = "ModelMergeSDXL"

	sockets: {
		inputs: Required<ModelMergeSDXLInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model1": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model1"),
				"model2": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model2"),
				"time_embed.": new ComfyNodeTypedInputRef<number>(this, "time_embed."),
				"label_emb.": new ComfyNodeTypedInputRef<number>(this, "label_emb."),
				"input_blocks.0": new ComfyNodeTypedInputRef<number>(this, "input_blocks.0"),
				"input_blocks.1": new ComfyNodeTypedInputRef<number>(this, "input_blocks.1"),
				"input_blocks.2": new ComfyNodeTypedInputRef<number>(this, "input_blocks.2"),
				"input_blocks.3": new ComfyNodeTypedInputRef<number>(this, "input_blocks.3"),
				"input_blocks.4": new ComfyNodeTypedInputRef<number>(this, "input_blocks.4"),
				"input_blocks.5": new ComfyNodeTypedInputRef<number>(this, "input_blocks.5"),
				"input_blocks.6": new ComfyNodeTypedInputRef<number>(this, "input_blocks.6"),
				"input_blocks.7": new ComfyNodeTypedInputRef<number>(this, "input_blocks.7"),
				"input_blocks.8": new ComfyNodeTypedInputRef<number>(this, "input_blocks.8"),
				"middle_block.0": new ComfyNodeTypedInputRef<number>(this, "middle_block.0"),
				"middle_block.1": new ComfyNodeTypedInputRef<number>(this, "middle_block.1"),
				"middle_block.2": new ComfyNodeTypedInputRef<number>(this, "middle_block.2"),
				"output_blocks.0": new ComfyNodeTypedInputRef<number>(this, "output_blocks.0"),
				"output_blocks.1": new ComfyNodeTypedInputRef<number>(this, "output_blocks.1"),
				"output_blocks.2": new ComfyNodeTypedInputRef<number>(this, "output_blocks.2"),
				"output_blocks.3": new ComfyNodeTypedInputRef<number>(this, "output_blocks.3"),
				"output_blocks.4": new ComfyNodeTypedInputRef<number>(this, "output_blocks.4"),
				"output_blocks.5": new ComfyNodeTypedInputRef<number>(this, "output_blocks.5"),
				"output_blocks.6": new ComfyNodeTypedInputRef<number>(this, "output_blocks.6"),
				"output_blocks.7": new ComfyNodeTypedInputRef<number>(this, "output_blocks.7"),
				"output_blocks.8": new ComfyNodeTypedInputRef<number>(this, "output_blocks.8"),
				"out.": new ComfyNodeTypedInputRef<number>(this, "out."),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelMergeSDXLInputs>) {
		if (typeof sources["model1"] === "object") {
			this.sockets.inputs["model1"].connectTo(sources["model1"])
		} else {
			this.sockets.inputs["model1"].value = sources["model1"]
		}

		if (typeof sources["model2"] === "object") {
			this.sockets.inputs["model2"].connectTo(sources["model2"])
		} else {
			this.sockets.inputs["model2"].value = sources["model2"]
		}

		if (typeof sources["time_embed."] === "object") {
			this.sockets.inputs["time_embed."].connectTo(sources["time_embed."])
		} else {
			this.sockets.inputs["time_embed."].value = sources["time_embed."]
		}

		if (typeof sources["label_emb."] === "object") {
			this.sockets.inputs["label_emb."].connectTo(sources["label_emb."])
		} else {
			this.sockets.inputs["label_emb."].value = sources["label_emb."]
		}

		if (typeof sources["input_blocks.0"] === "object") {
			this.sockets.inputs["input_blocks.0"].connectTo(sources["input_blocks.0"])
		} else {
			this.sockets.inputs["input_blocks.0"].value = sources["input_blocks.0"]
		}

		if (typeof sources["input_blocks.1"] === "object") {
			this.sockets.inputs["input_blocks.1"].connectTo(sources["input_blocks.1"])
		} else {
			this.sockets.inputs["input_blocks.1"].value = sources["input_blocks.1"]
		}

		if (typeof sources["input_blocks.2"] === "object") {
			this.sockets.inputs["input_blocks.2"].connectTo(sources["input_blocks.2"])
		} else {
			this.sockets.inputs["input_blocks.2"].value = sources["input_blocks.2"]
		}

		if (typeof sources["input_blocks.3"] === "object") {
			this.sockets.inputs["input_blocks.3"].connectTo(sources["input_blocks.3"])
		} else {
			this.sockets.inputs["input_blocks.3"].value = sources["input_blocks.3"]
		}

		if (typeof sources["input_blocks.4"] === "object") {
			this.sockets.inputs["input_blocks.4"].connectTo(sources["input_blocks.4"])
		} else {
			this.sockets.inputs["input_blocks.4"].value = sources["input_blocks.4"]
		}

		if (typeof sources["input_blocks.5"] === "object") {
			this.sockets.inputs["input_blocks.5"].connectTo(sources["input_blocks.5"])
		} else {
			this.sockets.inputs["input_blocks.5"].value = sources["input_blocks.5"]
		}

		if (typeof sources["input_blocks.6"] === "object") {
			this.sockets.inputs["input_blocks.6"].connectTo(sources["input_blocks.6"])
		} else {
			this.sockets.inputs["input_blocks.6"].value = sources["input_blocks.6"]
		}

		if (typeof sources["input_blocks.7"] === "object") {
			this.sockets.inputs["input_blocks.7"].connectTo(sources["input_blocks.7"])
		} else {
			this.sockets.inputs["input_blocks.7"].value = sources["input_blocks.7"]
		}

		if (typeof sources["input_blocks.8"] === "object") {
			this.sockets.inputs["input_blocks.8"].connectTo(sources["input_blocks.8"])
		} else {
			this.sockets.inputs["input_blocks.8"].value = sources["input_blocks.8"]
		}

		if (typeof sources["middle_block.0"] === "object") {
			this.sockets.inputs["middle_block.0"].connectTo(sources["middle_block.0"])
		} else {
			this.sockets.inputs["middle_block.0"].value = sources["middle_block.0"]
		}

		if (typeof sources["middle_block.1"] === "object") {
			this.sockets.inputs["middle_block.1"].connectTo(sources["middle_block.1"])
		} else {
			this.sockets.inputs["middle_block.1"].value = sources["middle_block.1"]
		}

		if (typeof sources["middle_block.2"] === "object") {
			this.sockets.inputs["middle_block.2"].connectTo(sources["middle_block.2"])
		} else {
			this.sockets.inputs["middle_block.2"].value = sources["middle_block.2"]
		}

		if (typeof sources["output_blocks.0"] === "object") {
			this.sockets.inputs["output_blocks.0"].connectTo(sources["output_blocks.0"])
		} else {
			this.sockets.inputs["output_blocks.0"].value = sources["output_blocks.0"]
		}

		if (typeof sources["output_blocks.1"] === "object") {
			this.sockets.inputs["output_blocks.1"].connectTo(sources["output_blocks.1"])
		} else {
			this.sockets.inputs["output_blocks.1"].value = sources["output_blocks.1"]
		}

		if (typeof sources["output_blocks.2"] === "object") {
			this.sockets.inputs["output_blocks.2"].connectTo(sources["output_blocks.2"])
		} else {
			this.sockets.inputs["output_blocks.2"].value = sources["output_blocks.2"]
		}

		if (typeof sources["output_blocks.3"] === "object") {
			this.sockets.inputs["output_blocks.3"].connectTo(sources["output_blocks.3"])
		} else {
			this.sockets.inputs["output_blocks.3"].value = sources["output_blocks.3"]
		}

		if (typeof sources["output_blocks.4"] === "object") {
			this.sockets.inputs["output_blocks.4"].connectTo(sources["output_blocks.4"])
		} else {
			this.sockets.inputs["output_blocks.4"].value = sources["output_blocks.4"]
		}

		if (typeof sources["output_blocks.5"] === "object") {
			this.sockets.inputs["output_blocks.5"].connectTo(sources["output_blocks.5"])
		} else {
			this.sockets.inputs["output_blocks.5"].value = sources["output_blocks.5"]
		}

		if (typeof sources["output_blocks.6"] === "object") {
			this.sockets.inputs["output_blocks.6"].connectTo(sources["output_blocks.6"])
		} else {
			this.sockets.inputs["output_blocks.6"].value = sources["output_blocks.6"]
		}

		if (typeof sources["output_blocks.7"] === "object") {
			this.sockets.inputs["output_blocks.7"].connectTo(sources["output_blocks.7"])
		} else {
			this.sockets.inputs["output_blocks.7"].value = sources["output_blocks.7"]
		}

		if (typeof sources["output_blocks.8"] === "object") {
			this.sockets.inputs["output_blocks.8"].connectTo(sources["output_blocks.8"])
		} else {
			this.sockets.inputs["output_blocks.8"].value = sources["output_blocks.8"]
		}

		if (typeof sources["out."] === "object") {
			this.sockets.inputs["out."].connectTo(sources["out."])
		} else {
			this.sockets.inputs["out."].value = sources["out."]
		}

	}
}

type ModelMergeSDXLInputs = {
			"model1": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model2": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"time_embed.": ComfyNodeTypedInputRef<number>
			"label_emb.": ComfyNodeTypedInputRef<number>
			"input_blocks.0": ComfyNodeTypedInputRef<number>
			"input_blocks.1": ComfyNodeTypedInputRef<number>
			"input_blocks.2": ComfyNodeTypedInputRef<number>
			"input_blocks.3": ComfyNodeTypedInputRef<number>
			"input_blocks.4": ComfyNodeTypedInputRef<number>
			"input_blocks.5": ComfyNodeTypedInputRef<number>
			"input_blocks.6": ComfyNodeTypedInputRef<number>
			"input_blocks.7": ComfyNodeTypedInputRef<number>
			"input_blocks.8": ComfyNodeTypedInputRef<number>
			"middle_block.0": ComfyNodeTypedInputRef<number>
			"middle_block.1": ComfyNodeTypedInputRef<number>
			"middle_block.2": ComfyNodeTypedInputRef<number>
			"output_blocks.0": ComfyNodeTypedInputRef<number>
			"output_blocks.1": ComfyNodeTypedInputRef<number>
			"output_blocks.2": ComfyNodeTypedInputRef<number>
			"output_blocks.3": ComfyNodeTypedInputRef<number>
			"output_blocks.4": ComfyNodeTypedInputRef<number>
			"output_blocks.5": ComfyNodeTypedInputRef<number>
			"output_blocks.6": ComfyNodeTypedInputRef<number>
			"output_blocks.7": ComfyNodeTypedInputRef<number>
			"output_blocks.8": ComfyNodeTypedInputRef<number>
			"out.": ComfyNodeTypedInputRef<number>
}


export class ModelMergeSD3_2B extends ComfyNode {
	classType: string = "ModelMergeSD3_2B"

	sockets: {
		inputs: Required<ModelMergeSD3_2BInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model1": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model1"),
				"model2": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model2"),
				"pos_embed.": new ComfyNodeTypedInputRef<number>(this, "pos_embed."),
				"x_embedder.": new ComfyNodeTypedInputRef<number>(this, "x_embedder."),
				"context_embedder.": new ComfyNodeTypedInputRef<number>(this, "context_embedder."),
				"y_embedder.": new ComfyNodeTypedInputRef<number>(this, "y_embedder."),
				"t_embedder.": new ComfyNodeTypedInputRef<number>(this, "t_embedder."),
				"joint_blocks.0.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.0."),
				"joint_blocks.1.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.1."),
				"joint_blocks.2.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.2."),
				"joint_blocks.3.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.3."),
				"joint_blocks.4.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.4."),
				"joint_blocks.5.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.5."),
				"joint_blocks.6.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.6."),
				"joint_blocks.7.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.7."),
				"joint_blocks.8.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.8."),
				"joint_blocks.9.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.9."),
				"joint_blocks.10.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.10."),
				"joint_blocks.11.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.11."),
				"joint_blocks.12.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.12."),
				"joint_blocks.13.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.13."),
				"joint_blocks.14.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.14."),
				"joint_blocks.15.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.15."),
				"joint_blocks.16.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.16."),
				"joint_blocks.17.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.17."),
				"joint_blocks.18.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.18."),
				"joint_blocks.19.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.19."),
				"joint_blocks.20.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.20."),
				"joint_blocks.21.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.21."),
				"joint_blocks.22.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.22."),
				"joint_blocks.23.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.23."),
				"final_layer.": new ComfyNodeTypedInputRef<number>(this, "final_layer."),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelMergeSD3_2BInputs>) {
		if (typeof sources["model1"] === "object") {
			this.sockets.inputs["model1"].connectTo(sources["model1"])
		} else {
			this.sockets.inputs["model1"].value = sources["model1"]
		}

		if (typeof sources["model2"] === "object") {
			this.sockets.inputs["model2"].connectTo(sources["model2"])
		} else {
			this.sockets.inputs["model2"].value = sources["model2"]
		}

		if (typeof sources["pos_embed."] === "object") {
			this.sockets.inputs["pos_embed."].connectTo(sources["pos_embed."])
		} else {
			this.sockets.inputs["pos_embed."].value = sources["pos_embed."]
		}

		if (typeof sources["x_embedder."] === "object") {
			this.sockets.inputs["x_embedder."].connectTo(sources["x_embedder."])
		} else {
			this.sockets.inputs["x_embedder."].value = sources["x_embedder."]
		}

		if (typeof sources["context_embedder."] === "object") {
			this.sockets.inputs["context_embedder."].connectTo(sources["context_embedder."])
		} else {
			this.sockets.inputs["context_embedder."].value = sources["context_embedder."]
		}

		if (typeof sources["y_embedder."] === "object") {
			this.sockets.inputs["y_embedder."].connectTo(sources["y_embedder."])
		} else {
			this.sockets.inputs["y_embedder."].value = sources["y_embedder."]
		}

		if (typeof sources["t_embedder."] === "object") {
			this.sockets.inputs["t_embedder."].connectTo(sources["t_embedder."])
		} else {
			this.sockets.inputs["t_embedder."].value = sources["t_embedder."]
		}

		if (typeof sources["joint_blocks.0."] === "object") {
			this.sockets.inputs["joint_blocks.0."].connectTo(sources["joint_blocks.0."])
		} else {
			this.sockets.inputs["joint_blocks.0."].value = sources["joint_blocks.0."]
		}

		if (typeof sources["joint_blocks.1."] === "object") {
			this.sockets.inputs["joint_blocks.1."].connectTo(sources["joint_blocks.1."])
		} else {
			this.sockets.inputs["joint_blocks.1."].value = sources["joint_blocks.1."]
		}

		if (typeof sources["joint_blocks.2."] === "object") {
			this.sockets.inputs["joint_blocks.2."].connectTo(sources["joint_blocks.2."])
		} else {
			this.sockets.inputs["joint_blocks.2."].value = sources["joint_blocks.2."]
		}

		if (typeof sources["joint_blocks.3."] === "object") {
			this.sockets.inputs["joint_blocks.3."].connectTo(sources["joint_blocks.3."])
		} else {
			this.sockets.inputs["joint_blocks.3."].value = sources["joint_blocks.3."]
		}

		if (typeof sources["joint_blocks.4."] === "object") {
			this.sockets.inputs["joint_blocks.4."].connectTo(sources["joint_blocks.4."])
		} else {
			this.sockets.inputs["joint_blocks.4."].value = sources["joint_blocks.4."]
		}

		if (typeof sources["joint_blocks.5."] === "object") {
			this.sockets.inputs["joint_blocks.5."].connectTo(sources["joint_blocks.5."])
		} else {
			this.sockets.inputs["joint_blocks.5."].value = sources["joint_blocks.5."]
		}

		if (typeof sources["joint_blocks.6."] === "object") {
			this.sockets.inputs["joint_blocks.6."].connectTo(sources["joint_blocks.6."])
		} else {
			this.sockets.inputs["joint_blocks.6."].value = sources["joint_blocks.6."]
		}

		if (typeof sources["joint_blocks.7."] === "object") {
			this.sockets.inputs["joint_blocks.7."].connectTo(sources["joint_blocks.7."])
		} else {
			this.sockets.inputs["joint_blocks.7."].value = sources["joint_blocks.7."]
		}

		if (typeof sources["joint_blocks.8."] === "object") {
			this.sockets.inputs["joint_blocks.8."].connectTo(sources["joint_blocks.8."])
		} else {
			this.sockets.inputs["joint_blocks.8."].value = sources["joint_blocks.8."]
		}

		if (typeof sources["joint_blocks.9."] === "object") {
			this.sockets.inputs["joint_blocks.9."].connectTo(sources["joint_blocks.9."])
		} else {
			this.sockets.inputs["joint_blocks.9."].value = sources["joint_blocks.9."]
		}

		if (typeof sources["joint_blocks.10."] === "object") {
			this.sockets.inputs["joint_blocks.10."].connectTo(sources["joint_blocks.10."])
		} else {
			this.sockets.inputs["joint_blocks.10."].value = sources["joint_blocks.10."]
		}

		if (typeof sources["joint_blocks.11."] === "object") {
			this.sockets.inputs["joint_blocks.11."].connectTo(sources["joint_blocks.11."])
		} else {
			this.sockets.inputs["joint_blocks.11."].value = sources["joint_blocks.11."]
		}

		if (typeof sources["joint_blocks.12."] === "object") {
			this.sockets.inputs["joint_blocks.12."].connectTo(sources["joint_blocks.12."])
		} else {
			this.sockets.inputs["joint_blocks.12."].value = sources["joint_blocks.12."]
		}

		if (typeof sources["joint_blocks.13."] === "object") {
			this.sockets.inputs["joint_blocks.13."].connectTo(sources["joint_blocks.13."])
		} else {
			this.sockets.inputs["joint_blocks.13."].value = sources["joint_blocks.13."]
		}

		if (typeof sources["joint_blocks.14."] === "object") {
			this.sockets.inputs["joint_blocks.14."].connectTo(sources["joint_blocks.14."])
		} else {
			this.sockets.inputs["joint_blocks.14."].value = sources["joint_blocks.14."]
		}

		if (typeof sources["joint_blocks.15."] === "object") {
			this.sockets.inputs["joint_blocks.15."].connectTo(sources["joint_blocks.15."])
		} else {
			this.sockets.inputs["joint_blocks.15."].value = sources["joint_blocks.15."]
		}

		if (typeof sources["joint_blocks.16."] === "object") {
			this.sockets.inputs["joint_blocks.16."].connectTo(sources["joint_blocks.16."])
		} else {
			this.sockets.inputs["joint_blocks.16."].value = sources["joint_blocks.16."]
		}

		if (typeof sources["joint_blocks.17."] === "object") {
			this.sockets.inputs["joint_blocks.17."].connectTo(sources["joint_blocks.17."])
		} else {
			this.sockets.inputs["joint_blocks.17."].value = sources["joint_blocks.17."]
		}

		if (typeof sources["joint_blocks.18."] === "object") {
			this.sockets.inputs["joint_blocks.18."].connectTo(sources["joint_blocks.18."])
		} else {
			this.sockets.inputs["joint_blocks.18."].value = sources["joint_blocks.18."]
		}

		if (typeof sources["joint_blocks.19."] === "object") {
			this.sockets.inputs["joint_blocks.19."].connectTo(sources["joint_blocks.19."])
		} else {
			this.sockets.inputs["joint_blocks.19."].value = sources["joint_blocks.19."]
		}

		if (typeof sources["joint_blocks.20."] === "object") {
			this.sockets.inputs["joint_blocks.20."].connectTo(sources["joint_blocks.20."])
		} else {
			this.sockets.inputs["joint_blocks.20."].value = sources["joint_blocks.20."]
		}

		if (typeof sources["joint_blocks.21."] === "object") {
			this.sockets.inputs["joint_blocks.21."].connectTo(sources["joint_blocks.21."])
		} else {
			this.sockets.inputs["joint_blocks.21."].value = sources["joint_blocks.21."]
		}

		if (typeof sources["joint_blocks.22."] === "object") {
			this.sockets.inputs["joint_blocks.22."].connectTo(sources["joint_blocks.22."])
		} else {
			this.sockets.inputs["joint_blocks.22."].value = sources["joint_blocks.22."]
		}

		if (typeof sources["joint_blocks.23."] === "object") {
			this.sockets.inputs["joint_blocks.23."].connectTo(sources["joint_blocks.23."])
		} else {
			this.sockets.inputs["joint_blocks.23."].value = sources["joint_blocks.23."]
		}

		if (typeof sources["final_layer."] === "object") {
			this.sockets.inputs["final_layer."].connectTo(sources["final_layer."])
		} else {
			this.sockets.inputs["final_layer."].value = sources["final_layer."]
		}

	}
}

type ModelMergeSD3_2BInputs = {
			"model1": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model2": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"pos_embed.": ComfyNodeTypedInputRef<number>
			"x_embedder.": ComfyNodeTypedInputRef<number>
			"context_embedder.": ComfyNodeTypedInputRef<number>
			"y_embedder.": ComfyNodeTypedInputRef<number>
			"t_embedder.": ComfyNodeTypedInputRef<number>
			"joint_blocks.0.": ComfyNodeTypedInputRef<number>
			"joint_blocks.1.": ComfyNodeTypedInputRef<number>
			"joint_blocks.2.": ComfyNodeTypedInputRef<number>
			"joint_blocks.3.": ComfyNodeTypedInputRef<number>
			"joint_blocks.4.": ComfyNodeTypedInputRef<number>
			"joint_blocks.5.": ComfyNodeTypedInputRef<number>
			"joint_blocks.6.": ComfyNodeTypedInputRef<number>
			"joint_blocks.7.": ComfyNodeTypedInputRef<number>
			"joint_blocks.8.": ComfyNodeTypedInputRef<number>
			"joint_blocks.9.": ComfyNodeTypedInputRef<number>
			"joint_blocks.10.": ComfyNodeTypedInputRef<number>
			"joint_blocks.11.": ComfyNodeTypedInputRef<number>
			"joint_blocks.12.": ComfyNodeTypedInputRef<number>
			"joint_blocks.13.": ComfyNodeTypedInputRef<number>
			"joint_blocks.14.": ComfyNodeTypedInputRef<number>
			"joint_blocks.15.": ComfyNodeTypedInputRef<number>
			"joint_blocks.16.": ComfyNodeTypedInputRef<number>
			"joint_blocks.17.": ComfyNodeTypedInputRef<number>
			"joint_blocks.18.": ComfyNodeTypedInputRef<number>
			"joint_blocks.19.": ComfyNodeTypedInputRef<number>
			"joint_blocks.20.": ComfyNodeTypedInputRef<number>
			"joint_blocks.21.": ComfyNodeTypedInputRef<number>
			"joint_blocks.22.": ComfyNodeTypedInputRef<number>
			"joint_blocks.23.": ComfyNodeTypedInputRef<number>
			"final_layer.": ComfyNodeTypedInputRef<number>
}


export class ModelMergeAuraflow extends ComfyNode {
	classType: string = "ModelMergeAuraflow"

	sockets: {
		inputs: Required<ModelMergeAuraflowInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model1": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model1"),
				"model2": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model2"),
				"init_x_linear.": new ComfyNodeTypedInputRef<number>(this, "init_x_linear."),
				"positional_encoding": new ComfyNodeTypedInputRef<number>(this, "positional_encoding"),
				"cond_seq_linear.": new ComfyNodeTypedInputRef<number>(this, "cond_seq_linear."),
				"register_tokens": new ComfyNodeTypedInputRef<number>(this, "register_tokens"),
				"t_embedder.": new ComfyNodeTypedInputRef<number>(this, "t_embedder."),
				"double_layers.0.": new ComfyNodeTypedInputRef<number>(this, "double_layers.0."),
				"double_layers.1.": new ComfyNodeTypedInputRef<number>(this, "double_layers.1."),
				"double_layers.2.": new ComfyNodeTypedInputRef<number>(this, "double_layers.2."),
				"double_layers.3.": new ComfyNodeTypedInputRef<number>(this, "double_layers.3."),
				"single_layers.0.": new ComfyNodeTypedInputRef<number>(this, "single_layers.0."),
				"single_layers.1.": new ComfyNodeTypedInputRef<number>(this, "single_layers.1."),
				"single_layers.2.": new ComfyNodeTypedInputRef<number>(this, "single_layers.2."),
				"single_layers.3.": new ComfyNodeTypedInputRef<number>(this, "single_layers.3."),
				"single_layers.4.": new ComfyNodeTypedInputRef<number>(this, "single_layers.4."),
				"single_layers.5.": new ComfyNodeTypedInputRef<number>(this, "single_layers.5."),
				"single_layers.6.": new ComfyNodeTypedInputRef<number>(this, "single_layers.6."),
				"single_layers.7.": new ComfyNodeTypedInputRef<number>(this, "single_layers.7."),
				"single_layers.8.": new ComfyNodeTypedInputRef<number>(this, "single_layers.8."),
				"single_layers.9.": new ComfyNodeTypedInputRef<number>(this, "single_layers.9."),
				"single_layers.10.": new ComfyNodeTypedInputRef<number>(this, "single_layers.10."),
				"single_layers.11.": new ComfyNodeTypedInputRef<number>(this, "single_layers.11."),
				"single_layers.12.": new ComfyNodeTypedInputRef<number>(this, "single_layers.12."),
				"single_layers.13.": new ComfyNodeTypedInputRef<number>(this, "single_layers.13."),
				"single_layers.14.": new ComfyNodeTypedInputRef<number>(this, "single_layers.14."),
				"single_layers.15.": new ComfyNodeTypedInputRef<number>(this, "single_layers.15."),
				"single_layers.16.": new ComfyNodeTypedInputRef<number>(this, "single_layers.16."),
				"single_layers.17.": new ComfyNodeTypedInputRef<number>(this, "single_layers.17."),
				"single_layers.18.": new ComfyNodeTypedInputRef<number>(this, "single_layers.18."),
				"single_layers.19.": new ComfyNodeTypedInputRef<number>(this, "single_layers.19."),
				"single_layers.20.": new ComfyNodeTypedInputRef<number>(this, "single_layers.20."),
				"single_layers.21.": new ComfyNodeTypedInputRef<number>(this, "single_layers.21."),
				"single_layers.22.": new ComfyNodeTypedInputRef<number>(this, "single_layers.22."),
				"single_layers.23.": new ComfyNodeTypedInputRef<number>(this, "single_layers.23."),
				"single_layers.24.": new ComfyNodeTypedInputRef<number>(this, "single_layers.24."),
				"single_layers.25.": new ComfyNodeTypedInputRef<number>(this, "single_layers.25."),
				"single_layers.26.": new ComfyNodeTypedInputRef<number>(this, "single_layers.26."),
				"single_layers.27.": new ComfyNodeTypedInputRef<number>(this, "single_layers.27."),
				"single_layers.28.": new ComfyNodeTypedInputRef<number>(this, "single_layers.28."),
				"single_layers.29.": new ComfyNodeTypedInputRef<number>(this, "single_layers.29."),
				"single_layers.30.": new ComfyNodeTypedInputRef<number>(this, "single_layers.30."),
				"single_layers.31.": new ComfyNodeTypedInputRef<number>(this, "single_layers.31."),
				"modF.": new ComfyNodeTypedInputRef<number>(this, "modF."),
				"final_linear.": new ComfyNodeTypedInputRef<number>(this, "final_linear."),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelMergeAuraflowInputs>) {
		if (typeof sources["model1"] === "object") {
			this.sockets.inputs["model1"].connectTo(sources["model1"])
		} else {
			this.sockets.inputs["model1"].value = sources["model1"]
		}

		if (typeof sources["model2"] === "object") {
			this.sockets.inputs["model2"].connectTo(sources["model2"])
		} else {
			this.sockets.inputs["model2"].value = sources["model2"]
		}

		if (typeof sources["init_x_linear."] === "object") {
			this.sockets.inputs["init_x_linear."].connectTo(sources["init_x_linear."])
		} else {
			this.sockets.inputs["init_x_linear."].value = sources["init_x_linear."]
		}

		if (typeof sources["positional_encoding"] === "object") {
			this.sockets.inputs["positional_encoding"].connectTo(sources["positional_encoding"])
		} else {
			this.sockets.inputs["positional_encoding"].value = sources["positional_encoding"]
		}

		if (typeof sources["cond_seq_linear."] === "object") {
			this.sockets.inputs["cond_seq_linear."].connectTo(sources["cond_seq_linear."])
		} else {
			this.sockets.inputs["cond_seq_linear."].value = sources["cond_seq_linear."]
		}

		if (typeof sources["register_tokens"] === "object") {
			this.sockets.inputs["register_tokens"].connectTo(sources["register_tokens"])
		} else {
			this.sockets.inputs["register_tokens"].value = sources["register_tokens"]
		}

		if (typeof sources["t_embedder."] === "object") {
			this.sockets.inputs["t_embedder."].connectTo(sources["t_embedder."])
		} else {
			this.sockets.inputs["t_embedder."].value = sources["t_embedder."]
		}

		if (typeof sources["double_layers.0."] === "object") {
			this.sockets.inputs["double_layers.0."].connectTo(sources["double_layers.0."])
		} else {
			this.sockets.inputs["double_layers.0."].value = sources["double_layers.0."]
		}

		if (typeof sources["double_layers.1."] === "object") {
			this.sockets.inputs["double_layers.1."].connectTo(sources["double_layers.1."])
		} else {
			this.sockets.inputs["double_layers.1."].value = sources["double_layers.1."]
		}

		if (typeof sources["double_layers.2."] === "object") {
			this.sockets.inputs["double_layers.2."].connectTo(sources["double_layers.2."])
		} else {
			this.sockets.inputs["double_layers.2."].value = sources["double_layers.2."]
		}

		if (typeof sources["double_layers.3."] === "object") {
			this.sockets.inputs["double_layers.3."].connectTo(sources["double_layers.3."])
		} else {
			this.sockets.inputs["double_layers.3."].value = sources["double_layers.3."]
		}

		if (typeof sources["single_layers.0."] === "object") {
			this.sockets.inputs["single_layers.0."].connectTo(sources["single_layers.0."])
		} else {
			this.sockets.inputs["single_layers.0."].value = sources["single_layers.0."]
		}

		if (typeof sources["single_layers.1."] === "object") {
			this.sockets.inputs["single_layers.1."].connectTo(sources["single_layers.1."])
		} else {
			this.sockets.inputs["single_layers.1."].value = sources["single_layers.1."]
		}

		if (typeof sources["single_layers.2."] === "object") {
			this.sockets.inputs["single_layers.2."].connectTo(sources["single_layers.2."])
		} else {
			this.sockets.inputs["single_layers.2."].value = sources["single_layers.2."]
		}

		if (typeof sources["single_layers.3."] === "object") {
			this.sockets.inputs["single_layers.3."].connectTo(sources["single_layers.3."])
		} else {
			this.sockets.inputs["single_layers.3."].value = sources["single_layers.3."]
		}

		if (typeof sources["single_layers.4."] === "object") {
			this.sockets.inputs["single_layers.4."].connectTo(sources["single_layers.4."])
		} else {
			this.sockets.inputs["single_layers.4."].value = sources["single_layers.4."]
		}

		if (typeof sources["single_layers.5."] === "object") {
			this.sockets.inputs["single_layers.5."].connectTo(sources["single_layers.5."])
		} else {
			this.sockets.inputs["single_layers.5."].value = sources["single_layers.5."]
		}

		if (typeof sources["single_layers.6."] === "object") {
			this.sockets.inputs["single_layers.6."].connectTo(sources["single_layers.6."])
		} else {
			this.sockets.inputs["single_layers.6."].value = sources["single_layers.6."]
		}

		if (typeof sources["single_layers.7."] === "object") {
			this.sockets.inputs["single_layers.7."].connectTo(sources["single_layers.7."])
		} else {
			this.sockets.inputs["single_layers.7."].value = sources["single_layers.7."]
		}

		if (typeof sources["single_layers.8."] === "object") {
			this.sockets.inputs["single_layers.8."].connectTo(sources["single_layers.8."])
		} else {
			this.sockets.inputs["single_layers.8."].value = sources["single_layers.8."]
		}

		if (typeof sources["single_layers.9."] === "object") {
			this.sockets.inputs["single_layers.9."].connectTo(sources["single_layers.9."])
		} else {
			this.sockets.inputs["single_layers.9."].value = sources["single_layers.9."]
		}

		if (typeof sources["single_layers.10."] === "object") {
			this.sockets.inputs["single_layers.10."].connectTo(sources["single_layers.10."])
		} else {
			this.sockets.inputs["single_layers.10."].value = sources["single_layers.10."]
		}

		if (typeof sources["single_layers.11."] === "object") {
			this.sockets.inputs["single_layers.11."].connectTo(sources["single_layers.11."])
		} else {
			this.sockets.inputs["single_layers.11."].value = sources["single_layers.11."]
		}

		if (typeof sources["single_layers.12."] === "object") {
			this.sockets.inputs["single_layers.12."].connectTo(sources["single_layers.12."])
		} else {
			this.sockets.inputs["single_layers.12."].value = sources["single_layers.12."]
		}

		if (typeof sources["single_layers.13."] === "object") {
			this.sockets.inputs["single_layers.13."].connectTo(sources["single_layers.13."])
		} else {
			this.sockets.inputs["single_layers.13."].value = sources["single_layers.13."]
		}

		if (typeof sources["single_layers.14."] === "object") {
			this.sockets.inputs["single_layers.14."].connectTo(sources["single_layers.14."])
		} else {
			this.sockets.inputs["single_layers.14."].value = sources["single_layers.14."]
		}

		if (typeof sources["single_layers.15."] === "object") {
			this.sockets.inputs["single_layers.15."].connectTo(sources["single_layers.15."])
		} else {
			this.sockets.inputs["single_layers.15."].value = sources["single_layers.15."]
		}

		if (typeof sources["single_layers.16."] === "object") {
			this.sockets.inputs["single_layers.16."].connectTo(sources["single_layers.16."])
		} else {
			this.sockets.inputs["single_layers.16."].value = sources["single_layers.16."]
		}

		if (typeof sources["single_layers.17."] === "object") {
			this.sockets.inputs["single_layers.17."].connectTo(sources["single_layers.17."])
		} else {
			this.sockets.inputs["single_layers.17."].value = sources["single_layers.17."]
		}

		if (typeof sources["single_layers.18."] === "object") {
			this.sockets.inputs["single_layers.18."].connectTo(sources["single_layers.18."])
		} else {
			this.sockets.inputs["single_layers.18."].value = sources["single_layers.18."]
		}

		if (typeof sources["single_layers.19."] === "object") {
			this.sockets.inputs["single_layers.19."].connectTo(sources["single_layers.19."])
		} else {
			this.sockets.inputs["single_layers.19."].value = sources["single_layers.19."]
		}

		if (typeof sources["single_layers.20."] === "object") {
			this.sockets.inputs["single_layers.20."].connectTo(sources["single_layers.20."])
		} else {
			this.sockets.inputs["single_layers.20."].value = sources["single_layers.20."]
		}

		if (typeof sources["single_layers.21."] === "object") {
			this.sockets.inputs["single_layers.21."].connectTo(sources["single_layers.21."])
		} else {
			this.sockets.inputs["single_layers.21."].value = sources["single_layers.21."]
		}

		if (typeof sources["single_layers.22."] === "object") {
			this.sockets.inputs["single_layers.22."].connectTo(sources["single_layers.22."])
		} else {
			this.sockets.inputs["single_layers.22."].value = sources["single_layers.22."]
		}

		if (typeof sources["single_layers.23."] === "object") {
			this.sockets.inputs["single_layers.23."].connectTo(sources["single_layers.23."])
		} else {
			this.sockets.inputs["single_layers.23."].value = sources["single_layers.23."]
		}

		if (typeof sources["single_layers.24."] === "object") {
			this.sockets.inputs["single_layers.24."].connectTo(sources["single_layers.24."])
		} else {
			this.sockets.inputs["single_layers.24."].value = sources["single_layers.24."]
		}

		if (typeof sources["single_layers.25."] === "object") {
			this.sockets.inputs["single_layers.25."].connectTo(sources["single_layers.25."])
		} else {
			this.sockets.inputs["single_layers.25."].value = sources["single_layers.25."]
		}

		if (typeof sources["single_layers.26."] === "object") {
			this.sockets.inputs["single_layers.26."].connectTo(sources["single_layers.26."])
		} else {
			this.sockets.inputs["single_layers.26."].value = sources["single_layers.26."]
		}

		if (typeof sources["single_layers.27."] === "object") {
			this.sockets.inputs["single_layers.27."].connectTo(sources["single_layers.27."])
		} else {
			this.sockets.inputs["single_layers.27."].value = sources["single_layers.27."]
		}

		if (typeof sources["single_layers.28."] === "object") {
			this.sockets.inputs["single_layers.28."].connectTo(sources["single_layers.28."])
		} else {
			this.sockets.inputs["single_layers.28."].value = sources["single_layers.28."]
		}

		if (typeof sources["single_layers.29."] === "object") {
			this.sockets.inputs["single_layers.29."].connectTo(sources["single_layers.29."])
		} else {
			this.sockets.inputs["single_layers.29."].value = sources["single_layers.29."]
		}

		if (typeof sources["single_layers.30."] === "object") {
			this.sockets.inputs["single_layers.30."].connectTo(sources["single_layers.30."])
		} else {
			this.sockets.inputs["single_layers.30."].value = sources["single_layers.30."]
		}

		if (typeof sources["single_layers.31."] === "object") {
			this.sockets.inputs["single_layers.31."].connectTo(sources["single_layers.31."])
		} else {
			this.sockets.inputs["single_layers.31."].value = sources["single_layers.31."]
		}

		if (typeof sources["modF."] === "object") {
			this.sockets.inputs["modF."].connectTo(sources["modF."])
		} else {
			this.sockets.inputs["modF."].value = sources["modF."]
		}

		if (typeof sources["final_linear."] === "object") {
			this.sockets.inputs["final_linear."].connectTo(sources["final_linear."])
		} else {
			this.sockets.inputs["final_linear."].value = sources["final_linear."]
		}

	}
}

type ModelMergeAuraflowInputs = {
			"model1": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model2": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"init_x_linear.": ComfyNodeTypedInputRef<number>
			"positional_encoding": ComfyNodeTypedInputRef<number>
			"cond_seq_linear.": ComfyNodeTypedInputRef<number>
			"register_tokens": ComfyNodeTypedInputRef<number>
			"t_embedder.": ComfyNodeTypedInputRef<number>
			"double_layers.0.": ComfyNodeTypedInputRef<number>
			"double_layers.1.": ComfyNodeTypedInputRef<number>
			"double_layers.2.": ComfyNodeTypedInputRef<number>
			"double_layers.3.": ComfyNodeTypedInputRef<number>
			"single_layers.0.": ComfyNodeTypedInputRef<number>
			"single_layers.1.": ComfyNodeTypedInputRef<number>
			"single_layers.2.": ComfyNodeTypedInputRef<number>
			"single_layers.3.": ComfyNodeTypedInputRef<number>
			"single_layers.4.": ComfyNodeTypedInputRef<number>
			"single_layers.5.": ComfyNodeTypedInputRef<number>
			"single_layers.6.": ComfyNodeTypedInputRef<number>
			"single_layers.7.": ComfyNodeTypedInputRef<number>
			"single_layers.8.": ComfyNodeTypedInputRef<number>
			"single_layers.9.": ComfyNodeTypedInputRef<number>
			"single_layers.10.": ComfyNodeTypedInputRef<number>
			"single_layers.11.": ComfyNodeTypedInputRef<number>
			"single_layers.12.": ComfyNodeTypedInputRef<number>
			"single_layers.13.": ComfyNodeTypedInputRef<number>
			"single_layers.14.": ComfyNodeTypedInputRef<number>
			"single_layers.15.": ComfyNodeTypedInputRef<number>
			"single_layers.16.": ComfyNodeTypedInputRef<number>
			"single_layers.17.": ComfyNodeTypedInputRef<number>
			"single_layers.18.": ComfyNodeTypedInputRef<number>
			"single_layers.19.": ComfyNodeTypedInputRef<number>
			"single_layers.20.": ComfyNodeTypedInputRef<number>
			"single_layers.21.": ComfyNodeTypedInputRef<number>
			"single_layers.22.": ComfyNodeTypedInputRef<number>
			"single_layers.23.": ComfyNodeTypedInputRef<number>
			"single_layers.24.": ComfyNodeTypedInputRef<number>
			"single_layers.25.": ComfyNodeTypedInputRef<number>
			"single_layers.26.": ComfyNodeTypedInputRef<number>
			"single_layers.27.": ComfyNodeTypedInputRef<number>
			"single_layers.28.": ComfyNodeTypedInputRef<number>
			"single_layers.29.": ComfyNodeTypedInputRef<number>
			"single_layers.30.": ComfyNodeTypedInputRef<number>
			"single_layers.31.": ComfyNodeTypedInputRef<number>
			"modF.": ComfyNodeTypedInputRef<number>
			"final_linear.": ComfyNodeTypedInputRef<number>
}


export class ModelMergeFlux1 extends ComfyNode {
	classType: string = "ModelMergeFlux1"

	sockets: {
		inputs: Required<ModelMergeFlux1Inputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model1": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model1"),
				"model2": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model2"),
				"img_in.": new ComfyNodeTypedInputRef<number>(this, "img_in."),
				"time_in.": new ComfyNodeTypedInputRef<number>(this, "time_in."),
				"guidance_in": new ComfyNodeTypedInputRef<number>(this, "guidance_in"),
				"vector_in.": new ComfyNodeTypedInputRef<number>(this, "vector_in."),
				"txt_in.": new ComfyNodeTypedInputRef<number>(this, "txt_in."),
				"double_blocks.0.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.0."),
				"double_blocks.1.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.1."),
				"double_blocks.2.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.2."),
				"double_blocks.3.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.3."),
				"double_blocks.4.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.4."),
				"double_blocks.5.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.5."),
				"double_blocks.6.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.6."),
				"double_blocks.7.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.7."),
				"double_blocks.8.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.8."),
				"double_blocks.9.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.9."),
				"double_blocks.10.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.10."),
				"double_blocks.11.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.11."),
				"double_blocks.12.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.12."),
				"double_blocks.13.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.13."),
				"double_blocks.14.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.14."),
				"double_blocks.15.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.15."),
				"double_blocks.16.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.16."),
				"double_blocks.17.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.17."),
				"double_blocks.18.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.18."),
				"single_blocks.0.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.0."),
				"single_blocks.1.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.1."),
				"single_blocks.2.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.2."),
				"single_blocks.3.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.3."),
				"single_blocks.4.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.4."),
				"single_blocks.5.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.5."),
				"single_blocks.6.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.6."),
				"single_blocks.7.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.7."),
				"single_blocks.8.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.8."),
				"single_blocks.9.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.9."),
				"single_blocks.10.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.10."),
				"single_blocks.11.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.11."),
				"single_blocks.12.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.12."),
				"single_blocks.13.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.13."),
				"single_blocks.14.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.14."),
				"single_blocks.15.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.15."),
				"single_blocks.16.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.16."),
				"single_blocks.17.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.17."),
				"single_blocks.18.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.18."),
				"single_blocks.19.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.19."),
				"single_blocks.20.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.20."),
				"single_blocks.21.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.21."),
				"single_blocks.22.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.22."),
				"single_blocks.23.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.23."),
				"single_blocks.24.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.24."),
				"single_blocks.25.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.25."),
				"single_blocks.26.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.26."),
				"single_blocks.27.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.27."),
				"single_blocks.28.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.28."),
				"single_blocks.29.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.29."),
				"single_blocks.30.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.30."),
				"single_blocks.31.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.31."),
				"single_blocks.32.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.32."),
				"single_blocks.33.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.33."),
				"single_blocks.34.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.34."),
				"single_blocks.35.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.35."),
				"single_blocks.36.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.36."),
				"single_blocks.37.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.37."),
				"final_layer.": new ComfyNodeTypedInputRef<number>(this, "final_layer."),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelMergeFlux1Inputs>) {
		if (typeof sources["model1"] === "object") {
			this.sockets.inputs["model1"].connectTo(sources["model1"])
		} else {
			this.sockets.inputs["model1"].value = sources["model1"]
		}

		if (typeof sources["model2"] === "object") {
			this.sockets.inputs["model2"].connectTo(sources["model2"])
		} else {
			this.sockets.inputs["model2"].value = sources["model2"]
		}

		if (typeof sources["img_in."] === "object") {
			this.sockets.inputs["img_in."].connectTo(sources["img_in."])
		} else {
			this.sockets.inputs["img_in."].value = sources["img_in."]
		}

		if (typeof sources["time_in."] === "object") {
			this.sockets.inputs["time_in."].connectTo(sources["time_in."])
		} else {
			this.sockets.inputs["time_in."].value = sources["time_in."]
		}

		if (typeof sources["guidance_in"] === "object") {
			this.sockets.inputs["guidance_in"].connectTo(sources["guidance_in"])
		} else {
			this.sockets.inputs["guidance_in"].value = sources["guidance_in"]
		}

		if (typeof sources["vector_in."] === "object") {
			this.sockets.inputs["vector_in."].connectTo(sources["vector_in."])
		} else {
			this.sockets.inputs["vector_in."].value = sources["vector_in."]
		}

		if (typeof sources["txt_in."] === "object") {
			this.sockets.inputs["txt_in."].connectTo(sources["txt_in."])
		} else {
			this.sockets.inputs["txt_in."].value = sources["txt_in."]
		}

		if (typeof sources["double_blocks.0."] === "object") {
			this.sockets.inputs["double_blocks.0."].connectTo(sources["double_blocks.0."])
		} else {
			this.sockets.inputs["double_blocks.0."].value = sources["double_blocks.0."]
		}

		if (typeof sources["double_blocks.1."] === "object") {
			this.sockets.inputs["double_blocks.1."].connectTo(sources["double_blocks.1."])
		} else {
			this.sockets.inputs["double_blocks.1."].value = sources["double_blocks.1."]
		}

		if (typeof sources["double_blocks.2."] === "object") {
			this.sockets.inputs["double_blocks.2."].connectTo(sources["double_blocks.2."])
		} else {
			this.sockets.inputs["double_blocks.2."].value = sources["double_blocks.2."]
		}

		if (typeof sources["double_blocks.3."] === "object") {
			this.sockets.inputs["double_blocks.3."].connectTo(sources["double_blocks.3."])
		} else {
			this.sockets.inputs["double_blocks.3."].value = sources["double_blocks.3."]
		}

		if (typeof sources["double_blocks.4."] === "object") {
			this.sockets.inputs["double_blocks.4."].connectTo(sources["double_blocks.4."])
		} else {
			this.sockets.inputs["double_blocks.4."].value = sources["double_blocks.4."]
		}

		if (typeof sources["double_blocks.5."] === "object") {
			this.sockets.inputs["double_blocks.5."].connectTo(sources["double_blocks.5."])
		} else {
			this.sockets.inputs["double_blocks.5."].value = sources["double_blocks.5."]
		}

		if (typeof sources["double_blocks.6."] === "object") {
			this.sockets.inputs["double_blocks.6."].connectTo(sources["double_blocks.6."])
		} else {
			this.sockets.inputs["double_blocks.6."].value = sources["double_blocks.6."]
		}

		if (typeof sources["double_blocks.7."] === "object") {
			this.sockets.inputs["double_blocks.7."].connectTo(sources["double_blocks.7."])
		} else {
			this.sockets.inputs["double_blocks.7."].value = sources["double_blocks.7."]
		}

		if (typeof sources["double_blocks.8."] === "object") {
			this.sockets.inputs["double_blocks.8."].connectTo(sources["double_blocks.8."])
		} else {
			this.sockets.inputs["double_blocks.8."].value = sources["double_blocks.8."]
		}

		if (typeof sources["double_blocks.9."] === "object") {
			this.sockets.inputs["double_blocks.9."].connectTo(sources["double_blocks.9."])
		} else {
			this.sockets.inputs["double_blocks.9."].value = sources["double_blocks.9."]
		}

		if (typeof sources["double_blocks.10."] === "object") {
			this.sockets.inputs["double_blocks.10."].connectTo(sources["double_blocks.10."])
		} else {
			this.sockets.inputs["double_blocks.10."].value = sources["double_blocks.10."]
		}

		if (typeof sources["double_blocks.11."] === "object") {
			this.sockets.inputs["double_blocks.11."].connectTo(sources["double_blocks.11."])
		} else {
			this.sockets.inputs["double_blocks.11."].value = sources["double_blocks.11."]
		}

		if (typeof sources["double_blocks.12."] === "object") {
			this.sockets.inputs["double_blocks.12."].connectTo(sources["double_blocks.12."])
		} else {
			this.sockets.inputs["double_blocks.12."].value = sources["double_blocks.12."]
		}

		if (typeof sources["double_blocks.13."] === "object") {
			this.sockets.inputs["double_blocks.13."].connectTo(sources["double_blocks.13."])
		} else {
			this.sockets.inputs["double_blocks.13."].value = sources["double_blocks.13."]
		}

		if (typeof sources["double_blocks.14."] === "object") {
			this.sockets.inputs["double_blocks.14."].connectTo(sources["double_blocks.14."])
		} else {
			this.sockets.inputs["double_blocks.14."].value = sources["double_blocks.14."]
		}

		if (typeof sources["double_blocks.15."] === "object") {
			this.sockets.inputs["double_blocks.15."].connectTo(sources["double_blocks.15."])
		} else {
			this.sockets.inputs["double_blocks.15."].value = sources["double_blocks.15."]
		}

		if (typeof sources["double_blocks.16."] === "object") {
			this.sockets.inputs["double_blocks.16."].connectTo(sources["double_blocks.16."])
		} else {
			this.sockets.inputs["double_blocks.16."].value = sources["double_blocks.16."]
		}

		if (typeof sources["double_blocks.17."] === "object") {
			this.sockets.inputs["double_blocks.17."].connectTo(sources["double_blocks.17."])
		} else {
			this.sockets.inputs["double_blocks.17."].value = sources["double_blocks.17."]
		}

		if (typeof sources["double_blocks.18."] === "object") {
			this.sockets.inputs["double_blocks.18."].connectTo(sources["double_blocks.18."])
		} else {
			this.sockets.inputs["double_blocks.18."].value = sources["double_blocks.18."]
		}

		if (typeof sources["single_blocks.0."] === "object") {
			this.sockets.inputs["single_blocks.0."].connectTo(sources["single_blocks.0."])
		} else {
			this.sockets.inputs["single_blocks.0."].value = sources["single_blocks.0."]
		}

		if (typeof sources["single_blocks.1."] === "object") {
			this.sockets.inputs["single_blocks.1."].connectTo(sources["single_blocks.1."])
		} else {
			this.sockets.inputs["single_blocks.1."].value = sources["single_blocks.1."]
		}

		if (typeof sources["single_blocks.2."] === "object") {
			this.sockets.inputs["single_blocks.2."].connectTo(sources["single_blocks.2."])
		} else {
			this.sockets.inputs["single_blocks.2."].value = sources["single_blocks.2."]
		}

		if (typeof sources["single_blocks.3."] === "object") {
			this.sockets.inputs["single_blocks.3."].connectTo(sources["single_blocks.3."])
		} else {
			this.sockets.inputs["single_blocks.3."].value = sources["single_blocks.3."]
		}

		if (typeof sources["single_blocks.4."] === "object") {
			this.sockets.inputs["single_blocks.4."].connectTo(sources["single_blocks.4."])
		} else {
			this.sockets.inputs["single_blocks.4."].value = sources["single_blocks.4."]
		}

		if (typeof sources["single_blocks.5."] === "object") {
			this.sockets.inputs["single_blocks.5."].connectTo(sources["single_blocks.5."])
		} else {
			this.sockets.inputs["single_blocks.5."].value = sources["single_blocks.5."]
		}

		if (typeof sources["single_blocks.6."] === "object") {
			this.sockets.inputs["single_blocks.6."].connectTo(sources["single_blocks.6."])
		} else {
			this.sockets.inputs["single_blocks.6."].value = sources["single_blocks.6."]
		}

		if (typeof sources["single_blocks.7."] === "object") {
			this.sockets.inputs["single_blocks.7."].connectTo(sources["single_blocks.7."])
		} else {
			this.sockets.inputs["single_blocks.7."].value = sources["single_blocks.7."]
		}

		if (typeof sources["single_blocks.8."] === "object") {
			this.sockets.inputs["single_blocks.8."].connectTo(sources["single_blocks.8."])
		} else {
			this.sockets.inputs["single_blocks.8."].value = sources["single_blocks.8."]
		}

		if (typeof sources["single_blocks.9."] === "object") {
			this.sockets.inputs["single_blocks.9."].connectTo(sources["single_blocks.9."])
		} else {
			this.sockets.inputs["single_blocks.9."].value = sources["single_blocks.9."]
		}

		if (typeof sources["single_blocks.10."] === "object") {
			this.sockets.inputs["single_blocks.10."].connectTo(sources["single_blocks.10."])
		} else {
			this.sockets.inputs["single_blocks.10."].value = sources["single_blocks.10."]
		}

		if (typeof sources["single_blocks.11."] === "object") {
			this.sockets.inputs["single_blocks.11."].connectTo(sources["single_blocks.11."])
		} else {
			this.sockets.inputs["single_blocks.11."].value = sources["single_blocks.11."]
		}

		if (typeof sources["single_blocks.12."] === "object") {
			this.sockets.inputs["single_blocks.12."].connectTo(sources["single_blocks.12."])
		} else {
			this.sockets.inputs["single_blocks.12."].value = sources["single_blocks.12."]
		}

		if (typeof sources["single_blocks.13."] === "object") {
			this.sockets.inputs["single_blocks.13."].connectTo(sources["single_blocks.13."])
		} else {
			this.sockets.inputs["single_blocks.13."].value = sources["single_blocks.13."]
		}

		if (typeof sources["single_blocks.14."] === "object") {
			this.sockets.inputs["single_blocks.14."].connectTo(sources["single_blocks.14."])
		} else {
			this.sockets.inputs["single_blocks.14."].value = sources["single_blocks.14."]
		}

		if (typeof sources["single_blocks.15."] === "object") {
			this.sockets.inputs["single_blocks.15."].connectTo(sources["single_blocks.15."])
		} else {
			this.sockets.inputs["single_blocks.15."].value = sources["single_blocks.15."]
		}

		if (typeof sources["single_blocks.16."] === "object") {
			this.sockets.inputs["single_blocks.16."].connectTo(sources["single_blocks.16."])
		} else {
			this.sockets.inputs["single_blocks.16."].value = sources["single_blocks.16."]
		}

		if (typeof sources["single_blocks.17."] === "object") {
			this.sockets.inputs["single_blocks.17."].connectTo(sources["single_blocks.17."])
		} else {
			this.sockets.inputs["single_blocks.17."].value = sources["single_blocks.17."]
		}

		if (typeof sources["single_blocks.18."] === "object") {
			this.sockets.inputs["single_blocks.18."].connectTo(sources["single_blocks.18."])
		} else {
			this.sockets.inputs["single_blocks.18."].value = sources["single_blocks.18."]
		}

		if (typeof sources["single_blocks.19."] === "object") {
			this.sockets.inputs["single_blocks.19."].connectTo(sources["single_blocks.19."])
		} else {
			this.sockets.inputs["single_blocks.19."].value = sources["single_blocks.19."]
		}

		if (typeof sources["single_blocks.20."] === "object") {
			this.sockets.inputs["single_blocks.20."].connectTo(sources["single_blocks.20."])
		} else {
			this.sockets.inputs["single_blocks.20."].value = sources["single_blocks.20."]
		}

		if (typeof sources["single_blocks.21."] === "object") {
			this.sockets.inputs["single_blocks.21."].connectTo(sources["single_blocks.21."])
		} else {
			this.sockets.inputs["single_blocks.21."].value = sources["single_blocks.21."]
		}

		if (typeof sources["single_blocks.22."] === "object") {
			this.sockets.inputs["single_blocks.22."].connectTo(sources["single_blocks.22."])
		} else {
			this.sockets.inputs["single_blocks.22."].value = sources["single_blocks.22."]
		}

		if (typeof sources["single_blocks.23."] === "object") {
			this.sockets.inputs["single_blocks.23."].connectTo(sources["single_blocks.23."])
		} else {
			this.sockets.inputs["single_blocks.23."].value = sources["single_blocks.23."]
		}

		if (typeof sources["single_blocks.24."] === "object") {
			this.sockets.inputs["single_blocks.24."].connectTo(sources["single_blocks.24."])
		} else {
			this.sockets.inputs["single_blocks.24."].value = sources["single_blocks.24."]
		}

		if (typeof sources["single_blocks.25."] === "object") {
			this.sockets.inputs["single_blocks.25."].connectTo(sources["single_blocks.25."])
		} else {
			this.sockets.inputs["single_blocks.25."].value = sources["single_blocks.25."]
		}

		if (typeof sources["single_blocks.26."] === "object") {
			this.sockets.inputs["single_blocks.26."].connectTo(sources["single_blocks.26."])
		} else {
			this.sockets.inputs["single_blocks.26."].value = sources["single_blocks.26."]
		}

		if (typeof sources["single_blocks.27."] === "object") {
			this.sockets.inputs["single_blocks.27."].connectTo(sources["single_blocks.27."])
		} else {
			this.sockets.inputs["single_blocks.27."].value = sources["single_blocks.27."]
		}

		if (typeof sources["single_blocks.28."] === "object") {
			this.sockets.inputs["single_blocks.28."].connectTo(sources["single_blocks.28."])
		} else {
			this.sockets.inputs["single_blocks.28."].value = sources["single_blocks.28."]
		}

		if (typeof sources["single_blocks.29."] === "object") {
			this.sockets.inputs["single_blocks.29."].connectTo(sources["single_blocks.29."])
		} else {
			this.sockets.inputs["single_blocks.29."].value = sources["single_blocks.29."]
		}

		if (typeof sources["single_blocks.30."] === "object") {
			this.sockets.inputs["single_blocks.30."].connectTo(sources["single_blocks.30."])
		} else {
			this.sockets.inputs["single_blocks.30."].value = sources["single_blocks.30."]
		}

		if (typeof sources["single_blocks.31."] === "object") {
			this.sockets.inputs["single_blocks.31."].connectTo(sources["single_blocks.31."])
		} else {
			this.sockets.inputs["single_blocks.31."].value = sources["single_blocks.31."]
		}

		if (typeof sources["single_blocks.32."] === "object") {
			this.sockets.inputs["single_blocks.32."].connectTo(sources["single_blocks.32."])
		} else {
			this.sockets.inputs["single_blocks.32."].value = sources["single_blocks.32."]
		}

		if (typeof sources["single_blocks.33."] === "object") {
			this.sockets.inputs["single_blocks.33."].connectTo(sources["single_blocks.33."])
		} else {
			this.sockets.inputs["single_blocks.33."].value = sources["single_blocks.33."]
		}

		if (typeof sources["single_blocks.34."] === "object") {
			this.sockets.inputs["single_blocks.34."].connectTo(sources["single_blocks.34."])
		} else {
			this.sockets.inputs["single_blocks.34."].value = sources["single_blocks.34."]
		}

		if (typeof sources["single_blocks.35."] === "object") {
			this.sockets.inputs["single_blocks.35."].connectTo(sources["single_blocks.35."])
		} else {
			this.sockets.inputs["single_blocks.35."].value = sources["single_blocks.35."]
		}

		if (typeof sources["single_blocks.36."] === "object") {
			this.sockets.inputs["single_blocks.36."].connectTo(sources["single_blocks.36."])
		} else {
			this.sockets.inputs["single_blocks.36."].value = sources["single_blocks.36."]
		}

		if (typeof sources["single_blocks.37."] === "object") {
			this.sockets.inputs["single_blocks.37."].connectTo(sources["single_blocks.37."])
		} else {
			this.sockets.inputs["single_blocks.37."].value = sources["single_blocks.37."]
		}

		if (typeof sources["final_layer."] === "object") {
			this.sockets.inputs["final_layer."].connectTo(sources["final_layer."])
		} else {
			this.sockets.inputs["final_layer."].value = sources["final_layer."]
		}

	}
}

type ModelMergeFlux1Inputs = {
			"model1": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model2": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"img_in.": ComfyNodeTypedInputRef<number>
			"time_in.": ComfyNodeTypedInputRef<number>
			"guidance_in": ComfyNodeTypedInputRef<number>
			"vector_in.": ComfyNodeTypedInputRef<number>
			"txt_in.": ComfyNodeTypedInputRef<number>
			"double_blocks.0.": ComfyNodeTypedInputRef<number>
			"double_blocks.1.": ComfyNodeTypedInputRef<number>
			"double_blocks.2.": ComfyNodeTypedInputRef<number>
			"double_blocks.3.": ComfyNodeTypedInputRef<number>
			"double_blocks.4.": ComfyNodeTypedInputRef<number>
			"double_blocks.5.": ComfyNodeTypedInputRef<number>
			"double_blocks.6.": ComfyNodeTypedInputRef<number>
			"double_blocks.7.": ComfyNodeTypedInputRef<number>
			"double_blocks.8.": ComfyNodeTypedInputRef<number>
			"double_blocks.9.": ComfyNodeTypedInputRef<number>
			"double_blocks.10.": ComfyNodeTypedInputRef<number>
			"double_blocks.11.": ComfyNodeTypedInputRef<number>
			"double_blocks.12.": ComfyNodeTypedInputRef<number>
			"double_blocks.13.": ComfyNodeTypedInputRef<number>
			"double_blocks.14.": ComfyNodeTypedInputRef<number>
			"double_blocks.15.": ComfyNodeTypedInputRef<number>
			"double_blocks.16.": ComfyNodeTypedInputRef<number>
			"double_blocks.17.": ComfyNodeTypedInputRef<number>
			"double_blocks.18.": ComfyNodeTypedInputRef<number>
			"single_blocks.0.": ComfyNodeTypedInputRef<number>
			"single_blocks.1.": ComfyNodeTypedInputRef<number>
			"single_blocks.2.": ComfyNodeTypedInputRef<number>
			"single_blocks.3.": ComfyNodeTypedInputRef<number>
			"single_blocks.4.": ComfyNodeTypedInputRef<number>
			"single_blocks.5.": ComfyNodeTypedInputRef<number>
			"single_blocks.6.": ComfyNodeTypedInputRef<number>
			"single_blocks.7.": ComfyNodeTypedInputRef<number>
			"single_blocks.8.": ComfyNodeTypedInputRef<number>
			"single_blocks.9.": ComfyNodeTypedInputRef<number>
			"single_blocks.10.": ComfyNodeTypedInputRef<number>
			"single_blocks.11.": ComfyNodeTypedInputRef<number>
			"single_blocks.12.": ComfyNodeTypedInputRef<number>
			"single_blocks.13.": ComfyNodeTypedInputRef<number>
			"single_blocks.14.": ComfyNodeTypedInputRef<number>
			"single_blocks.15.": ComfyNodeTypedInputRef<number>
			"single_blocks.16.": ComfyNodeTypedInputRef<number>
			"single_blocks.17.": ComfyNodeTypedInputRef<number>
			"single_blocks.18.": ComfyNodeTypedInputRef<number>
			"single_blocks.19.": ComfyNodeTypedInputRef<number>
			"single_blocks.20.": ComfyNodeTypedInputRef<number>
			"single_blocks.21.": ComfyNodeTypedInputRef<number>
			"single_blocks.22.": ComfyNodeTypedInputRef<number>
			"single_blocks.23.": ComfyNodeTypedInputRef<number>
			"single_blocks.24.": ComfyNodeTypedInputRef<number>
			"single_blocks.25.": ComfyNodeTypedInputRef<number>
			"single_blocks.26.": ComfyNodeTypedInputRef<number>
			"single_blocks.27.": ComfyNodeTypedInputRef<number>
			"single_blocks.28.": ComfyNodeTypedInputRef<number>
			"single_blocks.29.": ComfyNodeTypedInputRef<number>
			"single_blocks.30.": ComfyNodeTypedInputRef<number>
			"single_blocks.31.": ComfyNodeTypedInputRef<number>
			"single_blocks.32.": ComfyNodeTypedInputRef<number>
			"single_blocks.33.": ComfyNodeTypedInputRef<number>
			"single_blocks.34.": ComfyNodeTypedInputRef<number>
			"single_blocks.35.": ComfyNodeTypedInputRef<number>
			"single_blocks.36.": ComfyNodeTypedInputRef<number>
			"single_blocks.37.": ComfyNodeTypedInputRef<number>
			"final_layer.": ComfyNodeTypedInputRef<number>
}


export class ModelMergeSD35_Large extends ComfyNode {
	classType: string = "ModelMergeSD35_Large"

	sockets: {
		inputs: Required<ModelMergeSD35_LargeInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model1": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model1"),
				"model2": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model2"),
				"pos_embed.": new ComfyNodeTypedInputRef<number>(this, "pos_embed."),
				"x_embedder.": new ComfyNodeTypedInputRef<number>(this, "x_embedder."),
				"context_embedder.": new ComfyNodeTypedInputRef<number>(this, "context_embedder."),
				"y_embedder.": new ComfyNodeTypedInputRef<number>(this, "y_embedder."),
				"t_embedder.": new ComfyNodeTypedInputRef<number>(this, "t_embedder."),
				"joint_blocks.0.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.0."),
				"joint_blocks.1.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.1."),
				"joint_blocks.2.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.2."),
				"joint_blocks.3.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.3."),
				"joint_blocks.4.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.4."),
				"joint_blocks.5.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.5."),
				"joint_blocks.6.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.6."),
				"joint_blocks.7.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.7."),
				"joint_blocks.8.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.8."),
				"joint_blocks.9.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.9."),
				"joint_blocks.10.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.10."),
				"joint_blocks.11.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.11."),
				"joint_blocks.12.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.12."),
				"joint_blocks.13.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.13."),
				"joint_blocks.14.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.14."),
				"joint_blocks.15.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.15."),
				"joint_blocks.16.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.16."),
				"joint_blocks.17.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.17."),
				"joint_blocks.18.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.18."),
				"joint_blocks.19.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.19."),
				"joint_blocks.20.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.20."),
				"joint_blocks.21.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.21."),
				"joint_blocks.22.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.22."),
				"joint_blocks.23.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.23."),
				"joint_blocks.24.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.24."),
				"joint_blocks.25.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.25."),
				"joint_blocks.26.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.26."),
				"joint_blocks.27.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.27."),
				"joint_blocks.28.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.28."),
				"joint_blocks.29.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.29."),
				"joint_blocks.30.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.30."),
				"joint_blocks.31.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.31."),
				"joint_blocks.32.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.32."),
				"joint_blocks.33.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.33."),
				"joint_blocks.34.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.34."),
				"joint_blocks.35.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.35."),
				"joint_blocks.36.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.36."),
				"joint_blocks.37.": new ComfyNodeTypedInputRef<number>(this, "joint_blocks.37."),
				"final_layer.": new ComfyNodeTypedInputRef<number>(this, "final_layer."),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelMergeSD35_LargeInputs>) {
		if (typeof sources["model1"] === "object") {
			this.sockets.inputs["model1"].connectTo(sources["model1"])
		} else {
			this.sockets.inputs["model1"].value = sources["model1"]
		}

		if (typeof sources["model2"] === "object") {
			this.sockets.inputs["model2"].connectTo(sources["model2"])
		} else {
			this.sockets.inputs["model2"].value = sources["model2"]
		}

		if (typeof sources["pos_embed."] === "object") {
			this.sockets.inputs["pos_embed."].connectTo(sources["pos_embed."])
		} else {
			this.sockets.inputs["pos_embed."].value = sources["pos_embed."]
		}

		if (typeof sources["x_embedder."] === "object") {
			this.sockets.inputs["x_embedder."].connectTo(sources["x_embedder."])
		} else {
			this.sockets.inputs["x_embedder."].value = sources["x_embedder."]
		}

		if (typeof sources["context_embedder."] === "object") {
			this.sockets.inputs["context_embedder."].connectTo(sources["context_embedder."])
		} else {
			this.sockets.inputs["context_embedder."].value = sources["context_embedder."]
		}

		if (typeof sources["y_embedder."] === "object") {
			this.sockets.inputs["y_embedder."].connectTo(sources["y_embedder."])
		} else {
			this.sockets.inputs["y_embedder."].value = sources["y_embedder."]
		}

		if (typeof sources["t_embedder."] === "object") {
			this.sockets.inputs["t_embedder."].connectTo(sources["t_embedder."])
		} else {
			this.sockets.inputs["t_embedder."].value = sources["t_embedder."]
		}

		if (typeof sources["joint_blocks.0."] === "object") {
			this.sockets.inputs["joint_blocks.0."].connectTo(sources["joint_blocks.0."])
		} else {
			this.sockets.inputs["joint_blocks.0."].value = sources["joint_blocks.0."]
		}

		if (typeof sources["joint_blocks.1."] === "object") {
			this.sockets.inputs["joint_blocks.1."].connectTo(sources["joint_blocks.1."])
		} else {
			this.sockets.inputs["joint_blocks.1."].value = sources["joint_blocks.1."]
		}

		if (typeof sources["joint_blocks.2."] === "object") {
			this.sockets.inputs["joint_blocks.2."].connectTo(sources["joint_blocks.2."])
		} else {
			this.sockets.inputs["joint_blocks.2."].value = sources["joint_blocks.2."]
		}

		if (typeof sources["joint_blocks.3."] === "object") {
			this.sockets.inputs["joint_blocks.3."].connectTo(sources["joint_blocks.3."])
		} else {
			this.sockets.inputs["joint_blocks.3."].value = sources["joint_blocks.3."]
		}

		if (typeof sources["joint_blocks.4."] === "object") {
			this.sockets.inputs["joint_blocks.4."].connectTo(sources["joint_blocks.4."])
		} else {
			this.sockets.inputs["joint_blocks.4."].value = sources["joint_blocks.4."]
		}

		if (typeof sources["joint_blocks.5."] === "object") {
			this.sockets.inputs["joint_blocks.5."].connectTo(sources["joint_blocks.5."])
		} else {
			this.sockets.inputs["joint_blocks.5."].value = sources["joint_blocks.5."]
		}

		if (typeof sources["joint_blocks.6."] === "object") {
			this.sockets.inputs["joint_blocks.6."].connectTo(sources["joint_blocks.6."])
		} else {
			this.sockets.inputs["joint_blocks.6."].value = sources["joint_blocks.6."]
		}

		if (typeof sources["joint_blocks.7."] === "object") {
			this.sockets.inputs["joint_blocks.7."].connectTo(sources["joint_blocks.7."])
		} else {
			this.sockets.inputs["joint_blocks.7."].value = sources["joint_blocks.7."]
		}

		if (typeof sources["joint_blocks.8."] === "object") {
			this.sockets.inputs["joint_blocks.8."].connectTo(sources["joint_blocks.8."])
		} else {
			this.sockets.inputs["joint_blocks.8."].value = sources["joint_blocks.8."]
		}

		if (typeof sources["joint_blocks.9."] === "object") {
			this.sockets.inputs["joint_blocks.9."].connectTo(sources["joint_blocks.9."])
		} else {
			this.sockets.inputs["joint_blocks.9."].value = sources["joint_blocks.9."]
		}

		if (typeof sources["joint_blocks.10."] === "object") {
			this.sockets.inputs["joint_blocks.10."].connectTo(sources["joint_blocks.10."])
		} else {
			this.sockets.inputs["joint_blocks.10."].value = sources["joint_blocks.10."]
		}

		if (typeof sources["joint_blocks.11."] === "object") {
			this.sockets.inputs["joint_blocks.11."].connectTo(sources["joint_blocks.11."])
		} else {
			this.sockets.inputs["joint_blocks.11."].value = sources["joint_blocks.11."]
		}

		if (typeof sources["joint_blocks.12."] === "object") {
			this.sockets.inputs["joint_blocks.12."].connectTo(sources["joint_blocks.12."])
		} else {
			this.sockets.inputs["joint_blocks.12."].value = sources["joint_blocks.12."]
		}

		if (typeof sources["joint_blocks.13."] === "object") {
			this.sockets.inputs["joint_blocks.13."].connectTo(sources["joint_blocks.13."])
		} else {
			this.sockets.inputs["joint_blocks.13."].value = sources["joint_blocks.13."]
		}

		if (typeof sources["joint_blocks.14."] === "object") {
			this.sockets.inputs["joint_blocks.14."].connectTo(sources["joint_blocks.14."])
		} else {
			this.sockets.inputs["joint_blocks.14."].value = sources["joint_blocks.14."]
		}

		if (typeof sources["joint_blocks.15."] === "object") {
			this.sockets.inputs["joint_blocks.15."].connectTo(sources["joint_blocks.15."])
		} else {
			this.sockets.inputs["joint_blocks.15."].value = sources["joint_blocks.15."]
		}

		if (typeof sources["joint_blocks.16."] === "object") {
			this.sockets.inputs["joint_blocks.16."].connectTo(sources["joint_blocks.16."])
		} else {
			this.sockets.inputs["joint_blocks.16."].value = sources["joint_blocks.16."]
		}

		if (typeof sources["joint_blocks.17."] === "object") {
			this.sockets.inputs["joint_blocks.17."].connectTo(sources["joint_blocks.17."])
		} else {
			this.sockets.inputs["joint_blocks.17."].value = sources["joint_blocks.17."]
		}

		if (typeof sources["joint_blocks.18."] === "object") {
			this.sockets.inputs["joint_blocks.18."].connectTo(sources["joint_blocks.18."])
		} else {
			this.sockets.inputs["joint_blocks.18."].value = sources["joint_blocks.18."]
		}

		if (typeof sources["joint_blocks.19."] === "object") {
			this.sockets.inputs["joint_blocks.19."].connectTo(sources["joint_blocks.19."])
		} else {
			this.sockets.inputs["joint_blocks.19."].value = sources["joint_blocks.19."]
		}

		if (typeof sources["joint_blocks.20."] === "object") {
			this.sockets.inputs["joint_blocks.20."].connectTo(sources["joint_blocks.20."])
		} else {
			this.sockets.inputs["joint_blocks.20."].value = sources["joint_blocks.20."]
		}

		if (typeof sources["joint_blocks.21."] === "object") {
			this.sockets.inputs["joint_blocks.21."].connectTo(sources["joint_blocks.21."])
		} else {
			this.sockets.inputs["joint_blocks.21."].value = sources["joint_blocks.21."]
		}

		if (typeof sources["joint_blocks.22."] === "object") {
			this.sockets.inputs["joint_blocks.22."].connectTo(sources["joint_blocks.22."])
		} else {
			this.sockets.inputs["joint_blocks.22."].value = sources["joint_blocks.22."]
		}

		if (typeof sources["joint_blocks.23."] === "object") {
			this.sockets.inputs["joint_blocks.23."].connectTo(sources["joint_blocks.23."])
		} else {
			this.sockets.inputs["joint_blocks.23."].value = sources["joint_blocks.23."]
		}

		if (typeof sources["joint_blocks.24."] === "object") {
			this.sockets.inputs["joint_blocks.24."].connectTo(sources["joint_blocks.24."])
		} else {
			this.sockets.inputs["joint_blocks.24."].value = sources["joint_blocks.24."]
		}

		if (typeof sources["joint_blocks.25."] === "object") {
			this.sockets.inputs["joint_blocks.25."].connectTo(sources["joint_blocks.25."])
		} else {
			this.sockets.inputs["joint_blocks.25."].value = sources["joint_blocks.25."]
		}

		if (typeof sources["joint_blocks.26."] === "object") {
			this.sockets.inputs["joint_blocks.26."].connectTo(sources["joint_blocks.26."])
		} else {
			this.sockets.inputs["joint_blocks.26."].value = sources["joint_blocks.26."]
		}

		if (typeof sources["joint_blocks.27."] === "object") {
			this.sockets.inputs["joint_blocks.27."].connectTo(sources["joint_blocks.27."])
		} else {
			this.sockets.inputs["joint_blocks.27."].value = sources["joint_blocks.27."]
		}

		if (typeof sources["joint_blocks.28."] === "object") {
			this.sockets.inputs["joint_blocks.28."].connectTo(sources["joint_blocks.28."])
		} else {
			this.sockets.inputs["joint_blocks.28."].value = sources["joint_blocks.28."]
		}

		if (typeof sources["joint_blocks.29."] === "object") {
			this.sockets.inputs["joint_blocks.29."].connectTo(sources["joint_blocks.29."])
		} else {
			this.sockets.inputs["joint_blocks.29."].value = sources["joint_blocks.29."]
		}

		if (typeof sources["joint_blocks.30."] === "object") {
			this.sockets.inputs["joint_blocks.30."].connectTo(sources["joint_blocks.30."])
		} else {
			this.sockets.inputs["joint_blocks.30."].value = sources["joint_blocks.30."]
		}

		if (typeof sources["joint_blocks.31."] === "object") {
			this.sockets.inputs["joint_blocks.31."].connectTo(sources["joint_blocks.31."])
		} else {
			this.sockets.inputs["joint_blocks.31."].value = sources["joint_blocks.31."]
		}

		if (typeof sources["joint_blocks.32."] === "object") {
			this.sockets.inputs["joint_blocks.32."].connectTo(sources["joint_blocks.32."])
		} else {
			this.sockets.inputs["joint_blocks.32."].value = sources["joint_blocks.32."]
		}

		if (typeof sources["joint_blocks.33."] === "object") {
			this.sockets.inputs["joint_blocks.33."].connectTo(sources["joint_blocks.33."])
		} else {
			this.sockets.inputs["joint_blocks.33."].value = sources["joint_blocks.33."]
		}

		if (typeof sources["joint_blocks.34."] === "object") {
			this.sockets.inputs["joint_blocks.34."].connectTo(sources["joint_blocks.34."])
		} else {
			this.sockets.inputs["joint_blocks.34."].value = sources["joint_blocks.34."]
		}

		if (typeof sources["joint_blocks.35."] === "object") {
			this.sockets.inputs["joint_blocks.35."].connectTo(sources["joint_blocks.35."])
		} else {
			this.sockets.inputs["joint_blocks.35."].value = sources["joint_blocks.35."]
		}

		if (typeof sources["joint_blocks.36."] === "object") {
			this.sockets.inputs["joint_blocks.36."].connectTo(sources["joint_blocks.36."])
		} else {
			this.sockets.inputs["joint_blocks.36."].value = sources["joint_blocks.36."]
		}

		if (typeof sources["joint_blocks.37."] === "object") {
			this.sockets.inputs["joint_blocks.37."].connectTo(sources["joint_blocks.37."])
		} else {
			this.sockets.inputs["joint_blocks.37."].value = sources["joint_blocks.37."]
		}

		if (typeof sources["final_layer."] === "object") {
			this.sockets.inputs["final_layer."].connectTo(sources["final_layer."])
		} else {
			this.sockets.inputs["final_layer."].value = sources["final_layer."]
		}

	}
}

type ModelMergeSD35_LargeInputs = {
			"model1": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model2": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"pos_embed.": ComfyNodeTypedInputRef<number>
			"x_embedder.": ComfyNodeTypedInputRef<number>
			"context_embedder.": ComfyNodeTypedInputRef<number>
			"y_embedder.": ComfyNodeTypedInputRef<number>
			"t_embedder.": ComfyNodeTypedInputRef<number>
			"joint_blocks.0.": ComfyNodeTypedInputRef<number>
			"joint_blocks.1.": ComfyNodeTypedInputRef<number>
			"joint_blocks.2.": ComfyNodeTypedInputRef<number>
			"joint_blocks.3.": ComfyNodeTypedInputRef<number>
			"joint_blocks.4.": ComfyNodeTypedInputRef<number>
			"joint_blocks.5.": ComfyNodeTypedInputRef<number>
			"joint_blocks.6.": ComfyNodeTypedInputRef<number>
			"joint_blocks.7.": ComfyNodeTypedInputRef<number>
			"joint_blocks.8.": ComfyNodeTypedInputRef<number>
			"joint_blocks.9.": ComfyNodeTypedInputRef<number>
			"joint_blocks.10.": ComfyNodeTypedInputRef<number>
			"joint_blocks.11.": ComfyNodeTypedInputRef<number>
			"joint_blocks.12.": ComfyNodeTypedInputRef<number>
			"joint_blocks.13.": ComfyNodeTypedInputRef<number>
			"joint_blocks.14.": ComfyNodeTypedInputRef<number>
			"joint_blocks.15.": ComfyNodeTypedInputRef<number>
			"joint_blocks.16.": ComfyNodeTypedInputRef<number>
			"joint_blocks.17.": ComfyNodeTypedInputRef<number>
			"joint_blocks.18.": ComfyNodeTypedInputRef<number>
			"joint_blocks.19.": ComfyNodeTypedInputRef<number>
			"joint_blocks.20.": ComfyNodeTypedInputRef<number>
			"joint_blocks.21.": ComfyNodeTypedInputRef<number>
			"joint_blocks.22.": ComfyNodeTypedInputRef<number>
			"joint_blocks.23.": ComfyNodeTypedInputRef<number>
			"joint_blocks.24.": ComfyNodeTypedInputRef<number>
			"joint_blocks.25.": ComfyNodeTypedInputRef<number>
			"joint_blocks.26.": ComfyNodeTypedInputRef<number>
			"joint_blocks.27.": ComfyNodeTypedInputRef<number>
			"joint_blocks.28.": ComfyNodeTypedInputRef<number>
			"joint_blocks.29.": ComfyNodeTypedInputRef<number>
			"joint_blocks.30.": ComfyNodeTypedInputRef<number>
			"joint_blocks.31.": ComfyNodeTypedInputRef<number>
			"joint_blocks.32.": ComfyNodeTypedInputRef<number>
			"joint_blocks.33.": ComfyNodeTypedInputRef<number>
			"joint_blocks.34.": ComfyNodeTypedInputRef<number>
			"joint_blocks.35.": ComfyNodeTypedInputRef<number>
			"joint_blocks.36.": ComfyNodeTypedInputRef<number>
			"joint_blocks.37.": ComfyNodeTypedInputRef<number>
			"final_layer.": ComfyNodeTypedInputRef<number>
}


export class ModelMergeMochiPreview extends ComfyNode {
	classType: string = "ModelMergeMochiPreview"

	sockets: {
		inputs: Required<ModelMergeMochiPreviewInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model1": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model1"),
				"model2": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model2"),
				"pos_frequencies.": new ComfyNodeTypedInputRef<number>(this, "pos_frequencies."),
				"t_embedder.": new ComfyNodeTypedInputRef<number>(this, "t_embedder."),
				"t5_y_embedder.": new ComfyNodeTypedInputRef<number>(this, "t5_y_embedder."),
				"t5_yproj.": new ComfyNodeTypedInputRef<number>(this, "t5_yproj."),
				"blocks.0.": new ComfyNodeTypedInputRef<number>(this, "blocks.0."),
				"blocks.1.": new ComfyNodeTypedInputRef<number>(this, "blocks.1."),
				"blocks.2.": new ComfyNodeTypedInputRef<number>(this, "blocks.2."),
				"blocks.3.": new ComfyNodeTypedInputRef<number>(this, "blocks.3."),
				"blocks.4.": new ComfyNodeTypedInputRef<number>(this, "blocks.4."),
				"blocks.5.": new ComfyNodeTypedInputRef<number>(this, "blocks.5."),
				"blocks.6.": new ComfyNodeTypedInputRef<number>(this, "blocks.6."),
				"blocks.7.": new ComfyNodeTypedInputRef<number>(this, "blocks.7."),
				"blocks.8.": new ComfyNodeTypedInputRef<number>(this, "blocks.8."),
				"blocks.9.": new ComfyNodeTypedInputRef<number>(this, "blocks.9."),
				"blocks.10.": new ComfyNodeTypedInputRef<number>(this, "blocks.10."),
				"blocks.11.": new ComfyNodeTypedInputRef<number>(this, "blocks.11."),
				"blocks.12.": new ComfyNodeTypedInputRef<number>(this, "blocks.12."),
				"blocks.13.": new ComfyNodeTypedInputRef<number>(this, "blocks.13."),
				"blocks.14.": new ComfyNodeTypedInputRef<number>(this, "blocks.14."),
				"blocks.15.": new ComfyNodeTypedInputRef<number>(this, "blocks.15."),
				"blocks.16.": new ComfyNodeTypedInputRef<number>(this, "blocks.16."),
				"blocks.17.": new ComfyNodeTypedInputRef<number>(this, "blocks.17."),
				"blocks.18.": new ComfyNodeTypedInputRef<number>(this, "blocks.18."),
				"blocks.19.": new ComfyNodeTypedInputRef<number>(this, "blocks.19."),
				"blocks.20.": new ComfyNodeTypedInputRef<number>(this, "blocks.20."),
				"blocks.21.": new ComfyNodeTypedInputRef<number>(this, "blocks.21."),
				"blocks.22.": new ComfyNodeTypedInputRef<number>(this, "blocks.22."),
				"blocks.23.": new ComfyNodeTypedInputRef<number>(this, "blocks.23."),
				"blocks.24.": new ComfyNodeTypedInputRef<number>(this, "blocks.24."),
				"blocks.25.": new ComfyNodeTypedInputRef<number>(this, "blocks.25."),
				"blocks.26.": new ComfyNodeTypedInputRef<number>(this, "blocks.26."),
				"blocks.27.": new ComfyNodeTypedInputRef<number>(this, "blocks.27."),
				"blocks.28.": new ComfyNodeTypedInputRef<number>(this, "blocks.28."),
				"blocks.29.": new ComfyNodeTypedInputRef<number>(this, "blocks.29."),
				"blocks.30.": new ComfyNodeTypedInputRef<number>(this, "blocks.30."),
				"blocks.31.": new ComfyNodeTypedInputRef<number>(this, "blocks.31."),
				"blocks.32.": new ComfyNodeTypedInputRef<number>(this, "blocks.32."),
				"blocks.33.": new ComfyNodeTypedInputRef<number>(this, "blocks.33."),
				"blocks.34.": new ComfyNodeTypedInputRef<number>(this, "blocks.34."),
				"blocks.35.": new ComfyNodeTypedInputRef<number>(this, "blocks.35."),
				"blocks.36.": new ComfyNodeTypedInputRef<number>(this, "blocks.36."),
				"blocks.37.": new ComfyNodeTypedInputRef<number>(this, "blocks.37."),
				"blocks.38.": new ComfyNodeTypedInputRef<number>(this, "blocks.38."),
				"blocks.39.": new ComfyNodeTypedInputRef<number>(this, "blocks.39."),
				"blocks.40.": new ComfyNodeTypedInputRef<number>(this, "blocks.40."),
				"blocks.41.": new ComfyNodeTypedInputRef<number>(this, "blocks.41."),
				"blocks.42.": new ComfyNodeTypedInputRef<number>(this, "blocks.42."),
				"blocks.43.": new ComfyNodeTypedInputRef<number>(this, "blocks.43."),
				"blocks.44.": new ComfyNodeTypedInputRef<number>(this, "blocks.44."),
				"blocks.45.": new ComfyNodeTypedInputRef<number>(this, "blocks.45."),
				"blocks.46.": new ComfyNodeTypedInputRef<number>(this, "blocks.46."),
				"blocks.47.": new ComfyNodeTypedInputRef<number>(this, "blocks.47."),
				"final_layer.": new ComfyNodeTypedInputRef<number>(this, "final_layer."),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelMergeMochiPreviewInputs>) {
		if (typeof sources["model1"] === "object") {
			this.sockets.inputs["model1"].connectTo(sources["model1"])
		} else {
			this.sockets.inputs["model1"].value = sources["model1"]
		}

		if (typeof sources["model2"] === "object") {
			this.sockets.inputs["model2"].connectTo(sources["model2"])
		} else {
			this.sockets.inputs["model2"].value = sources["model2"]
		}

		if (typeof sources["pos_frequencies."] === "object") {
			this.sockets.inputs["pos_frequencies."].connectTo(sources["pos_frequencies."])
		} else {
			this.sockets.inputs["pos_frequencies."].value = sources["pos_frequencies."]
		}

		if (typeof sources["t_embedder."] === "object") {
			this.sockets.inputs["t_embedder."].connectTo(sources["t_embedder."])
		} else {
			this.sockets.inputs["t_embedder."].value = sources["t_embedder."]
		}

		if (typeof sources["t5_y_embedder."] === "object") {
			this.sockets.inputs["t5_y_embedder."].connectTo(sources["t5_y_embedder."])
		} else {
			this.sockets.inputs["t5_y_embedder."].value = sources["t5_y_embedder."]
		}

		if (typeof sources["t5_yproj."] === "object") {
			this.sockets.inputs["t5_yproj."].connectTo(sources["t5_yproj."])
		} else {
			this.sockets.inputs["t5_yproj."].value = sources["t5_yproj."]
		}

		if (typeof sources["blocks.0."] === "object") {
			this.sockets.inputs["blocks.0."].connectTo(sources["blocks.0."])
		} else {
			this.sockets.inputs["blocks.0."].value = sources["blocks.0."]
		}

		if (typeof sources["blocks.1."] === "object") {
			this.sockets.inputs["blocks.1."].connectTo(sources["blocks.1."])
		} else {
			this.sockets.inputs["blocks.1."].value = sources["blocks.1."]
		}

		if (typeof sources["blocks.2."] === "object") {
			this.sockets.inputs["blocks.2."].connectTo(sources["blocks.2."])
		} else {
			this.sockets.inputs["blocks.2."].value = sources["blocks.2."]
		}

		if (typeof sources["blocks.3."] === "object") {
			this.sockets.inputs["blocks.3."].connectTo(sources["blocks.3."])
		} else {
			this.sockets.inputs["blocks.3."].value = sources["blocks.3."]
		}

		if (typeof sources["blocks.4."] === "object") {
			this.sockets.inputs["blocks.4."].connectTo(sources["blocks.4."])
		} else {
			this.sockets.inputs["blocks.4."].value = sources["blocks.4."]
		}

		if (typeof sources["blocks.5."] === "object") {
			this.sockets.inputs["blocks.5."].connectTo(sources["blocks.5."])
		} else {
			this.sockets.inputs["blocks.5."].value = sources["blocks.5."]
		}

		if (typeof sources["blocks.6."] === "object") {
			this.sockets.inputs["blocks.6."].connectTo(sources["blocks.6."])
		} else {
			this.sockets.inputs["blocks.6."].value = sources["blocks.6."]
		}

		if (typeof sources["blocks.7."] === "object") {
			this.sockets.inputs["blocks.7."].connectTo(sources["blocks.7."])
		} else {
			this.sockets.inputs["blocks.7."].value = sources["blocks.7."]
		}

		if (typeof sources["blocks.8."] === "object") {
			this.sockets.inputs["blocks.8."].connectTo(sources["blocks.8."])
		} else {
			this.sockets.inputs["blocks.8."].value = sources["blocks.8."]
		}

		if (typeof sources["blocks.9."] === "object") {
			this.sockets.inputs["blocks.9."].connectTo(sources["blocks.9."])
		} else {
			this.sockets.inputs["blocks.9."].value = sources["blocks.9."]
		}

		if (typeof sources["blocks.10."] === "object") {
			this.sockets.inputs["blocks.10."].connectTo(sources["blocks.10."])
		} else {
			this.sockets.inputs["blocks.10."].value = sources["blocks.10."]
		}

		if (typeof sources["blocks.11."] === "object") {
			this.sockets.inputs["blocks.11."].connectTo(sources["blocks.11."])
		} else {
			this.sockets.inputs["blocks.11."].value = sources["blocks.11."]
		}

		if (typeof sources["blocks.12."] === "object") {
			this.sockets.inputs["blocks.12."].connectTo(sources["blocks.12."])
		} else {
			this.sockets.inputs["blocks.12."].value = sources["blocks.12."]
		}

		if (typeof sources["blocks.13."] === "object") {
			this.sockets.inputs["blocks.13."].connectTo(sources["blocks.13."])
		} else {
			this.sockets.inputs["blocks.13."].value = sources["blocks.13."]
		}

		if (typeof sources["blocks.14."] === "object") {
			this.sockets.inputs["blocks.14."].connectTo(sources["blocks.14."])
		} else {
			this.sockets.inputs["blocks.14."].value = sources["blocks.14."]
		}

		if (typeof sources["blocks.15."] === "object") {
			this.sockets.inputs["blocks.15."].connectTo(sources["blocks.15."])
		} else {
			this.sockets.inputs["blocks.15."].value = sources["blocks.15."]
		}

		if (typeof sources["blocks.16."] === "object") {
			this.sockets.inputs["blocks.16."].connectTo(sources["blocks.16."])
		} else {
			this.sockets.inputs["blocks.16."].value = sources["blocks.16."]
		}

		if (typeof sources["blocks.17."] === "object") {
			this.sockets.inputs["blocks.17."].connectTo(sources["blocks.17."])
		} else {
			this.sockets.inputs["blocks.17."].value = sources["blocks.17."]
		}

		if (typeof sources["blocks.18."] === "object") {
			this.sockets.inputs["blocks.18."].connectTo(sources["blocks.18."])
		} else {
			this.sockets.inputs["blocks.18."].value = sources["blocks.18."]
		}

		if (typeof sources["blocks.19."] === "object") {
			this.sockets.inputs["blocks.19."].connectTo(sources["blocks.19."])
		} else {
			this.sockets.inputs["blocks.19."].value = sources["blocks.19."]
		}

		if (typeof sources["blocks.20."] === "object") {
			this.sockets.inputs["blocks.20."].connectTo(sources["blocks.20."])
		} else {
			this.sockets.inputs["blocks.20."].value = sources["blocks.20."]
		}

		if (typeof sources["blocks.21."] === "object") {
			this.sockets.inputs["blocks.21."].connectTo(sources["blocks.21."])
		} else {
			this.sockets.inputs["blocks.21."].value = sources["blocks.21."]
		}

		if (typeof sources["blocks.22."] === "object") {
			this.sockets.inputs["blocks.22."].connectTo(sources["blocks.22."])
		} else {
			this.sockets.inputs["blocks.22."].value = sources["blocks.22."]
		}

		if (typeof sources["blocks.23."] === "object") {
			this.sockets.inputs["blocks.23."].connectTo(sources["blocks.23."])
		} else {
			this.sockets.inputs["blocks.23."].value = sources["blocks.23."]
		}

		if (typeof sources["blocks.24."] === "object") {
			this.sockets.inputs["blocks.24."].connectTo(sources["blocks.24."])
		} else {
			this.sockets.inputs["blocks.24."].value = sources["blocks.24."]
		}

		if (typeof sources["blocks.25."] === "object") {
			this.sockets.inputs["blocks.25."].connectTo(sources["blocks.25."])
		} else {
			this.sockets.inputs["blocks.25."].value = sources["blocks.25."]
		}

		if (typeof sources["blocks.26."] === "object") {
			this.sockets.inputs["blocks.26."].connectTo(sources["blocks.26."])
		} else {
			this.sockets.inputs["blocks.26."].value = sources["blocks.26."]
		}

		if (typeof sources["blocks.27."] === "object") {
			this.sockets.inputs["blocks.27."].connectTo(sources["blocks.27."])
		} else {
			this.sockets.inputs["blocks.27."].value = sources["blocks.27."]
		}

		if (typeof sources["blocks.28."] === "object") {
			this.sockets.inputs["blocks.28."].connectTo(sources["blocks.28."])
		} else {
			this.sockets.inputs["blocks.28."].value = sources["blocks.28."]
		}

		if (typeof sources["blocks.29."] === "object") {
			this.sockets.inputs["blocks.29."].connectTo(sources["blocks.29."])
		} else {
			this.sockets.inputs["blocks.29."].value = sources["blocks.29."]
		}

		if (typeof sources["blocks.30."] === "object") {
			this.sockets.inputs["blocks.30."].connectTo(sources["blocks.30."])
		} else {
			this.sockets.inputs["blocks.30."].value = sources["blocks.30."]
		}

		if (typeof sources["blocks.31."] === "object") {
			this.sockets.inputs["blocks.31."].connectTo(sources["blocks.31."])
		} else {
			this.sockets.inputs["blocks.31."].value = sources["blocks.31."]
		}

		if (typeof sources["blocks.32."] === "object") {
			this.sockets.inputs["blocks.32."].connectTo(sources["blocks.32."])
		} else {
			this.sockets.inputs["blocks.32."].value = sources["blocks.32."]
		}

		if (typeof sources["blocks.33."] === "object") {
			this.sockets.inputs["blocks.33."].connectTo(sources["blocks.33."])
		} else {
			this.sockets.inputs["blocks.33."].value = sources["blocks.33."]
		}

		if (typeof sources["blocks.34."] === "object") {
			this.sockets.inputs["blocks.34."].connectTo(sources["blocks.34."])
		} else {
			this.sockets.inputs["blocks.34."].value = sources["blocks.34."]
		}

		if (typeof sources["blocks.35."] === "object") {
			this.sockets.inputs["blocks.35."].connectTo(sources["blocks.35."])
		} else {
			this.sockets.inputs["blocks.35."].value = sources["blocks.35."]
		}

		if (typeof sources["blocks.36."] === "object") {
			this.sockets.inputs["blocks.36."].connectTo(sources["blocks.36."])
		} else {
			this.sockets.inputs["blocks.36."].value = sources["blocks.36."]
		}

		if (typeof sources["blocks.37."] === "object") {
			this.sockets.inputs["blocks.37."].connectTo(sources["blocks.37."])
		} else {
			this.sockets.inputs["blocks.37."].value = sources["blocks.37."]
		}

		if (typeof sources["blocks.38."] === "object") {
			this.sockets.inputs["blocks.38."].connectTo(sources["blocks.38."])
		} else {
			this.sockets.inputs["blocks.38."].value = sources["blocks.38."]
		}

		if (typeof sources["blocks.39."] === "object") {
			this.sockets.inputs["blocks.39."].connectTo(sources["blocks.39."])
		} else {
			this.sockets.inputs["blocks.39."].value = sources["blocks.39."]
		}

		if (typeof sources["blocks.40."] === "object") {
			this.sockets.inputs["blocks.40."].connectTo(sources["blocks.40."])
		} else {
			this.sockets.inputs["blocks.40."].value = sources["blocks.40."]
		}

		if (typeof sources["blocks.41."] === "object") {
			this.sockets.inputs["blocks.41."].connectTo(sources["blocks.41."])
		} else {
			this.sockets.inputs["blocks.41."].value = sources["blocks.41."]
		}

		if (typeof sources["blocks.42."] === "object") {
			this.sockets.inputs["blocks.42."].connectTo(sources["blocks.42."])
		} else {
			this.sockets.inputs["blocks.42."].value = sources["blocks.42."]
		}

		if (typeof sources["blocks.43."] === "object") {
			this.sockets.inputs["blocks.43."].connectTo(sources["blocks.43."])
		} else {
			this.sockets.inputs["blocks.43."].value = sources["blocks.43."]
		}

		if (typeof sources["blocks.44."] === "object") {
			this.sockets.inputs["blocks.44."].connectTo(sources["blocks.44."])
		} else {
			this.sockets.inputs["blocks.44."].value = sources["blocks.44."]
		}

		if (typeof sources["blocks.45."] === "object") {
			this.sockets.inputs["blocks.45."].connectTo(sources["blocks.45."])
		} else {
			this.sockets.inputs["blocks.45."].value = sources["blocks.45."]
		}

		if (typeof sources["blocks.46."] === "object") {
			this.sockets.inputs["blocks.46."].connectTo(sources["blocks.46."])
		} else {
			this.sockets.inputs["blocks.46."].value = sources["blocks.46."]
		}

		if (typeof sources["blocks.47."] === "object") {
			this.sockets.inputs["blocks.47."].connectTo(sources["blocks.47."])
		} else {
			this.sockets.inputs["blocks.47."].value = sources["blocks.47."]
		}

		if (typeof sources["final_layer."] === "object") {
			this.sockets.inputs["final_layer."].connectTo(sources["final_layer."])
		} else {
			this.sockets.inputs["final_layer."].value = sources["final_layer."]
		}

	}
}

type ModelMergeMochiPreviewInputs = {
			"model1": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model2": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"pos_frequencies.": ComfyNodeTypedInputRef<number>
			"t_embedder.": ComfyNodeTypedInputRef<number>
			"t5_y_embedder.": ComfyNodeTypedInputRef<number>
			"t5_yproj.": ComfyNodeTypedInputRef<number>
			"blocks.0.": ComfyNodeTypedInputRef<number>
			"blocks.1.": ComfyNodeTypedInputRef<number>
			"blocks.2.": ComfyNodeTypedInputRef<number>
			"blocks.3.": ComfyNodeTypedInputRef<number>
			"blocks.4.": ComfyNodeTypedInputRef<number>
			"blocks.5.": ComfyNodeTypedInputRef<number>
			"blocks.6.": ComfyNodeTypedInputRef<number>
			"blocks.7.": ComfyNodeTypedInputRef<number>
			"blocks.8.": ComfyNodeTypedInputRef<number>
			"blocks.9.": ComfyNodeTypedInputRef<number>
			"blocks.10.": ComfyNodeTypedInputRef<number>
			"blocks.11.": ComfyNodeTypedInputRef<number>
			"blocks.12.": ComfyNodeTypedInputRef<number>
			"blocks.13.": ComfyNodeTypedInputRef<number>
			"blocks.14.": ComfyNodeTypedInputRef<number>
			"blocks.15.": ComfyNodeTypedInputRef<number>
			"blocks.16.": ComfyNodeTypedInputRef<number>
			"blocks.17.": ComfyNodeTypedInputRef<number>
			"blocks.18.": ComfyNodeTypedInputRef<number>
			"blocks.19.": ComfyNodeTypedInputRef<number>
			"blocks.20.": ComfyNodeTypedInputRef<number>
			"blocks.21.": ComfyNodeTypedInputRef<number>
			"blocks.22.": ComfyNodeTypedInputRef<number>
			"blocks.23.": ComfyNodeTypedInputRef<number>
			"blocks.24.": ComfyNodeTypedInputRef<number>
			"blocks.25.": ComfyNodeTypedInputRef<number>
			"blocks.26.": ComfyNodeTypedInputRef<number>
			"blocks.27.": ComfyNodeTypedInputRef<number>
			"blocks.28.": ComfyNodeTypedInputRef<number>
			"blocks.29.": ComfyNodeTypedInputRef<number>
			"blocks.30.": ComfyNodeTypedInputRef<number>
			"blocks.31.": ComfyNodeTypedInputRef<number>
			"blocks.32.": ComfyNodeTypedInputRef<number>
			"blocks.33.": ComfyNodeTypedInputRef<number>
			"blocks.34.": ComfyNodeTypedInputRef<number>
			"blocks.35.": ComfyNodeTypedInputRef<number>
			"blocks.36.": ComfyNodeTypedInputRef<number>
			"blocks.37.": ComfyNodeTypedInputRef<number>
			"blocks.38.": ComfyNodeTypedInputRef<number>
			"blocks.39.": ComfyNodeTypedInputRef<number>
			"blocks.40.": ComfyNodeTypedInputRef<number>
			"blocks.41.": ComfyNodeTypedInputRef<number>
			"blocks.42.": ComfyNodeTypedInputRef<number>
			"blocks.43.": ComfyNodeTypedInputRef<number>
			"blocks.44.": ComfyNodeTypedInputRef<number>
			"blocks.45.": ComfyNodeTypedInputRef<number>
			"blocks.46.": ComfyNodeTypedInputRef<number>
			"blocks.47.": ComfyNodeTypedInputRef<number>
			"final_layer.": ComfyNodeTypedInputRef<number>
}


export class ModelMergeLTXV extends ComfyNode {
	classType: string = "ModelMergeLTXV"

	sockets: {
		inputs: Required<ModelMergeLTXVInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model1": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model1"),
				"model2": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model2"),
				"patchify_proj.": new ComfyNodeTypedInputRef<number>(this, "patchify_proj."),
				"adaln_single.": new ComfyNodeTypedInputRef<number>(this, "adaln_single."),
				"caption_projection.": new ComfyNodeTypedInputRef<number>(this, "caption_projection."),
				"transformer_blocks.0.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.0."),
				"transformer_blocks.1.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.1."),
				"transformer_blocks.2.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.2."),
				"transformer_blocks.3.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.3."),
				"transformer_blocks.4.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.4."),
				"transformer_blocks.5.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.5."),
				"transformer_blocks.6.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.6."),
				"transformer_blocks.7.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.7."),
				"transformer_blocks.8.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.8."),
				"transformer_blocks.9.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.9."),
				"transformer_blocks.10.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.10."),
				"transformer_blocks.11.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.11."),
				"transformer_blocks.12.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.12."),
				"transformer_blocks.13.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.13."),
				"transformer_blocks.14.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.14."),
				"transformer_blocks.15.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.15."),
				"transformer_blocks.16.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.16."),
				"transformer_blocks.17.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.17."),
				"transformer_blocks.18.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.18."),
				"transformer_blocks.19.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.19."),
				"transformer_blocks.20.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.20."),
				"transformer_blocks.21.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.21."),
				"transformer_blocks.22.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.22."),
				"transformer_blocks.23.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.23."),
				"transformer_blocks.24.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.24."),
				"transformer_blocks.25.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.25."),
				"transformer_blocks.26.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.26."),
				"transformer_blocks.27.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.27."),
				"scale_shift_table": new ComfyNodeTypedInputRef<number>(this, "scale_shift_table"),
				"proj_out.": new ComfyNodeTypedInputRef<number>(this, "proj_out."),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelMergeLTXVInputs>) {
		if (typeof sources["model1"] === "object") {
			this.sockets.inputs["model1"].connectTo(sources["model1"])
		} else {
			this.sockets.inputs["model1"].value = sources["model1"]
		}

		if (typeof sources["model2"] === "object") {
			this.sockets.inputs["model2"].connectTo(sources["model2"])
		} else {
			this.sockets.inputs["model2"].value = sources["model2"]
		}

		if (typeof sources["patchify_proj."] === "object") {
			this.sockets.inputs["patchify_proj."].connectTo(sources["patchify_proj."])
		} else {
			this.sockets.inputs["patchify_proj."].value = sources["patchify_proj."]
		}

		if (typeof sources["adaln_single."] === "object") {
			this.sockets.inputs["adaln_single."].connectTo(sources["adaln_single."])
		} else {
			this.sockets.inputs["adaln_single."].value = sources["adaln_single."]
		}

		if (typeof sources["caption_projection."] === "object") {
			this.sockets.inputs["caption_projection."].connectTo(sources["caption_projection."])
		} else {
			this.sockets.inputs["caption_projection."].value = sources["caption_projection."]
		}

		if (typeof sources["transformer_blocks.0."] === "object") {
			this.sockets.inputs["transformer_blocks.0."].connectTo(sources["transformer_blocks.0."])
		} else {
			this.sockets.inputs["transformer_blocks.0."].value = sources["transformer_blocks.0."]
		}

		if (typeof sources["transformer_blocks.1."] === "object") {
			this.sockets.inputs["transformer_blocks.1."].connectTo(sources["transformer_blocks.1."])
		} else {
			this.sockets.inputs["transformer_blocks.1."].value = sources["transformer_blocks.1."]
		}

		if (typeof sources["transformer_blocks.2."] === "object") {
			this.sockets.inputs["transformer_blocks.2."].connectTo(sources["transformer_blocks.2."])
		} else {
			this.sockets.inputs["transformer_blocks.2."].value = sources["transformer_blocks.2."]
		}

		if (typeof sources["transformer_blocks.3."] === "object") {
			this.sockets.inputs["transformer_blocks.3."].connectTo(sources["transformer_blocks.3."])
		} else {
			this.sockets.inputs["transformer_blocks.3."].value = sources["transformer_blocks.3."]
		}

		if (typeof sources["transformer_blocks.4."] === "object") {
			this.sockets.inputs["transformer_blocks.4."].connectTo(sources["transformer_blocks.4."])
		} else {
			this.sockets.inputs["transformer_blocks.4."].value = sources["transformer_blocks.4."]
		}

		if (typeof sources["transformer_blocks.5."] === "object") {
			this.sockets.inputs["transformer_blocks.5."].connectTo(sources["transformer_blocks.5."])
		} else {
			this.sockets.inputs["transformer_blocks.5."].value = sources["transformer_blocks.5."]
		}

		if (typeof sources["transformer_blocks.6."] === "object") {
			this.sockets.inputs["transformer_blocks.6."].connectTo(sources["transformer_blocks.6."])
		} else {
			this.sockets.inputs["transformer_blocks.6."].value = sources["transformer_blocks.6."]
		}

		if (typeof sources["transformer_blocks.7."] === "object") {
			this.sockets.inputs["transformer_blocks.7."].connectTo(sources["transformer_blocks.7."])
		} else {
			this.sockets.inputs["transformer_blocks.7."].value = sources["transformer_blocks.7."]
		}

		if (typeof sources["transformer_blocks.8."] === "object") {
			this.sockets.inputs["transformer_blocks.8."].connectTo(sources["transformer_blocks.8."])
		} else {
			this.sockets.inputs["transformer_blocks.8."].value = sources["transformer_blocks.8."]
		}

		if (typeof sources["transformer_blocks.9."] === "object") {
			this.sockets.inputs["transformer_blocks.9."].connectTo(sources["transformer_blocks.9."])
		} else {
			this.sockets.inputs["transformer_blocks.9."].value = sources["transformer_blocks.9."]
		}

		if (typeof sources["transformer_blocks.10."] === "object") {
			this.sockets.inputs["transformer_blocks.10."].connectTo(sources["transformer_blocks.10."])
		} else {
			this.sockets.inputs["transformer_blocks.10."].value = sources["transformer_blocks.10."]
		}

		if (typeof sources["transformer_blocks.11."] === "object") {
			this.sockets.inputs["transformer_blocks.11."].connectTo(sources["transformer_blocks.11."])
		} else {
			this.sockets.inputs["transformer_blocks.11."].value = sources["transformer_blocks.11."]
		}

		if (typeof sources["transformer_blocks.12."] === "object") {
			this.sockets.inputs["transformer_blocks.12."].connectTo(sources["transformer_blocks.12."])
		} else {
			this.sockets.inputs["transformer_blocks.12."].value = sources["transformer_blocks.12."]
		}

		if (typeof sources["transformer_blocks.13."] === "object") {
			this.sockets.inputs["transformer_blocks.13."].connectTo(sources["transformer_blocks.13."])
		} else {
			this.sockets.inputs["transformer_blocks.13."].value = sources["transformer_blocks.13."]
		}

		if (typeof sources["transformer_blocks.14."] === "object") {
			this.sockets.inputs["transformer_blocks.14."].connectTo(sources["transformer_blocks.14."])
		} else {
			this.sockets.inputs["transformer_blocks.14."].value = sources["transformer_blocks.14."]
		}

		if (typeof sources["transformer_blocks.15."] === "object") {
			this.sockets.inputs["transformer_blocks.15."].connectTo(sources["transformer_blocks.15."])
		} else {
			this.sockets.inputs["transformer_blocks.15."].value = sources["transformer_blocks.15."]
		}

		if (typeof sources["transformer_blocks.16."] === "object") {
			this.sockets.inputs["transformer_blocks.16."].connectTo(sources["transformer_blocks.16."])
		} else {
			this.sockets.inputs["transformer_blocks.16."].value = sources["transformer_blocks.16."]
		}

		if (typeof sources["transformer_blocks.17."] === "object") {
			this.sockets.inputs["transformer_blocks.17."].connectTo(sources["transformer_blocks.17."])
		} else {
			this.sockets.inputs["transformer_blocks.17."].value = sources["transformer_blocks.17."]
		}

		if (typeof sources["transformer_blocks.18."] === "object") {
			this.sockets.inputs["transformer_blocks.18."].connectTo(sources["transformer_blocks.18."])
		} else {
			this.sockets.inputs["transformer_blocks.18."].value = sources["transformer_blocks.18."]
		}

		if (typeof sources["transformer_blocks.19."] === "object") {
			this.sockets.inputs["transformer_blocks.19."].connectTo(sources["transformer_blocks.19."])
		} else {
			this.sockets.inputs["transformer_blocks.19."].value = sources["transformer_blocks.19."]
		}

		if (typeof sources["transformer_blocks.20."] === "object") {
			this.sockets.inputs["transformer_blocks.20."].connectTo(sources["transformer_blocks.20."])
		} else {
			this.sockets.inputs["transformer_blocks.20."].value = sources["transformer_blocks.20."]
		}

		if (typeof sources["transformer_blocks.21."] === "object") {
			this.sockets.inputs["transformer_blocks.21."].connectTo(sources["transformer_blocks.21."])
		} else {
			this.sockets.inputs["transformer_blocks.21."].value = sources["transformer_blocks.21."]
		}

		if (typeof sources["transformer_blocks.22."] === "object") {
			this.sockets.inputs["transformer_blocks.22."].connectTo(sources["transformer_blocks.22."])
		} else {
			this.sockets.inputs["transformer_blocks.22."].value = sources["transformer_blocks.22."]
		}

		if (typeof sources["transformer_blocks.23."] === "object") {
			this.sockets.inputs["transformer_blocks.23."].connectTo(sources["transformer_blocks.23."])
		} else {
			this.sockets.inputs["transformer_blocks.23."].value = sources["transformer_blocks.23."]
		}

		if (typeof sources["transformer_blocks.24."] === "object") {
			this.sockets.inputs["transformer_blocks.24."].connectTo(sources["transformer_blocks.24."])
		} else {
			this.sockets.inputs["transformer_blocks.24."].value = sources["transformer_blocks.24."]
		}

		if (typeof sources["transformer_blocks.25."] === "object") {
			this.sockets.inputs["transformer_blocks.25."].connectTo(sources["transformer_blocks.25."])
		} else {
			this.sockets.inputs["transformer_blocks.25."].value = sources["transformer_blocks.25."]
		}

		if (typeof sources["transformer_blocks.26."] === "object") {
			this.sockets.inputs["transformer_blocks.26."].connectTo(sources["transformer_blocks.26."])
		} else {
			this.sockets.inputs["transformer_blocks.26."].value = sources["transformer_blocks.26."]
		}

		if (typeof sources["transformer_blocks.27."] === "object") {
			this.sockets.inputs["transformer_blocks.27."].connectTo(sources["transformer_blocks.27."])
		} else {
			this.sockets.inputs["transformer_blocks.27."].value = sources["transformer_blocks.27."]
		}

		if (typeof sources["scale_shift_table"] === "object") {
			this.sockets.inputs["scale_shift_table"].connectTo(sources["scale_shift_table"])
		} else {
			this.sockets.inputs["scale_shift_table"].value = sources["scale_shift_table"]
		}

		if (typeof sources["proj_out."] === "object") {
			this.sockets.inputs["proj_out."].connectTo(sources["proj_out."])
		} else {
			this.sockets.inputs["proj_out."].value = sources["proj_out."]
		}

	}
}

type ModelMergeLTXVInputs = {
			"model1": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model2": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"patchify_proj.": ComfyNodeTypedInputRef<number>
			"adaln_single.": ComfyNodeTypedInputRef<number>
			"caption_projection.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.0.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.1.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.2.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.3.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.4.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.5.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.6.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.7.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.8.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.9.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.10.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.11.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.12.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.13.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.14.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.15.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.16.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.17.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.18.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.19.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.20.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.21.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.22.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.23.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.24.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.25.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.26.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.27.": ComfyNodeTypedInputRef<number>
			"scale_shift_table": ComfyNodeTypedInputRef<number>
			"proj_out.": ComfyNodeTypedInputRef<number>
}


export class ModelMergeCosmos7B extends ComfyNode {
	classType: string = "ModelMergeCosmos7B"

	sockets: {
		inputs: Required<ModelMergeCosmos7BInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model1": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model1"),
				"model2": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model2"),
				"pos_embedder.": new ComfyNodeTypedInputRef<number>(this, "pos_embedder."),
				"extra_pos_embedder.": new ComfyNodeTypedInputRef<number>(this, "extra_pos_embedder."),
				"x_embedder.": new ComfyNodeTypedInputRef<number>(this, "x_embedder."),
				"t_embedder.": new ComfyNodeTypedInputRef<number>(this, "t_embedder."),
				"affline_norm.": new ComfyNodeTypedInputRef<number>(this, "affline_norm."),
				"blocks.block0.": new ComfyNodeTypedInputRef<number>(this, "blocks.block0."),
				"blocks.block1.": new ComfyNodeTypedInputRef<number>(this, "blocks.block1."),
				"blocks.block2.": new ComfyNodeTypedInputRef<number>(this, "blocks.block2."),
				"blocks.block3.": new ComfyNodeTypedInputRef<number>(this, "blocks.block3."),
				"blocks.block4.": new ComfyNodeTypedInputRef<number>(this, "blocks.block4."),
				"blocks.block5.": new ComfyNodeTypedInputRef<number>(this, "blocks.block5."),
				"blocks.block6.": new ComfyNodeTypedInputRef<number>(this, "blocks.block6."),
				"blocks.block7.": new ComfyNodeTypedInputRef<number>(this, "blocks.block7."),
				"blocks.block8.": new ComfyNodeTypedInputRef<number>(this, "blocks.block8."),
				"blocks.block9.": new ComfyNodeTypedInputRef<number>(this, "blocks.block9."),
				"blocks.block10.": new ComfyNodeTypedInputRef<number>(this, "blocks.block10."),
				"blocks.block11.": new ComfyNodeTypedInputRef<number>(this, "blocks.block11."),
				"blocks.block12.": new ComfyNodeTypedInputRef<number>(this, "blocks.block12."),
				"blocks.block13.": new ComfyNodeTypedInputRef<number>(this, "blocks.block13."),
				"blocks.block14.": new ComfyNodeTypedInputRef<number>(this, "blocks.block14."),
				"blocks.block15.": new ComfyNodeTypedInputRef<number>(this, "blocks.block15."),
				"blocks.block16.": new ComfyNodeTypedInputRef<number>(this, "blocks.block16."),
				"blocks.block17.": new ComfyNodeTypedInputRef<number>(this, "blocks.block17."),
				"blocks.block18.": new ComfyNodeTypedInputRef<number>(this, "blocks.block18."),
				"blocks.block19.": new ComfyNodeTypedInputRef<number>(this, "blocks.block19."),
				"blocks.block20.": new ComfyNodeTypedInputRef<number>(this, "blocks.block20."),
				"blocks.block21.": new ComfyNodeTypedInputRef<number>(this, "blocks.block21."),
				"blocks.block22.": new ComfyNodeTypedInputRef<number>(this, "blocks.block22."),
				"blocks.block23.": new ComfyNodeTypedInputRef<number>(this, "blocks.block23."),
				"blocks.block24.": new ComfyNodeTypedInputRef<number>(this, "blocks.block24."),
				"blocks.block25.": new ComfyNodeTypedInputRef<number>(this, "blocks.block25."),
				"blocks.block26.": new ComfyNodeTypedInputRef<number>(this, "blocks.block26."),
				"blocks.block27.": new ComfyNodeTypedInputRef<number>(this, "blocks.block27."),
				"final_layer.": new ComfyNodeTypedInputRef<number>(this, "final_layer."),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelMergeCosmos7BInputs>) {
		if (typeof sources["model1"] === "object") {
			this.sockets.inputs["model1"].connectTo(sources["model1"])
		} else {
			this.sockets.inputs["model1"].value = sources["model1"]
		}

		if (typeof sources["model2"] === "object") {
			this.sockets.inputs["model2"].connectTo(sources["model2"])
		} else {
			this.sockets.inputs["model2"].value = sources["model2"]
		}

		if (typeof sources["pos_embedder."] === "object") {
			this.sockets.inputs["pos_embedder."].connectTo(sources["pos_embedder."])
		} else {
			this.sockets.inputs["pos_embedder."].value = sources["pos_embedder."]
		}

		if (typeof sources["extra_pos_embedder."] === "object") {
			this.sockets.inputs["extra_pos_embedder."].connectTo(sources["extra_pos_embedder."])
		} else {
			this.sockets.inputs["extra_pos_embedder."].value = sources["extra_pos_embedder."]
		}

		if (typeof sources["x_embedder."] === "object") {
			this.sockets.inputs["x_embedder."].connectTo(sources["x_embedder."])
		} else {
			this.sockets.inputs["x_embedder."].value = sources["x_embedder."]
		}

		if (typeof sources["t_embedder."] === "object") {
			this.sockets.inputs["t_embedder."].connectTo(sources["t_embedder."])
		} else {
			this.sockets.inputs["t_embedder."].value = sources["t_embedder."]
		}

		if (typeof sources["affline_norm."] === "object") {
			this.sockets.inputs["affline_norm."].connectTo(sources["affline_norm."])
		} else {
			this.sockets.inputs["affline_norm."].value = sources["affline_norm."]
		}

		if (typeof sources["blocks.block0."] === "object") {
			this.sockets.inputs["blocks.block0."].connectTo(sources["blocks.block0."])
		} else {
			this.sockets.inputs["blocks.block0."].value = sources["blocks.block0."]
		}

		if (typeof sources["blocks.block1."] === "object") {
			this.sockets.inputs["blocks.block1."].connectTo(sources["blocks.block1."])
		} else {
			this.sockets.inputs["blocks.block1."].value = sources["blocks.block1."]
		}

		if (typeof sources["blocks.block2."] === "object") {
			this.sockets.inputs["blocks.block2."].connectTo(sources["blocks.block2."])
		} else {
			this.sockets.inputs["blocks.block2."].value = sources["blocks.block2."]
		}

		if (typeof sources["blocks.block3."] === "object") {
			this.sockets.inputs["blocks.block3."].connectTo(sources["blocks.block3."])
		} else {
			this.sockets.inputs["blocks.block3."].value = sources["blocks.block3."]
		}

		if (typeof sources["blocks.block4."] === "object") {
			this.sockets.inputs["blocks.block4."].connectTo(sources["blocks.block4."])
		} else {
			this.sockets.inputs["blocks.block4."].value = sources["blocks.block4."]
		}

		if (typeof sources["blocks.block5."] === "object") {
			this.sockets.inputs["blocks.block5."].connectTo(sources["blocks.block5."])
		} else {
			this.sockets.inputs["blocks.block5."].value = sources["blocks.block5."]
		}

		if (typeof sources["blocks.block6."] === "object") {
			this.sockets.inputs["blocks.block6."].connectTo(sources["blocks.block6."])
		} else {
			this.sockets.inputs["blocks.block6."].value = sources["blocks.block6."]
		}

		if (typeof sources["blocks.block7."] === "object") {
			this.sockets.inputs["blocks.block7."].connectTo(sources["blocks.block7."])
		} else {
			this.sockets.inputs["blocks.block7."].value = sources["blocks.block7."]
		}

		if (typeof sources["blocks.block8."] === "object") {
			this.sockets.inputs["blocks.block8."].connectTo(sources["blocks.block8."])
		} else {
			this.sockets.inputs["blocks.block8."].value = sources["blocks.block8."]
		}

		if (typeof sources["blocks.block9."] === "object") {
			this.sockets.inputs["blocks.block9."].connectTo(sources["blocks.block9."])
		} else {
			this.sockets.inputs["blocks.block9."].value = sources["blocks.block9."]
		}

		if (typeof sources["blocks.block10."] === "object") {
			this.sockets.inputs["blocks.block10."].connectTo(sources["blocks.block10."])
		} else {
			this.sockets.inputs["blocks.block10."].value = sources["blocks.block10."]
		}

		if (typeof sources["blocks.block11."] === "object") {
			this.sockets.inputs["blocks.block11."].connectTo(sources["blocks.block11."])
		} else {
			this.sockets.inputs["blocks.block11."].value = sources["blocks.block11."]
		}

		if (typeof sources["blocks.block12."] === "object") {
			this.sockets.inputs["blocks.block12."].connectTo(sources["blocks.block12."])
		} else {
			this.sockets.inputs["blocks.block12."].value = sources["blocks.block12."]
		}

		if (typeof sources["blocks.block13."] === "object") {
			this.sockets.inputs["blocks.block13."].connectTo(sources["blocks.block13."])
		} else {
			this.sockets.inputs["blocks.block13."].value = sources["blocks.block13."]
		}

		if (typeof sources["blocks.block14."] === "object") {
			this.sockets.inputs["blocks.block14."].connectTo(sources["blocks.block14."])
		} else {
			this.sockets.inputs["blocks.block14."].value = sources["blocks.block14."]
		}

		if (typeof sources["blocks.block15."] === "object") {
			this.sockets.inputs["blocks.block15."].connectTo(sources["blocks.block15."])
		} else {
			this.sockets.inputs["blocks.block15."].value = sources["blocks.block15."]
		}

		if (typeof sources["blocks.block16."] === "object") {
			this.sockets.inputs["blocks.block16."].connectTo(sources["blocks.block16."])
		} else {
			this.sockets.inputs["blocks.block16."].value = sources["blocks.block16."]
		}

		if (typeof sources["blocks.block17."] === "object") {
			this.sockets.inputs["blocks.block17."].connectTo(sources["blocks.block17."])
		} else {
			this.sockets.inputs["blocks.block17."].value = sources["blocks.block17."]
		}

		if (typeof sources["blocks.block18."] === "object") {
			this.sockets.inputs["blocks.block18."].connectTo(sources["blocks.block18."])
		} else {
			this.sockets.inputs["blocks.block18."].value = sources["blocks.block18."]
		}

		if (typeof sources["blocks.block19."] === "object") {
			this.sockets.inputs["blocks.block19."].connectTo(sources["blocks.block19."])
		} else {
			this.sockets.inputs["blocks.block19."].value = sources["blocks.block19."]
		}

		if (typeof sources["blocks.block20."] === "object") {
			this.sockets.inputs["blocks.block20."].connectTo(sources["blocks.block20."])
		} else {
			this.sockets.inputs["blocks.block20."].value = sources["blocks.block20."]
		}

		if (typeof sources["blocks.block21."] === "object") {
			this.sockets.inputs["blocks.block21."].connectTo(sources["blocks.block21."])
		} else {
			this.sockets.inputs["blocks.block21."].value = sources["blocks.block21."]
		}

		if (typeof sources["blocks.block22."] === "object") {
			this.sockets.inputs["blocks.block22."].connectTo(sources["blocks.block22."])
		} else {
			this.sockets.inputs["blocks.block22."].value = sources["blocks.block22."]
		}

		if (typeof sources["blocks.block23."] === "object") {
			this.sockets.inputs["blocks.block23."].connectTo(sources["blocks.block23."])
		} else {
			this.sockets.inputs["blocks.block23."].value = sources["blocks.block23."]
		}

		if (typeof sources["blocks.block24."] === "object") {
			this.sockets.inputs["blocks.block24."].connectTo(sources["blocks.block24."])
		} else {
			this.sockets.inputs["blocks.block24."].value = sources["blocks.block24."]
		}

		if (typeof sources["blocks.block25."] === "object") {
			this.sockets.inputs["blocks.block25."].connectTo(sources["blocks.block25."])
		} else {
			this.sockets.inputs["blocks.block25."].value = sources["blocks.block25."]
		}

		if (typeof sources["blocks.block26."] === "object") {
			this.sockets.inputs["blocks.block26."].connectTo(sources["blocks.block26."])
		} else {
			this.sockets.inputs["blocks.block26."].value = sources["blocks.block26."]
		}

		if (typeof sources["blocks.block27."] === "object") {
			this.sockets.inputs["blocks.block27."].connectTo(sources["blocks.block27."])
		} else {
			this.sockets.inputs["blocks.block27."].value = sources["blocks.block27."]
		}

		if (typeof sources["final_layer."] === "object") {
			this.sockets.inputs["final_layer."].connectTo(sources["final_layer."])
		} else {
			this.sockets.inputs["final_layer."].value = sources["final_layer."]
		}

	}
}

type ModelMergeCosmos7BInputs = {
			"model1": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model2": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"pos_embedder.": ComfyNodeTypedInputRef<number>
			"extra_pos_embedder.": ComfyNodeTypedInputRef<number>
			"x_embedder.": ComfyNodeTypedInputRef<number>
			"t_embedder.": ComfyNodeTypedInputRef<number>
			"affline_norm.": ComfyNodeTypedInputRef<number>
			"blocks.block0.": ComfyNodeTypedInputRef<number>
			"blocks.block1.": ComfyNodeTypedInputRef<number>
			"blocks.block2.": ComfyNodeTypedInputRef<number>
			"blocks.block3.": ComfyNodeTypedInputRef<number>
			"blocks.block4.": ComfyNodeTypedInputRef<number>
			"blocks.block5.": ComfyNodeTypedInputRef<number>
			"blocks.block6.": ComfyNodeTypedInputRef<number>
			"blocks.block7.": ComfyNodeTypedInputRef<number>
			"blocks.block8.": ComfyNodeTypedInputRef<number>
			"blocks.block9.": ComfyNodeTypedInputRef<number>
			"blocks.block10.": ComfyNodeTypedInputRef<number>
			"blocks.block11.": ComfyNodeTypedInputRef<number>
			"blocks.block12.": ComfyNodeTypedInputRef<number>
			"blocks.block13.": ComfyNodeTypedInputRef<number>
			"blocks.block14.": ComfyNodeTypedInputRef<number>
			"blocks.block15.": ComfyNodeTypedInputRef<number>
			"blocks.block16.": ComfyNodeTypedInputRef<number>
			"blocks.block17.": ComfyNodeTypedInputRef<number>
			"blocks.block18.": ComfyNodeTypedInputRef<number>
			"blocks.block19.": ComfyNodeTypedInputRef<number>
			"blocks.block20.": ComfyNodeTypedInputRef<number>
			"blocks.block21.": ComfyNodeTypedInputRef<number>
			"blocks.block22.": ComfyNodeTypedInputRef<number>
			"blocks.block23.": ComfyNodeTypedInputRef<number>
			"blocks.block24.": ComfyNodeTypedInputRef<number>
			"blocks.block25.": ComfyNodeTypedInputRef<number>
			"blocks.block26.": ComfyNodeTypedInputRef<number>
			"blocks.block27.": ComfyNodeTypedInputRef<number>
			"final_layer.": ComfyNodeTypedInputRef<number>
}


export class ModelMergeCosmos14B extends ComfyNode {
	classType: string = "ModelMergeCosmos14B"

	sockets: {
		inputs: Required<ModelMergeCosmos14BInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model1": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model1"),
				"model2": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model2"),
				"pos_embedder.": new ComfyNodeTypedInputRef<number>(this, "pos_embedder."),
				"extra_pos_embedder.": new ComfyNodeTypedInputRef<number>(this, "extra_pos_embedder."),
				"x_embedder.": new ComfyNodeTypedInputRef<number>(this, "x_embedder."),
				"t_embedder.": new ComfyNodeTypedInputRef<number>(this, "t_embedder."),
				"affline_norm.": new ComfyNodeTypedInputRef<number>(this, "affline_norm."),
				"blocks.block0.": new ComfyNodeTypedInputRef<number>(this, "blocks.block0."),
				"blocks.block1.": new ComfyNodeTypedInputRef<number>(this, "blocks.block1."),
				"blocks.block2.": new ComfyNodeTypedInputRef<number>(this, "blocks.block2."),
				"blocks.block3.": new ComfyNodeTypedInputRef<number>(this, "blocks.block3."),
				"blocks.block4.": new ComfyNodeTypedInputRef<number>(this, "blocks.block4."),
				"blocks.block5.": new ComfyNodeTypedInputRef<number>(this, "blocks.block5."),
				"blocks.block6.": new ComfyNodeTypedInputRef<number>(this, "blocks.block6."),
				"blocks.block7.": new ComfyNodeTypedInputRef<number>(this, "blocks.block7."),
				"blocks.block8.": new ComfyNodeTypedInputRef<number>(this, "blocks.block8."),
				"blocks.block9.": new ComfyNodeTypedInputRef<number>(this, "blocks.block9."),
				"blocks.block10.": new ComfyNodeTypedInputRef<number>(this, "blocks.block10."),
				"blocks.block11.": new ComfyNodeTypedInputRef<number>(this, "blocks.block11."),
				"blocks.block12.": new ComfyNodeTypedInputRef<number>(this, "blocks.block12."),
				"blocks.block13.": new ComfyNodeTypedInputRef<number>(this, "blocks.block13."),
				"blocks.block14.": new ComfyNodeTypedInputRef<number>(this, "blocks.block14."),
				"blocks.block15.": new ComfyNodeTypedInputRef<number>(this, "blocks.block15."),
				"blocks.block16.": new ComfyNodeTypedInputRef<number>(this, "blocks.block16."),
				"blocks.block17.": new ComfyNodeTypedInputRef<number>(this, "blocks.block17."),
				"blocks.block18.": new ComfyNodeTypedInputRef<number>(this, "blocks.block18."),
				"blocks.block19.": new ComfyNodeTypedInputRef<number>(this, "blocks.block19."),
				"blocks.block20.": new ComfyNodeTypedInputRef<number>(this, "blocks.block20."),
				"blocks.block21.": new ComfyNodeTypedInputRef<number>(this, "blocks.block21."),
				"blocks.block22.": new ComfyNodeTypedInputRef<number>(this, "blocks.block22."),
				"blocks.block23.": new ComfyNodeTypedInputRef<number>(this, "blocks.block23."),
				"blocks.block24.": new ComfyNodeTypedInputRef<number>(this, "blocks.block24."),
				"blocks.block25.": new ComfyNodeTypedInputRef<number>(this, "blocks.block25."),
				"blocks.block26.": new ComfyNodeTypedInputRef<number>(this, "blocks.block26."),
				"blocks.block27.": new ComfyNodeTypedInputRef<number>(this, "blocks.block27."),
				"blocks.block28.": new ComfyNodeTypedInputRef<number>(this, "blocks.block28."),
				"blocks.block29.": new ComfyNodeTypedInputRef<number>(this, "blocks.block29."),
				"blocks.block30.": new ComfyNodeTypedInputRef<number>(this, "blocks.block30."),
				"blocks.block31.": new ComfyNodeTypedInputRef<number>(this, "blocks.block31."),
				"blocks.block32.": new ComfyNodeTypedInputRef<number>(this, "blocks.block32."),
				"blocks.block33.": new ComfyNodeTypedInputRef<number>(this, "blocks.block33."),
				"blocks.block34.": new ComfyNodeTypedInputRef<number>(this, "blocks.block34."),
				"blocks.block35.": new ComfyNodeTypedInputRef<number>(this, "blocks.block35."),
				"final_layer.": new ComfyNodeTypedInputRef<number>(this, "final_layer."),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelMergeCosmos14BInputs>) {
		if (typeof sources["model1"] === "object") {
			this.sockets.inputs["model1"].connectTo(sources["model1"])
		} else {
			this.sockets.inputs["model1"].value = sources["model1"]
		}

		if (typeof sources["model2"] === "object") {
			this.sockets.inputs["model2"].connectTo(sources["model2"])
		} else {
			this.sockets.inputs["model2"].value = sources["model2"]
		}

		if (typeof sources["pos_embedder."] === "object") {
			this.sockets.inputs["pos_embedder."].connectTo(sources["pos_embedder."])
		} else {
			this.sockets.inputs["pos_embedder."].value = sources["pos_embedder."]
		}

		if (typeof sources["extra_pos_embedder."] === "object") {
			this.sockets.inputs["extra_pos_embedder."].connectTo(sources["extra_pos_embedder."])
		} else {
			this.sockets.inputs["extra_pos_embedder."].value = sources["extra_pos_embedder."]
		}

		if (typeof sources["x_embedder."] === "object") {
			this.sockets.inputs["x_embedder."].connectTo(sources["x_embedder."])
		} else {
			this.sockets.inputs["x_embedder."].value = sources["x_embedder."]
		}

		if (typeof sources["t_embedder."] === "object") {
			this.sockets.inputs["t_embedder."].connectTo(sources["t_embedder."])
		} else {
			this.sockets.inputs["t_embedder."].value = sources["t_embedder."]
		}

		if (typeof sources["affline_norm."] === "object") {
			this.sockets.inputs["affline_norm."].connectTo(sources["affline_norm."])
		} else {
			this.sockets.inputs["affline_norm."].value = sources["affline_norm."]
		}

		if (typeof sources["blocks.block0."] === "object") {
			this.sockets.inputs["blocks.block0."].connectTo(sources["blocks.block0."])
		} else {
			this.sockets.inputs["blocks.block0."].value = sources["blocks.block0."]
		}

		if (typeof sources["blocks.block1."] === "object") {
			this.sockets.inputs["blocks.block1."].connectTo(sources["blocks.block1."])
		} else {
			this.sockets.inputs["blocks.block1."].value = sources["blocks.block1."]
		}

		if (typeof sources["blocks.block2."] === "object") {
			this.sockets.inputs["blocks.block2."].connectTo(sources["blocks.block2."])
		} else {
			this.sockets.inputs["blocks.block2."].value = sources["blocks.block2."]
		}

		if (typeof sources["blocks.block3."] === "object") {
			this.sockets.inputs["blocks.block3."].connectTo(sources["blocks.block3."])
		} else {
			this.sockets.inputs["blocks.block3."].value = sources["blocks.block3."]
		}

		if (typeof sources["blocks.block4."] === "object") {
			this.sockets.inputs["blocks.block4."].connectTo(sources["blocks.block4."])
		} else {
			this.sockets.inputs["blocks.block4."].value = sources["blocks.block4."]
		}

		if (typeof sources["blocks.block5."] === "object") {
			this.sockets.inputs["blocks.block5."].connectTo(sources["blocks.block5."])
		} else {
			this.sockets.inputs["blocks.block5."].value = sources["blocks.block5."]
		}

		if (typeof sources["blocks.block6."] === "object") {
			this.sockets.inputs["blocks.block6."].connectTo(sources["blocks.block6."])
		} else {
			this.sockets.inputs["blocks.block6."].value = sources["blocks.block6."]
		}

		if (typeof sources["blocks.block7."] === "object") {
			this.sockets.inputs["blocks.block7."].connectTo(sources["blocks.block7."])
		} else {
			this.sockets.inputs["blocks.block7."].value = sources["blocks.block7."]
		}

		if (typeof sources["blocks.block8."] === "object") {
			this.sockets.inputs["blocks.block8."].connectTo(sources["blocks.block8."])
		} else {
			this.sockets.inputs["blocks.block8."].value = sources["blocks.block8."]
		}

		if (typeof sources["blocks.block9."] === "object") {
			this.sockets.inputs["blocks.block9."].connectTo(sources["blocks.block9."])
		} else {
			this.sockets.inputs["blocks.block9."].value = sources["blocks.block9."]
		}

		if (typeof sources["blocks.block10."] === "object") {
			this.sockets.inputs["blocks.block10."].connectTo(sources["blocks.block10."])
		} else {
			this.sockets.inputs["blocks.block10."].value = sources["blocks.block10."]
		}

		if (typeof sources["blocks.block11."] === "object") {
			this.sockets.inputs["blocks.block11."].connectTo(sources["blocks.block11."])
		} else {
			this.sockets.inputs["blocks.block11."].value = sources["blocks.block11."]
		}

		if (typeof sources["blocks.block12."] === "object") {
			this.sockets.inputs["blocks.block12."].connectTo(sources["blocks.block12."])
		} else {
			this.sockets.inputs["blocks.block12."].value = sources["blocks.block12."]
		}

		if (typeof sources["blocks.block13."] === "object") {
			this.sockets.inputs["blocks.block13."].connectTo(sources["blocks.block13."])
		} else {
			this.sockets.inputs["blocks.block13."].value = sources["blocks.block13."]
		}

		if (typeof sources["blocks.block14."] === "object") {
			this.sockets.inputs["blocks.block14."].connectTo(sources["blocks.block14."])
		} else {
			this.sockets.inputs["blocks.block14."].value = sources["blocks.block14."]
		}

		if (typeof sources["blocks.block15."] === "object") {
			this.sockets.inputs["blocks.block15."].connectTo(sources["blocks.block15."])
		} else {
			this.sockets.inputs["blocks.block15."].value = sources["blocks.block15."]
		}

		if (typeof sources["blocks.block16."] === "object") {
			this.sockets.inputs["blocks.block16."].connectTo(sources["blocks.block16."])
		} else {
			this.sockets.inputs["blocks.block16."].value = sources["blocks.block16."]
		}

		if (typeof sources["blocks.block17."] === "object") {
			this.sockets.inputs["blocks.block17."].connectTo(sources["blocks.block17."])
		} else {
			this.sockets.inputs["blocks.block17."].value = sources["blocks.block17."]
		}

		if (typeof sources["blocks.block18."] === "object") {
			this.sockets.inputs["blocks.block18."].connectTo(sources["blocks.block18."])
		} else {
			this.sockets.inputs["blocks.block18."].value = sources["blocks.block18."]
		}

		if (typeof sources["blocks.block19."] === "object") {
			this.sockets.inputs["blocks.block19."].connectTo(sources["blocks.block19."])
		} else {
			this.sockets.inputs["blocks.block19."].value = sources["blocks.block19."]
		}

		if (typeof sources["blocks.block20."] === "object") {
			this.sockets.inputs["blocks.block20."].connectTo(sources["blocks.block20."])
		} else {
			this.sockets.inputs["blocks.block20."].value = sources["blocks.block20."]
		}

		if (typeof sources["blocks.block21."] === "object") {
			this.sockets.inputs["blocks.block21."].connectTo(sources["blocks.block21."])
		} else {
			this.sockets.inputs["blocks.block21."].value = sources["blocks.block21."]
		}

		if (typeof sources["blocks.block22."] === "object") {
			this.sockets.inputs["blocks.block22."].connectTo(sources["blocks.block22."])
		} else {
			this.sockets.inputs["blocks.block22."].value = sources["blocks.block22."]
		}

		if (typeof sources["blocks.block23."] === "object") {
			this.sockets.inputs["blocks.block23."].connectTo(sources["blocks.block23."])
		} else {
			this.sockets.inputs["blocks.block23."].value = sources["blocks.block23."]
		}

		if (typeof sources["blocks.block24."] === "object") {
			this.sockets.inputs["blocks.block24."].connectTo(sources["blocks.block24."])
		} else {
			this.sockets.inputs["blocks.block24."].value = sources["blocks.block24."]
		}

		if (typeof sources["blocks.block25."] === "object") {
			this.sockets.inputs["blocks.block25."].connectTo(sources["blocks.block25."])
		} else {
			this.sockets.inputs["blocks.block25."].value = sources["blocks.block25."]
		}

		if (typeof sources["blocks.block26."] === "object") {
			this.sockets.inputs["blocks.block26."].connectTo(sources["blocks.block26."])
		} else {
			this.sockets.inputs["blocks.block26."].value = sources["blocks.block26."]
		}

		if (typeof sources["blocks.block27."] === "object") {
			this.sockets.inputs["blocks.block27."].connectTo(sources["blocks.block27."])
		} else {
			this.sockets.inputs["blocks.block27."].value = sources["blocks.block27."]
		}

		if (typeof sources["blocks.block28."] === "object") {
			this.sockets.inputs["blocks.block28."].connectTo(sources["blocks.block28."])
		} else {
			this.sockets.inputs["blocks.block28."].value = sources["blocks.block28."]
		}

		if (typeof sources["blocks.block29."] === "object") {
			this.sockets.inputs["blocks.block29."].connectTo(sources["blocks.block29."])
		} else {
			this.sockets.inputs["blocks.block29."].value = sources["blocks.block29."]
		}

		if (typeof sources["blocks.block30."] === "object") {
			this.sockets.inputs["blocks.block30."].connectTo(sources["blocks.block30."])
		} else {
			this.sockets.inputs["blocks.block30."].value = sources["blocks.block30."]
		}

		if (typeof sources["blocks.block31."] === "object") {
			this.sockets.inputs["blocks.block31."].connectTo(sources["blocks.block31."])
		} else {
			this.sockets.inputs["blocks.block31."].value = sources["blocks.block31."]
		}

		if (typeof sources["blocks.block32."] === "object") {
			this.sockets.inputs["blocks.block32."].connectTo(sources["blocks.block32."])
		} else {
			this.sockets.inputs["blocks.block32."].value = sources["blocks.block32."]
		}

		if (typeof sources["blocks.block33."] === "object") {
			this.sockets.inputs["blocks.block33."].connectTo(sources["blocks.block33."])
		} else {
			this.sockets.inputs["blocks.block33."].value = sources["blocks.block33."]
		}

		if (typeof sources["blocks.block34."] === "object") {
			this.sockets.inputs["blocks.block34."].connectTo(sources["blocks.block34."])
		} else {
			this.sockets.inputs["blocks.block34."].value = sources["blocks.block34."]
		}

		if (typeof sources["blocks.block35."] === "object") {
			this.sockets.inputs["blocks.block35."].connectTo(sources["blocks.block35."])
		} else {
			this.sockets.inputs["blocks.block35."].value = sources["blocks.block35."]
		}

		if (typeof sources["final_layer."] === "object") {
			this.sockets.inputs["final_layer."].connectTo(sources["final_layer."])
		} else {
			this.sockets.inputs["final_layer."].value = sources["final_layer."]
		}

	}
}

type ModelMergeCosmos14BInputs = {
			"model1": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model2": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"pos_embedder.": ComfyNodeTypedInputRef<number>
			"extra_pos_embedder.": ComfyNodeTypedInputRef<number>
			"x_embedder.": ComfyNodeTypedInputRef<number>
			"t_embedder.": ComfyNodeTypedInputRef<number>
			"affline_norm.": ComfyNodeTypedInputRef<number>
			"blocks.block0.": ComfyNodeTypedInputRef<number>
			"blocks.block1.": ComfyNodeTypedInputRef<number>
			"blocks.block2.": ComfyNodeTypedInputRef<number>
			"blocks.block3.": ComfyNodeTypedInputRef<number>
			"blocks.block4.": ComfyNodeTypedInputRef<number>
			"blocks.block5.": ComfyNodeTypedInputRef<number>
			"blocks.block6.": ComfyNodeTypedInputRef<number>
			"blocks.block7.": ComfyNodeTypedInputRef<number>
			"blocks.block8.": ComfyNodeTypedInputRef<number>
			"blocks.block9.": ComfyNodeTypedInputRef<number>
			"blocks.block10.": ComfyNodeTypedInputRef<number>
			"blocks.block11.": ComfyNodeTypedInputRef<number>
			"blocks.block12.": ComfyNodeTypedInputRef<number>
			"blocks.block13.": ComfyNodeTypedInputRef<number>
			"blocks.block14.": ComfyNodeTypedInputRef<number>
			"blocks.block15.": ComfyNodeTypedInputRef<number>
			"blocks.block16.": ComfyNodeTypedInputRef<number>
			"blocks.block17.": ComfyNodeTypedInputRef<number>
			"blocks.block18.": ComfyNodeTypedInputRef<number>
			"blocks.block19.": ComfyNodeTypedInputRef<number>
			"blocks.block20.": ComfyNodeTypedInputRef<number>
			"blocks.block21.": ComfyNodeTypedInputRef<number>
			"blocks.block22.": ComfyNodeTypedInputRef<number>
			"blocks.block23.": ComfyNodeTypedInputRef<number>
			"blocks.block24.": ComfyNodeTypedInputRef<number>
			"blocks.block25.": ComfyNodeTypedInputRef<number>
			"blocks.block26.": ComfyNodeTypedInputRef<number>
			"blocks.block27.": ComfyNodeTypedInputRef<number>
			"blocks.block28.": ComfyNodeTypedInputRef<number>
			"blocks.block29.": ComfyNodeTypedInputRef<number>
			"blocks.block30.": ComfyNodeTypedInputRef<number>
			"blocks.block31.": ComfyNodeTypedInputRef<number>
			"blocks.block32.": ComfyNodeTypedInputRef<number>
			"blocks.block33.": ComfyNodeTypedInputRef<number>
			"blocks.block34.": ComfyNodeTypedInputRef<number>
			"blocks.block35.": ComfyNodeTypedInputRef<number>
			"final_layer.": ComfyNodeTypedInputRef<number>
}


export class ModelMergeWAN2_1 extends ComfyNode {
	classType: string = "ModelMergeWAN2_1"

	sockets: {
		inputs: Required<ModelMergeWAN2_1Inputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model1": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model1"),
				"model2": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model2"),
				"patch_embedding.": new ComfyNodeTypedInputRef<number>(this, "patch_embedding."),
				"time_embedding.": new ComfyNodeTypedInputRef<number>(this, "time_embedding."),
				"time_projection.": new ComfyNodeTypedInputRef<number>(this, "time_projection."),
				"text_embedding.": new ComfyNodeTypedInputRef<number>(this, "text_embedding."),
				"img_emb.": new ComfyNodeTypedInputRef<number>(this, "img_emb."),
				"blocks.0.": new ComfyNodeTypedInputRef<number>(this, "blocks.0."),
				"blocks.1.": new ComfyNodeTypedInputRef<number>(this, "blocks.1."),
				"blocks.2.": new ComfyNodeTypedInputRef<number>(this, "blocks.2."),
				"blocks.3.": new ComfyNodeTypedInputRef<number>(this, "blocks.3."),
				"blocks.4.": new ComfyNodeTypedInputRef<number>(this, "blocks.4."),
				"blocks.5.": new ComfyNodeTypedInputRef<number>(this, "blocks.5."),
				"blocks.6.": new ComfyNodeTypedInputRef<number>(this, "blocks.6."),
				"blocks.7.": new ComfyNodeTypedInputRef<number>(this, "blocks.7."),
				"blocks.8.": new ComfyNodeTypedInputRef<number>(this, "blocks.8."),
				"blocks.9.": new ComfyNodeTypedInputRef<number>(this, "blocks.9."),
				"blocks.10.": new ComfyNodeTypedInputRef<number>(this, "blocks.10."),
				"blocks.11.": new ComfyNodeTypedInputRef<number>(this, "blocks.11."),
				"blocks.12.": new ComfyNodeTypedInputRef<number>(this, "blocks.12."),
				"blocks.13.": new ComfyNodeTypedInputRef<number>(this, "blocks.13."),
				"blocks.14.": new ComfyNodeTypedInputRef<number>(this, "blocks.14."),
				"blocks.15.": new ComfyNodeTypedInputRef<number>(this, "blocks.15."),
				"blocks.16.": new ComfyNodeTypedInputRef<number>(this, "blocks.16."),
				"blocks.17.": new ComfyNodeTypedInputRef<number>(this, "blocks.17."),
				"blocks.18.": new ComfyNodeTypedInputRef<number>(this, "blocks.18."),
				"blocks.19.": new ComfyNodeTypedInputRef<number>(this, "blocks.19."),
				"blocks.20.": new ComfyNodeTypedInputRef<number>(this, "blocks.20."),
				"blocks.21.": new ComfyNodeTypedInputRef<number>(this, "blocks.21."),
				"blocks.22.": new ComfyNodeTypedInputRef<number>(this, "blocks.22."),
				"blocks.23.": new ComfyNodeTypedInputRef<number>(this, "blocks.23."),
				"blocks.24.": new ComfyNodeTypedInputRef<number>(this, "blocks.24."),
				"blocks.25.": new ComfyNodeTypedInputRef<number>(this, "blocks.25."),
				"blocks.26.": new ComfyNodeTypedInputRef<number>(this, "blocks.26."),
				"blocks.27.": new ComfyNodeTypedInputRef<number>(this, "blocks.27."),
				"blocks.28.": new ComfyNodeTypedInputRef<number>(this, "blocks.28."),
				"blocks.29.": new ComfyNodeTypedInputRef<number>(this, "blocks.29."),
				"blocks.30.": new ComfyNodeTypedInputRef<number>(this, "blocks.30."),
				"blocks.31.": new ComfyNodeTypedInputRef<number>(this, "blocks.31."),
				"blocks.32.": new ComfyNodeTypedInputRef<number>(this, "blocks.32."),
				"blocks.33.": new ComfyNodeTypedInputRef<number>(this, "blocks.33."),
				"blocks.34.": new ComfyNodeTypedInputRef<number>(this, "blocks.34."),
				"blocks.35.": new ComfyNodeTypedInputRef<number>(this, "blocks.35."),
				"blocks.36.": new ComfyNodeTypedInputRef<number>(this, "blocks.36."),
				"blocks.37.": new ComfyNodeTypedInputRef<number>(this, "blocks.37."),
				"blocks.38.": new ComfyNodeTypedInputRef<number>(this, "blocks.38."),
				"blocks.39.": new ComfyNodeTypedInputRef<number>(this, "blocks.39."),
				"head.": new ComfyNodeTypedInputRef<number>(this, "head."),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelMergeWAN2_1Inputs>) {
		if (typeof sources["model1"] === "object") {
			this.sockets.inputs["model1"].connectTo(sources["model1"])
		} else {
			this.sockets.inputs["model1"].value = sources["model1"]
		}

		if (typeof sources["model2"] === "object") {
			this.sockets.inputs["model2"].connectTo(sources["model2"])
		} else {
			this.sockets.inputs["model2"].value = sources["model2"]
		}

		if (typeof sources["patch_embedding."] === "object") {
			this.sockets.inputs["patch_embedding."].connectTo(sources["patch_embedding."])
		} else {
			this.sockets.inputs["patch_embedding."].value = sources["patch_embedding."]
		}

		if (typeof sources["time_embedding."] === "object") {
			this.sockets.inputs["time_embedding."].connectTo(sources["time_embedding."])
		} else {
			this.sockets.inputs["time_embedding."].value = sources["time_embedding."]
		}

		if (typeof sources["time_projection."] === "object") {
			this.sockets.inputs["time_projection."].connectTo(sources["time_projection."])
		} else {
			this.sockets.inputs["time_projection."].value = sources["time_projection."]
		}

		if (typeof sources["text_embedding."] === "object") {
			this.sockets.inputs["text_embedding."].connectTo(sources["text_embedding."])
		} else {
			this.sockets.inputs["text_embedding."].value = sources["text_embedding."]
		}

		if (typeof sources["img_emb."] === "object") {
			this.sockets.inputs["img_emb."].connectTo(sources["img_emb."])
		} else {
			this.sockets.inputs["img_emb."].value = sources["img_emb."]
		}

		if (typeof sources["blocks.0."] === "object") {
			this.sockets.inputs["blocks.0."].connectTo(sources["blocks.0."])
		} else {
			this.sockets.inputs["blocks.0."].value = sources["blocks.0."]
		}

		if (typeof sources["blocks.1."] === "object") {
			this.sockets.inputs["blocks.1."].connectTo(sources["blocks.1."])
		} else {
			this.sockets.inputs["blocks.1."].value = sources["blocks.1."]
		}

		if (typeof sources["blocks.2."] === "object") {
			this.sockets.inputs["blocks.2."].connectTo(sources["blocks.2."])
		} else {
			this.sockets.inputs["blocks.2."].value = sources["blocks.2."]
		}

		if (typeof sources["blocks.3."] === "object") {
			this.sockets.inputs["blocks.3."].connectTo(sources["blocks.3."])
		} else {
			this.sockets.inputs["blocks.3."].value = sources["blocks.3."]
		}

		if (typeof sources["blocks.4."] === "object") {
			this.sockets.inputs["blocks.4."].connectTo(sources["blocks.4."])
		} else {
			this.sockets.inputs["blocks.4."].value = sources["blocks.4."]
		}

		if (typeof sources["blocks.5."] === "object") {
			this.sockets.inputs["blocks.5."].connectTo(sources["blocks.5."])
		} else {
			this.sockets.inputs["blocks.5."].value = sources["blocks.5."]
		}

		if (typeof sources["blocks.6."] === "object") {
			this.sockets.inputs["blocks.6."].connectTo(sources["blocks.6."])
		} else {
			this.sockets.inputs["blocks.6."].value = sources["blocks.6."]
		}

		if (typeof sources["blocks.7."] === "object") {
			this.sockets.inputs["blocks.7."].connectTo(sources["blocks.7."])
		} else {
			this.sockets.inputs["blocks.7."].value = sources["blocks.7."]
		}

		if (typeof sources["blocks.8."] === "object") {
			this.sockets.inputs["blocks.8."].connectTo(sources["blocks.8."])
		} else {
			this.sockets.inputs["blocks.8."].value = sources["blocks.8."]
		}

		if (typeof sources["blocks.9."] === "object") {
			this.sockets.inputs["blocks.9."].connectTo(sources["blocks.9."])
		} else {
			this.sockets.inputs["blocks.9."].value = sources["blocks.9."]
		}

		if (typeof sources["blocks.10."] === "object") {
			this.sockets.inputs["blocks.10."].connectTo(sources["blocks.10."])
		} else {
			this.sockets.inputs["blocks.10."].value = sources["blocks.10."]
		}

		if (typeof sources["blocks.11."] === "object") {
			this.sockets.inputs["blocks.11."].connectTo(sources["blocks.11."])
		} else {
			this.sockets.inputs["blocks.11."].value = sources["blocks.11."]
		}

		if (typeof sources["blocks.12."] === "object") {
			this.sockets.inputs["blocks.12."].connectTo(sources["blocks.12."])
		} else {
			this.sockets.inputs["blocks.12."].value = sources["blocks.12."]
		}

		if (typeof sources["blocks.13."] === "object") {
			this.sockets.inputs["blocks.13."].connectTo(sources["blocks.13."])
		} else {
			this.sockets.inputs["blocks.13."].value = sources["blocks.13."]
		}

		if (typeof sources["blocks.14."] === "object") {
			this.sockets.inputs["blocks.14."].connectTo(sources["blocks.14."])
		} else {
			this.sockets.inputs["blocks.14."].value = sources["blocks.14."]
		}

		if (typeof sources["blocks.15."] === "object") {
			this.sockets.inputs["blocks.15."].connectTo(sources["blocks.15."])
		} else {
			this.sockets.inputs["blocks.15."].value = sources["blocks.15."]
		}

		if (typeof sources["blocks.16."] === "object") {
			this.sockets.inputs["blocks.16."].connectTo(sources["blocks.16."])
		} else {
			this.sockets.inputs["blocks.16."].value = sources["blocks.16."]
		}

		if (typeof sources["blocks.17."] === "object") {
			this.sockets.inputs["blocks.17."].connectTo(sources["blocks.17."])
		} else {
			this.sockets.inputs["blocks.17."].value = sources["blocks.17."]
		}

		if (typeof sources["blocks.18."] === "object") {
			this.sockets.inputs["blocks.18."].connectTo(sources["blocks.18."])
		} else {
			this.sockets.inputs["blocks.18."].value = sources["blocks.18."]
		}

		if (typeof sources["blocks.19."] === "object") {
			this.sockets.inputs["blocks.19."].connectTo(sources["blocks.19."])
		} else {
			this.sockets.inputs["blocks.19."].value = sources["blocks.19."]
		}

		if (typeof sources["blocks.20."] === "object") {
			this.sockets.inputs["blocks.20."].connectTo(sources["blocks.20."])
		} else {
			this.sockets.inputs["blocks.20."].value = sources["blocks.20."]
		}

		if (typeof sources["blocks.21."] === "object") {
			this.sockets.inputs["blocks.21."].connectTo(sources["blocks.21."])
		} else {
			this.sockets.inputs["blocks.21."].value = sources["blocks.21."]
		}

		if (typeof sources["blocks.22."] === "object") {
			this.sockets.inputs["blocks.22."].connectTo(sources["blocks.22."])
		} else {
			this.sockets.inputs["blocks.22."].value = sources["blocks.22."]
		}

		if (typeof sources["blocks.23."] === "object") {
			this.sockets.inputs["blocks.23."].connectTo(sources["blocks.23."])
		} else {
			this.sockets.inputs["blocks.23."].value = sources["blocks.23."]
		}

		if (typeof sources["blocks.24."] === "object") {
			this.sockets.inputs["blocks.24."].connectTo(sources["blocks.24."])
		} else {
			this.sockets.inputs["blocks.24."].value = sources["blocks.24."]
		}

		if (typeof sources["blocks.25."] === "object") {
			this.sockets.inputs["blocks.25."].connectTo(sources["blocks.25."])
		} else {
			this.sockets.inputs["blocks.25."].value = sources["blocks.25."]
		}

		if (typeof sources["blocks.26."] === "object") {
			this.sockets.inputs["blocks.26."].connectTo(sources["blocks.26."])
		} else {
			this.sockets.inputs["blocks.26."].value = sources["blocks.26."]
		}

		if (typeof sources["blocks.27."] === "object") {
			this.sockets.inputs["blocks.27."].connectTo(sources["blocks.27."])
		} else {
			this.sockets.inputs["blocks.27."].value = sources["blocks.27."]
		}

		if (typeof sources["blocks.28."] === "object") {
			this.sockets.inputs["blocks.28."].connectTo(sources["blocks.28."])
		} else {
			this.sockets.inputs["blocks.28."].value = sources["blocks.28."]
		}

		if (typeof sources["blocks.29."] === "object") {
			this.sockets.inputs["blocks.29."].connectTo(sources["blocks.29."])
		} else {
			this.sockets.inputs["blocks.29."].value = sources["blocks.29."]
		}

		if (typeof sources["blocks.30."] === "object") {
			this.sockets.inputs["blocks.30."].connectTo(sources["blocks.30."])
		} else {
			this.sockets.inputs["blocks.30."].value = sources["blocks.30."]
		}

		if (typeof sources["blocks.31."] === "object") {
			this.sockets.inputs["blocks.31."].connectTo(sources["blocks.31."])
		} else {
			this.sockets.inputs["blocks.31."].value = sources["blocks.31."]
		}

		if (typeof sources["blocks.32."] === "object") {
			this.sockets.inputs["blocks.32."].connectTo(sources["blocks.32."])
		} else {
			this.sockets.inputs["blocks.32."].value = sources["blocks.32."]
		}

		if (typeof sources["blocks.33."] === "object") {
			this.sockets.inputs["blocks.33."].connectTo(sources["blocks.33."])
		} else {
			this.sockets.inputs["blocks.33."].value = sources["blocks.33."]
		}

		if (typeof sources["blocks.34."] === "object") {
			this.sockets.inputs["blocks.34."].connectTo(sources["blocks.34."])
		} else {
			this.sockets.inputs["blocks.34."].value = sources["blocks.34."]
		}

		if (typeof sources["blocks.35."] === "object") {
			this.sockets.inputs["blocks.35."].connectTo(sources["blocks.35."])
		} else {
			this.sockets.inputs["blocks.35."].value = sources["blocks.35."]
		}

		if (typeof sources["blocks.36."] === "object") {
			this.sockets.inputs["blocks.36."].connectTo(sources["blocks.36."])
		} else {
			this.sockets.inputs["blocks.36."].value = sources["blocks.36."]
		}

		if (typeof sources["blocks.37."] === "object") {
			this.sockets.inputs["blocks.37."].connectTo(sources["blocks.37."])
		} else {
			this.sockets.inputs["blocks.37."].value = sources["blocks.37."]
		}

		if (typeof sources["blocks.38."] === "object") {
			this.sockets.inputs["blocks.38."].connectTo(sources["blocks.38."])
		} else {
			this.sockets.inputs["blocks.38."].value = sources["blocks.38."]
		}

		if (typeof sources["blocks.39."] === "object") {
			this.sockets.inputs["blocks.39."].connectTo(sources["blocks.39."])
		} else {
			this.sockets.inputs["blocks.39."].value = sources["blocks.39."]
		}

		if (typeof sources["head."] === "object") {
			this.sockets.inputs["head."].connectTo(sources["head."])
		} else {
			this.sockets.inputs["head."].value = sources["head."]
		}

	}
}

type ModelMergeWAN2_1Inputs = {
			"model1": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model2": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"patch_embedding.": ComfyNodeTypedInputRef<number>
			"time_embedding.": ComfyNodeTypedInputRef<number>
			"time_projection.": ComfyNodeTypedInputRef<number>
			"text_embedding.": ComfyNodeTypedInputRef<number>
			"img_emb.": ComfyNodeTypedInputRef<number>
			"blocks.0.": ComfyNodeTypedInputRef<number>
			"blocks.1.": ComfyNodeTypedInputRef<number>
			"blocks.2.": ComfyNodeTypedInputRef<number>
			"blocks.3.": ComfyNodeTypedInputRef<number>
			"blocks.4.": ComfyNodeTypedInputRef<number>
			"blocks.5.": ComfyNodeTypedInputRef<number>
			"blocks.6.": ComfyNodeTypedInputRef<number>
			"blocks.7.": ComfyNodeTypedInputRef<number>
			"blocks.8.": ComfyNodeTypedInputRef<number>
			"blocks.9.": ComfyNodeTypedInputRef<number>
			"blocks.10.": ComfyNodeTypedInputRef<number>
			"blocks.11.": ComfyNodeTypedInputRef<number>
			"blocks.12.": ComfyNodeTypedInputRef<number>
			"blocks.13.": ComfyNodeTypedInputRef<number>
			"blocks.14.": ComfyNodeTypedInputRef<number>
			"blocks.15.": ComfyNodeTypedInputRef<number>
			"blocks.16.": ComfyNodeTypedInputRef<number>
			"blocks.17.": ComfyNodeTypedInputRef<number>
			"blocks.18.": ComfyNodeTypedInputRef<number>
			"blocks.19.": ComfyNodeTypedInputRef<number>
			"blocks.20.": ComfyNodeTypedInputRef<number>
			"blocks.21.": ComfyNodeTypedInputRef<number>
			"blocks.22.": ComfyNodeTypedInputRef<number>
			"blocks.23.": ComfyNodeTypedInputRef<number>
			"blocks.24.": ComfyNodeTypedInputRef<number>
			"blocks.25.": ComfyNodeTypedInputRef<number>
			"blocks.26.": ComfyNodeTypedInputRef<number>
			"blocks.27.": ComfyNodeTypedInputRef<number>
			"blocks.28.": ComfyNodeTypedInputRef<number>
			"blocks.29.": ComfyNodeTypedInputRef<number>
			"blocks.30.": ComfyNodeTypedInputRef<number>
			"blocks.31.": ComfyNodeTypedInputRef<number>
			"blocks.32.": ComfyNodeTypedInputRef<number>
			"blocks.33.": ComfyNodeTypedInputRef<number>
			"blocks.34.": ComfyNodeTypedInputRef<number>
			"blocks.35.": ComfyNodeTypedInputRef<number>
			"blocks.36.": ComfyNodeTypedInputRef<number>
			"blocks.37.": ComfyNodeTypedInputRef<number>
			"blocks.38.": ComfyNodeTypedInputRef<number>
			"blocks.39.": ComfyNodeTypedInputRef<number>
			"head.": ComfyNodeTypedInputRef<number>
}


export class ModelMergeCosmosPredict2_2B extends ComfyNode {
	classType: string = "ModelMergeCosmosPredict2_2B"

	sockets: {
		inputs: Required<ModelMergeCosmosPredict2_2BInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model1": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model1"),
				"model2": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model2"),
				"pos_embedder.": new ComfyNodeTypedInputRef<number>(this, "pos_embedder."),
				"x_embedder.": new ComfyNodeTypedInputRef<number>(this, "x_embedder."),
				"t_embedder.": new ComfyNodeTypedInputRef<number>(this, "t_embedder."),
				"t_embedding_norm.": new ComfyNodeTypedInputRef<number>(this, "t_embedding_norm."),
				"blocks.0.": new ComfyNodeTypedInputRef<number>(this, "blocks.0."),
				"blocks.1.": new ComfyNodeTypedInputRef<number>(this, "blocks.1."),
				"blocks.2.": new ComfyNodeTypedInputRef<number>(this, "blocks.2."),
				"blocks.3.": new ComfyNodeTypedInputRef<number>(this, "blocks.3."),
				"blocks.4.": new ComfyNodeTypedInputRef<number>(this, "blocks.4."),
				"blocks.5.": new ComfyNodeTypedInputRef<number>(this, "blocks.5."),
				"blocks.6.": new ComfyNodeTypedInputRef<number>(this, "blocks.6."),
				"blocks.7.": new ComfyNodeTypedInputRef<number>(this, "blocks.7."),
				"blocks.8.": new ComfyNodeTypedInputRef<number>(this, "blocks.8."),
				"blocks.9.": new ComfyNodeTypedInputRef<number>(this, "blocks.9."),
				"blocks.10.": new ComfyNodeTypedInputRef<number>(this, "blocks.10."),
				"blocks.11.": new ComfyNodeTypedInputRef<number>(this, "blocks.11."),
				"blocks.12.": new ComfyNodeTypedInputRef<number>(this, "blocks.12."),
				"blocks.13.": new ComfyNodeTypedInputRef<number>(this, "blocks.13."),
				"blocks.14.": new ComfyNodeTypedInputRef<number>(this, "blocks.14."),
				"blocks.15.": new ComfyNodeTypedInputRef<number>(this, "blocks.15."),
				"blocks.16.": new ComfyNodeTypedInputRef<number>(this, "blocks.16."),
				"blocks.17.": new ComfyNodeTypedInputRef<number>(this, "blocks.17."),
				"blocks.18.": new ComfyNodeTypedInputRef<number>(this, "blocks.18."),
				"blocks.19.": new ComfyNodeTypedInputRef<number>(this, "blocks.19."),
				"blocks.20.": new ComfyNodeTypedInputRef<number>(this, "blocks.20."),
				"blocks.21.": new ComfyNodeTypedInputRef<number>(this, "blocks.21."),
				"blocks.22.": new ComfyNodeTypedInputRef<number>(this, "blocks.22."),
				"blocks.23.": new ComfyNodeTypedInputRef<number>(this, "blocks.23."),
				"blocks.24.": new ComfyNodeTypedInputRef<number>(this, "blocks.24."),
				"blocks.25.": new ComfyNodeTypedInputRef<number>(this, "blocks.25."),
				"blocks.26.": new ComfyNodeTypedInputRef<number>(this, "blocks.26."),
				"blocks.27.": new ComfyNodeTypedInputRef<number>(this, "blocks.27."),
				"final_layer.": new ComfyNodeTypedInputRef<number>(this, "final_layer."),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelMergeCosmosPredict2_2BInputs>) {
		if (typeof sources["model1"] === "object") {
			this.sockets.inputs["model1"].connectTo(sources["model1"])
		} else {
			this.sockets.inputs["model1"].value = sources["model1"]
		}

		if (typeof sources["model2"] === "object") {
			this.sockets.inputs["model2"].connectTo(sources["model2"])
		} else {
			this.sockets.inputs["model2"].value = sources["model2"]
		}

		if (typeof sources["pos_embedder."] === "object") {
			this.sockets.inputs["pos_embedder."].connectTo(sources["pos_embedder."])
		} else {
			this.sockets.inputs["pos_embedder."].value = sources["pos_embedder."]
		}

		if (typeof sources["x_embedder."] === "object") {
			this.sockets.inputs["x_embedder."].connectTo(sources["x_embedder."])
		} else {
			this.sockets.inputs["x_embedder."].value = sources["x_embedder."]
		}

		if (typeof sources["t_embedder."] === "object") {
			this.sockets.inputs["t_embedder."].connectTo(sources["t_embedder."])
		} else {
			this.sockets.inputs["t_embedder."].value = sources["t_embedder."]
		}

		if (typeof sources["t_embedding_norm."] === "object") {
			this.sockets.inputs["t_embedding_norm."].connectTo(sources["t_embedding_norm."])
		} else {
			this.sockets.inputs["t_embedding_norm."].value = sources["t_embedding_norm."]
		}

		if (typeof sources["blocks.0."] === "object") {
			this.sockets.inputs["blocks.0."].connectTo(sources["blocks.0."])
		} else {
			this.sockets.inputs["blocks.0."].value = sources["blocks.0."]
		}

		if (typeof sources["blocks.1."] === "object") {
			this.sockets.inputs["blocks.1."].connectTo(sources["blocks.1."])
		} else {
			this.sockets.inputs["blocks.1."].value = sources["blocks.1."]
		}

		if (typeof sources["blocks.2."] === "object") {
			this.sockets.inputs["blocks.2."].connectTo(sources["blocks.2."])
		} else {
			this.sockets.inputs["blocks.2."].value = sources["blocks.2."]
		}

		if (typeof sources["blocks.3."] === "object") {
			this.sockets.inputs["blocks.3."].connectTo(sources["blocks.3."])
		} else {
			this.sockets.inputs["blocks.3."].value = sources["blocks.3."]
		}

		if (typeof sources["blocks.4."] === "object") {
			this.sockets.inputs["blocks.4."].connectTo(sources["blocks.4."])
		} else {
			this.sockets.inputs["blocks.4."].value = sources["blocks.4."]
		}

		if (typeof sources["blocks.5."] === "object") {
			this.sockets.inputs["blocks.5."].connectTo(sources["blocks.5."])
		} else {
			this.sockets.inputs["blocks.5."].value = sources["blocks.5."]
		}

		if (typeof sources["blocks.6."] === "object") {
			this.sockets.inputs["blocks.6."].connectTo(sources["blocks.6."])
		} else {
			this.sockets.inputs["blocks.6."].value = sources["blocks.6."]
		}

		if (typeof sources["blocks.7."] === "object") {
			this.sockets.inputs["blocks.7."].connectTo(sources["blocks.7."])
		} else {
			this.sockets.inputs["blocks.7."].value = sources["blocks.7."]
		}

		if (typeof sources["blocks.8."] === "object") {
			this.sockets.inputs["blocks.8."].connectTo(sources["blocks.8."])
		} else {
			this.sockets.inputs["blocks.8."].value = sources["blocks.8."]
		}

		if (typeof sources["blocks.9."] === "object") {
			this.sockets.inputs["blocks.9."].connectTo(sources["blocks.9."])
		} else {
			this.sockets.inputs["blocks.9."].value = sources["blocks.9."]
		}

		if (typeof sources["blocks.10."] === "object") {
			this.sockets.inputs["blocks.10."].connectTo(sources["blocks.10."])
		} else {
			this.sockets.inputs["blocks.10."].value = sources["blocks.10."]
		}

		if (typeof sources["blocks.11."] === "object") {
			this.sockets.inputs["blocks.11."].connectTo(sources["blocks.11."])
		} else {
			this.sockets.inputs["blocks.11."].value = sources["blocks.11."]
		}

		if (typeof sources["blocks.12."] === "object") {
			this.sockets.inputs["blocks.12."].connectTo(sources["blocks.12."])
		} else {
			this.sockets.inputs["blocks.12."].value = sources["blocks.12."]
		}

		if (typeof sources["blocks.13."] === "object") {
			this.sockets.inputs["blocks.13."].connectTo(sources["blocks.13."])
		} else {
			this.sockets.inputs["blocks.13."].value = sources["blocks.13."]
		}

		if (typeof sources["blocks.14."] === "object") {
			this.sockets.inputs["blocks.14."].connectTo(sources["blocks.14."])
		} else {
			this.sockets.inputs["blocks.14."].value = sources["blocks.14."]
		}

		if (typeof sources["blocks.15."] === "object") {
			this.sockets.inputs["blocks.15."].connectTo(sources["blocks.15."])
		} else {
			this.sockets.inputs["blocks.15."].value = sources["blocks.15."]
		}

		if (typeof sources["blocks.16."] === "object") {
			this.sockets.inputs["blocks.16."].connectTo(sources["blocks.16."])
		} else {
			this.sockets.inputs["blocks.16."].value = sources["blocks.16."]
		}

		if (typeof sources["blocks.17."] === "object") {
			this.sockets.inputs["blocks.17."].connectTo(sources["blocks.17."])
		} else {
			this.sockets.inputs["blocks.17."].value = sources["blocks.17."]
		}

		if (typeof sources["blocks.18."] === "object") {
			this.sockets.inputs["blocks.18."].connectTo(sources["blocks.18."])
		} else {
			this.sockets.inputs["blocks.18."].value = sources["blocks.18."]
		}

		if (typeof sources["blocks.19."] === "object") {
			this.sockets.inputs["blocks.19."].connectTo(sources["blocks.19."])
		} else {
			this.sockets.inputs["blocks.19."].value = sources["blocks.19."]
		}

		if (typeof sources["blocks.20."] === "object") {
			this.sockets.inputs["blocks.20."].connectTo(sources["blocks.20."])
		} else {
			this.sockets.inputs["blocks.20."].value = sources["blocks.20."]
		}

		if (typeof sources["blocks.21."] === "object") {
			this.sockets.inputs["blocks.21."].connectTo(sources["blocks.21."])
		} else {
			this.sockets.inputs["blocks.21."].value = sources["blocks.21."]
		}

		if (typeof sources["blocks.22."] === "object") {
			this.sockets.inputs["blocks.22."].connectTo(sources["blocks.22."])
		} else {
			this.sockets.inputs["blocks.22."].value = sources["blocks.22."]
		}

		if (typeof sources["blocks.23."] === "object") {
			this.sockets.inputs["blocks.23."].connectTo(sources["blocks.23."])
		} else {
			this.sockets.inputs["blocks.23."].value = sources["blocks.23."]
		}

		if (typeof sources["blocks.24."] === "object") {
			this.sockets.inputs["blocks.24."].connectTo(sources["blocks.24."])
		} else {
			this.sockets.inputs["blocks.24."].value = sources["blocks.24."]
		}

		if (typeof sources["blocks.25."] === "object") {
			this.sockets.inputs["blocks.25."].connectTo(sources["blocks.25."])
		} else {
			this.sockets.inputs["blocks.25."].value = sources["blocks.25."]
		}

		if (typeof sources["blocks.26."] === "object") {
			this.sockets.inputs["blocks.26."].connectTo(sources["blocks.26."])
		} else {
			this.sockets.inputs["blocks.26."].value = sources["blocks.26."]
		}

		if (typeof sources["blocks.27."] === "object") {
			this.sockets.inputs["blocks.27."].connectTo(sources["blocks.27."])
		} else {
			this.sockets.inputs["blocks.27."].value = sources["blocks.27."]
		}

		if (typeof sources["final_layer."] === "object") {
			this.sockets.inputs["final_layer."].connectTo(sources["final_layer."])
		} else {
			this.sockets.inputs["final_layer."].value = sources["final_layer."]
		}

	}
}

type ModelMergeCosmosPredict2_2BInputs = {
			"model1": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model2": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"pos_embedder.": ComfyNodeTypedInputRef<number>
			"x_embedder.": ComfyNodeTypedInputRef<number>
			"t_embedder.": ComfyNodeTypedInputRef<number>
			"t_embedding_norm.": ComfyNodeTypedInputRef<number>
			"blocks.0.": ComfyNodeTypedInputRef<number>
			"blocks.1.": ComfyNodeTypedInputRef<number>
			"blocks.2.": ComfyNodeTypedInputRef<number>
			"blocks.3.": ComfyNodeTypedInputRef<number>
			"blocks.4.": ComfyNodeTypedInputRef<number>
			"blocks.5.": ComfyNodeTypedInputRef<number>
			"blocks.6.": ComfyNodeTypedInputRef<number>
			"blocks.7.": ComfyNodeTypedInputRef<number>
			"blocks.8.": ComfyNodeTypedInputRef<number>
			"blocks.9.": ComfyNodeTypedInputRef<number>
			"blocks.10.": ComfyNodeTypedInputRef<number>
			"blocks.11.": ComfyNodeTypedInputRef<number>
			"blocks.12.": ComfyNodeTypedInputRef<number>
			"blocks.13.": ComfyNodeTypedInputRef<number>
			"blocks.14.": ComfyNodeTypedInputRef<number>
			"blocks.15.": ComfyNodeTypedInputRef<number>
			"blocks.16.": ComfyNodeTypedInputRef<number>
			"blocks.17.": ComfyNodeTypedInputRef<number>
			"blocks.18.": ComfyNodeTypedInputRef<number>
			"blocks.19.": ComfyNodeTypedInputRef<number>
			"blocks.20.": ComfyNodeTypedInputRef<number>
			"blocks.21.": ComfyNodeTypedInputRef<number>
			"blocks.22.": ComfyNodeTypedInputRef<number>
			"blocks.23.": ComfyNodeTypedInputRef<number>
			"blocks.24.": ComfyNodeTypedInputRef<number>
			"blocks.25.": ComfyNodeTypedInputRef<number>
			"blocks.26.": ComfyNodeTypedInputRef<number>
			"blocks.27.": ComfyNodeTypedInputRef<number>
			"final_layer.": ComfyNodeTypedInputRef<number>
}


export class ModelMergeCosmosPredict2_14B extends ComfyNode {
	classType: string = "ModelMergeCosmosPredict2_14B"

	sockets: {
		inputs: Required<ModelMergeCosmosPredict2_14BInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model1": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model1"),
				"model2": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model2"),
				"pos_embedder.": new ComfyNodeTypedInputRef<number>(this, "pos_embedder."),
				"x_embedder.": new ComfyNodeTypedInputRef<number>(this, "x_embedder."),
				"t_embedder.": new ComfyNodeTypedInputRef<number>(this, "t_embedder."),
				"t_embedding_norm.": new ComfyNodeTypedInputRef<number>(this, "t_embedding_norm."),
				"blocks.0.": new ComfyNodeTypedInputRef<number>(this, "blocks.0."),
				"blocks.1.": new ComfyNodeTypedInputRef<number>(this, "blocks.1."),
				"blocks.2.": new ComfyNodeTypedInputRef<number>(this, "blocks.2."),
				"blocks.3.": new ComfyNodeTypedInputRef<number>(this, "blocks.3."),
				"blocks.4.": new ComfyNodeTypedInputRef<number>(this, "blocks.4."),
				"blocks.5.": new ComfyNodeTypedInputRef<number>(this, "blocks.5."),
				"blocks.6.": new ComfyNodeTypedInputRef<number>(this, "blocks.6."),
				"blocks.7.": new ComfyNodeTypedInputRef<number>(this, "blocks.7."),
				"blocks.8.": new ComfyNodeTypedInputRef<number>(this, "blocks.8."),
				"blocks.9.": new ComfyNodeTypedInputRef<number>(this, "blocks.9."),
				"blocks.10.": new ComfyNodeTypedInputRef<number>(this, "blocks.10."),
				"blocks.11.": new ComfyNodeTypedInputRef<number>(this, "blocks.11."),
				"blocks.12.": new ComfyNodeTypedInputRef<number>(this, "blocks.12."),
				"blocks.13.": new ComfyNodeTypedInputRef<number>(this, "blocks.13."),
				"blocks.14.": new ComfyNodeTypedInputRef<number>(this, "blocks.14."),
				"blocks.15.": new ComfyNodeTypedInputRef<number>(this, "blocks.15."),
				"blocks.16.": new ComfyNodeTypedInputRef<number>(this, "blocks.16."),
				"blocks.17.": new ComfyNodeTypedInputRef<number>(this, "blocks.17."),
				"blocks.18.": new ComfyNodeTypedInputRef<number>(this, "blocks.18."),
				"blocks.19.": new ComfyNodeTypedInputRef<number>(this, "blocks.19."),
				"blocks.20.": new ComfyNodeTypedInputRef<number>(this, "blocks.20."),
				"blocks.21.": new ComfyNodeTypedInputRef<number>(this, "blocks.21."),
				"blocks.22.": new ComfyNodeTypedInputRef<number>(this, "blocks.22."),
				"blocks.23.": new ComfyNodeTypedInputRef<number>(this, "blocks.23."),
				"blocks.24.": new ComfyNodeTypedInputRef<number>(this, "blocks.24."),
				"blocks.25.": new ComfyNodeTypedInputRef<number>(this, "blocks.25."),
				"blocks.26.": new ComfyNodeTypedInputRef<number>(this, "blocks.26."),
				"blocks.27.": new ComfyNodeTypedInputRef<number>(this, "blocks.27."),
				"blocks.28.": new ComfyNodeTypedInputRef<number>(this, "blocks.28."),
				"blocks.29.": new ComfyNodeTypedInputRef<number>(this, "blocks.29."),
				"blocks.30.": new ComfyNodeTypedInputRef<number>(this, "blocks.30."),
				"blocks.31.": new ComfyNodeTypedInputRef<number>(this, "blocks.31."),
				"blocks.32.": new ComfyNodeTypedInputRef<number>(this, "blocks.32."),
				"blocks.33.": new ComfyNodeTypedInputRef<number>(this, "blocks.33."),
				"blocks.34.": new ComfyNodeTypedInputRef<number>(this, "blocks.34."),
				"blocks.35.": new ComfyNodeTypedInputRef<number>(this, "blocks.35."),
				"final_layer.": new ComfyNodeTypedInputRef<number>(this, "final_layer."),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelMergeCosmosPredict2_14BInputs>) {
		if (typeof sources["model1"] === "object") {
			this.sockets.inputs["model1"].connectTo(sources["model1"])
		} else {
			this.sockets.inputs["model1"].value = sources["model1"]
		}

		if (typeof sources["model2"] === "object") {
			this.sockets.inputs["model2"].connectTo(sources["model2"])
		} else {
			this.sockets.inputs["model2"].value = sources["model2"]
		}

		if (typeof sources["pos_embedder."] === "object") {
			this.sockets.inputs["pos_embedder."].connectTo(sources["pos_embedder."])
		} else {
			this.sockets.inputs["pos_embedder."].value = sources["pos_embedder."]
		}

		if (typeof sources["x_embedder."] === "object") {
			this.sockets.inputs["x_embedder."].connectTo(sources["x_embedder."])
		} else {
			this.sockets.inputs["x_embedder."].value = sources["x_embedder."]
		}

		if (typeof sources["t_embedder."] === "object") {
			this.sockets.inputs["t_embedder."].connectTo(sources["t_embedder."])
		} else {
			this.sockets.inputs["t_embedder."].value = sources["t_embedder."]
		}

		if (typeof sources["t_embedding_norm."] === "object") {
			this.sockets.inputs["t_embedding_norm."].connectTo(sources["t_embedding_norm."])
		} else {
			this.sockets.inputs["t_embedding_norm."].value = sources["t_embedding_norm."]
		}

		if (typeof sources["blocks.0."] === "object") {
			this.sockets.inputs["blocks.0."].connectTo(sources["blocks.0."])
		} else {
			this.sockets.inputs["blocks.0."].value = sources["blocks.0."]
		}

		if (typeof sources["blocks.1."] === "object") {
			this.sockets.inputs["blocks.1."].connectTo(sources["blocks.1."])
		} else {
			this.sockets.inputs["blocks.1."].value = sources["blocks.1."]
		}

		if (typeof sources["blocks.2."] === "object") {
			this.sockets.inputs["blocks.2."].connectTo(sources["blocks.2."])
		} else {
			this.sockets.inputs["blocks.2."].value = sources["blocks.2."]
		}

		if (typeof sources["blocks.3."] === "object") {
			this.sockets.inputs["blocks.3."].connectTo(sources["blocks.3."])
		} else {
			this.sockets.inputs["blocks.3."].value = sources["blocks.3."]
		}

		if (typeof sources["blocks.4."] === "object") {
			this.sockets.inputs["blocks.4."].connectTo(sources["blocks.4."])
		} else {
			this.sockets.inputs["blocks.4."].value = sources["blocks.4."]
		}

		if (typeof sources["blocks.5."] === "object") {
			this.sockets.inputs["blocks.5."].connectTo(sources["blocks.5."])
		} else {
			this.sockets.inputs["blocks.5."].value = sources["blocks.5."]
		}

		if (typeof sources["blocks.6."] === "object") {
			this.sockets.inputs["blocks.6."].connectTo(sources["blocks.6."])
		} else {
			this.sockets.inputs["blocks.6."].value = sources["blocks.6."]
		}

		if (typeof sources["blocks.7."] === "object") {
			this.sockets.inputs["blocks.7."].connectTo(sources["blocks.7."])
		} else {
			this.sockets.inputs["blocks.7."].value = sources["blocks.7."]
		}

		if (typeof sources["blocks.8."] === "object") {
			this.sockets.inputs["blocks.8."].connectTo(sources["blocks.8."])
		} else {
			this.sockets.inputs["blocks.8."].value = sources["blocks.8."]
		}

		if (typeof sources["blocks.9."] === "object") {
			this.sockets.inputs["blocks.9."].connectTo(sources["blocks.9."])
		} else {
			this.sockets.inputs["blocks.9."].value = sources["blocks.9."]
		}

		if (typeof sources["blocks.10."] === "object") {
			this.sockets.inputs["blocks.10."].connectTo(sources["blocks.10."])
		} else {
			this.sockets.inputs["blocks.10."].value = sources["blocks.10."]
		}

		if (typeof sources["blocks.11."] === "object") {
			this.sockets.inputs["blocks.11."].connectTo(sources["blocks.11."])
		} else {
			this.sockets.inputs["blocks.11."].value = sources["blocks.11."]
		}

		if (typeof sources["blocks.12."] === "object") {
			this.sockets.inputs["blocks.12."].connectTo(sources["blocks.12."])
		} else {
			this.sockets.inputs["blocks.12."].value = sources["blocks.12."]
		}

		if (typeof sources["blocks.13."] === "object") {
			this.sockets.inputs["blocks.13."].connectTo(sources["blocks.13."])
		} else {
			this.sockets.inputs["blocks.13."].value = sources["blocks.13."]
		}

		if (typeof sources["blocks.14."] === "object") {
			this.sockets.inputs["blocks.14."].connectTo(sources["blocks.14."])
		} else {
			this.sockets.inputs["blocks.14."].value = sources["blocks.14."]
		}

		if (typeof sources["blocks.15."] === "object") {
			this.sockets.inputs["blocks.15."].connectTo(sources["blocks.15."])
		} else {
			this.sockets.inputs["blocks.15."].value = sources["blocks.15."]
		}

		if (typeof sources["blocks.16."] === "object") {
			this.sockets.inputs["blocks.16."].connectTo(sources["blocks.16."])
		} else {
			this.sockets.inputs["blocks.16."].value = sources["blocks.16."]
		}

		if (typeof sources["blocks.17."] === "object") {
			this.sockets.inputs["blocks.17."].connectTo(sources["blocks.17."])
		} else {
			this.sockets.inputs["blocks.17."].value = sources["blocks.17."]
		}

		if (typeof sources["blocks.18."] === "object") {
			this.sockets.inputs["blocks.18."].connectTo(sources["blocks.18."])
		} else {
			this.sockets.inputs["blocks.18."].value = sources["blocks.18."]
		}

		if (typeof sources["blocks.19."] === "object") {
			this.sockets.inputs["blocks.19."].connectTo(sources["blocks.19."])
		} else {
			this.sockets.inputs["blocks.19."].value = sources["blocks.19."]
		}

		if (typeof sources["blocks.20."] === "object") {
			this.sockets.inputs["blocks.20."].connectTo(sources["blocks.20."])
		} else {
			this.sockets.inputs["blocks.20."].value = sources["blocks.20."]
		}

		if (typeof sources["blocks.21."] === "object") {
			this.sockets.inputs["blocks.21."].connectTo(sources["blocks.21."])
		} else {
			this.sockets.inputs["blocks.21."].value = sources["blocks.21."]
		}

		if (typeof sources["blocks.22."] === "object") {
			this.sockets.inputs["blocks.22."].connectTo(sources["blocks.22."])
		} else {
			this.sockets.inputs["blocks.22."].value = sources["blocks.22."]
		}

		if (typeof sources["blocks.23."] === "object") {
			this.sockets.inputs["blocks.23."].connectTo(sources["blocks.23."])
		} else {
			this.sockets.inputs["blocks.23."].value = sources["blocks.23."]
		}

		if (typeof sources["blocks.24."] === "object") {
			this.sockets.inputs["blocks.24."].connectTo(sources["blocks.24."])
		} else {
			this.sockets.inputs["blocks.24."].value = sources["blocks.24."]
		}

		if (typeof sources["blocks.25."] === "object") {
			this.sockets.inputs["blocks.25."].connectTo(sources["blocks.25."])
		} else {
			this.sockets.inputs["blocks.25."].value = sources["blocks.25."]
		}

		if (typeof sources["blocks.26."] === "object") {
			this.sockets.inputs["blocks.26."].connectTo(sources["blocks.26."])
		} else {
			this.sockets.inputs["blocks.26."].value = sources["blocks.26."]
		}

		if (typeof sources["blocks.27."] === "object") {
			this.sockets.inputs["blocks.27."].connectTo(sources["blocks.27."])
		} else {
			this.sockets.inputs["blocks.27."].value = sources["blocks.27."]
		}

		if (typeof sources["blocks.28."] === "object") {
			this.sockets.inputs["blocks.28."].connectTo(sources["blocks.28."])
		} else {
			this.sockets.inputs["blocks.28."].value = sources["blocks.28."]
		}

		if (typeof sources["blocks.29."] === "object") {
			this.sockets.inputs["blocks.29."].connectTo(sources["blocks.29."])
		} else {
			this.sockets.inputs["blocks.29."].value = sources["blocks.29."]
		}

		if (typeof sources["blocks.30."] === "object") {
			this.sockets.inputs["blocks.30."].connectTo(sources["blocks.30."])
		} else {
			this.sockets.inputs["blocks.30."].value = sources["blocks.30."]
		}

		if (typeof sources["blocks.31."] === "object") {
			this.sockets.inputs["blocks.31."].connectTo(sources["blocks.31."])
		} else {
			this.sockets.inputs["blocks.31."].value = sources["blocks.31."]
		}

		if (typeof sources["blocks.32."] === "object") {
			this.sockets.inputs["blocks.32."].connectTo(sources["blocks.32."])
		} else {
			this.sockets.inputs["blocks.32."].value = sources["blocks.32."]
		}

		if (typeof sources["blocks.33."] === "object") {
			this.sockets.inputs["blocks.33."].connectTo(sources["blocks.33."])
		} else {
			this.sockets.inputs["blocks.33."].value = sources["blocks.33."]
		}

		if (typeof sources["blocks.34."] === "object") {
			this.sockets.inputs["blocks.34."].connectTo(sources["blocks.34."])
		} else {
			this.sockets.inputs["blocks.34."].value = sources["blocks.34."]
		}

		if (typeof sources["blocks.35."] === "object") {
			this.sockets.inputs["blocks.35."].connectTo(sources["blocks.35."])
		} else {
			this.sockets.inputs["blocks.35."].value = sources["blocks.35."]
		}

		if (typeof sources["final_layer."] === "object") {
			this.sockets.inputs["final_layer."].connectTo(sources["final_layer."])
		} else {
			this.sockets.inputs["final_layer."].value = sources["final_layer."]
		}

	}
}

type ModelMergeCosmosPredict2_14BInputs = {
			"model1": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model2": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"pos_embedder.": ComfyNodeTypedInputRef<number>
			"x_embedder.": ComfyNodeTypedInputRef<number>
			"t_embedder.": ComfyNodeTypedInputRef<number>
			"t_embedding_norm.": ComfyNodeTypedInputRef<number>
			"blocks.0.": ComfyNodeTypedInputRef<number>
			"blocks.1.": ComfyNodeTypedInputRef<number>
			"blocks.2.": ComfyNodeTypedInputRef<number>
			"blocks.3.": ComfyNodeTypedInputRef<number>
			"blocks.4.": ComfyNodeTypedInputRef<number>
			"blocks.5.": ComfyNodeTypedInputRef<number>
			"blocks.6.": ComfyNodeTypedInputRef<number>
			"blocks.7.": ComfyNodeTypedInputRef<number>
			"blocks.8.": ComfyNodeTypedInputRef<number>
			"blocks.9.": ComfyNodeTypedInputRef<number>
			"blocks.10.": ComfyNodeTypedInputRef<number>
			"blocks.11.": ComfyNodeTypedInputRef<number>
			"blocks.12.": ComfyNodeTypedInputRef<number>
			"blocks.13.": ComfyNodeTypedInputRef<number>
			"blocks.14.": ComfyNodeTypedInputRef<number>
			"blocks.15.": ComfyNodeTypedInputRef<number>
			"blocks.16.": ComfyNodeTypedInputRef<number>
			"blocks.17.": ComfyNodeTypedInputRef<number>
			"blocks.18.": ComfyNodeTypedInputRef<number>
			"blocks.19.": ComfyNodeTypedInputRef<number>
			"blocks.20.": ComfyNodeTypedInputRef<number>
			"blocks.21.": ComfyNodeTypedInputRef<number>
			"blocks.22.": ComfyNodeTypedInputRef<number>
			"blocks.23.": ComfyNodeTypedInputRef<number>
			"blocks.24.": ComfyNodeTypedInputRef<number>
			"blocks.25.": ComfyNodeTypedInputRef<number>
			"blocks.26.": ComfyNodeTypedInputRef<number>
			"blocks.27.": ComfyNodeTypedInputRef<number>
			"blocks.28.": ComfyNodeTypedInputRef<number>
			"blocks.29.": ComfyNodeTypedInputRef<number>
			"blocks.30.": ComfyNodeTypedInputRef<number>
			"blocks.31.": ComfyNodeTypedInputRef<number>
			"blocks.32.": ComfyNodeTypedInputRef<number>
			"blocks.33.": ComfyNodeTypedInputRef<number>
			"blocks.34.": ComfyNodeTypedInputRef<number>
			"blocks.35.": ComfyNodeTypedInputRef<number>
			"final_layer.": ComfyNodeTypedInputRef<number>
}


export class ModelMergeQwenImage extends ComfyNode {
	classType: string = "ModelMergeQwenImage"

	sockets: {
		inputs: Required<ModelMergeQwenImageInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model1": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model1"),
				"model2": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model2"),
				"pos_embeds.": new ComfyNodeTypedInputRef<number>(this, "pos_embeds."),
				"img_in.": new ComfyNodeTypedInputRef<number>(this, "img_in."),
				"txt_norm.": new ComfyNodeTypedInputRef<number>(this, "txt_norm."),
				"txt_in.": new ComfyNodeTypedInputRef<number>(this, "txt_in."),
				"time_text_embed.": new ComfyNodeTypedInputRef<number>(this, "time_text_embed."),
				"transformer_blocks.0.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.0."),
				"transformer_blocks.1.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.1."),
				"transformer_blocks.2.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.2."),
				"transformer_blocks.3.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.3."),
				"transformer_blocks.4.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.4."),
				"transformer_blocks.5.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.5."),
				"transformer_blocks.6.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.6."),
				"transformer_blocks.7.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.7."),
				"transformer_blocks.8.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.8."),
				"transformer_blocks.9.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.9."),
				"transformer_blocks.10.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.10."),
				"transformer_blocks.11.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.11."),
				"transformer_blocks.12.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.12."),
				"transformer_blocks.13.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.13."),
				"transformer_blocks.14.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.14."),
				"transformer_blocks.15.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.15."),
				"transformer_blocks.16.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.16."),
				"transformer_blocks.17.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.17."),
				"transformer_blocks.18.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.18."),
				"transformer_blocks.19.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.19."),
				"transformer_blocks.20.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.20."),
				"transformer_blocks.21.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.21."),
				"transformer_blocks.22.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.22."),
				"transformer_blocks.23.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.23."),
				"transformer_blocks.24.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.24."),
				"transformer_blocks.25.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.25."),
				"transformer_blocks.26.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.26."),
				"transformer_blocks.27.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.27."),
				"transformer_blocks.28.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.28."),
				"transformer_blocks.29.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.29."),
				"transformer_blocks.30.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.30."),
				"transformer_blocks.31.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.31."),
				"transformer_blocks.32.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.32."),
				"transformer_blocks.33.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.33."),
				"transformer_blocks.34.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.34."),
				"transformer_blocks.35.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.35."),
				"transformer_blocks.36.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.36."),
				"transformer_blocks.37.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.37."),
				"transformer_blocks.38.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.38."),
				"transformer_blocks.39.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.39."),
				"transformer_blocks.40.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.40."),
				"transformer_blocks.41.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.41."),
				"transformer_blocks.42.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.42."),
				"transformer_blocks.43.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.43."),
				"transformer_blocks.44.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.44."),
				"transformer_blocks.45.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.45."),
				"transformer_blocks.46.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.46."),
				"transformer_blocks.47.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.47."),
				"transformer_blocks.48.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.48."),
				"transformer_blocks.49.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.49."),
				"transformer_blocks.50.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.50."),
				"transformer_blocks.51.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.51."),
				"transformer_blocks.52.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.52."),
				"transformer_blocks.53.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.53."),
				"transformer_blocks.54.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.54."),
				"transformer_blocks.55.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.55."),
				"transformer_blocks.56.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.56."),
				"transformer_blocks.57.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.57."),
				"transformer_blocks.58.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.58."),
				"transformer_blocks.59.": new ComfyNodeTypedInputRef<number>(this, "transformer_blocks.59."),
				"proj_out.": new ComfyNodeTypedInputRef<number>(this, "proj_out."),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelMergeQwenImageInputs>) {
		if (typeof sources["model1"] === "object") {
			this.sockets.inputs["model1"].connectTo(sources["model1"])
		} else {
			this.sockets.inputs["model1"].value = sources["model1"]
		}

		if (typeof sources["model2"] === "object") {
			this.sockets.inputs["model2"].connectTo(sources["model2"])
		} else {
			this.sockets.inputs["model2"].value = sources["model2"]
		}

		if (typeof sources["pos_embeds."] === "object") {
			this.sockets.inputs["pos_embeds."].connectTo(sources["pos_embeds."])
		} else {
			this.sockets.inputs["pos_embeds."].value = sources["pos_embeds."]
		}

		if (typeof sources["img_in."] === "object") {
			this.sockets.inputs["img_in."].connectTo(sources["img_in."])
		} else {
			this.sockets.inputs["img_in."].value = sources["img_in."]
		}

		if (typeof sources["txt_norm."] === "object") {
			this.sockets.inputs["txt_norm."].connectTo(sources["txt_norm."])
		} else {
			this.sockets.inputs["txt_norm."].value = sources["txt_norm."]
		}

		if (typeof sources["txt_in."] === "object") {
			this.sockets.inputs["txt_in."].connectTo(sources["txt_in."])
		} else {
			this.sockets.inputs["txt_in."].value = sources["txt_in."]
		}

		if (typeof sources["time_text_embed."] === "object") {
			this.sockets.inputs["time_text_embed."].connectTo(sources["time_text_embed."])
		} else {
			this.sockets.inputs["time_text_embed."].value = sources["time_text_embed."]
		}

		if (typeof sources["transformer_blocks.0."] === "object") {
			this.sockets.inputs["transformer_blocks.0."].connectTo(sources["transformer_blocks.0."])
		} else {
			this.sockets.inputs["transformer_blocks.0."].value = sources["transformer_blocks.0."]
		}

		if (typeof sources["transformer_blocks.1."] === "object") {
			this.sockets.inputs["transformer_blocks.1."].connectTo(sources["transformer_blocks.1."])
		} else {
			this.sockets.inputs["transformer_blocks.1."].value = sources["transformer_blocks.1."]
		}

		if (typeof sources["transformer_blocks.2."] === "object") {
			this.sockets.inputs["transformer_blocks.2."].connectTo(sources["transformer_blocks.2."])
		} else {
			this.sockets.inputs["transformer_blocks.2."].value = sources["transformer_blocks.2."]
		}

		if (typeof sources["transformer_blocks.3."] === "object") {
			this.sockets.inputs["transformer_blocks.3."].connectTo(sources["transformer_blocks.3."])
		} else {
			this.sockets.inputs["transformer_blocks.3."].value = sources["transformer_blocks.3."]
		}

		if (typeof sources["transformer_blocks.4."] === "object") {
			this.sockets.inputs["transformer_blocks.4."].connectTo(sources["transformer_blocks.4."])
		} else {
			this.sockets.inputs["transformer_blocks.4."].value = sources["transformer_blocks.4."]
		}

		if (typeof sources["transformer_blocks.5."] === "object") {
			this.sockets.inputs["transformer_blocks.5."].connectTo(sources["transformer_blocks.5."])
		} else {
			this.sockets.inputs["transformer_blocks.5."].value = sources["transformer_blocks.5."]
		}

		if (typeof sources["transformer_blocks.6."] === "object") {
			this.sockets.inputs["transformer_blocks.6."].connectTo(sources["transformer_blocks.6."])
		} else {
			this.sockets.inputs["transformer_blocks.6."].value = sources["transformer_blocks.6."]
		}

		if (typeof sources["transformer_blocks.7."] === "object") {
			this.sockets.inputs["transformer_blocks.7."].connectTo(sources["transformer_blocks.7."])
		} else {
			this.sockets.inputs["transformer_blocks.7."].value = sources["transformer_blocks.7."]
		}

		if (typeof sources["transformer_blocks.8."] === "object") {
			this.sockets.inputs["transformer_blocks.8."].connectTo(sources["transformer_blocks.8."])
		} else {
			this.sockets.inputs["transformer_blocks.8."].value = sources["transformer_blocks.8."]
		}

		if (typeof sources["transformer_blocks.9."] === "object") {
			this.sockets.inputs["transformer_blocks.9."].connectTo(sources["transformer_blocks.9."])
		} else {
			this.sockets.inputs["transformer_blocks.9."].value = sources["transformer_blocks.9."]
		}

		if (typeof sources["transformer_blocks.10."] === "object") {
			this.sockets.inputs["transformer_blocks.10."].connectTo(sources["transformer_blocks.10."])
		} else {
			this.sockets.inputs["transformer_blocks.10."].value = sources["transformer_blocks.10."]
		}

		if (typeof sources["transformer_blocks.11."] === "object") {
			this.sockets.inputs["transformer_blocks.11."].connectTo(sources["transformer_blocks.11."])
		} else {
			this.sockets.inputs["transformer_blocks.11."].value = sources["transformer_blocks.11."]
		}

		if (typeof sources["transformer_blocks.12."] === "object") {
			this.sockets.inputs["transformer_blocks.12."].connectTo(sources["transformer_blocks.12."])
		} else {
			this.sockets.inputs["transformer_blocks.12."].value = sources["transformer_blocks.12."]
		}

		if (typeof sources["transformer_blocks.13."] === "object") {
			this.sockets.inputs["transformer_blocks.13."].connectTo(sources["transformer_blocks.13."])
		} else {
			this.sockets.inputs["transformer_blocks.13."].value = sources["transformer_blocks.13."]
		}

		if (typeof sources["transformer_blocks.14."] === "object") {
			this.sockets.inputs["transformer_blocks.14."].connectTo(sources["transformer_blocks.14."])
		} else {
			this.sockets.inputs["transformer_blocks.14."].value = sources["transformer_blocks.14."]
		}

		if (typeof sources["transformer_blocks.15."] === "object") {
			this.sockets.inputs["transformer_blocks.15."].connectTo(sources["transformer_blocks.15."])
		} else {
			this.sockets.inputs["transformer_blocks.15."].value = sources["transformer_blocks.15."]
		}

		if (typeof sources["transformer_blocks.16."] === "object") {
			this.sockets.inputs["transformer_blocks.16."].connectTo(sources["transformer_blocks.16."])
		} else {
			this.sockets.inputs["transformer_blocks.16."].value = sources["transformer_blocks.16."]
		}

		if (typeof sources["transformer_blocks.17."] === "object") {
			this.sockets.inputs["transformer_blocks.17."].connectTo(sources["transformer_blocks.17."])
		} else {
			this.sockets.inputs["transformer_blocks.17."].value = sources["transformer_blocks.17."]
		}

		if (typeof sources["transformer_blocks.18."] === "object") {
			this.sockets.inputs["transformer_blocks.18."].connectTo(sources["transformer_blocks.18."])
		} else {
			this.sockets.inputs["transformer_blocks.18."].value = sources["transformer_blocks.18."]
		}

		if (typeof sources["transformer_blocks.19."] === "object") {
			this.sockets.inputs["transformer_blocks.19."].connectTo(sources["transformer_blocks.19."])
		} else {
			this.sockets.inputs["transformer_blocks.19."].value = sources["transformer_blocks.19."]
		}

		if (typeof sources["transformer_blocks.20."] === "object") {
			this.sockets.inputs["transformer_blocks.20."].connectTo(sources["transformer_blocks.20."])
		} else {
			this.sockets.inputs["transformer_blocks.20."].value = sources["transformer_blocks.20."]
		}

		if (typeof sources["transformer_blocks.21."] === "object") {
			this.sockets.inputs["transformer_blocks.21."].connectTo(sources["transformer_blocks.21."])
		} else {
			this.sockets.inputs["transformer_blocks.21."].value = sources["transformer_blocks.21."]
		}

		if (typeof sources["transformer_blocks.22."] === "object") {
			this.sockets.inputs["transformer_blocks.22."].connectTo(sources["transformer_blocks.22."])
		} else {
			this.sockets.inputs["transformer_blocks.22."].value = sources["transformer_blocks.22."]
		}

		if (typeof sources["transformer_blocks.23."] === "object") {
			this.sockets.inputs["transformer_blocks.23."].connectTo(sources["transformer_blocks.23."])
		} else {
			this.sockets.inputs["transformer_blocks.23."].value = sources["transformer_blocks.23."]
		}

		if (typeof sources["transformer_blocks.24."] === "object") {
			this.sockets.inputs["transformer_blocks.24."].connectTo(sources["transformer_blocks.24."])
		} else {
			this.sockets.inputs["transformer_blocks.24."].value = sources["transformer_blocks.24."]
		}

		if (typeof sources["transformer_blocks.25."] === "object") {
			this.sockets.inputs["transformer_blocks.25."].connectTo(sources["transformer_blocks.25."])
		} else {
			this.sockets.inputs["transformer_blocks.25."].value = sources["transformer_blocks.25."]
		}

		if (typeof sources["transformer_blocks.26."] === "object") {
			this.sockets.inputs["transformer_blocks.26."].connectTo(sources["transformer_blocks.26."])
		} else {
			this.sockets.inputs["transformer_blocks.26."].value = sources["transformer_blocks.26."]
		}

		if (typeof sources["transformer_blocks.27."] === "object") {
			this.sockets.inputs["transformer_blocks.27."].connectTo(sources["transformer_blocks.27."])
		} else {
			this.sockets.inputs["transformer_blocks.27."].value = sources["transformer_blocks.27."]
		}

		if (typeof sources["transformer_blocks.28."] === "object") {
			this.sockets.inputs["transformer_blocks.28."].connectTo(sources["transformer_blocks.28."])
		} else {
			this.sockets.inputs["transformer_blocks.28."].value = sources["transformer_blocks.28."]
		}

		if (typeof sources["transformer_blocks.29."] === "object") {
			this.sockets.inputs["transformer_blocks.29."].connectTo(sources["transformer_blocks.29."])
		} else {
			this.sockets.inputs["transformer_blocks.29."].value = sources["transformer_blocks.29."]
		}

		if (typeof sources["transformer_blocks.30."] === "object") {
			this.sockets.inputs["transformer_blocks.30."].connectTo(sources["transformer_blocks.30."])
		} else {
			this.sockets.inputs["transformer_blocks.30."].value = sources["transformer_blocks.30."]
		}

		if (typeof sources["transformer_blocks.31."] === "object") {
			this.sockets.inputs["transformer_blocks.31."].connectTo(sources["transformer_blocks.31."])
		} else {
			this.sockets.inputs["transformer_blocks.31."].value = sources["transformer_blocks.31."]
		}

		if (typeof sources["transformer_blocks.32."] === "object") {
			this.sockets.inputs["transformer_blocks.32."].connectTo(sources["transformer_blocks.32."])
		} else {
			this.sockets.inputs["transformer_blocks.32."].value = sources["transformer_blocks.32."]
		}

		if (typeof sources["transformer_blocks.33."] === "object") {
			this.sockets.inputs["transformer_blocks.33."].connectTo(sources["transformer_blocks.33."])
		} else {
			this.sockets.inputs["transformer_blocks.33."].value = sources["transformer_blocks.33."]
		}

		if (typeof sources["transformer_blocks.34."] === "object") {
			this.sockets.inputs["transformer_blocks.34."].connectTo(sources["transformer_blocks.34."])
		} else {
			this.sockets.inputs["transformer_blocks.34."].value = sources["transformer_blocks.34."]
		}

		if (typeof sources["transformer_blocks.35."] === "object") {
			this.sockets.inputs["transformer_blocks.35."].connectTo(sources["transformer_blocks.35."])
		} else {
			this.sockets.inputs["transformer_blocks.35."].value = sources["transformer_blocks.35."]
		}

		if (typeof sources["transformer_blocks.36."] === "object") {
			this.sockets.inputs["transformer_blocks.36."].connectTo(sources["transformer_blocks.36."])
		} else {
			this.sockets.inputs["transformer_blocks.36."].value = sources["transformer_blocks.36."]
		}

		if (typeof sources["transformer_blocks.37."] === "object") {
			this.sockets.inputs["transformer_blocks.37."].connectTo(sources["transformer_blocks.37."])
		} else {
			this.sockets.inputs["transformer_blocks.37."].value = sources["transformer_blocks.37."]
		}

		if (typeof sources["transformer_blocks.38."] === "object") {
			this.sockets.inputs["transformer_blocks.38."].connectTo(sources["transformer_blocks.38."])
		} else {
			this.sockets.inputs["transformer_blocks.38."].value = sources["transformer_blocks.38."]
		}

		if (typeof sources["transformer_blocks.39."] === "object") {
			this.sockets.inputs["transformer_blocks.39."].connectTo(sources["transformer_blocks.39."])
		} else {
			this.sockets.inputs["transformer_blocks.39."].value = sources["transformer_blocks.39."]
		}

		if (typeof sources["transformer_blocks.40."] === "object") {
			this.sockets.inputs["transformer_blocks.40."].connectTo(sources["transformer_blocks.40."])
		} else {
			this.sockets.inputs["transformer_blocks.40."].value = sources["transformer_blocks.40."]
		}

		if (typeof sources["transformer_blocks.41."] === "object") {
			this.sockets.inputs["transformer_blocks.41."].connectTo(sources["transformer_blocks.41."])
		} else {
			this.sockets.inputs["transformer_blocks.41."].value = sources["transformer_blocks.41."]
		}

		if (typeof sources["transformer_blocks.42."] === "object") {
			this.sockets.inputs["transformer_blocks.42."].connectTo(sources["transformer_blocks.42."])
		} else {
			this.sockets.inputs["transformer_blocks.42."].value = sources["transformer_blocks.42."]
		}

		if (typeof sources["transformer_blocks.43."] === "object") {
			this.sockets.inputs["transformer_blocks.43."].connectTo(sources["transformer_blocks.43."])
		} else {
			this.sockets.inputs["transformer_blocks.43."].value = sources["transformer_blocks.43."]
		}

		if (typeof sources["transformer_blocks.44."] === "object") {
			this.sockets.inputs["transformer_blocks.44."].connectTo(sources["transformer_blocks.44."])
		} else {
			this.sockets.inputs["transformer_blocks.44."].value = sources["transformer_blocks.44."]
		}

		if (typeof sources["transformer_blocks.45."] === "object") {
			this.sockets.inputs["transformer_blocks.45."].connectTo(sources["transformer_blocks.45."])
		} else {
			this.sockets.inputs["transformer_blocks.45."].value = sources["transformer_blocks.45."]
		}

		if (typeof sources["transformer_blocks.46."] === "object") {
			this.sockets.inputs["transformer_blocks.46."].connectTo(sources["transformer_blocks.46."])
		} else {
			this.sockets.inputs["transformer_blocks.46."].value = sources["transformer_blocks.46."]
		}

		if (typeof sources["transformer_blocks.47."] === "object") {
			this.sockets.inputs["transformer_blocks.47."].connectTo(sources["transformer_blocks.47."])
		} else {
			this.sockets.inputs["transformer_blocks.47."].value = sources["transformer_blocks.47."]
		}

		if (typeof sources["transformer_blocks.48."] === "object") {
			this.sockets.inputs["transformer_blocks.48."].connectTo(sources["transformer_blocks.48."])
		} else {
			this.sockets.inputs["transformer_blocks.48."].value = sources["transformer_blocks.48."]
		}

		if (typeof sources["transformer_blocks.49."] === "object") {
			this.sockets.inputs["transformer_blocks.49."].connectTo(sources["transformer_blocks.49."])
		} else {
			this.sockets.inputs["transformer_blocks.49."].value = sources["transformer_blocks.49."]
		}

		if (typeof sources["transformer_blocks.50."] === "object") {
			this.sockets.inputs["transformer_blocks.50."].connectTo(sources["transformer_blocks.50."])
		} else {
			this.sockets.inputs["transformer_blocks.50."].value = sources["transformer_blocks.50."]
		}

		if (typeof sources["transformer_blocks.51."] === "object") {
			this.sockets.inputs["transformer_blocks.51."].connectTo(sources["transformer_blocks.51."])
		} else {
			this.sockets.inputs["transformer_blocks.51."].value = sources["transformer_blocks.51."]
		}

		if (typeof sources["transformer_blocks.52."] === "object") {
			this.sockets.inputs["transformer_blocks.52."].connectTo(sources["transformer_blocks.52."])
		} else {
			this.sockets.inputs["transformer_blocks.52."].value = sources["transformer_blocks.52."]
		}

		if (typeof sources["transformer_blocks.53."] === "object") {
			this.sockets.inputs["transformer_blocks.53."].connectTo(sources["transformer_blocks.53."])
		} else {
			this.sockets.inputs["transformer_blocks.53."].value = sources["transformer_blocks.53."]
		}

		if (typeof sources["transformer_blocks.54."] === "object") {
			this.sockets.inputs["transformer_blocks.54."].connectTo(sources["transformer_blocks.54."])
		} else {
			this.sockets.inputs["transformer_blocks.54."].value = sources["transformer_blocks.54."]
		}

		if (typeof sources["transformer_blocks.55."] === "object") {
			this.sockets.inputs["transformer_blocks.55."].connectTo(sources["transformer_blocks.55."])
		} else {
			this.sockets.inputs["transformer_blocks.55."].value = sources["transformer_blocks.55."]
		}

		if (typeof sources["transformer_blocks.56."] === "object") {
			this.sockets.inputs["transformer_blocks.56."].connectTo(sources["transformer_blocks.56."])
		} else {
			this.sockets.inputs["transformer_blocks.56."].value = sources["transformer_blocks.56."]
		}

		if (typeof sources["transformer_blocks.57."] === "object") {
			this.sockets.inputs["transformer_blocks.57."].connectTo(sources["transformer_blocks.57."])
		} else {
			this.sockets.inputs["transformer_blocks.57."].value = sources["transformer_blocks.57."]
		}

		if (typeof sources["transformer_blocks.58."] === "object") {
			this.sockets.inputs["transformer_blocks.58."].connectTo(sources["transformer_blocks.58."])
		} else {
			this.sockets.inputs["transformer_blocks.58."].value = sources["transformer_blocks.58."]
		}

		if (typeof sources["transformer_blocks.59."] === "object") {
			this.sockets.inputs["transformer_blocks.59."].connectTo(sources["transformer_blocks.59."])
		} else {
			this.sockets.inputs["transformer_blocks.59."].value = sources["transformer_blocks.59."]
		}

		if (typeof sources["proj_out."] === "object") {
			this.sockets.inputs["proj_out."].connectTo(sources["proj_out."])
		} else {
			this.sockets.inputs["proj_out."].value = sources["proj_out."]
		}

	}
}

type ModelMergeQwenImageInputs = {
			"model1": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model2": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"pos_embeds.": ComfyNodeTypedInputRef<number>
			"img_in.": ComfyNodeTypedInputRef<number>
			"txt_norm.": ComfyNodeTypedInputRef<number>
			"txt_in.": ComfyNodeTypedInputRef<number>
			"time_text_embed.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.0.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.1.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.2.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.3.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.4.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.5.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.6.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.7.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.8.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.9.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.10.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.11.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.12.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.13.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.14.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.15.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.16.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.17.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.18.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.19.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.20.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.21.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.22.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.23.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.24.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.25.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.26.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.27.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.28.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.29.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.30.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.31.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.32.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.33.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.34.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.35.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.36.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.37.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.38.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.39.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.40.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.41.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.42.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.43.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.44.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.45.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.46.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.47.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.48.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.49.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.50.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.51.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.52.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.53.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.54.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.55.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.56.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.57.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.58.": ComfyNodeTypedInputRef<number>
			"transformer_blocks.59.": ComfyNodeTypedInputRef<number>
			"proj_out.": ComfyNodeTypedInputRef<number>
}


export class PerturbedAttentionGuidance extends ComfyNode {
	classType: string = "PerturbedAttentionGuidance"

	sockets: {
		inputs: Required<PerturbedAttentionGuidanceInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"scale": new ComfyNodeTypedInputRef<number>(this, "scale"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PerturbedAttentionGuidanceInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["scale"] === "object") {
			this.sockets.inputs["scale"].connectTo(sources["scale"])
		} else {
			this.sockets.inputs["scale"].value = sources["scale"]
		}

	}
}

type PerturbedAttentionGuidanceInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"scale": ComfyNodeTypedInputRef<number>
}


export class AlignYourStepsScheduler extends ComfyNode {
	classType: string = "AlignYourStepsScheduler"

	sockets: {
		inputs: Required<AlignYourStepsSchedulerInputs>
		outputs: {
			SIGMAS: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_type": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "model_type"),
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"denoise": new ComfyNodeTypedInputRef<number>(this, "denoise"),
			},
			outputs: Object.create(Object.prototype, {
				"SIGMAS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<AlignYourStepsSchedulerInputs>) {
		if (typeof sources["model_type"] === "object") {
			this.sockets.inputs["model_type"].connectTo(sources["model_type"])
		} else {
			this.sockets.inputs["model_type"].value = sources["model_type"]
		}

		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["denoise"] === "object") {
			this.sockets.inputs["denoise"].connectTo(sources["denoise"])
		} else {
			this.sockets.inputs["denoise"].value = sources["denoise"]
		}

	}
}

type AlignYourStepsSchedulerInputs = {
			"model_type": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"steps": ComfyNodeTypedInputRef<number>
			"denoise": ComfyNodeTypedInputRef<number>
}


export class UNetSelfAttentionMultiply extends ComfyNode {
	classType: string = "UNetSelfAttentionMultiply"

	sockets: {
		inputs: Required<UNetSelfAttentionMultiplyInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"q": new ComfyNodeTypedInputRef<number>(this, "q"),
				"k": new ComfyNodeTypedInputRef<number>(this, "k"),
				"v": new ComfyNodeTypedInputRef<number>(this, "v"),
				"out": new ComfyNodeTypedInputRef<number>(this, "out"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<UNetSelfAttentionMultiplyInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["q"] === "object") {
			this.sockets.inputs["q"].connectTo(sources["q"])
		} else {
			this.sockets.inputs["q"].value = sources["q"]
		}

		if (typeof sources["k"] === "object") {
			this.sockets.inputs["k"].connectTo(sources["k"])
		} else {
			this.sockets.inputs["k"].value = sources["k"]
		}

		if (typeof sources["v"] === "object") {
			this.sockets.inputs["v"].connectTo(sources["v"])
		} else {
			this.sockets.inputs["v"].value = sources["v"]
		}

		if (typeof sources["out"] === "object") {
			this.sockets.inputs["out"].connectTo(sources["out"])
		} else {
			this.sockets.inputs["out"].value = sources["out"]
		}

	}
}

type UNetSelfAttentionMultiplyInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"q": ComfyNodeTypedInputRef<number>
			"k": ComfyNodeTypedInputRef<number>
			"v": ComfyNodeTypedInputRef<number>
			"out": ComfyNodeTypedInputRef<number>
}


export class UNetCrossAttentionMultiply extends ComfyNode {
	classType: string = "UNetCrossAttentionMultiply"

	sockets: {
		inputs: Required<UNetCrossAttentionMultiplyInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"q": new ComfyNodeTypedInputRef<number>(this, "q"),
				"k": new ComfyNodeTypedInputRef<number>(this, "k"),
				"v": new ComfyNodeTypedInputRef<number>(this, "v"),
				"out": new ComfyNodeTypedInputRef<number>(this, "out"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<UNetCrossAttentionMultiplyInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["q"] === "object") {
			this.sockets.inputs["q"].connectTo(sources["q"])
		} else {
			this.sockets.inputs["q"].value = sources["q"]
		}

		if (typeof sources["k"] === "object") {
			this.sockets.inputs["k"].connectTo(sources["k"])
		} else {
			this.sockets.inputs["k"].value = sources["k"]
		}

		if (typeof sources["v"] === "object") {
			this.sockets.inputs["v"].connectTo(sources["v"])
		} else {
			this.sockets.inputs["v"].value = sources["v"]
		}

		if (typeof sources["out"] === "object") {
			this.sockets.inputs["out"].connectTo(sources["out"])
		} else {
			this.sockets.inputs["out"].value = sources["out"]
		}

	}
}

type UNetCrossAttentionMultiplyInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"q": ComfyNodeTypedInputRef<number>
			"k": ComfyNodeTypedInputRef<number>
			"v": ComfyNodeTypedInputRef<number>
			"out": ComfyNodeTypedInputRef<number>
}


export class CLIPAttentionMultiply extends ComfyNode {
	classType: string = "CLIPAttentionMultiply"

	sockets: {
		inputs: Required<CLIPAttentionMultiplyInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"q": new ComfyNodeTypedInputRef<number>(this, "q"),
				"k": new ComfyNodeTypedInputRef<number>(this, "k"),
				"v": new ComfyNodeTypedInputRef<number>(this, "v"),
				"out": new ComfyNodeTypedInputRef<number>(this, "out"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPAttentionMultiplyInputs>) {
		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["q"] === "object") {
			this.sockets.inputs["q"].connectTo(sources["q"])
		} else {
			this.sockets.inputs["q"].value = sources["q"]
		}

		if (typeof sources["k"] === "object") {
			this.sockets.inputs["k"].connectTo(sources["k"])
		} else {
			this.sockets.inputs["k"].value = sources["k"]
		}

		if (typeof sources["v"] === "object") {
			this.sockets.inputs["v"].connectTo(sources["v"])
		} else {
			this.sockets.inputs["v"].value = sources["v"]
		}

		if (typeof sources["out"] === "object") {
			this.sockets.inputs["out"].connectTo(sources["out"])
		} else {
			this.sockets.inputs["out"].value = sources["out"]
		}

	}
}

type CLIPAttentionMultiplyInputs = {
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"q": ComfyNodeTypedInputRef<number>
			"k": ComfyNodeTypedInputRef<number>
			"v": ComfyNodeTypedInputRef<number>
			"out": ComfyNodeTypedInputRef<number>
}


export class UNetTemporalAttentionMultiply extends ComfyNode {
	classType: string = "UNetTemporalAttentionMultiply"

	sockets: {
		inputs: Required<UNetTemporalAttentionMultiplyInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"self_structural": new ComfyNodeTypedInputRef<number>(this, "self_structural"),
				"self_temporal": new ComfyNodeTypedInputRef<number>(this, "self_temporal"),
				"cross_structural": new ComfyNodeTypedInputRef<number>(this, "cross_structural"),
				"cross_temporal": new ComfyNodeTypedInputRef<number>(this, "cross_temporal"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<UNetTemporalAttentionMultiplyInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["self_structural"] === "object") {
			this.sockets.inputs["self_structural"].connectTo(sources["self_structural"])
		} else {
			this.sockets.inputs["self_structural"].value = sources["self_structural"]
		}

		if (typeof sources["self_temporal"] === "object") {
			this.sockets.inputs["self_temporal"].connectTo(sources["self_temporal"])
		} else {
			this.sockets.inputs["self_temporal"].value = sources["self_temporal"]
		}

		if (typeof sources["cross_structural"] === "object") {
			this.sockets.inputs["cross_structural"].connectTo(sources["cross_structural"])
		} else {
			this.sockets.inputs["cross_structural"].value = sources["cross_structural"]
		}

		if (typeof sources["cross_temporal"] === "object") {
			this.sockets.inputs["cross_temporal"].connectTo(sources["cross_temporal"])
		} else {
			this.sockets.inputs["cross_temporal"].value = sources["cross_temporal"]
		}

	}
}

type UNetTemporalAttentionMultiplyInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"self_structural": ComfyNodeTypedInputRef<number>
			"self_temporal": ComfyNodeTypedInputRef<number>
			"cross_structural": ComfyNodeTypedInputRef<number>
			"cross_temporal": ComfyNodeTypedInputRef<number>
}


export class SamplerLCMUpscale extends ComfyNode {
	classType: string = "SamplerLCMUpscale"

	sockets: {
		inputs: Required<SamplerLCMUpscaleInputs>
		outputs: {
			SAMPLER: ComfyNodeTypedSourceRef<ComfyValueType_SAMPLER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"scale_ratio": new ComfyNodeTypedInputRef<number>(this, "scale_ratio"),
				"scale_steps": new ComfyNodeTypedInputRef<number>(this, "scale_steps"),
				"upscale_method": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "upscale_method"),
			},
			outputs: Object.create(Object.prototype, {
				"SAMPLER": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SamplerLCMUpscaleInputs>) {
		if (typeof sources["scale_ratio"] === "object") {
			this.sockets.inputs["scale_ratio"].connectTo(sources["scale_ratio"])
		} else {
			this.sockets.inputs["scale_ratio"].value = sources["scale_ratio"]
		}

		if (typeof sources["scale_steps"] === "object") {
			this.sockets.inputs["scale_steps"].connectTo(sources["scale_steps"])
		} else {
			this.sockets.inputs["scale_steps"].value = sources["scale_steps"]
		}

		if (typeof sources["upscale_method"] === "object") {
			this.sockets.inputs["upscale_method"].connectTo(sources["upscale_method"])
		} else {
			this.sockets.inputs["upscale_method"].value = sources["upscale_method"]
		}

	}
}

type SamplerLCMUpscaleInputs = {
			"scale_ratio": ComfyNodeTypedInputRef<number>
			"scale_steps": ComfyNodeTypedInputRef<number>
			"upscale_method": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class SamplerEulerCFGpp extends ComfyNode {
	classType: string = "SamplerEulerCFGpp"

	sockets: {
		inputs: Required<SamplerEulerCFGppInputs>
		outputs: {
			SAMPLER: ComfyNodeTypedSourceRef<ComfyValueType_SAMPLER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"version": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "version"),
			},
			outputs: Object.create(Object.prototype, {
				"SAMPLER": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SamplerEulerCFGppInputs>) {
		if (typeof sources["version"] === "object") {
			this.sockets.inputs["version"].connectTo(sources["version"])
		} else {
			this.sockets.inputs["version"].value = sources["version"]
		}

	}
}

type SamplerEulerCFGppInputs = {
			"version": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class WebcamCapture extends ComfyNode {
	classType: string = "WebcamCapture"

	sockets: {
		inputs: Required<WebcamCaptureInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_WEBCAM>(this, "image"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"capture_on_queue": new ComfyNodeTypedInputRef<boolean>(this, "capture_on_queue"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WebcamCaptureInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["capture_on_queue"] === "object") {
			this.sockets.inputs["capture_on_queue"].connectTo(sources["capture_on_queue"])
		} else {
			this.sockets.inputs["capture_on_queue"].value = sources["capture_on_queue"]
		}

	}
}

type WebcamCaptureInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_WEBCAM>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"capture_on_queue": ComfyNodeTypedInputRef<boolean>
}


export class TripleCLIPLoader extends ComfyNode {
	classType: string = "TripleCLIPLoader"

	sockets: {
		inputs: Required<TripleCLIPLoaderInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "clip_name2"),
				"clip_name3": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "clip_name3"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TripleCLIPLoaderInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["clip_name3"] === "object") {
			this.sockets.inputs["clip_name3"].connectTo(sources["clip_name3"])
		} else {
			this.sockets.inputs["clip_name3"].value = sources["clip_name3"]
		}

	}
}

type TripleCLIPLoaderInputs = {
			"clip_name1": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"clip_name2": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"clip_name3": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class EmptySD3LatentImage extends ComfyNode {
	classType: string = "EmptySD3LatentImage"

	sockets: {
		inputs: Required<EmptySD3LatentImageInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<EmptySD3LatentImageInputs>) {
		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

	}
}

type EmptySD3LatentImageInputs = {
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
}


export class CLIPTextEncodeSD3 extends ComfyNode {
	classType: string = "CLIPTextEncodeSD3"

	sockets: {
		inputs: Required<CLIPTextEncodeSD3Inputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"clip_l": new ComfyNodeTypedInputRef<string>(this, "clip_l"),
				"clip_g": new ComfyNodeTypedInputRef<string>(this, "clip_g"),
				"t5xxl": new ComfyNodeTypedInputRef<string>(this, "t5xxl"),
				"empty_padding": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "empty_padding"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPTextEncodeSD3Inputs>) {
		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["clip_l"] === "object") {
			this.sockets.inputs["clip_l"].connectTo(sources["clip_l"])
		} else {
			this.sockets.inputs["clip_l"].value = sources["clip_l"]
		}

		if (typeof sources["clip_g"] === "object") {
			this.sockets.inputs["clip_g"].connectTo(sources["clip_g"])
		} else {
			this.sockets.inputs["clip_g"].value = sources["clip_g"]
		}

		if (typeof sources["t5xxl"] === "object") {
			this.sockets.inputs["t5xxl"].connectTo(sources["t5xxl"])
		} else {
			this.sockets.inputs["t5xxl"].value = sources["t5xxl"]
		}

		if (typeof sources["empty_padding"] === "object") {
			this.sockets.inputs["empty_padding"].connectTo(sources["empty_padding"])
		} else {
			this.sockets.inputs["empty_padding"].value = sources["empty_padding"]
		}

	}
}

type CLIPTextEncodeSD3Inputs = {
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"clip_l": ComfyNodeTypedInputRef<string>
			"clip_g": ComfyNodeTypedInputRef<string>
			"t5xxl": ComfyNodeTypedInputRef<string>
			"empty_padding": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class ControlNetApplySD3 extends ComfyNode {
	classType: string = "ControlNetApplySD3"

	sockets: {
		inputs: Required<ControlNetApplySD3Inputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"control_net": new ComfyNodeTypedInputRef<ComfyValueType_CONTROL_NET>(this, "control_net"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ControlNetApplySD3Inputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["control_net"] === "object") {
			this.sockets.inputs["control_net"].connectTo(sources["control_net"])
		} else {
			this.sockets.inputs["control_net"].value = sources["control_net"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

	}
}

type ControlNetApplySD3Inputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"control_net": ComfyNodeTypedInputRef<ComfyValueType_CONTROL_NET>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"strength": ComfyNodeTypedInputRef<number>
			"start_percent": ComfyNodeTypedInputRef<number>
			"end_percent": ComfyNodeTypedInputRef<number>
}


export class SkipLayerGuidanceSD3 extends ComfyNode {
	classType: string = "SkipLayerGuidanceSD3"

	sockets: {
		inputs: Required<SkipLayerGuidanceSD3Inputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"layers": new ComfyNodeTypedInputRef<string>(this, "layers"),
				"scale": new ComfyNodeTypedInputRef<number>(this, "scale"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SkipLayerGuidanceSD3Inputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["layers"] === "object") {
			this.sockets.inputs["layers"].connectTo(sources["layers"])
		} else {
			this.sockets.inputs["layers"].value = sources["layers"]
		}

		if (typeof sources["scale"] === "object") {
			this.sockets.inputs["scale"].connectTo(sources["scale"])
		} else {
			this.sockets.inputs["scale"].value = sources["scale"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

	}
}

type SkipLayerGuidanceSD3Inputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"layers": ComfyNodeTypedInputRef<string>
			"scale": ComfyNodeTypedInputRef<number>
			"start_percent": ComfyNodeTypedInputRef<number>
			"end_percent": ComfyNodeTypedInputRef<number>
}


export class GITSScheduler extends ComfyNode {
	classType: string = "GITSScheduler"

	sockets: {
		inputs: Required<GITSSchedulerInputs>
		outputs: {
			SIGMAS: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"coeff": new ComfyNodeTypedInputRef<number>(this, "coeff"),
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"denoise": new ComfyNodeTypedInputRef<number>(this, "denoise"),
			},
			outputs: Object.create(Object.prototype, {
				"SIGMAS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<GITSSchedulerInputs>) {
		if (typeof sources["coeff"] === "object") {
			this.sockets.inputs["coeff"].connectTo(sources["coeff"])
		} else {
			this.sockets.inputs["coeff"].value = sources["coeff"]
		}

		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["denoise"] === "object") {
			this.sockets.inputs["denoise"].connectTo(sources["denoise"])
		} else {
			this.sockets.inputs["denoise"].value = sources["denoise"]
		}

	}
}

type GITSSchedulerInputs = {
			"coeff": ComfyNodeTypedInputRef<number>
			"steps": ComfyNodeTypedInputRef<number>
			"denoise": ComfyNodeTypedInputRef<number>
}


export class SetUnionControlNetType extends ComfyNode {
	classType: string = "SetUnionControlNetType"

	sockets: {
		inputs: Required<SetUnionControlNetTypeInputs>
		outputs: {
			CONTROL_NET: ComfyNodeTypedSourceRef<ComfyValueType_CONTROL_NET>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"control_net": new ComfyNodeTypedInputRef<ComfyValueType_CONTROL_NET>(this, "control_net"),
				"type": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "type"),
			},
			outputs: Object.create(Object.prototype, {
				"CONTROL_NET": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SetUnionControlNetTypeInputs>) {
		if (typeof sources["control_net"] === "object") {
			this.sockets.inputs["control_net"].connectTo(sources["control_net"])
		} else {
			this.sockets.inputs["control_net"].value = sources["control_net"]
		}

		if (typeof sources["type"] === "object") {
			this.sockets.inputs["type"].connectTo(sources["type"])
		} else {
			this.sockets.inputs["type"].value = sources["type"]
		}

	}
}

type SetUnionControlNetTypeInputs = {
			"control_net": ComfyNodeTypedInputRef<ComfyValueType_CONTROL_NET>
			"type": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class ControlNetInpaintingAliMamaApply extends ComfyNode {
	classType: string = "ControlNetInpaintingAliMamaApply"

	sockets: {
		inputs: Required<ControlNetInpaintingAliMamaApplyInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"control_net": new ComfyNodeTypedInputRef<ComfyValueType_CONTROL_NET>(this, "control_net"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ControlNetInpaintingAliMamaApplyInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["control_net"] === "object") {
			this.sockets.inputs["control_net"].connectTo(sources["control_net"])
		} else {
			this.sockets.inputs["control_net"].value = sources["control_net"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

	}
}

type ControlNetInpaintingAliMamaApplyInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"control_net": ComfyNodeTypedInputRef<ComfyValueType_CONTROL_NET>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"strength": ComfyNodeTypedInputRef<number>
			"start_percent": ComfyNodeTypedInputRef<number>
			"end_percent": ComfyNodeTypedInputRef<number>
}


export class CLIPTextEncodeHunyuanDiT extends ComfyNode {
	classType: string = "CLIPTextEncodeHunyuanDiT"

	sockets: {
		inputs: Required<CLIPTextEncodeHunyuanDiTInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"bert": new ComfyNodeTypedInputRef<string>(this, "bert"),
				"mt5xl": new ComfyNodeTypedInputRef<string>(this, "mt5xl"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPTextEncodeHunyuanDiTInputs>) {
		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["bert"] === "object") {
			this.sockets.inputs["bert"].connectTo(sources["bert"])
		} else {
			this.sockets.inputs["bert"].value = sources["bert"]
		}

		if (typeof sources["mt5xl"] === "object") {
			this.sockets.inputs["mt5xl"].connectTo(sources["mt5xl"])
		} else {
			this.sockets.inputs["mt5xl"].value = sources["mt5xl"]
		}

	}
}

type CLIPTextEncodeHunyuanDiTInputs = {
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"bert": ComfyNodeTypedInputRef<string>
			"mt5xl": ComfyNodeTypedInputRef<string>
}


export class TextEncodeHunyuanVideo_ImageToVideo extends ComfyNode {
	classType: string = "TextEncodeHunyuanVideo_ImageToVideo"

	sockets: {
		inputs: Required<TextEncodeHunyuanVideo_ImageToVideoInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"clip_vision_output": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>(this, "clip_vision_output"),
				"prompt": new ComfyNodeTypedInputRef<string>(this, "prompt"),
				"image_interleave": new ComfyNodeTypedInputRef<number>(this, "image_interleave"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TextEncodeHunyuanVideo_ImageToVideoInputs>) {
		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["clip_vision_output"] === "object") {
			this.sockets.inputs["clip_vision_output"].connectTo(sources["clip_vision_output"])
		} else {
			this.sockets.inputs["clip_vision_output"].value = sources["clip_vision_output"]
		}

		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}

		if (typeof sources["image_interleave"] === "object") {
			this.sockets.inputs["image_interleave"].connectTo(sources["image_interleave"])
		} else {
			this.sockets.inputs["image_interleave"].value = sources["image_interleave"]
		}

	}
}

type TextEncodeHunyuanVideo_ImageToVideoInputs = {
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"clip_vision_output": ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>
			"prompt": ComfyNodeTypedInputRef<string>
			/** How much the image influences things vs the text prompt. Higher number means more influence from the text prompt.*/
			"image_interleave": ComfyNodeTypedInputRef<number>
}


export class EmptyHunyuanLatentVideo extends ComfyNode {
	classType: string = "EmptyHunyuanLatentVideo"

	sockets: {
		inputs: Required<EmptyHunyuanLatentVideoInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<EmptyHunyuanLatentVideoInputs>) {
		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

	}
}

type EmptyHunyuanLatentVideoInputs = {
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
}


export class HunyuanImageToVideo extends ComfyNode {
	classType: string = "HunyuanImageToVideo"

	sockets: {
		inputs: Required<HunyuanImageToVideoInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"guidance_type": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "guidance_type"),
				"start_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "start_image"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<HunyuanImageToVideoInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (typeof sources["guidance_type"] === "object") {
			this.sockets.inputs["guidance_type"].connectTo(sources["guidance_type"])
		} else {
			this.sockets.inputs["guidance_type"].value = sources["guidance_type"]
		}

		if (sources["start_image"] !== undefined) {
		if (typeof sources["start_image"] === "object") {
			this.sockets.inputs["start_image"].connectTo(sources["start_image"])
		} else {
			this.sockets.inputs["start_image"].value = sources["start_image"]
		}
		}

	}
}

type HunyuanImageToVideoInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"guidance_type": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"start_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class EmptyHunyuanImageLatent extends ComfyNode {
	classType: string = "EmptyHunyuanImageLatent"

	sockets: {
		inputs: Required<EmptyHunyuanImageLatentInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<EmptyHunyuanImageLatentInputs>) {
		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

	}
}

type EmptyHunyuanImageLatentInputs = {
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
}


export class HunyuanRefinerLatent extends ComfyNode {
	classType: string = "HunyuanRefinerLatent"

	sockets: {
		inputs: Required<HunyuanRefinerLatentInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latent"),
				"noise_augmentation": new ComfyNodeTypedInputRef<number>(this, "noise_augmentation"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<HunyuanRefinerLatentInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["latent"] === "object") {
			this.sockets.inputs["latent"].connectTo(sources["latent"])
		} else {
			this.sockets.inputs["latent"].value = sources["latent"]
		}

		if (typeof sources["noise_augmentation"] === "object") {
			this.sockets.inputs["noise_augmentation"].connectTo(sources["noise_augmentation"])
		} else {
			this.sockets.inputs["noise_augmentation"].value = sources["noise_augmentation"]
		}

	}
}

type HunyuanRefinerLatentInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"latent": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"noise_augmentation": ComfyNodeTypedInputRef<number>
}


export class TemporalScoreRescaling extends ComfyNode {
	classType: string = "TemporalScoreRescaling"

	sockets: {
		inputs: Required<TemporalScoreRescalingInputs>
		outputs: {
			patched_model: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"tsr_k": new ComfyNodeTypedInputRef<number>(this, "tsr_k"),
				"tsr_sigma": new ComfyNodeTypedInputRef<number>(this, "tsr_sigma"),
			},
			outputs: Object.create(Object.prototype, {
				"patched_model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TemporalScoreRescalingInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["tsr_k"] === "object") {
			this.sockets.inputs["tsr_k"].connectTo(sources["tsr_k"])
		} else {
			this.sockets.inputs["tsr_k"].value = sources["tsr_k"]
		}

		if (typeof sources["tsr_sigma"] === "object") {
			this.sockets.inputs["tsr_sigma"].connectTo(sources["tsr_sigma"])
		} else {
			this.sockets.inputs["tsr_sigma"].value = sources["tsr_sigma"]
		}

	}
}

type TemporalScoreRescalingInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** Controls the rescaling strength.
Lower k produces more detailed results; higher k produces smoother results in image generation. Setting k = 1 disables rescaling.*/
			"tsr_k": ComfyNodeTypedInputRef<number>
			/** Controls how early rescaling takes effect.
Larger values take effect earlier.*/
			"tsr_sigma": ComfyNodeTypedInputRef<number>
}


export class CLIPTextEncodeFlux extends ComfyNode {
	classType: string = "CLIPTextEncodeFlux"

	sockets: {
		inputs: Required<CLIPTextEncodeFluxInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"clip_l": new ComfyNodeTypedInputRef<string>(this, "clip_l"),
				"t5xxl": new ComfyNodeTypedInputRef<string>(this, "t5xxl"),
				"guidance": new ComfyNodeTypedInputRef<number>(this, "guidance"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPTextEncodeFluxInputs>) {
		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["clip_l"] === "object") {
			this.sockets.inputs["clip_l"].connectTo(sources["clip_l"])
		} else {
			this.sockets.inputs["clip_l"].value = sources["clip_l"]
		}

		if (typeof sources["t5xxl"] === "object") {
			this.sockets.inputs["t5xxl"].connectTo(sources["t5xxl"])
		} else {
			this.sockets.inputs["t5xxl"].value = sources["t5xxl"]
		}

		if (typeof sources["guidance"] === "object") {
			this.sockets.inputs["guidance"].connectTo(sources["guidance"])
		} else {
			this.sockets.inputs["guidance"].value = sources["guidance"]
		}

	}
}

type CLIPTextEncodeFluxInputs = {
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"clip_l": ComfyNodeTypedInputRef<string>
			"t5xxl": ComfyNodeTypedInputRef<string>
			"guidance": ComfyNodeTypedInputRef<number>
}


export class FluxGuidance extends ComfyNode {
	classType: string = "FluxGuidance"

	sockets: {
		inputs: Required<FluxGuidanceInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning"),
				"guidance": new ComfyNodeTypedInputRef<number>(this, "guidance"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<FluxGuidanceInputs>) {
		if (typeof sources["conditioning"] === "object") {
			this.sockets.inputs["conditioning"].connectTo(sources["conditioning"])
		} else {
			this.sockets.inputs["conditioning"].value = sources["conditioning"]
		}

		if (typeof sources["guidance"] === "object") {
			this.sockets.inputs["guidance"].connectTo(sources["guidance"])
		} else {
			this.sockets.inputs["guidance"].value = sources["guidance"]
		}

	}
}

type FluxGuidanceInputs = {
			"conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"guidance": ComfyNodeTypedInputRef<number>
}


export class FluxDisableGuidance extends ComfyNode {
	classType: string = "FluxDisableGuidance"

	sockets: {
		inputs: Required<FluxDisableGuidanceInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<FluxDisableGuidanceInputs>) {
		if (typeof sources["conditioning"] === "object") {
			this.sockets.inputs["conditioning"].connectTo(sources["conditioning"])
		} else {
			this.sockets.inputs["conditioning"].value = sources["conditioning"]
		}

	}
}

type FluxDisableGuidanceInputs = {
			"conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
}


export class FluxKontextImageScale extends ComfyNode {
	classType: string = "FluxKontextImageScale"

	sockets: {
		inputs: Required<FluxKontextImageScaleInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<FluxKontextImageScaleInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

	}
}

type FluxKontextImageScaleInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class FluxKontextMultiReferenceLatentMethod extends ComfyNode {
	classType: string = "FluxKontextMultiReferenceLatentMethod"

	sockets: {
		inputs: Required<FluxKontextMultiReferenceLatentMethodInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning"),
				"reference_latents_method": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "reference_latents_method"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<FluxKontextMultiReferenceLatentMethodInputs>) {
		if (typeof sources["conditioning"] === "object") {
			this.sockets.inputs["conditioning"].connectTo(sources["conditioning"])
		} else {
			this.sockets.inputs["conditioning"].value = sources["conditioning"]
		}

		if (typeof sources["reference_latents_method"] === "object") {
			this.sockets.inputs["reference_latents_method"].connectTo(sources["reference_latents_method"])
		} else {
			this.sockets.inputs["reference_latents_method"].value = sources["reference_latents_method"]
		}

	}
}

type FluxKontextMultiReferenceLatentMethodInputs = {
			"conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"reference_latents_method": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class LoraSave extends ComfyNode {
	classType: string = "LoraSave"

	sockets: {
		inputs: Required<LoraSaveInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"rank": new ComfyNodeTypedInputRef<number>(this, "rank"),
				"lora_type": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "lora_type"),
				"bias_diff": new ComfyNodeTypedInputRef<boolean>(this, "bias_diff"),
				"model_diff": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model_diff"),
				"text_encoder_diff": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "text_encoder_diff"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_PROMPT>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_EXTRA_PNGINFO>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<LoraSaveInputs>) {
		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (typeof sources["rank"] === "object") {
			this.sockets.inputs["rank"].connectTo(sources["rank"])
		} else {
			this.sockets.inputs["rank"].value = sources["rank"]
		}

		if (typeof sources["lora_type"] === "object") {
			this.sockets.inputs["lora_type"].connectTo(sources["lora_type"])
		} else {
			this.sockets.inputs["lora_type"].value = sources["lora_type"]
		}

		if (typeof sources["bias_diff"] === "object") {
			this.sockets.inputs["bias_diff"].connectTo(sources["bias_diff"])
		} else {
			this.sockets.inputs["bias_diff"].value = sources["bias_diff"]
		}

		if (sources["model_diff"] !== undefined) {
		if (typeof sources["model_diff"] === "object") {
			this.sockets.inputs["model_diff"].connectTo(sources["model_diff"])
		} else {
			this.sockets.inputs["model_diff"].value = sources["model_diff"]
		}
		}

		if (sources["text_encoder_diff"] !== undefined) {
		if (typeof sources["text_encoder_diff"] === "object") {
			this.sockets.inputs["text_encoder_diff"].connectTo(sources["text_encoder_diff"])
		} else {
			this.sockets.inputs["text_encoder_diff"].value = sources["text_encoder_diff"]
		}
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type LoraSaveInputs = {
			"filename_prefix": ComfyNodeTypedInputRef<string>
			"rank": ComfyNodeTypedInputRef<number>
			"lora_type": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"bias_diff": ComfyNodeTypedInputRef<boolean>
			/** The ModelSubtract output to be converted to a lora.*/
			"model_diff"?: ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** The CLIPSubtract output to be converted to a lora.*/
			"text_encoder_diff"?: ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_PROMPT>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_EXTRA_PNGINFO>
}


export class TorchCompileModel extends ComfyNode {
	classType: string = "TorchCompileModel"

	sockets: {
		inputs: Required<TorchCompileModelInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"backend": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "backend"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TorchCompileModelInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["backend"] === "object") {
			this.sockets.inputs["backend"].connectTo(sources["backend"])
		} else {
			this.sockets.inputs["backend"].value = sources["backend"]
		}

	}
}

type TorchCompileModelInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"backend": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class EmptyMochiLatentVideo extends ComfyNode {
	classType: string = "EmptyMochiLatentVideo"

	sockets: {
		inputs: Required<EmptyMochiLatentVideoInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<EmptyMochiLatentVideoInputs>) {
		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

	}
}

type EmptyMochiLatentVideoInputs = {
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
}


export class SkipLayerGuidanceDiT extends ComfyNode {
	classType: string = "SkipLayerGuidanceDiT"

	sockets: {
		inputs: Required<SkipLayerGuidanceDiTInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"double_layers": new ComfyNodeTypedInputRef<string>(this, "double_layers"),
				"single_layers": new ComfyNodeTypedInputRef<string>(this, "single_layers"),
				"scale": new ComfyNodeTypedInputRef<number>(this, "scale"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
				"rescaling_scale": new ComfyNodeTypedInputRef<number>(this, "rescaling_scale"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SkipLayerGuidanceDiTInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["double_layers"] === "object") {
			this.sockets.inputs["double_layers"].connectTo(sources["double_layers"])
		} else {
			this.sockets.inputs["double_layers"].value = sources["double_layers"]
		}

		if (typeof sources["single_layers"] === "object") {
			this.sockets.inputs["single_layers"].connectTo(sources["single_layers"])
		} else {
			this.sockets.inputs["single_layers"].value = sources["single_layers"]
		}

		if (typeof sources["scale"] === "object") {
			this.sockets.inputs["scale"].connectTo(sources["scale"])
		} else {
			this.sockets.inputs["scale"].value = sources["scale"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

		if (typeof sources["rescaling_scale"] === "object") {
			this.sockets.inputs["rescaling_scale"].connectTo(sources["rescaling_scale"])
		} else {
			this.sockets.inputs["rescaling_scale"].value = sources["rescaling_scale"]
		}

	}
}

type SkipLayerGuidanceDiTInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"double_layers": ComfyNodeTypedInputRef<string>
			"single_layers": ComfyNodeTypedInputRef<string>
			"scale": ComfyNodeTypedInputRef<number>
			"start_percent": ComfyNodeTypedInputRef<number>
			"end_percent": ComfyNodeTypedInputRef<number>
			"rescaling_scale": ComfyNodeTypedInputRef<number>
}


export class SkipLayerGuidanceDiTSimple extends ComfyNode {
	classType: string = "SkipLayerGuidanceDiTSimple"

	sockets: {
		inputs: Required<SkipLayerGuidanceDiTSimpleInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"double_layers": new ComfyNodeTypedInputRef<string>(this, "double_layers"),
				"single_layers": new ComfyNodeTypedInputRef<string>(this, "single_layers"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SkipLayerGuidanceDiTSimpleInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["double_layers"] === "object") {
			this.sockets.inputs["double_layers"].connectTo(sources["double_layers"])
		} else {
			this.sockets.inputs["double_layers"].value = sources["double_layers"]
		}

		if (typeof sources["single_layers"] === "object") {
			this.sockets.inputs["single_layers"].connectTo(sources["single_layers"])
		} else {
			this.sockets.inputs["single_layers"].value = sources["single_layers"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

	}
}

type SkipLayerGuidanceDiTSimpleInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"double_layers": ComfyNodeTypedInputRef<string>
			"single_layers": ComfyNodeTypedInputRef<string>
			"start_percent": ComfyNodeTypedInputRef<number>
			"end_percent": ComfyNodeTypedInputRef<number>
}


export class Mahiro extends ComfyNode {
	classType: string = "Mahiro"

	sockets: {
		inputs: Required<MahiroInputs>
		outputs: {
			patched_model: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
			},
			outputs: Object.create(Object.prototype, {
				"patched_model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<MahiroInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

	}
}

type MahiroInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
}


export class EmptyLTXVLatentVideo extends ComfyNode {
	classType: string = "EmptyLTXVLatentVideo"

	sockets: {
		inputs: Required<EmptyLTXVLatentVideoInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<EmptyLTXVLatentVideoInputs>) {
		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

	}
}

type EmptyLTXVLatentVideoInputs = {
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
}


export class LTXVImgToVideo extends ComfyNode {
	classType: string = "LTXVImgToVideo"

	sockets: {
		inputs: Required<LTXVImgToVideoInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LTXVImgToVideoInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

	}
}

type LTXVImgToVideoInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"strength": ComfyNodeTypedInputRef<number>
}


export class ModelSamplingLTXV extends ComfyNode {
	classType: string = "ModelSamplingLTXV"

	sockets: {
		inputs: Required<ModelSamplingLTXVInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"max_shift": new ComfyNodeTypedInputRef<number>(this, "max_shift"),
				"base_shift": new ComfyNodeTypedInputRef<number>(this, "base_shift"),
				"latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latent"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelSamplingLTXVInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["max_shift"] === "object") {
			this.sockets.inputs["max_shift"].connectTo(sources["max_shift"])
		} else {
			this.sockets.inputs["max_shift"].value = sources["max_shift"]
		}

		if (typeof sources["base_shift"] === "object") {
			this.sockets.inputs["base_shift"].connectTo(sources["base_shift"])
		} else {
			this.sockets.inputs["base_shift"].value = sources["base_shift"]
		}

		if (sources["latent"] !== undefined) {
		if (typeof sources["latent"] === "object") {
			this.sockets.inputs["latent"].connectTo(sources["latent"])
		} else {
			this.sockets.inputs["latent"].value = sources["latent"]
		}
		}

	}
}

type ModelSamplingLTXVInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"max_shift": ComfyNodeTypedInputRef<number>
			"base_shift": ComfyNodeTypedInputRef<number>
			"latent"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class LTXVConditioning extends ComfyNode {
	classType: string = "LTXVConditioning"

	sockets: {
		inputs: Required<LTXVConditioningInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"frame_rate": new ComfyNodeTypedInputRef<number>(this, "frame_rate"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LTXVConditioningInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["frame_rate"] === "object") {
			this.sockets.inputs["frame_rate"].connectTo(sources["frame_rate"])
		} else {
			this.sockets.inputs["frame_rate"].value = sources["frame_rate"]
		}

	}
}

type LTXVConditioningInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"frame_rate": ComfyNodeTypedInputRef<number>
}


export class LTXVScheduler extends ComfyNode {
	classType: string = "LTXVScheduler"

	sockets: {
		inputs: Required<LTXVSchedulerInputs>
		outputs: {
			SIGMAS: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"max_shift": new ComfyNodeTypedInputRef<number>(this, "max_shift"),
				"base_shift": new ComfyNodeTypedInputRef<number>(this, "base_shift"),
				"stretch": new ComfyNodeTypedInputRef<boolean>(this, "stretch"),
				"terminal": new ComfyNodeTypedInputRef<number>(this, "terminal"),
				"latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latent"),
			},
			outputs: Object.create(Object.prototype, {
				"SIGMAS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LTXVSchedulerInputs>) {
		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["max_shift"] === "object") {
			this.sockets.inputs["max_shift"].connectTo(sources["max_shift"])
		} else {
			this.sockets.inputs["max_shift"].value = sources["max_shift"]
		}

		if (typeof sources["base_shift"] === "object") {
			this.sockets.inputs["base_shift"].connectTo(sources["base_shift"])
		} else {
			this.sockets.inputs["base_shift"].value = sources["base_shift"]
		}

		if (typeof sources["stretch"] === "object") {
			this.sockets.inputs["stretch"].connectTo(sources["stretch"])
		} else {
			this.sockets.inputs["stretch"].value = sources["stretch"]
		}

		if (typeof sources["terminal"] === "object") {
			this.sockets.inputs["terminal"].connectTo(sources["terminal"])
		} else {
			this.sockets.inputs["terminal"].value = sources["terminal"]
		}

		if (sources["latent"] !== undefined) {
		if (typeof sources["latent"] === "object") {
			this.sockets.inputs["latent"].connectTo(sources["latent"])
		} else {
			this.sockets.inputs["latent"].value = sources["latent"]
		}
		}

	}
}

type LTXVSchedulerInputs = {
			"steps": ComfyNodeTypedInputRef<number>
			"max_shift": ComfyNodeTypedInputRef<number>
			"base_shift": ComfyNodeTypedInputRef<number>
			/** Stretch the sigmas to be in the range [terminal, 1].*/
			"stretch": ComfyNodeTypedInputRef<boolean>
			/** The terminal value of the sigmas after stretching.*/
			"terminal": ComfyNodeTypedInputRef<number>
			"latent"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class LTXVAddGuide extends ComfyNode {
	classType: string = "LTXVAddGuide"

	sockets: {
		inputs: Required<LTXVAddGuideInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latent"),
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"frame_idx": new ComfyNodeTypedInputRef<number>(this, "frame_idx"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LTXVAddGuideInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["latent"] === "object") {
			this.sockets.inputs["latent"].connectTo(sources["latent"])
		} else {
			this.sockets.inputs["latent"].value = sources["latent"]
		}

		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["frame_idx"] === "object") {
			this.sockets.inputs["frame_idx"].connectTo(sources["frame_idx"])
		} else {
			this.sockets.inputs["frame_idx"].value = sources["frame_idx"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

	}
}

type LTXVAddGuideInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"latent": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** Image or video to condition the latent video on. Must be 8*n + 1 frames. If the video is not 8*n + 1 frames, it will be cropped to the nearest 8*n + 1 frames.*/
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Frame index to start the conditioning at. For single-frame images or videos with 1-8 frames, any frame_idx value is acceptable. For videos with 9+ frames, frame_idx must be divisible by 8, otherwise it will be rounded down to the nearest multiple of 8. Negative values are counted from the end of the video.*/
			"frame_idx": ComfyNodeTypedInputRef<number>
			"strength": ComfyNodeTypedInputRef<number>
}


export class LTXVPreprocess extends ComfyNode {
	classType: string = "LTXVPreprocess"

	sockets: {
		inputs: Required<LTXVPreprocessInputs>
		outputs: {
			output_image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"img_compression": new ComfyNodeTypedInputRef<number>(this, "img_compression"),
			},
			outputs: Object.create(Object.prototype, {
				"output_image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LTXVPreprocessInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["img_compression"] === "object") {
			this.sockets.inputs["img_compression"].connectTo(sources["img_compression"])
		} else {
			this.sockets.inputs["img_compression"].value = sources["img_compression"]
		}

	}
}

type LTXVPreprocessInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Amount of compression to apply on image.*/
			"img_compression": ComfyNodeTypedInputRef<number>
}


export class LTXVCropGuides extends ComfyNode {
	classType: string = "LTXVCropGuides"

	sockets: {
		inputs: Required<LTXVCropGuidesInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latent"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LTXVCropGuidesInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["latent"] === "object") {
			this.sockets.inputs["latent"].connectTo(sources["latent"])
		} else {
			this.sockets.inputs["latent"].value = sources["latent"]
		}

	}
}

type LTXVCropGuidesInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"latent": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class CreateHookLora extends ComfyNode {
	classType: string = "CreateHookLora"

	sockets: {
		inputs: Required<CreateHookLoraInputs>
		outputs: {
			HOOKS: ComfyNodeTypedSourceRef<ComfyValueType_HOOKS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"lora_name": new ComfyNodeTypedInputRef<string>(this, "lora_name"),
				"strength_model": new ComfyNodeTypedInputRef<number>(this, "strength_model"),
				"strength_clip": new ComfyNodeTypedInputRef<number>(this, "strength_clip"),
				"prev_hooks": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "prev_hooks"),
			},
			outputs: Object.create(Object.prototype, {
				"HOOKS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateHookLoraInputs>) {
		if (typeof sources["lora_name"] === "object") {
			this.sockets.inputs["lora_name"].connectTo(sources["lora_name"])
		} else {
			this.sockets.inputs["lora_name"].value = sources["lora_name"]
		}

		if (typeof sources["strength_model"] === "object") {
			this.sockets.inputs["strength_model"].connectTo(sources["strength_model"])
		} else {
			this.sockets.inputs["strength_model"].value = sources["strength_model"]
		}

		if (typeof sources["strength_clip"] === "object") {
			this.sockets.inputs["strength_clip"].connectTo(sources["strength_clip"])
		} else {
			this.sockets.inputs["strength_clip"].value = sources["strength_clip"]
		}

		if (sources["prev_hooks"] !== undefined) {
		if (typeof sources["prev_hooks"] === "object") {
			this.sockets.inputs["prev_hooks"].connectTo(sources["prev_hooks"])
		} else {
			this.sockets.inputs["prev_hooks"].value = sources["prev_hooks"]
		}
		}

	}
}

type CreateHookLoraInputs = {
			"lora_name": ComfyNodeTypedInputRef<string>
			"strength_model": ComfyNodeTypedInputRef<number>
			"strength_clip": ComfyNodeTypedInputRef<number>
			"prev_hooks"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
}


export class CreateHookLoraModelOnly extends ComfyNode {
	classType: string = "CreateHookLoraModelOnly"

	sockets: {
		inputs: Required<CreateHookLoraModelOnlyInputs>
		outputs: {
			HOOKS: ComfyNodeTypedSourceRef<ComfyValueType_HOOKS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"lora_name": new ComfyNodeTypedInputRef<string>(this, "lora_name"),
				"strength_model": new ComfyNodeTypedInputRef<number>(this, "strength_model"),
				"prev_hooks": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "prev_hooks"),
			},
			outputs: Object.create(Object.prototype, {
				"HOOKS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateHookLoraModelOnlyInputs>) {
		if (typeof sources["lora_name"] === "object") {
			this.sockets.inputs["lora_name"].connectTo(sources["lora_name"])
		} else {
			this.sockets.inputs["lora_name"].value = sources["lora_name"]
		}

		if (typeof sources["strength_model"] === "object") {
			this.sockets.inputs["strength_model"].connectTo(sources["strength_model"])
		} else {
			this.sockets.inputs["strength_model"].value = sources["strength_model"]
		}

		if (sources["prev_hooks"] !== undefined) {
		if (typeof sources["prev_hooks"] === "object") {
			this.sockets.inputs["prev_hooks"].connectTo(sources["prev_hooks"])
		} else {
			this.sockets.inputs["prev_hooks"].value = sources["prev_hooks"]
		}
		}

	}
}

type CreateHookLoraModelOnlyInputs = {
			"lora_name": ComfyNodeTypedInputRef<string>
			"strength_model": ComfyNodeTypedInputRef<number>
			"prev_hooks"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
}


export class CreateHookModelAsLora extends ComfyNode {
	classType: string = "CreateHookModelAsLora"

	sockets: {
		inputs: Required<CreateHookModelAsLoraInputs>
		outputs: {
			HOOKS: ComfyNodeTypedSourceRef<ComfyValueType_HOOKS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"ckpt_name": new ComfyNodeTypedInputRef<string>(this, "ckpt_name"),
				"strength_model": new ComfyNodeTypedInputRef<number>(this, "strength_model"),
				"strength_clip": new ComfyNodeTypedInputRef<number>(this, "strength_clip"),
				"prev_hooks": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "prev_hooks"),
			},
			outputs: Object.create(Object.prototype, {
				"HOOKS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateHookModelAsLoraInputs>) {
		if (typeof sources["ckpt_name"] === "object") {
			this.sockets.inputs["ckpt_name"].connectTo(sources["ckpt_name"])
		} else {
			this.sockets.inputs["ckpt_name"].value = sources["ckpt_name"]
		}

		if (typeof sources["strength_model"] === "object") {
			this.sockets.inputs["strength_model"].connectTo(sources["strength_model"])
		} else {
			this.sockets.inputs["strength_model"].value = sources["strength_model"]
		}

		if (typeof sources["strength_clip"] === "object") {
			this.sockets.inputs["strength_clip"].connectTo(sources["strength_clip"])
		} else {
			this.sockets.inputs["strength_clip"].value = sources["strength_clip"]
		}

		if (sources["prev_hooks"] !== undefined) {
		if (typeof sources["prev_hooks"] === "object") {
			this.sockets.inputs["prev_hooks"].connectTo(sources["prev_hooks"])
		} else {
			this.sockets.inputs["prev_hooks"].value = sources["prev_hooks"]
		}
		}

	}
}

type CreateHookModelAsLoraInputs = {
			"ckpt_name": ComfyNodeTypedInputRef<string>
			"strength_model": ComfyNodeTypedInputRef<number>
			"strength_clip": ComfyNodeTypedInputRef<number>
			"prev_hooks"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
}


export class CreateHookModelAsLoraModelOnly extends ComfyNode {
	classType: string = "CreateHookModelAsLoraModelOnly"

	sockets: {
		inputs: Required<CreateHookModelAsLoraModelOnlyInputs>
		outputs: {
			HOOKS: ComfyNodeTypedSourceRef<ComfyValueType_HOOKS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"ckpt_name": new ComfyNodeTypedInputRef<string>(this, "ckpt_name"),
				"strength_model": new ComfyNodeTypedInputRef<number>(this, "strength_model"),
				"prev_hooks": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "prev_hooks"),
			},
			outputs: Object.create(Object.prototype, {
				"HOOKS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateHookModelAsLoraModelOnlyInputs>) {
		if (typeof sources["ckpt_name"] === "object") {
			this.sockets.inputs["ckpt_name"].connectTo(sources["ckpt_name"])
		} else {
			this.sockets.inputs["ckpt_name"].value = sources["ckpt_name"]
		}

		if (typeof sources["strength_model"] === "object") {
			this.sockets.inputs["strength_model"].connectTo(sources["strength_model"])
		} else {
			this.sockets.inputs["strength_model"].value = sources["strength_model"]
		}

		if (sources["prev_hooks"] !== undefined) {
		if (typeof sources["prev_hooks"] === "object") {
			this.sockets.inputs["prev_hooks"].connectTo(sources["prev_hooks"])
		} else {
			this.sockets.inputs["prev_hooks"].value = sources["prev_hooks"]
		}
		}

	}
}

type CreateHookModelAsLoraModelOnlyInputs = {
			"ckpt_name": ComfyNodeTypedInputRef<string>
			"strength_model": ComfyNodeTypedInputRef<number>
			"prev_hooks"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
}


export class SetHookKeyframes extends ComfyNode {
	classType: string = "SetHookKeyframes"

	sockets: {
		inputs: Required<SetHookKeyframesInputs>
		outputs: {
			HOOKS: ComfyNodeTypedSourceRef<ComfyValueType_HOOKS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"hooks": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks"),
				"hook_kf": new ComfyNodeTypedInputRef<ComfyValueType_HOOK_KEYFRAMES>(this, "hook_kf"),
			},
			outputs: Object.create(Object.prototype, {
				"HOOKS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SetHookKeyframesInputs>) {
		if (typeof sources["hooks"] === "object") {
			this.sockets.inputs["hooks"].connectTo(sources["hooks"])
		} else {
			this.sockets.inputs["hooks"].value = sources["hooks"]
		}

		if (sources["hook_kf"] !== undefined) {
		if (typeof sources["hook_kf"] === "object") {
			this.sockets.inputs["hook_kf"].connectTo(sources["hook_kf"])
		} else {
			this.sockets.inputs["hook_kf"].value = sources["hook_kf"]
		}
		}

	}
}

type SetHookKeyframesInputs = {
			"hooks": ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
			"hook_kf"?: ComfyNodeTypedInputRef<ComfyValueType_HOOK_KEYFRAMES>
}


export class CreateHookKeyframe extends ComfyNode {
	classType: string = "CreateHookKeyframe"

	sockets: {
		inputs: Required<CreateHookKeyframeInputs>
		outputs: {
			HOOK_KF: ComfyNodeTypedSourceRef<ComfyValueType_HOOK_KEYFRAMES>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"strength_mult": new ComfyNodeTypedInputRef<number>(this, "strength_mult"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"prev_hook_kf": new ComfyNodeTypedInputRef<ComfyValueType_HOOK_KEYFRAMES>(this, "prev_hook_kf"),
			},
			outputs: Object.create(Object.prototype, {
				"HOOK_KF": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateHookKeyframeInputs>) {
		if (typeof sources["strength_mult"] === "object") {
			this.sockets.inputs["strength_mult"].connectTo(sources["strength_mult"])
		} else {
			this.sockets.inputs["strength_mult"].value = sources["strength_mult"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (sources["prev_hook_kf"] !== undefined) {
		if (typeof sources["prev_hook_kf"] === "object") {
			this.sockets.inputs["prev_hook_kf"].connectTo(sources["prev_hook_kf"])
		} else {
			this.sockets.inputs["prev_hook_kf"].value = sources["prev_hook_kf"]
		}
		}

	}
}

type CreateHookKeyframeInputs = {
			"strength_mult": ComfyNodeTypedInputRef<number>
			"start_percent": ComfyNodeTypedInputRef<number>
			"prev_hook_kf"?: ComfyNodeTypedInputRef<ComfyValueType_HOOK_KEYFRAMES>
}


export class CreateHookKeyframesInterpolated extends ComfyNode {
	classType: string = "CreateHookKeyframesInterpolated"

	sockets: {
		inputs: Required<CreateHookKeyframesInterpolatedInputs>
		outputs: {
			HOOK_KF: ComfyNodeTypedSourceRef<ComfyValueType_HOOK_KEYFRAMES>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"strength_start": new ComfyNodeTypedInputRef<number>(this, "strength_start"),
				"strength_end": new ComfyNodeTypedInputRef<number>(this, "strength_end"),
				"interpolation": new ComfyNodeTypedInputRef<string>(this, "interpolation"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
				"keyframes_count": new ComfyNodeTypedInputRef<number>(this, "keyframes_count"),
				"print_keyframes": new ComfyNodeTypedInputRef<boolean>(this, "print_keyframes"),
				"prev_hook_kf": new ComfyNodeTypedInputRef<ComfyValueType_HOOK_KEYFRAMES>(this, "prev_hook_kf"),
			},
			outputs: Object.create(Object.prototype, {
				"HOOK_KF": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateHookKeyframesInterpolatedInputs>) {
		if (typeof sources["strength_start"] === "object") {
			this.sockets.inputs["strength_start"].connectTo(sources["strength_start"])
		} else {
			this.sockets.inputs["strength_start"].value = sources["strength_start"]
		}

		if (typeof sources["strength_end"] === "object") {
			this.sockets.inputs["strength_end"].connectTo(sources["strength_end"])
		} else {
			this.sockets.inputs["strength_end"].value = sources["strength_end"]
		}

		if (typeof sources["interpolation"] === "object") {
			this.sockets.inputs["interpolation"].connectTo(sources["interpolation"])
		} else {
			this.sockets.inputs["interpolation"].value = sources["interpolation"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

		if (typeof sources["keyframes_count"] === "object") {
			this.sockets.inputs["keyframes_count"].connectTo(sources["keyframes_count"])
		} else {
			this.sockets.inputs["keyframes_count"].value = sources["keyframes_count"]
		}

		if (typeof sources["print_keyframes"] === "object") {
			this.sockets.inputs["print_keyframes"].connectTo(sources["print_keyframes"])
		} else {
			this.sockets.inputs["print_keyframes"].value = sources["print_keyframes"]
		}

		if (sources["prev_hook_kf"] !== undefined) {
		if (typeof sources["prev_hook_kf"] === "object") {
			this.sockets.inputs["prev_hook_kf"].connectTo(sources["prev_hook_kf"])
		} else {
			this.sockets.inputs["prev_hook_kf"].value = sources["prev_hook_kf"]
		}
		}

	}
}

type CreateHookKeyframesInterpolatedInputs = {
			"strength_start": ComfyNodeTypedInputRef<number>
			"strength_end": ComfyNodeTypedInputRef<number>
			"interpolation": ComfyNodeTypedInputRef<string>
			"start_percent": ComfyNodeTypedInputRef<number>
			"end_percent": ComfyNodeTypedInputRef<number>
			"keyframes_count": ComfyNodeTypedInputRef<number>
			"print_keyframes": ComfyNodeTypedInputRef<boolean>
			"prev_hook_kf"?: ComfyNodeTypedInputRef<ComfyValueType_HOOK_KEYFRAMES>
}


export class CreateHookKeyframesFromFloats extends ComfyNode {
	classType: string = "CreateHookKeyframesFromFloats"

	sockets: {
		inputs: Required<CreateHookKeyframesFromFloatsInputs>
		outputs: {
			HOOK_KF: ComfyNodeTypedSourceRef<ComfyValueType_HOOK_KEYFRAMES>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"floats_strength": new ComfyNodeTypedInputRef<ComfyValueType_FLOATS>(this, "floats_strength"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
				"print_keyframes": new ComfyNodeTypedInputRef<boolean>(this, "print_keyframes"),
				"prev_hook_kf": new ComfyNodeTypedInputRef<ComfyValueType_HOOK_KEYFRAMES>(this, "prev_hook_kf"),
			},
			outputs: Object.create(Object.prototype, {
				"HOOK_KF": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateHookKeyframesFromFloatsInputs>) {
		if (typeof sources["floats_strength"] === "object") {
			this.sockets.inputs["floats_strength"].connectTo(sources["floats_strength"])
		} else {
			this.sockets.inputs["floats_strength"].value = sources["floats_strength"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

		if (typeof sources["print_keyframes"] === "object") {
			this.sockets.inputs["print_keyframes"].connectTo(sources["print_keyframes"])
		} else {
			this.sockets.inputs["print_keyframes"].value = sources["print_keyframes"]
		}

		if (sources["prev_hook_kf"] !== undefined) {
		if (typeof sources["prev_hook_kf"] === "object") {
			this.sockets.inputs["prev_hook_kf"].connectTo(sources["prev_hook_kf"])
		} else {
			this.sockets.inputs["prev_hook_kf"].value = sources["prev_hook_kf"]
		}
		}

	}
}

type CreateHookKeyframesFromFloatsInputs = {
			"floats_strength": ComfyNodeTypedInputRef<ComfyValueType_FLOATS>
			"start_percent": ComfyNodeTypedInputRef<number>
			"end_percent": ComfyNodeTypedInputRef<number>
			"print_keyframes": ComfyNodeTypedInputRef<boolean>
			"prev_hook_kf"?: ComfyNodeTypedInputRef<ComfyValueType_HOOK_KEYFRAMES>
}


export class CombineHooks2 extends ComfyNode {
	classType: string = "CombineHooks2"

	sockets: {
		inputs: Required<CombineHooks2Inputs>
		outputs: {
			HOOKS: ComfyNodeTypedSourceRef<ComfyValueType_HOOKS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"hooks_A": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks_A"),
				"hooks_B": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks_B"),
			},
			outputs: Object.create(Object.prototype, {
				"HOOKS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CombineHooks2Inputs>) {
		if (sources["hooks_A"] !== undefined) {
		if (typeof sources["hooks_A"] === "object") {
			this.sockets.inputs["hooks_A"].connectTo(sources["hooks_A"])
		} else {
			this.sockets.inputs["hooks_A"].value = sources["hooks_A"]
		}
		}

		if (sources["hooks_B"] !== undefined) {
		if (typeof sources["hooks_B"] === "object") {
			this.sockets.inputs["hooks_B"].connectTo(sources["hooks_B"])
		} else {
			this.sockets.inputs["hooks_B"].value = sources["hooks_B"]
		}
		}

	}
}

type CombineHooks2Inputs = {
			"hooks_A"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
			"hooks_B"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
}


export class CombineHooks4 extends ComfyNode {
	classType: string = "CombineHooks4"

	sockets: {
		inputs: Required<CombineHooks4Inputs>
		outputs: {
			HOOKS: ComfyNodeTypedSourceRef<ComfyValueType_HOOKS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"hooks_A": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks_A"),
				"hooks_B": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks_B"),
				"hooks_C": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks_C"),
				"hooks_D": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks_D"),
			},
			outputs: Object.create(Object.prototype, {
				"HOOKS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CombineHooks4Inputs>) {
		if (sources["hooks_A"] !== undefined) {
		if (typeof sources["hooks_A"] === "object") {
			this.sockets.inputs["hooks_A"].connectTo(sources["hooks_A"])
		} else {
			this.sockets.inputs["hooks_A"].value = sources["hooks_A"]
		}
		}

		if (sources["hooks_B"] !== undefined) {
		if (typeof sources["hooks_B"] === "object") {
			this.sockets.inputs["hooks_B"].connectTo(sources["hooks_B"])
		} else {
			this.sockets.inputs["hooks_B"].value = sources["hooks_B"]
		}
		}

		if (sources["hooks_C"] !== undefined) {
		if (typeof sources["hooks_C"] === "object") {
			this.sockets.inputs["hooks_C"].connectTo(sources["hooks_C"])
		} else {
			this.sockets.inputs["hooks_C"].value = sources["hooks_C"]
		}
		}

		if (sources["hooks_D"] !== undefined) {
		if (typeof sources["hooks_D"] === "object") {
			this.sockets.inputs["hooks_D"].connectTo(sources["hooks_D"])
		} else {
			this.sockets.inputs["hooks_D"].value = sources["hooks_D"]
		}
		}

	}
}

type CombineHooks4Inputs = {
			"hooks_A"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
			"hooks_B"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
			"hooks_C"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
			"hooks_D"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
}


export class CombineHooks8 extends ComfyNode {
	classType: string = "CombineHooks8"

	sockets: {
		inputs: Required<CombineHooks8Inputs>
		outputs: {
			HOOKS: ComfyNodeTypedSourceRef<ComfyValueType_HOOKS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"hooks_A": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks_A"),
				"hooks_B": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks_B"),
				"hooks_C": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks_C"),
				"hooks_D": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks_D"),
				"hooks_E": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks_E"),
				"hooks_F": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks_F"),
				"hooks_G": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks_G"),
				"hooks_H": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks_H"),
			},
			outputs: Object.create(Object.prototype, {
				"HOOKS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CombineHooks8Inputs>) {
		if (sources["hooks_A"] !== undefined) {
		if (typeof sources["hooks_A"] === "object") {
			this.sockets.inputs["hooks_A"].connectTo(sources["hooks_A"])
		} else {
			this.sockets.inputs["hooks_A"].value = sources["hooks_A"]
		}
		}

		if (sources["hooks_B"] !== undefined) {
		if (typeof sources["hooks_B"] === "object") {
			this.sockets.inputs["hooks_B"].connectTo(sources["hooks_B"])
		} else {
			this.sockets.inputs["hooks_B"].value = sources["hooks_B"]
		}
		}

		if (sources["hooks_C"] !== undefined) {
		if (typeof sources["hooks_C"] === "object") {
			this.sockets.inputs["hooks_C"].connectTo(sources["hooks_C"])
		} else {
			this.sockets.inputs["hooks_C"].value = sources["hooks_C"]
		}
		}

		if (sources["hooks_D"] !== undefined) {
		if (typeof sources["hooks_D"] === "object") {
			this.sockets.inputs["hooks_D"].connectTo(sources["hooks_D"])
		} else {
			this.sockets.inputs["hooks_D"].value = sources["hooks_D"]
		}
		}

		if (sources["hooks_E"] !== undefined) {
		if (typeof sources["hooks_E"] === "object") {
			this.sockets.inputs["hooks_E"].connectTo(sources["hooks_E"])
		} else {
			this.sockets.inputs["hooks_E"].value = sources["hooks_E"]
		}
		}

		if (sources["hooks_F"] !== undefined) {
		if (typeof sources["hooks_F"] === "object") {
			this.sockets.inputs["hooks_F"].connectTo(sources["hooks_F"])
		} else {
			this.sockets.inputs["hooks_F"].value = sources["hooks_F"]
		}
		}

		if (sources["hooks_G"] !== undefined) {
		if (typeof sources["hooks_G"] === "object") {
			this.sockets.inputs["hooks_G"].connectTo(sources["hooks_G"])
		} else {
			this.sockets.inputs["hooks_G"].value = sources["hooks_G"]
		}
		}

		if (sources["hooks_H"] !== undefined) {
		if (typeof sources["hooks_H"] === "object") {
			this.sockets.inputs["hooks_H"].connectTo(sources["hooks_H"])
		} else {
			this.sockets.inputs["hooks_H"].value = sources["hooks_H"]
		}
		}

	}
}

type CombineHooks8Inputs = {
			"hooks_A"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
			"hooks_B"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
			"hooks_C"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
			"hooks_D"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
			"hooks_E"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
			"hooks_F"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
			"hooks_G"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
			"hooks_H"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
}


export class ConditioningSetProperties extends ComfyNode {
	classType: string = "ConditioningSetProperties"

	sockets: {
		inputs: Required<ConditioningSetPropertiesInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"cond_NEW": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "cond_NEW"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"set_cond_area": new ComfyNodeTypedInputRef<string>(this, "set_cond_area"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"hooks": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks"),
				"timesteps": new ComfyNodeTypedInputRef<ComfyValueType_TIMESTEPS_RANGE>(this, "timesteps"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ConditioningSetPropertiesInputs>) {
		if (typeof sources["cond_NEW"] === "object") {
			this.sockets.inputs["cond_NEW"].connectTo(sources["cond_NEW"])
		} else {
			this.sockets.inputs["cond_NEW"].value = sources["cond_NEW"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (typeof sources["set_cond_area"] === "object") {
			this.sockets.inputs["set_cond_area"].connectTo(sources["set_cond_area"])
		} else {
			this.sockets.inputs["set_cond_area"].value = sources["set_cond_area"]
		}

		if (sources["mask"] !== undefined) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}
		}

		if (sources["hooks"] !== undefined) {
		if (typeof sources["hooks"] === "object") {
			this.sockets.inputs["hooks"].connectTo(sources["hooks"])
		} else {
			this.sockets.inputs["hooks"].value = sources["hooks"]
		}
		}

		if (sources["timesteps"] !== undefined) {
		if (typeof sources["timesteps"] === "object") {
			this.sockets.inputs["timesteps"].connectTo(sources["timesteps"])
		} else {
			this.sockets.inputs["timesteps"].value = sources["timesteps"]
		}
		}

	}
}

type ConditioningSetPropertiesInputs = {
			"cond_NEW": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"strength": ComfyNodeTypedInputRef<number>
			"set_cond_area": ComfyNodeTypedInputRef<string>
			"mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"hooks"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
			"timesteps"?: ComfyNodeTypedInputRef<ComfyValueType_TIMESTEPS_RANGE>
}


export class ConditioningSetPropertiesAndCombine extends ComfyNode {
	classType: string = "ConditioningSetPropertiesAndCombine"

	sockets: {
		inputs: Required<ConditioningSetPropertiesAndCombineInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"cond": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "cond"),
				"cond_NEW": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "cond_NEW"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"set_cond_area": new ComfyNodeTypedInputRef<string>(this, "set_cond_area"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"hooks": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks"),
				"timesteps": new ComfyNodeTypedInputRef<ComfyValueType_TIMESTEPS_RANGE>(this, "timesteps"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ConditioningSetPropertiesAndCombineInputs>) {
		if (typeof sources["cond"] === "object") {
			this.sockets.inputs["cond"].connectTo(sources["cond"])
		} else {
			this.sockets.inputs["cond"].value = sources["cond"]
		}

		if (typeof sources["cond_NEW"] === "object") {
			this.sockets.inputs["cond_NEW"].connectTo(sources["cond_NEW"])
		} else {
			this.sockets.inputs["cond_NEW"].value = sources["cond_NEW"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (typeof sources["set_cond_area"] === "object") {
			this.sockets.inputs["set_cond_area"].connectTo(sources["set_cond_area"])
		} else {
			this.sockets.inputs["set_cond_area"].value = sources["set_cond_area"]
		}

		if (sources["mask"] !== undefined) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}
		}

		if (sources["hooks"] !== undefined) {
		if (typeof sources["hooks"] === "object") {
			this.sockets.inputs["hooks"].connectTo(sources["hooks"])
		} else {
			this.sockets.inputs["hooks"].value = sources["hooks"]
		}
		}

		if (sources["timesteps"] !== undefined) {
		if (typeof sources["timesteps"] === "object") {
			this.sockets.inputs["timesteps"].connectTo(sources["timesteps"])
		} else {
			this.sockets.inputs["timesteps"].value = sources["timesteps"]
		}
		}

	}
}

type ConditioningSetPropertiesAndCombineInputs = {
			"cond": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"cond_NEW": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"strength": ComfyNodeTypedInputRef<number>
			"set_cond_area": ComfyNodeTypedInputRef<string>
			"mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"hooks"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
			"timesteps"?: ComfyNodeTypedInputRef<ComfyValueType_TIMESTEPS_RANGE>
}


export class PairConditioningSetProperties extends ComfyNode {
	classType: string = "PairConditioningSetProperties"

	sockets: {
		inputs: Required<PairConditioningSetPropertiesInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive_NEW": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive_NEW"),
				"negative_NEW": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative_NEW"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"set_cond_area": new ComfyNodeTypedInputRef<string>(this, "set_cond_area"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"hooks": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks"),
				"timesteps": new ComfyNodeTypedInputRef<ComfyValueType_TIMESTEPS_RANGE>(this, "timesteps"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PairConditioningSetPropertiesInputs>) {
		if (typeof sources["positive_NEW"] === "object") {
			this.sockets.inputs["positive_NEW"].connectTo(sources["positive_NEW"])
		} else {
			this.sockets.inputs["positive_NEW"].value = sources["positive_NEW"]
		}

		if (typeof sources["negative_NEW"] === "object") {
			this.sockets.inputs["negative_NEW"].connectTo(sources["negative_NEW"])
		} else {
			this.sockets.inputs["negative_NEW"].value = sources["negative_NEW"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (typeof sources["set_cond_area"] === "object") {
			this.sockets.inputs["set_cond_area"].connectTo(sources["set_cond_area"])
		} else {
			this.sockets.inputs["set_cond_area"].value = sources["set_cond_area"]
		}

		if (sources["mask"] !== undefined) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}
		}

		if (sources["hooks"] !== undefined) {
		if (typeof sources["hooks"] === "object") {
			this.sockets.inputs["hooks"].connectTo(sources["hooks"])
		} else {
			this.sockets.inputs["hooks"].value = sources["hooks"]
		}
		}

		if (sources["timesteps"] !== undefined) {
		if (typeof sources["timesteps"] === "object") {
			this.sockets.inputs["timesteps"].connectTo(sources["timesteps"])
		} else {
			this.sockets.inputs["timesteps"].value = sources["timesteps"]
		}
		}

	}
}

type PairConditioningSetPropertiesInputs = {
			"positive_NEW": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative_NEW": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"strength": ComfyNodeTypedInputRef<number>
			"set_cond_area": ComfyNodeTypedInputRef<string>
			"mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"hooks"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
			"timesteps"?: ComfyNodeTypedInputRef<ComfyValueType_TIMESTEPS_RANGE>
}


export class PairConditioningSetPropertiesAndCombine extends ComfyNode {
	classType: string = "PairConditioningSetPropertiesAndCombine"

	sockets: {
		inputs: Required<PairConditioningSetPropertiesAndCombineInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"positive_NEW": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive_NEW"),
				"negative_NEW": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative_NEW"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"set_cond_area": new ComfyNodeTypedInputRef<string>(this, "set_cond_area"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"hooks": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks"),
				"timesteps": new ComfyNodeTypedInputRef<ComfyValueType_TIMESTEPS_RANGE>(this, "timesteps"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PairConditioningSetPropertiesAndCombineInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["positive_NEW"] === "object") {
			this.sockets.inputs["positive_NEW"].connectTo(sources["positive_NEW"])
		} else {
			this.sockets.inputs["positive_NEW"].value = sources["positive_NEW"]
		}

		if (typeof sources["negative_NEW"] === "object") {
			this.sockets.inputs["negative_NEW"].connectTo(sources["negative_NEW"])
		} else {
			this.sockets.inputs["negative_NEW"].value = sources["negative_NEW"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (typeof sources["set_cond_area"] === "object") {
			this.sockets.inputs["set_cond_area"].connectTo(sources["set_cond_area"])
		} else {
			this.sockets.inputs["set_cond_area"].value = sources["set_cond_area"]
		}

		if (sources["mask"] !== undefined) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}
		}

		if (sources["hooks"] !== undefined) {
		if (typeof sources["hooks"] === "object") {
			this.sockets.inputs["hooks"].connectTo(sources["hooks"])
		} else {
			this.sockets.inputs["hooks"].value = sources["hooks"]
		}
		}

		if (sources["timesteps"] !== undefined) {
		if (typeof sources["timesteps"] === "object") {
			this.sockets.inputs["timesteps"].connectTo(sources["timesteps"])
		} else {
			this.sockets.inputs["timesteps"].value = sources["timesteps"]
		}
		}

	}
}

type PairConditioningSetPropertiesAndCombineInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"positive_NEW": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative_NEW": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"strength": ComfyNodeTypedInputRef<number>
			"set_cond_area": ComfyNodeTypedInputRef<string>
			"mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"hooks"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
			"timesteps"?: ComfyNodeTypedInputRef<ComfyValueType_TIMESTEPS_RANGE>
}


export class ConditioningSetDefaultCombine extends ComfyNode {
	classType: string = "ConditioningSetDefaultCombine"

	sockets: {
		inputs: Required<ConditioningSetDefaultCombineInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"cond": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "cond"),
				"cond_DEFAULT": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "cond_DEFAULT"),
				"hooks": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ConditioningSetDefaultCombineInputs>) {
		if (typeof sources["cond"] === "object") {
			this.sockets.inputs["cond"].connectTo(sources["cond"])
		} else {
			this.sockets.inputs["cond"].value = sources["cond"]
		}

		if (typeof sources["cond_DEFAULT"] === "object") {
			this.sockets.inputs["cond_DEFAULT"].connectTo(sources["cond_DEFAULT"])
		} else {
			this.sockets.inputs["cond_DEFAULT"].value = sources["cond_DEFAULT"]
		}

		if (sources["hooks"] !== undefined) {
		if (typeof sources["hooks"] === "object") {
			this.sockets.inputs["hooks"].connectTo(sources["hooks"])
		} else {
			this.sockets.inputs["hooks"].value = sources["hooks"]
		}
		}

	}
}

type ConditioningSetDefaultCombineInputs = {
			"cond": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"cond_DEFAULT": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"hooks"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
}


export class PairConditioningSetDefaultCombine extends ComfyNode {
	classType: string = "PairConditioningSetDefaultCombine"

	sockets: {
		inputs: Required<PairConditioningSetDefaultCombineInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"positive_DEFAULT": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive_DEFAULT"),
				"negative_DEFAULT": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative_DEFAULT"),
				"hooks": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PairConditioningSetDefaultCombineInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["positive_DEFAULT"] === "object") {
			this.sockets.inputs["positive_DEFAULT"].connectTo(sources["positive_DEFAULT"])
		} else {
			this.sockets.inputs["positive_DEFAULT"].value = sources["positive_DEFAULT"]
		}

		if (typeof sources["negative_DEFAULT"] === "object") {
			this.sockets.inputs["negative_DEFAULT"].connectTo(sources["negative_DEFAULT"])
		} else {
			this.sockets.inputs["negative_DEFAULT"].value = sources["negative_DEFAULT"]
		}

		if (sources["hooks"] !== undefined) {
		if (typeof sources["hooks"] === "object") {
			this.sockets.inputs["hooks"].connectTo(sources["hooks"])
		} else {
			this.sockets.inputs["hooks"].value = sources["hooks"]
		}
		}

	}
}

type PairConditioningSetDefaultCombineInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"positive_DEFAULT": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative_DEFAULT": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"hooks"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
}


export class PairConditioningCombine extends ComfyNode {
	classType: string = "PairConditioningCombine"

	sockets: {
		inputs: Required<PairConditioningCombineInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive_A": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive_A"),
				"negative_A": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative_A"),
				"positive_B": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive_B"),
				"negative_B": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative_B"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PairConditioningCombineInputs>) {
		if (typeof sources["positive_A"] === "object") {
			this.sockets.inputs["positive_A"].connectTo(sources["positive_A"])
		} else {
			this.sockets.inputs["positive_A"].value = sources["positive_A"]
		}

		if (typeof sources["negative_A"] === "object") {
			this.sockets.inputs["negative_A"].connectTo(sources["negative_A"])
		} else {
			this.sockets.inputs["negative_A"].value = sources["negative_A"]
		}

		if (typeof sources["positive_B"] === "object") {
			this.sockets.inputs["positive_B"].connectTo(sources["positive_B"])
		} else {
			this.sockets.inputs["positive_B"].value = sources["positive_B"]
		}

		if (typeof sources["negative_B"] === "object") {
			this.sockets.inputs["negative_B"].connectTo(sources["negative_B"])
		} else {
			this.sockets.inputs["negative_B"].value = sources["negative_B"]
		}

	}
}

type PairConditioningCombineInputs = {
			"positive_A": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative_A": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"positive_B": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative_B": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
}


export class SetClipHooks extends ComfyNode {
	classType: string = "SetClipHooks"

	sockets: {
		inputs: Required<SetClipHooksInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"apply_to_conds": new ComfyNodeTypedInputRef<boolean>(this, "apply_to_conds"),
				"schedule_clip": new ComfyNodeTypedInputRef<boolean>(this, "schedule_clip"),
				"hooks": new ComfyNodeTypedInputRef<ComfyValueType_HOOKS>(this, "hooks"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SetClipHooksInputs>) {
		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["apply_to_conds"] === "object") {
			this.sockets.inputs["apply_to_conds"].connectTo(sources["apply_to_conds"])
		} else {
			this.sockets.inputs["apply_to_conds"].value = sources["apply_to_conds"]
		}

		if (typeof sources["schedule_clip"] === "object") {
			this.sockets.inputs["schedule_clip"].connectTo(sources["schedule_clip"])
		} else {
			this.sockets.inputs["schedule_clip"].value = sources["schedule_clip"]
		}

		if (sources["hooks"] !== undefined) {
		if (typeof sources["hooks"] === "object") {
			this.sockets.inputs["hooks"].connectTo(sources["hooks"])
		} else {
			this.sockets.inputs["hooks"].value = sources["hooks"]
		}
		}

	}
}

type SetClipHooksInputs = {
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"apply_to_conds": ComfyNodeTypedInputRef<boolean>
			"schedule_clip": ComfyNodeTypedInputRef<boolean>
			"hooks"?: ComfyNodeTypedInputRef<ComfyValueType_HOOKS>
}


export class ConditioningTimestepsRange extends ComfyNode {
	classType: string = "ConditioningTimestepsRange"

	sockets: {
		inputs: Required<ConditioningTimestepsRangeInputs>
		outputs: {
			TIMESTEPS_RANGE: ComfyNodeTypedSourceRef<ComfyValueType_TIMESTEPS_RANGE>
			BEFORE_RANGE: ComfyNodeTypedSourceRef<ComfyValueType_TIMESTEPS_RANGE>
			AFTER_RANGE: ComfyNodeTypedSourceRef<ComfyValueType_TIMESTEPS_RANGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
			},
			outputs: Object.create(Object.prototype, {
				"TIMESTEPS_RANGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"BEFORE_RANGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"AFTER_RANGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ConditioningTimestepsRangeInputs>) {
		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

	}
}

type ConditioningTimestepsRangeInputs = {
			"start_percent": ComfyNodeTypedInputRef<number>
			"end_percent": ComfyNodeTypedInputRef<number>
}


export class Load3D extends ComfyNode {
	classType: string = "Load3D"

	sockets: {
		inputs: Required<Load3DInputs>
		outputs: {
			image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			mesh_path: ComfyNodeTypedSourceRef<string>
			normal: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			lineart: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			camera_info: ComfyNodeTypedSourceRef<ComfyValueType_LOAD3D_CAMERA>
			recording_video: ComfyNodeTypedSourceRef<ComfyValueType_VIDEO>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_file": new ComfyNodeTypedInputRef<void>(this, "model_file"),
				"image": new ComfyNodeTypedInputRef<ComfyValueType_LOAD_3D>(this, "image"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
			},
			outputs: Object.create(Object.prototype, {
				"image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"mesh_path": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"normal": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
				"lineart": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 4 }
					}
				},
				"camera_info": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 5 }
					}
				},
				"recording_video": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 6 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<Load3DInputs>) {
		if (typeof sources["model_file"] === "object") {
			this.sockets.inputs["model_file"].connectTo(sources["model_file"])
		} else {
			this.sockets.inputs["model_file"].value = sources["model_file"]
		}

		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

	}
}

type Load3DInputs = {
			"model_file": ComfyNodeTypedInputRef<void>
			"image": ComfyNodeTypedInputRef<ComfyValueType_LOAD_3D>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
}


export class Load3DAnimation extends ComfyNode {
	classType: string = "Load3DAnimation"

	sockets: {
		inputs: Required<Load3DAnimationInputs>
		outputs: {
			image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			mesh_path: ComfyNodeTypedSourceRef<string>
			normal: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			camera_info: ComfyNodeTypedSourceRef<ComfyValueType_LOAD3D_CAMERA>
			recording_video: ComfyNodeTypedSourceRef<ComfyValueType_VIDEO>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_file": new ComfyNodeTypedInputRef<void>(this, "model_file"),
				"image": new ComfyNodeTypedInputRef<ComfyValueType_LOAD_3D_ANIMATION>(this, "image"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
			},
			outputs: Object.create(Object.prototype, {
				"image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"mesh_path": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"normal": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
				"camera_info": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 4 }
					}
				},
				"recording_video": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 5 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<Load3DAnimationInputs>) {
		if (typeof sources["model_file"] === "object") {
			this.sockets.inputs["model_file"].connectTo(sources["model_file"])
		} else {
			this.sockets.inputs["model_file"].value = sources["model_file"]
		}

		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

	}
}

type Load3DAnimationInputs = {
			"model_file": ComfyNodeTypedInputRef<void>
			"image": ComfyNodeTypedInputRef<ComfyValueType_LOAD_3D_ANIMATION>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
}


export class Preview3D extends ComfyNode {
	classType: string = "Preview3D"

	sockets: {
		inputs: Required<Preview3DInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_file": new ComfyNodeTypedInputRef<string>(this, "model_file"),
				"camera_info": new ComfyNodeTypedInputRef<ComfyValueType_LOAD3D_CAMERA>(this, "camera_info"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<Preview3DInputs>) {
		if (typeof sources["model_file"] === "object") {
			this.sockets.inputs["model_file"].connectTo(sources["model_file"])
		} else {
			this.sockets.inputs["model_file"].value = sources["model_file"]
		}

		if (sources["camera_info"] !== undefined) {
		if (typeof sources["camera_info"] === "object") {
			this.sockets.inputs["camera_info"].connectTo(sources["camera_info"])
		} else {
			this.sockets.inputs["camera_info"].value = sources["camera_info"]
		}
		}

	}
}

type Preview3DInputs = {
			"model_file": ComfyNodeTypedInputRef<string>
			"camera_info"?: ComfyNodeTypedInputRef<ComfyValueType_LOAD3D_CAMERA>
}


export class Preview3DAnimation extends ComfyNode {
	classType: string = "Preview3DAnimation"

	sockets: {
		inputs: Required<Preview3DAnimationInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_file": new ComfyNodeTypedInputRef<string>(this, "model_file"),
				"camera_info": new ComfyNodeTypedInputRef<ComfyValueType_LOAD3D_CAMERA>(this, "camera_info"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<Preview3DAnimationInputs>) {
		if (typeof sources["model_file"] === "object") {
			this.sockets.inputs["model_file"].connectTo(sources["model_file"])
		} else {
			this.sockets.inputs["model_file"].value = sources["model_file"]
		}

		if (sources["camera_info"] !== undefined) {
		if (typeof sources["camera_info"] === "object") {
			this.sockets.inputs["camera_info"].connectTo(sources["camera_info"])
		} else {
			this.sockets.inputs["camera_info"].value = sources["camera_info"]
		}
		}

	}
}

type Preview3DAnimationInputs = {
			"model_file": ComfyNodeTypedInputRef<string>
			"camera_info"?: ComfyNodeTypedInputRef<ComfyValueType_LOAD3D_CAMERA>
}


export class EmptyCosmosLatentVideo extends ComfyNode {
	classType: string = "EmptyCosmosLatentVideo"

	sockets: {
		inputs: Required<EmptyCosmosLatentVideoInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<EmptyCosmosLatentVideoInputs>) {
		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

	}
}

type EmptyCosmosLatentVideoInputs = {
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
}


export class CosmosImageToVideoLatent extends ComfyNode {
	classType: string = "CosmosImageToVideoLatent"

	sockets: {
		inputs: Required<CosmosImageToVideoLatentInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"start_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "start_image"),
				"end_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "end_image"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CosmosImageToVideoLatentInputs>) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (sources["start_image"] !== undefined) {
		if (typeof sources["start_image"] === "object") {
			this.sockets.inputs["start_image"].connectTo(sources["start_image"])
		} else {
			this.sockets.inputs["start_image"].value = sources["start_image"]
		}
		}

		if (sources["end_image"] !== undefined) {
		if (typeof sources["end_image"] === "object") {
			this.sockets.inputs["end_image"].connectTo(sources["end_image"])
		} else {
			this.sockets.inputs["end_image"].value = sources["end_image"]
		}
		}

	}
}

type CosmosImageToVideoLatentInputs = {
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"start_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"end_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class CosmosPredict2ImageToVideoLatent extends ComfyNode {
	classType: string = "CosmosPredict2ImageToVideoLatent"

	sockets: {
		inputs: Required<CosmosPredict2ImageToVideoLatentInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"start_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "start_image"),
				"end_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "end_image"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CosmosPredict2ImageToVideoLatentInputs>) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (sources["start_image"] !== undefined) {
		if (typeof sources["start_image"] === "object") {
			this.sockets.inputs["start_image"].connectTo(sources["start_image"])
		} else {
			this.sockets.inputs["start_image"].value = sources["start_image"]
		}
		}

		if (sources["end_image"] !== undefined) {
		if (typeof sources["end_image"] === "object") {
			this.sockets.inputs["end_image"].connectTo(sources["end_image"])
		} else {
			this.sockets.inputs["end_image"].value = sources["end_image"]
		}
		}

	}
}

type CosmosPredict2ImageToVideoLatentInputs = {
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"start_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"end_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class SaveWEBM extends ComfyNode {
	classType: string = "SaveWEBM"

	sockets: {
		inputs: Required<SaveWEBMInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"codec": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "codec"),
				"fps": new ComfyNodeTypedInputRef<number>(this, "fps"),
				"crf": new ComfyNodeTypedInputRef<number>(this, "crf"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_PROMPT>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_EXTRA_PNGINFO>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<SaveWEBMInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (typeof sources["codec"] === "object") {
			this.sockets.inputs["codec"].connectTo(sources["codec"])
		} else {
			this.sockets.inputs["codec"].value = sources["codec"]
		}

		if (typeof sources["fps"] === "object") {
			this.sockets.inputs["fps"].connectTo(sources["fps"])
		} else {
			this.sockets.inputs["fps"].value = sources["fps"]
		}

		if (typeof sources["crf"] === "object") {
			this.sockets.inputs["crf"].connectTo(sources["crf"])
		} else {
			this.sockets.inputs["crf"].value = sources["crf"]
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type SaveWEBMInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"filename_prefix": ComfyNodeTypedInputRef<string>
			"codec": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"fps": ComfyNodeTypedInputRef<number>
			/** Higher crf means lower quality with a smaller file size, lower crf means higher quality higher filesize.*/
			"crf": ComfyNodeTypedInputRef<number>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_PROMPT>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_EXTRA_PNGINFO>
}


export class SaveVideo extends ComfyNode {
	classType: string = "SaveVideo"

	sockets: {
		inputs: Required<SaveVideoInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"video": new ComfyNodeTypedInputRef<ComfyValueType_VIDEO>(this, "video"),
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"format": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "format"),
				"codec": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "codec"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_PROMPT>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_EXTRA_PNGINFO>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<SaveVideoInputs>) {
		if (typeof sources["video"] === "object") {
			this.sockets.inputs["video"].connectTo(sources["video"])
		} else {
			this.sockets.inputs["video"].value = sources["video"]
		}

		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (typeof sources["format"] === "object") {
			this.sockets.inputs["format"].connectTo(sources["format"])
		} else {
			this.sockets.inputs["format"].value = sources["format"]
		}

		if (typeof sources["codec"] === "object") {
			this.sockets.inputs["codec"].connectTo(sources["codec"])
		} else {
			this.sockets.inputs["codec"].value = sources["codec"]
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type SaveVideoInputs = {
			/** The video to save.*/
			"video": ComfyNodeTypedInputRef<ComfyValueType_VIDEO>
			/** The prefix for the file to save. This may include formatting information such as %date:yyyy-MM-dd% or %Empty Latent Image.width% to include values from nodes.*/
			"filename_prefix": ComfyNodeTypedInputRef<string>
			/** The format to save the video as.*/
			"format": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			/** The codec to use for the video.*/
			"codec": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_PROMPT>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_EXTRA_PNGINFO>
}


export class CreateVideo extends ComfyNode {
	classType: string = "CreateVideo"

	sockets: {
		inputs: Required<CreateVideoInputs>
		outputs: {
			VIDEO: ComfyNodeTypedSourceRef<ComfyValueType_VIDEO>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"fps": new ComfyNodeTypedInputRef<number>(this, "fps"),
				"audio": new ComfyNodeTypedInputRef<ComfyValueType_AUDIO>(this, "audio"),
			},
			outputs: Object.create(Object.prototype, {
				"VIDEO": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateVideoInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["fps"] === "object") {
			this.sockets.inputs["fps"].connectTo(sources["fps"])
		} else {
			this.sockets.inputs["fps"].value = sources["fps"]
		}

		if (sources["audio"] !== undefined) {
		if (typeof sources["audio"] === "object") {
			this.sockets.inputs["audio"].connectTo(sources["audio"])
		} else {
			this.sockets.inputs["audio"].value = sources["audio"]
		}
		}

	}
}

type CreateVideoInputs = {
			/** The images to create a video from.*/
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"fps": ComfyNodeTypedInputRef<number>
			/** The audio to add to the video.*/
			"audio"?: ComfyNodeTypedInputRef<ComfyValueType_AUDIO>
}


export class GetVideoComponents extends ComfyNode {
	classType: string = "GetVideoComponents"

	sockets: {
		inputs: Required<GetVideoComponentsInputs>
		outputs: {
			images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			audio: ComfyNodeTypedSourceRef<ComfyValueType_AUDIO>
			fps: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"video": new ComfyNodeTypedInputRef<ComfyValueType_VIDEO>(this, "video"),
			},
			outputs: Object.create(Object.prototype, {
				"images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"audio": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"fps": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<GetVideoComponentsInputs>) {
		if (typeof sources["video"] === "object") {
			this.sockets.inputs["video"].connectTo(sources["video"])
		} else {
			this.sockets.inputs["video"].value = sources["video"]
		}

	}
}

type GetVideoComponentsInputs = {
			/** The video to extract components from.*/
			"video": ComfyNodeTypedInputRef<ComfyValueType_VIDEO>
}


export class LoadVideo extends ComfyNode {
	classType: string = "LoadVideo"

	sockets: {
		inputs: Required<LoadVideoInputs>
		outputs: {
			VIDEO: ComfyNodeTypedSourceRef<ComfyValueType_VIDEO>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"file": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "file"),
			},
			outputs: Object.create(Object.prototype, {
				"VIDEO": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoadVideoInputs>) {
		if (typeof sources["file"] === "object") {
			this.sockets.inputs["file"].connectTo(sources["file"])
		} else {
			this.sockets.inputs["file"].value = sources["file"]
		}

	}
}

type LoadVideoInputs = {
			"file": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class CLIPTextEncodeLumina2 extends ComfyNode {
	classType: string = "CLIPTextEncodeLumina2"

	sockets: {
		inputs: Required<CLIPTextEncodeLumina2Inputs>
		outputs: {
			/** A conditioning containing the embedded text used to guide the diffusion model.*/
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"system_prompt": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "system_prompt"),
				"user_prompt": new ComfyNodeTypedInputRef<string>(this, "user_prompt"),
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPTextEncodeLumina2Inputs>) {
		if (typeof sources["system_prompt"] === "object") {
			this.sockets.inputs["system_prompt"].connectTo(sources["system_prompt"])
		} else {
			this.sockets.inputs["system_prompt"].value = sources["system_prompt"]
		}

		if (typeof sources["user_prompt"] === "object") {
			this.sockets.inputs["user_prompt"].connectTo(sources["user_prompt"])
		} else {
			this.sockets.inputs["user_prompt"].value = sources["user_prompt"]
		}

		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

	}
}

type CLIPTextEncodeLumina2Inputs = {
			/** Lumina2 provide two types of system prompts:Superior: You are an assistant designed to generate superior images with the superior degree of image-text alignment based on textual prompts or user prompts. Alignment: You are an assistant designed to generate high-quality images with the highest degree of image-text alignment based on textual prompts.*/
			"system_prompt": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			/** The text to be encoded.*/
			"user_prompt": ComfyNodeTypedInputRef<string>
			/** The CLIP model used for encoding the text.*/
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
}


export class RenormCFG extends ComfyNode {
	classType: string = "RenormCFG"

	sockets: {
		inputs: Required<RenormCFGInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"cfg_trunc": new ComfyNodeTypedInputRef<number>(this, "cfg_trunc"),
				"renorm_cfg": new ComfyNodeTypedInputRef<number>(this, "renorm_cfg"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<RenormCFGInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["cfg_trunc"] === "object") {
			this.sockets.inputs["cfg_trunc"].connectTo(sources["cfg_trunc"])
		} else {
			this.sockets.inputs["cfg_trunc"].value = sources["cfg_trunc"]
		}

		if (typeof sources["renorm_cfg"] === "object") {
			this.sockets.inputs["renorm_cfg"].connectTo(sources["renorm_cfg"])
		} else {
			this.sockets.inputs["renorm_cfg"].value = sources["renorm_cfg"]
		}

	}
}

type RenormCFGInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"cfg_trunc": ComfyNodeTypedInputRef<number>
			"renorm_cfg": ComfyNodeTypedInputRef<number>
}


export class WanTrackToVideo extends ComfyNode {
	classType: string = "WanTrackToVideo"

	sockets: {
		inputs: Required<WanTrackToVideoInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"tracks": new ComfyNodeTypedInputRef<string>(this, "tracks"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"temperature": new ComfyNodeTypedInputRef<number>(this, "temperature"),
				"topk": new ComfyNodeTypedInputRef<number>(this, "topk"),
				"start_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "start_image"),
				"clip_vision_output": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>(this, "clip_vision_output"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanTrackToVideoInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["tracks"] === "object") {
			this.sockets.inputs["tracks"].connectTo(sources["tracks"])
		} else {
			this.sockets.inputs["tracks"].value = sources["tracks"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (typeof sources["temperature"] === "object") {
			this.sockets.inputs["temperature"].connectTo(sources["temperature"])
		} else {
			this.sockets.inputs["temperature"].value = sources["temperature"]
		}

		if (typeof sources["topk"] === "object") {
			this.sockets.inputs["topk"].connectTo(sources["topk"])
		} else {
			this.sockets.inputs["topk"].value = sources["topk"]
		}

		if (typeof sources["start_image"] === "object") {
			this.sockets.inputs["start_image"].connectTo(sources["start_image"])
		} else {
			this.sockets.inputs["start_image"].value = sources["start_image"]
		}

		if (sources["clip_vision_output"] !== undefined) {
		if (typeof sources["clip_vision_output"] === "object") {
			this.sockets.inputs["clip_vision_output"].connectTo(sources["clip_vision_output"])
		} else {
			this.sockets.inputs["clip_vision_output"].value = sources["clip_vision_output"]
		}
		}

	}
}

type WanTrackToVideoInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"tracks": ComfyNodeTypedInputRef<string>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"temperature": ComfyNodeTypedInputRef<number>
			"topk": ComfyNodeTypedInputRef<number>
			"start_image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"clip_vision_output"?: ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>
}


export class WanImageToVideo extends ComfyNode {
	classType: string = "WanImageToVideo"

	sockets: {
		inputs: Required<WanImageToVideoInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"clip_vision_output": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>(this, "clip_vision_output"),
				"start_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "start_image"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanImageToVideoInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (sources["clip_vision_output"] !== undefined) {
		if (typeof sources["clip_vision_output"] === "object") {
			this.sockets.inputs["clip_vision_output"].connectTo(sources["clip_vision_output"])
		} else {
			this.sockets.inputs["clip_vision_output"].value = sources["clip_vision_output"]
		}
		}

		if (sources["start_image"] !== undefined) {
		if (typeof sources["start_image"] === "object") {
			this.sockets.inputs["start_image"].connectTo(sources["start_image"])
		} else {
			this.sockets.inputs["start_image"].value = sources["start_image"]
		}
		}

	}
}

type WanImageToVideoInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"clip_vision_output"?: ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>
			"start_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class WanFunControlToVideo extends ComfyNode {
	classType: string = "WanFunControlToVideo"

	sockets: {
		inputs: Required<WanFunControlToVideoInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"clip_vision_output": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>(this, "clip_vision_output"),
				"start_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "start_image"),
				"control_video": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "control_video"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanFunControlToVideoInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (sources["clip_vision_output"] !== undefined) {
		if (typeof sources["clip_vision_output"] === "object") {
			this.sockets.inputs["clip_vision_output"].connectTo(sources["clip_vision_output"])
		} else {
			this.sockets.inputs["clip_vision_output"].value = sources["clip_vision_output"]
		}
		}

		if (sources["start_image"] !== undefined) {
		if (typeof sources["start_image"] === "object") {
			this.sockets.inputs["start_image"].connectTo(sources["start_image"])
		} else {
			this.sockets.inputs["start_image"].value = sources["start_image"]
		}
		}

		if (sources["control_video"] !== undefined) {
		if (typeof sources["control_video"] === "object") {
			this.sockets.inputs["control_video"].connectTo(sources["control_video"])
		} else {
			this.sockets.inputs["control_video"].value = sources["control_video"]
		}
		}

	}
}

type WanFunControlToVideoInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"clip_vision_output"?: ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>
			"start_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"control_video"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class Wan22FunControlToVideo extends ComfyNode {
	classType: string = "Wan22FunControlToVideo"

	sockets: {
		inputs: Required<Wan22FunControlToVideoInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"ref_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "ref_image"),
				"control_video": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "control_video"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<Wan22FunControlToVideoInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (sources["ref_image"] !== undefined) {
		if (typeof sources["ref_image"] === "object") {
			this.sockets.inputs["ref_image"].connectTo(sources["ref_image"])
		} else {
			this.sockets.inputs["ref_image"].value = sources["ref_image"]
		}
		}

		if (sources["control_video"] !== undefined) {
		if (typeof sources["control_video"] === "object") {
			this.sockets.inputs["control_video"].connectTo(sources["control_video"])
		} else {
			this.sockets.inputs["control_video"].value = sources["control_video"]
		}
		}

	}
}

type Wan22FunControlToVideoInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"ref_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"control_video"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class WanFunInpaintToVideo extends ComfyNode {
	classType: string = "WanFunInpaintToVideo"

	sockets: {
		inputs: Required<WanFunInpaintToVideoInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"clip_vision_output": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>(this, "clip_vision_output"),
				"start_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "start_image"),
				"end_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "end_image"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanFunInpaintToVideoInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (sources["clip_vision_output"] !== undefined) {
		if (typeof sources["clip_vision_output"] === "object") {
			this.sockets.inputs["clip_vision_output"].connectTo(sources["clip_vision_output"])
		} else {
			this.sockets.inputs["clip_vision_output"].value = sources["clip_vision_output"]
		}
		}

		if (sources["start_image"] !== undefined) {
		if (typeof sources["start_image"] === "object") {
			this.sockets.inputs["start_image"].connectTo(sources["start_image"])
		} else {
			this.sockets.inputs["start_image"].value = sources["start_image"]
		}
		}

		if (sources["end_image"] !== undefined) {
		if (typeof sources["end_image"] === "object") {
			this.sockets.inputs["end_image"].connectTo(sources["end_image"])
		} else {
			this.sockets.inputs["end_image"].value = sources["end_image"]
		}
		}

	}
}

type WanFunInpaintToVideoInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"clip_vision_output"?: ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>
			"start_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"end_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class WanFirstLastFrameToVideo extends ComfyNode {
	classType: string = "WanFirstLastFrameToVideo"

	sockets: {
		inputs: Required<WanFirstLastFrameToVideoInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"clip_vision_start_image": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>(this, "clip_vision_start_image"),
				"clip_vision_end_image": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>(this, "clip_vision_end_image"),
				"start_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "start_image"),
				"end_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "end_image"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanFirstLastFrameToVideoInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (sources["clip_vision_start_image"] !== undefined) {
		if (typeof sources["clip_vision_start_image"] === "object") {
			this.sockets.inputs["clip_vision_start_image"].connectTo(sources["clip_vision_start_image"])
		} else {
			this.sockets.inputs["clip_vision_start_image"].value = sources["clip_vision_start_image"]
		}
		}

		if (sources["clip_vision_end_image"] !== undefined) {
		if (typeof sources["clip_vision_end_image"] === "object") {
			this.sockets.inputs["clip_vision_end_image"].connectTo(sources["clip_vision_end_image"])
		} else {
			this.sockets.inputs["clip_vision_end_image"].value = sources["clip_vision_end_image"]
		}
		}

		if (sources["start_image"] !== undefined) {
		if (typeof sources["start_image"] === "object") {
			this.sockets.inputs["start_image"].connectTo(sources["start_image"])
		} else {
			this.sockets.inputs["start_image"].value = sources["start_image"]
		}
		}

		if (sources["end_image"] !== undefined) {
		if (typeof sources["end_image"] === "object") {
			this.sockets.inputs["end_image"].connectTo(sources["end_image"])
		} else {
			this.sockets.inputs["end_image"].value = sources["end_image"]
		}
		}

	}
}

type WanFirstLastFrameToVideoInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"clip_vision_start_image"?: ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>
			"clip_vision_end_image"?: ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>
			"start_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"end_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class WanVaceToVideo extends ComfyNode {
	classType: string = "WanVaceToVideo"

	sockets: {
		inputs: Required<WanVaceToVideoInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
			trim_latent: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"control_video": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "control_video"),
				"control_masks": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "control_masks"),
				"reference_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "reference_image"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"trim_latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVaceToVideoInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (sources["control_video"] !== undefined) {
		if (typeof sources["control_video"] === "object") {
			this.sockets.inputs["control_video"].connectTo(sources["control_video"])
		} else {
			this.sockets.inputs["control_video"].value = sources["control_video"]
		}
		}

		if (sources["control_masks"] !== undefined) {
		if (typeof sources["control_masks"] === "object") {
			this.sockets.inputs["control_masks"].connectTo(sources["control_masks"])
		} else {
			this.sockets.inputs["control_masks"].value = sources["control_masks"]
		}
		}

		if (sources["reference_image"] !== undefined) {
		if (typeof sources["reference_image"] === "object") {
			this.sockets.inputs["reference_image"].connectTo(sources["reference_image"])
		} else {
			this.sockets.inputs["reference_image"].value = sources["reference_image"]
		}
		}

	}
}

type WanVaceToVideoInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"strength": ComfyNodeTypedInputRef<number>
			"control_video"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"control_masks"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"reference_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class TrimVideoLatent extends ComfyNode {
	classType: string = "TrimVideoLatent"

	sockets: {
		inputs: Required<TrimVideoLatentInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"trim_amount": new ComfyNodeTypedInputRef<number>(this, "trim_amount"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TrimVideoLatentInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["trim_amount"] === "object") {
			this.sockets.inputs["trim_amount"].connectTo(sources["trim_amount"])
		} else {
			this.sockets.inputs["trim_amount"].value = sources["trim_amount"]
		}

	}
}

type TrimVideoLatentInputs = {
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"trim_amount": ComfyNodeTypedInputRef<number>
}


export class WanCameraImageToVideo extends ComfyNode {
	classType: string = "WanCameraImageToVideo"

	sockets: {
		inputs: Required<WanCameraImageToVideoInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"clip_vision_output": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>(this, "clip_vision_output"),
				"start_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "start_image"),
				"camera_conditions": new ComfyNodeTypedInputRef<ComfyValueType_WAN_CAMERA_EMBEDDING>(this, "camera_conditions"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanCameraImageToVideoInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (sources["clip_vision_output"] !== undefined) {
		if (typeof sources["clip_vision_output"] === "object") {
			this.sockets.inputs["clip_vision_output"].connectTo(sources["clip_vision_output"])
		} else {
			this.sockets.inputs["clip_vision_output"].value = sources["clip_vision_output"]
		}
		}

		if (sources["start_image"] !== undefined) {
		if (typeof sources["start_image"] === "object") {
			this.sockets.inputs["start_image"].connectTo(sources["start_image"])
		} else {
			this.sockets.inputs["start_image"].value = sources["start_image"]
		}
		}

		if (sources["camera_conditions"] !== undefined) {
		if (typeof sources["camera_conditions"] === "object") {
			this.sockets.inputs["camera_conditions"].connectTo(sources["camera_conditions"])
		} else {
			this.sockets.inputs["camera_conditions"].value = sources["camera_conditions"]
		}
		}

	}
}

type WanCameraImageToVideoInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"clip_vision_output"?: ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>
			"start_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"camera_conditions"?: ComfyNodeTypedInputRef<ComfyValueType_WAN_CAMERA_EMBEDDING>
}


export class WanPhantomSubjectToVideo extends ComfyNode {
	classType: string = "WanPhantomSubjectToVideo"

	sockets: {
		inputs: Required<WanPhantomSubjectToVideoInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative_text: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative_img_text: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative_text": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"negative_img_text": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanPhantomSubjectToVideoInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (sources["images"] !== undefined) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}
		}

	}
}

type WanPhantomSubjectToVideoInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"images"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class WanSoundImageToVideo extends ComfyNode {
	classType: string = "WanSoundImageToVideo"

	sockets: {
		inputs: Required<WanSoundImageToVideoInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"audio_encoder_output": new ComfyNodeTypedInputRef<ComfyValueType_AUDIO_ENCODER_OUTPUT>(this, "audio_encoder_output"),
				"ref_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "ref_image"),
				"control_video": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "control_video"),
				"ref_motion": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "ref_motion"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanSoundImageToVideoInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (sources["audio_encoder_output"] !== undefined) {
		if (typeof sources["audio_encoder_output"] === "object") {
			this.sockets.inputs["audio_encoder_output"].connectTo(sources["audio_encoder_output"])
		} else {
			this.sockets.inputs["audio_encoder_output"].value = sources["audio_encoder_output"]
		}
		}

		if (sources["ref_image"] !== undefined) {
		if (typeof sources["ref_image"] === "object") {
			this.sockets.inputs["ref_image"].connectTo(sources["ref_image"])
		} else {
			this.sockets.inputs["ref_image"].value = sources["ref_image"]
		}
		}

		if (sources["control_video"] !== undefined) {
		if (typeof sources["control_video"] === "object") {
			this.sockets.inputs["control_video"].connectTo(sources["control_video"])
		} else {
			this.sockets.inputs["control_video"].value = sources["control_video"]
		}
		}

		if (sources["ref_motion"] !== undefined) {
		if (typeof sources["ref_motion"] === "object") {
			this.sockets.inputs["ref_motion"].connectTo(sources["ref_motion"])
		} else {
			this.sockets.inputs["ref_motion"].value = sources["ref_motion"]
		}
		}

	}
}

type WanSoundImageToVideoInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"audio_encoder_output"?: ComfyNodeTypedInputRef<ComfyValueType_AUDIO_ENCODER_OUTPUT>
			"ref_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"control_video"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"ref_motion"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class WanSoundImageToVideoExtend extends ComfyNode {
	classType: string = "WanSoundImageToVideoExtend"

	sockets: {
		inputs: Required<WanSoundImageToVideoExtendInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"video_latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "video_latent"),
				"audio_encoder_output": new ComfyNodeTypedInputRef<ComfyValueType_AUDIO_ENCODER_OUTPUT>(this, "audio_encoder_output"),
				"ref_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "ref_image"),
				"control_video": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "control_video"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanSoundImageToVideoExtendInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["video_latent"] === "object") {
			this.sockets.inputs["video_latent"].connectTo(sources["video_latent"])
		} else {
			this.sockets.inputs["video_latent"].value = sources["video_latent"]
		}

		if (sources["audio_encoder_output"] !== undefined) {
		if (typeof sources["audio_encoder_output"] === "object") {
			this.sockets.inputs["audio_encoder_output"].connectTo(sources["audio_encoder_output"])
		} else {
			this.sockets.inputs["audio_encoder_output"].value = sources["audio_encoder_output"]
		}
		}

		if (sources["ref_image"] !== undefined) {
		if (typeof sources["ref_image"] === "object") {
			this.sockets.inputs["ref_image"].connectTo(sources["ref_image"])
		} else {
			this.sockets.inputs["ref_image"].value = sources["ref_image"]
		}
		}

		if (sources["control_video"] !== undefined) {
		if (typeof sources["control_video"] === "object") {
			this.sockets.inputs["control_video"].connectTo(sources["control_video"])
		} else {
			this.sockets.inputs["control_video"].value = sources["control_video"]
		}
		}

	}
}

type WanSoundImageToVideoExtendInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"length": ComfyNodeTypedInputRef<number>
			"video_latent": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"audio_encoder_output"?: ComfyNodeTypedInputRef<ComfyValueType_AUDIO_ENCODER_OUTPUT>
			"ref_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"control_video"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class WanHuMoImageToVideo extends ComfyNode {
	classType: string = "WanHuMoImageToVideo"

	sockets: {
		inputs: Required<WanHuMoImageToVideoInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"audio_encoder_output": new ComfyNodeTypedInputRef<ComfyValueType_AUDIO_ENCODER_OUTPUT>(this, "audio_encoder_output"),
				"ref_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "ref_image"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanHuMoImageToVideoInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (sources["audio_encoder_output"] !== undefined) {
		if (typeof sources["audio_encoder_output"] === "object") {
			this.sockets.inputs["audio_encoder_output"].connectTo(sources["audio_encoder_output"])
		} else {
			this.sockets.inputs["audio_encoder_output"].value = sources["audio_encoder_output"]
		}
		}

		if (sources["ref_image"] !== undefined) {
		if (typeof sources["ref_image"] === "object") {
			this.sockets.inputs["ref_image"].connectTo(sources["ref_image"])
		} else {
			this.sockets.inputs["ref_image"].value = sources["ref_image"]
		}
		}

	}
}

type WanHuMoImageToVideoInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"audio_encoder_output"?: ComfyNodeTypedInputRef<ComfyValueType_AUDIO_ENCODER_OUTPUT>
			"ref_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class WanAnimateToVideo extends ComfyNode {
	classType: string = "WanAnimateToVideo"

	sockets: {
		inputs: Required<WanAnimateToVideoInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
			trim_latent: ComfyNodeTypedSourceRef<number>
			trim_image: ComfyNodeTypedSourceRef<number>
			video_frame_offset: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"continue_motion_max_frames": new ComfyNodeTypedInputRef<number>(this, "continue_motion_max_frames"),
				"video_frame_offset": new ComfyNodeTypedInputRef<number>(this, "video_frame_offset"),
				"clip_vision_output": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>(this, "clip_vision_output"),
				"reference_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "reference_image"),
				"face_video": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "face_video"),
				"pose_video": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "pose_video"),
				"background_video": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "background_video"),
				"character_mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "character_mask"),
				"continue_motion": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "continue_motion"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"trim_latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
				"trim_image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 4 }
					}
				},
				"video_frame_offset": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 5 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanAnimateToVideoInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (typeof sources["continue_motion_max_frames"] === "object") {
			this.sockets.inputs["continue_motion_max_frames"].connectTo(sources["continue_motion_max_frames"])
		} else {
			this.sockets.inputs["continue_motion_max_frames"].value = sources["continue_motion_max_frames"]
		}

		if (typeof sources["video_frame_offset"] === "object") {
			this.sockets.inputs["video_frame_offset"].connectTo(sources["video_frame_offset"])
		} else {
			this.sockets.inputs["video_frame_offset"].value = sources["video_frame_offset"]
		}

		if (sources["clip_vision_output"] !== undefined) {
		if (typeof sources["clip_vision_output"] === "object") {
			this.sockets.inputs["clip_vision_output"].connectTo(sources["clip_vision_output"])
		} else {
			this.sockets.inputs["clip_vision_output"].value = sources["clip_vision_output"]
		}
		}

		if (sources["reference_image"] !== undefined) {
		if (typeof sources["reference_image"] === "object") {
			this.sockets.inputs["reference_image"].connectTo(sources["reference_image"])
		} else {
			this.sockets.inputs["reference_image"].value = sources["reference_image"]
		}
		}

		if (sources["face_video"] !== undefined) {
		if (typeof sources["face_video"] === "object") {
			this.sockets.inputs["face_video"].connectTo(sources["face_video"])
		} else {
			this.sockets.inputs["face_video"].value = sources["face_video"]
		}
		}

		if (sources["pose_video"] !== undefined) {
		if (typeof sources["pose_video"] === "object") {
			this.sockets.inputs["pose_video"].connectTo(sources["pose_video"])
		} else {
			this.sockets.inputs["pose_video"].value = sources["pose_video"]
		}
		}

		if (sources["background_video"] !== undefined) {
		if (typeof sources["background_video"] === "object") {
			this.sockets.inputs["background_video"].connectTo(sources["background_video"])
		} else {
			this.sockets.inputs["background_video"].value = sources["background_video"]
		}
		}

		if (sources["character_mask"] !== undefined) {
		if (typeof sources["character_mask"] === "object") {
			this.sockets.inputs["character_mask"].connectTo(sources["character_mask"])
		} else {
			this.sockets.inputs["character_mask"].value = sources["character_mask"]
		}
		}

		if (sources["continue_motion"] !== undefined) {
		if (typeof sources["continue_motion"] === "object") {
			this.sockets.inputs["continue_motion"].connectTo(sources["continue_motion"])
		} else {
			this.sockets.inputs["continue_motion"].value = sources["continue_motion"]
		}
		}

	}
}

type WanAnimateToVideoInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"continue_motion_max_frames": ComfyNodeTypedInputRef<number>
			/** The amount of frames to seek in all the input videos. Used for generating longer videos by chunk. Connect to the video_frame_offset output of the previous node for extending a video.*/
			"video_frame_offset": ComfyNodeTypedInputRef<number>
			"clip_vision_output"?: ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>
			"reference_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"face_video"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"pose_video"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"background_video"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"character_mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"continue_motion"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class Wan22ImageToVideoLatent extends ComfyNode {
	classType: string = "Wan22ImageToVideoLatent"

	sockets: {
		inputs: Required<Wan22ImageToVideoLatentInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"start_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "start_image"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<Wan22ImageToVideoLatentInputs>) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (sources["start_image"] !== undefined) {
		if (typeof sources["start_image"] === "object") {
			this.sockets.inputs["start_image"].connectTo(sources["start_image"])
		} else {
			this.sockets.inputs["start_image"].value = sources["start_image"]
		}
		}

	}
}

type Wan22ImageToVideoLatentInputs = {
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"start_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class LotusConditioning extends ComfyNode {
	classType: string = "LotusConditioning"

	sockets: {
		inputs: Required<LotusConditioningInputs>
		outputs: {
			conditioning: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
			},
			outputs: Object.create(Object.prototype, {
				"conditioning": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LotusConditioningInputs>) {
	}
}

type LotusConditioningInputs = {
}


export class EmptyLatentHunyuan3Dv2 extends ComfyNode {
	classType: string = "EmptyLatentHunyuan3Dv2"

	sockets: {
		inputs: Required<EmptyLatentHunyuan3Dv2Inputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"resolution": new ComfyNodeTypedInputRef<number>(this, "resolution"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<EmptyLatentHunyuan3Dv2Inputs>) {
		if (typeof sources["resolution"] === "object") {
			this.sockets.inputs["resolution"].connectTo(sources["resolution"])
		} else {
			this.sockets.inputs["resolution"].value = sources["resolution"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

	}
}

type EmptyLatentHunyuan3Dv2Inputs = {
			"resolution": ComfyNodeTypedInputRef<number>
			/** The number of latent images in the batch.*/
			"batch_size": ComfyNodeTypedInputRef<number>
}


export class Hunyuan3Dv2Conditioning extends ComfyNode {
	classType: string = "Hunyuan3Dv2Conditioning"

	sockets: {
		inputs: Required<Hunyuan3Dv2ConditioningInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_vision_output": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>(this, "clip_vision_output"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<Hunyuan3Dv2ConditioningInputs>) {
		if (typeof sources["clip_vision_output"] === "object") {
			this.sockets.inputs["clip_vision_output"].connectTo(sources["clip_vision_output"])
		} else {
			this.sockets.inputs["clip_vision_output"].value = sources["clip_vision_output"]
		}

	}
}

type Hunyuan3Dv2ConditioningInputs = {
			"clip_vision_output": ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>
}


export class Hunyuan3Dv2ConditioningMultiView extends ComfyNode {
	classType: string = "Hunyuan3Dv2ConditioningMultiView"

	sockets: {
		inputs: Required<Hunyuan3Dv2ConditioningMultiViewInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"front": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>(this, "front"),
				"left": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>(this, "left"),
				"back": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>(this, "back"),
				"right": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>(this, "right"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<Hunyuan3Dv2ConditioningMultiViewInputs>) {
		if (sources["front"] !== undefined) {
		if (typeof sources["front"] === "object") {
			this.sockets.inputs["front"].connectTo(sources["front"])
		} else {
			this.sockets.inputs["front"].value = sources["front"]
		}
		}

		if (sources["left"] !== undefined) {
		if (typeof sources["left"] === "object") {
			this.sockets.inputs["left"].connectTo(sources["left"])
		} else {
			this.sockets.inputs["left"].value = sources["left"]
		}
		}

		if (sources["back"] !== undefined) {
		if (typeof sources["back"] === "object") {
			this.sockets.inputs["back"].connectTo(sources["back"])
		} else {
			this.sockets.inputs["back"].value = sources["back"]
		}
		}

		if (sources["right"] !== undefined) {
		if (typeof sources["right"] === "object") {
			this.sockets.inputs["right"].connectTo(sources["right"])
		} else {
			this.sockets.inputs["right"].value = sources["right"]
		}
		}

	}
}

type Hunyuan3Dv2ConditioningMultiViewInputs = {
			"front"?: ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>
			"left"?: ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>
			"back"?: ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>
			"right"?: ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>
}


export class VAEDecodeHunyuan3D extends ComfyNode {
	classType: string = "VAEDecodeHunyuan3D"

	sockets: {
		inputs: Required<VAEDecodeHunyuan3DInputs>
		outputs: {
			VOXEL: ComfyNodeTypedSourceRef<ComfyValueType_VOXEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"num_chunks": new ComfyNodeTypedInputRef<number>(this, "num_chunks"),
				"octree_resolution": new ComfyNodeTypedInputRef<number>(this, "octree_resolution"),
			},
			outputs: Object.create(Object.prototype, {
				"VOXEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VAEDecodeHunyuan3DInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["num_chunks"] === "object") {
			this.sockets.inputs["num_chunks"].connectTo(sources["num_chunks"])
		} else {
			this.sockets.inputs["num_chunks"].value = sources["num_chunks"]
		}

		if (typeof sources["octree_resolution"] === "object") {
			this.sockets.inputs["octree_resolution"].connectTo(sources["octree_resolution"])
		} else {
			this.sockets.inputs["octree_resolution"].value = sources["octree_resolution"]
		}

	}
}

type VAEDecodeHunyuan3DInputs = {
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"num_chunks": ComfyNodeTypedInputRef<number>
			"octree_resolution": ComfyNodeTypedInputRef<number>
}


export class VoxelToMeshBasic extends ComfyNode {
	classType: string = "VoxelToMeshBasic"

	sockets: {
		inputs: Required<VoxelToMeshBasicInputs>
		outputs: {
			MESH: ComfyNodeTypedSourceRef<ComfyValueType_MESH>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"voxel": new ComfyNodeTypedInputRef<ComfyValueType_VOXEL>(this, "voxel"),
				"threshold": new ComfyNodeTypedInputRef<number>(this, "threshold"),
			},
			outputs: Object.create(Object.prototype, {
				"MESH": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VoxelToMeshBasicInputs>) {
		if (typeof sources["voxel"] === "object") {
			this.sockets.inputs["voxel"].connectTo(sources["voxel"])
		} else {
			this.sockets.inputs["voxel"].value = sources["voxel"]
		}

		if (typeof sources["threshold"] === "object") {
			this.sockets.inputs["threshold"].connectTo(sources["threshold"])
		} else {
			this.sockets.inputs["threshold"].value = sources["threshold"]
		}

	}
}

type VoxelToMeshBasicInputs = {
			"voxel": ComfyNodeTypedInputRef<ComfyValueType_VOXEL>
			"threshold": ComfyNodeTypedInputRef<number>
}


export class VoxelToMesh extends ComfyNode {
	classType: string = "VoxelToMesh"

	sockets: {
		inputs: Required<VoxelToMeshInputs>
		outputs: {
			MESH: ComfyNodeTypedSourceRef<ComfyValueType_MESH>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"voxel": new ComfyNodeTypedInputRef<ComfyValueType_VOXEL>(this, "voxel"),
				"algorithm": new ComfyNodeTypedInputRef<string>(this, "algorithm"),
				"threshold": new ComfyNodeTypedInputRef<number>(this, "threshold"),
			},
			outputs: Object.create(Object.prototype, {
				"MESH": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VoxelToMeshInputs>) {
		if (typeof sources["voxel"] === "object") {
			this.sockets.inputs["voxel"].connectTo(sources["voxel"])
		} else {
			this.sockets.inputs["voxel"].value = sources["voxel"]
		}

		if (typeof sources["algorithm"] === "object") {
			this.sockets.inputs["algorithm"].connectTo(sources["algorithm"])
		} else {
			this.sockets.inputs["algorithm"].value = sources["algorithm"]
		}

		if (typeof sources["threshold"] === "object") {
			this.sockets.inputs["threshold"].connectTo(sources["threshold"])
		} else {
			this.sockets.inputs["threshold"].value = sources["threshold"]
		}

	}
}

type VoxelToMeshInputs = {
			"voxel": ComfyNodeTypedInputRef<ComfyValueType_VOXEL>
			"algorithm": ComfyNodeTypedInputRef<string>
			"threshold": ComfyNodeTypedInputRef<number>
}


export class SaveGLB extends ComfyNode {
	classType: string = "SaveGLB"

	sockets: {
		inputs: Required<SaveGLBInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mesh": new ComfyNodeTypedInputRef<ComfyValueType_MESH>(this, "mesh"),
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_E>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<SaveGLBInputs>) {
		if (typeof sources["mesh"] === "object") {
			this.sockets.inputs["mesh"].connectTo(sources["mesh"])
		} else {
			this.sockets.inputs["mesh"].value = sources["mesh"]
		}

		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type SaveGLBInputs = {
			"mesh": ComfyNodeTypedInputRef<ComfyValueType_MESH>
			"filename_prefix": ComfyNodeTypedInputRef<string>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_E>
}


export class PrimitiveString extends ComfyNode {
	classType: string = "PrimitiveString"

	sockets: {
		inputs: Required<PrimitiveStringInputs>
		outputs: {
			STRING: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"value": new ComfyNodeTypedInputRef<string>(this, "value"),
			},
			outputs: Object.create(Object.prototype, {
				"STRING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PrimitiveStringInputs>) {
		if (typeof sources["value"] === "object") {
			this.sockets.inputs["value"].connectTo(sources["value"])
		} else {
			this.sockets.inputs["value"].value = sources["value"]
		}

	}
}

type PrimitiveStringInputs = {
			"value": ComfyNodeTypedInputRef<string>
}


export class PrimitiveStringMultiline extends ComfyNode {
	classType: string = "PrimitiveStringMultiline"

	sockets: {
		inputs: Required<PrimitiveStringMultilineInputs>
		outputs: {
			STRING: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"value": new ComfyNodeTypedInputRef<string>(this, "value"),
			},
			outputs: Object.create(Object.prototype, {
				"STRING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PrimitiveStringMultilineInputs>) {
		if (typeof sources["value"] === "object") {
			this.sockets.inputs["value"].connectTo(sources["value"])
		} else {
			this.sockets.inputs["value"].value = sources["value"]
		}

	}
}

type PrimitiveStringMultilineInputs = {
			"value": ComfyNodeTypedInputRef<string>
}


export class PrimitiveInt extends ComfyNode {
	classType: string = "PrimitiveInt"

	sockets: {
		inputs: Required<PrimitiveIntInputs>
		outputs: {
			INT: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"value": new ComfyNodeTypedInputRef<number>(this, "value"),
			},
			outputs: Object.create(Object.prototype, {
				"INT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PrimitiveIntInputs>) {
		if (typeof sources["value"] === "object") {
			this.sockets.inputs["value"].connectTo(sources["value"])
		} else {
			this.sockets.inputs["value"].value = sources["value"]
		}

	}
}

type PrimitiveIntInputs = {
			"value": ComfyNodeTypedInputRef<number>
}


export class PrimitiveFloat extends ComfyNode {
	classType: string = "PrimitiveFloat"

	sockets: {
		inputs: Required<PrimitiveFloatInputs>
		outputs: {
			FLOAT: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"value": new ComfyNodeTypedInputRef<number>(this, "value"),
			},
			outputs: Object.create(Object.prototype, {
				"FLOAT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PrimitiveFloatInputs>) {
		if (typeof sources["value"] === "object") {
			this.sockets.inputs["value"].connectTo(sources["value"])
		} else {
			this.sockets.inputs["value"].value = sources["value"]
		}

	}
}

type PrimitiveFloatInputs = {
			"value": ComfyNodeTypedInputRef<number>
}


export class PrimitiveBoolean extends ComfyNode {
	classType: string = "PrimitiveBoolean"

	sockets: {
		inputs: Required<PrimitiveBooleanInputs>
		outputs: {
			BOOLEAN: ComfyNodeTypedSourceRef<boolean>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"value": new ComfyNodeTypedInputRef<boolean>(this, "value"),
			},
			outputs: Object.create(Object.prototype, {
				"BOOLEAN": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PrimitiveBooleanInputs>) {
		if (typeof sources["value"] === "object") {
			this.sockets.inputs["value"].connectTo(sources["value"])
		} else {
			this.sockets.inputs["value"].value = sources["value"]
		}

	}
}

type PrimitiveBooleanInputs = {
			"value": ComfyNodeTypedInputRef<boolean>
}


export class CFGZeroStar extends ComfyNode {
	classType: string = "CFGZeroStar"

	sockets: {
		inputs: Required<CFGZeroStarInputs>
		outputs: {
			patched_model: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
			},
			outputs: Object.create(Object.prototype, {
				"patched_model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CFGZeroStarInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

	}
}

type CFGZeroStarInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
}


export class CFGNorm extends ComfyNode {
	classType: string = "CFGNorm"

	sockets: {
		inputs: Required<CFGNormInputs>
		outputs: {
			patched_model: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
			},
			outputs: Object.create(Object.prototype, {
				"patched_model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CFGNormInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

	}
}

type CFGNormInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"strength": ComfyNodeTypedInputRef<number>
}


export class OptimalStepsScheduler extends ComfyNode {
	classType: string = "OptimalStepsScheduler"

	sockets: {
		inputs: Required<OptimalStepsSchedulerInputs>
		outputs: {
			SIGMAS: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_type": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "model_type"),
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"denoise": new ComfyNodeTypedInputRef<number>(this, "denoise"),
			},
			outputs: Object.create(Object.prototype, {
				"SIGMAS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<OptimalStepsSchedulerInputs>) {
		if (typeof sources["model_type"] === "object") {
			this.sockets.inputs["model_type"].connectTo(sources["model_type"])
		} else {
			this.sockets.inputs["model_type"].value = sources["model_type"]
		}

		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["denoise"] === "object") {
			this.sockets.inputs["denoise"].connectTo(sources["denoise"])
		} else {
			this.sockets.inputs["denoise"].value = sources["denoise"]
		}

	}
}

type OptimalStepsSchedulerInputs = {
			"model_type": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"steps": ComfyNodeTypedInputRef<number>
			"denoise": ComfyNodeTypedInputRef<number>
}


export class QuadrupleCLIPLoader extends ComfyNode {
	classType: string = "QuadrupleCLIPLoader"

	sockets: {
		inputs: Required<QuadrupleCLIPLoaderInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "clip_name2"),
				"clip_name3": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "clip_name3"),
				"clip_name4": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "clip_name4"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<QuadrupleCLIPLoaderInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["clip_name3"] === "object") {
			this.sockets.inputs["clip_name3"].connectTo(sources["clip_name3"])
		} else {
			this.sockets.inputs["clip_name3"].value = sources["clip_name3"]
		}

		if (typeof sources["clip_name4"] === "object") {
			this.sockets.inputs["clip_name4"].connectTo(sources["clip_name4"])
		} else {
			this.sockets.inputs["clip_name4"].value = sources["clip_name4"]
		}

	}
}

type QuadrupleCLIPLoaderInputs = {
			"clip_name1": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"clip_name2": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"clip_name3": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"clip_name4": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class CLIPTextEncodeHiDream extends ComfyNode {
	classType: string = "CLIPTextEncodeHiDream"

	sockets: {
		inputs: Required<CLIPTextEncodeHiDreamInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"clip_l": new ComfyNodeTypedInputRef<string>(this, "clip_l"),
				"clip_g": new ComfyNodeTypedInputRef<string>(this, "clip_g"),
				"t5xxl": new ComfyNodeTypedInputRef<string>(this, "t5xxl"),
				"llama": new ComfyNodeTypedInputRef<string>(this, "llama"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPTextEncodeHiDreamInputs>) {
		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["clip_l"] === "object") {
			this.sockets.inputs["clip_l"].connectTo(sources["clip_l"])
		} else {
			this.sockets.inputs["clip_l"].value = sources["clip_l"]
		}

		if (typeof sources["clip_g"] === "object") {
			this.sockets.inputs["clip_g"].connectTo(sources["clip_g"])
		} else {
			this.sockets.inputs["clip_g"].value = sources["clip_g"]
		}

		if (typeof sources["t5xxl"] === "object") {
			this.sockets.inputs["t5xxl"].connectTo(sources["t5xxl"])
		} else {
			this.sockets.inputs["t5xxl"].value = sources["t5xxl"]
		}

		if (typeof sources["llama"] === "object") {
			this.sockets.inputs["llama"].connectTo(sources["llama"])
		} else {
			this.sockets.inputs["llama"].value = sources["llama"]
		}

	}
}

type CLIPTextEncodeHiDreamInputs = {
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"clip_l": ComfyNodeTypedInputRef<string>
			"clip_g": ComfyNodeTypedInputRef<string>
			"t5xxl": ComfyNodeTypedInputRef<string>
			"llama": ComfyNodeTypedInputRef<string>
}


export class FreSca extends ComfyNode {
	classType: string = "FreSca"

	sockets: {
		inputs: Required<FreScaInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"scale_low": new ComfyNodeTypedInputRef<number>(this, "scale_low"),
				"scale_high": new ComfyNodeTypedInputRef<number>(this, "scale_high"),
				"freq_cutoff": new ComfyNodeTypedInputRef<number>(this, "freq_cutoff"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<FreScaInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["scale_low"] === "object") {
			this.sockets.inputs["scale_low"].connectTo(sources["scale_low"])
		} else {
			this.sockets.inputs["scale_low"].value = sources["scale_low"]
		}

		if (typeof sources["scale_high"] === "object") {
			this.sockets.inputs["scale_high"].connectTo(sources["scale_high"])
		} else {
			this.sockets.inputs["scale_high"].value = sources["scale_high"]
		}

		if (typeof sources["freq_cutoff"] === "object") {
			this.sockets.inputs["freq_cutoff"].connectTo(sources["freq_cutoff"])
		} else {
			this.sockets.inputs["freq_cutoff"].value = sources["freq_cutoff"]
		}

	}
}

type FreScaInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** Scaling factor for low-frequency components*/
			"scale_low": ComfyNodeTypedInputRef<number>
			/** Scaling factor for high-frequency components*/
			"scale_high": ComfyNodeTypedInputRef<number>
			/** Number of frequency indices around center to consider as low-frequency*/
			"freq_cutoff": ComfyNodeTypedInputRef<number>
}


export class APG extends ComfyNode {
	classType: string = "APG"

	sockets: {
		inputs: Required<APGInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"eta": new ComfyNodeTypedInputRef<number>(this, "eta"),
				"norm_threshold": new ComfyNodeTypedInputRef<number>(this, "norm_threshold"),
				"momentum": new ComfyNodeTypedInputRef<number>(this, "momentum"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<APGInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["eta"] === "object") {
			this.sockets.inputs["eta"].connectTo(sources["eta"])
		} else {
			this.sockets.inputs["eta"].value = sources["eta"]
		}

		if (typeof sources["norm_threshold"] === "object") {
			this.sockets.inputs["norm_threshold"].connectTo(sources["norm_threshold"])
		} else {
			this.sockets.inputs["norm_threshold"].value = sources["norm_threshold"]
		}

		if (typeof sources["momentum"] === "object") {
			this.sockets.inputs["momentum"].connectTo(sources["momentum"])
		} else {
			this.sockets.inputs["momentum"].value = sources["momentum"]
		}

	}
}

type APGInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** Controls the scale of the parallel guidance vector. Default CFG behavior at a setting of 1.*/
			"eta": ComfyNodeTypedInputRef<number>
			/** Normalize guidance vector to this value, normalization disable at a setting of 0.*/
			"norm_threshold": ComfyNodeTypedInputRef<number>
			/** Controls a running average of guidance during diffusion, disabled at a setting of 0.*/
			"momentum": ComfyNodeTypedInputRef<number>
}


export class PreviewAny extends ComfyNode {
	classType: string = "PreviewAny"

	sockets: {
		inputs: Required<PreviewAnyInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"source": new ComfyNodeTypedInputRef<ComfyValueType_$STAR>(this, "source"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<PreviewAnyInputs>) {
		if (typeof sources["source"] === "object") {
			this.sockets.inputs["source"].connectTo(sources["source"])
		} else {
			this.sockets.inputs["source"].value = sources["source"]
		}

	}
}

type PreviewAnyInputs = {
			"source": ComfyNodeTypedInputRef<ComfyValueType_$STAR>
}


export class TextEncodeAceStepAudio extends ComfyNode {
	classType: string = "TextEncodeAceStepAudio"

	sockets: {
		inputs: Required<TextEncodeAceStepAudioInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"tags": new ComfyNodeTypedInputRef<string>(this, "tags"),
				"lyrics": new ComfyNodeTypedInputRef<string>(this, "lyrics"),
				"lyrics_strength": new ComfyNodeTypedInputRef<number>(this, "lyrics_strength"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TextEncodeAceStepAudioInputs>) {
		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["tags"] === "object") {
			this.sockets.inputs["tags"].connectTo(sources["tags"])
		} else {
			this.sockets.inputs["tags"].value = sources["tags"]
		}

		if (typeof sources["lyrics"] === "object") {
			this.sockets.inputs["lyrics"].connectTo(sources["lyrics"])
		} else {
			this.sockets.inputs["lyrics"].value = sources["lyrics"]
		}

		if (typeof sources["lyrics_strength"] === "object") {
			this.sockets.inputs["lyrics_strength"].connectTo(sources["lyrics_strength"])
		} else {
			this.sockets.inputs["lyrics_strength"].value = sources["lyrics_strength"]
		}

	}
}

type TextEncodeAceStepAudioInputs = {
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"tags": ComfyNodeTypedInputRef<string>
			"lyrics": ComfyNodeTypedInputRef<string>
			"lyrics_strength": ComfyNodeTypedInputRef<number>
}


export class EmptyAceStepLatentAudio extends ComfyNode {
	classType: string = "EmptyAceStepLatentAudio"

	sockets: {
		inputs: Required<EmptyAceStepLatentAudioInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"seconds": new ComfyNodeTypedInputRef<number>(this, "seconds"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<EmptyAceStepLatentAudioInputs>) {
		if (typeof sources["seconds"] === "object") {
			this.sockets.inputs["seconds"].connectTo(sources["seconds"])
		} else {
			this.sockets.inputs["seconds"].value = sources["seconds"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

	}
}

type EmptyAceStepLatentAudioInputs = {
			"seconds": ComfyNodeTypedInputRef<number>
			/** The number of latent images in the batch.*/
			"batch_size": ComfyNodeTypedInputRef<number>
}


export class StringConcatenate extends ComfyNode {
	classType: string = "StringConcatenate"

	sockets: {
		inputs: Required<StringConcatenateInputs>
		outputs: {
			STRING: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"string_a": new ComfyNodeTypedInputRef<string>(this, "string_a"),
				"string_b": new ComfyNodeTypedInputRef<string>(this, "string_b"),
				"delimiter": new ComfyNodeTypedInputRef<string>(this, "delimiter"),
			},
			outputs: Object.create(Object.prototype, {
				"STRING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<StringConcatenateInputs>) {
		if (typeof sources["string_a"] === "object") {
			this.sockets.inputs["string_a"].connectTo(sources["string_a"])
		} else {
			this.sockets.inputs["string_a"].value = sources["string_a"]
		}

		if (typeof sources["string_b"] === "object") {
			this.sockets.inputs["string_b"].connectTo(sources["string_b"])
		} else {
			this.sockets.inputs["string_b"].value = sources["string_b"]
		}

		if (typeof sources["delimiter"] === "object") {
			this.sockets.inputs["delimiter"].connectTo(sources["delimiter"])
		} else {
			this.sockets.inputs["delimiter"].value = sources["delimiter"]
		}

	}
}

type StringConcatenateInputs = {
			"string_a": ComfyNodeTypedInputRef<string>
			"string_b": ComfyNodeTypedInputRef<string>
			"delimiter": ComfyNodeTypedInputRef<string>
}


export class StringSubstring extends ComfyNode {
	classType: string = "StringSubstring"

	sockets: {
		inputs: Required<StringSubstringInputs>
		outputs: {
			STRING: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"string": new ComfyNodeTypedInputRef<string>(this, "string"),
				"start": new ComfyNodeTypedInputRef<number>(this, "start"),
				"end": new ComfyNodeTypedInputRef<number>(this, "end"),
			},
			outputs: Object.create(Object.prototype, {
				"STRING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<StringSubstringInputs>) {
		if (typeof sources["string"] === "object") {
			this.sockets.inputs["string"].connectTo(sources["string"])
		} else {
			this.sockets.inputs["string"].value = sources["string"]
		}

		if (typeof sources["start"] === "object") {
			this.sockets.inputs["start"].connectTo(sources["start"])
		} else {
			this.sockets.inputs["start"].value = sources["start"]
		}

		if (typeof sources["end"] === "object") {
			this.sockets.inputs["end"].connectTo(sources["end"])
		} else {
			this.sockets.inputs["end"].value = sources["end"]
		}

	}
}

type StringSubstringInputs = {
			"string": ComfyNodeTypedInputRef<string>
			"start": ComfyNodeTypedInputRef<number>
			"end": ComfyNodeTypedInputRef<number>
}


export class StringLength extends ComfyNode {
	classType: string = "StringLength"

	sockets: {
		inputs: Required<StringLengthInputs>
		outputs: {
			length: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"string": new ComfyNodeTypedInputRef<string>(this, "string"),
			},
			outputs: Object.create(Object.prototype, {
				"length": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<StringLengthInputs>) {
		if (typeof sources["string"] === "object") {
			this.sockets.inputs["string"].connectTo(sources["string"])
		} else {
			this.sockets.inputs["string"].value = sources["string"]
		}

	}
}

type StringLengthInputs = {
			"string": ComfyNodeTypedInputRef<string>
}


export class CaseConverter extends ComfyNode {
	classType: string = "CaseConverter"

	sockets: {
		inputs: Required<CaseConverterInputs>
		outputs: {
			STRING: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"string": new ComfyNodeTypedInputRef<string>(this, "string"),
				"mode": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "mode"),
			},
			outputs: Object.create(Object.prototype, {
				"STRING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CaseConverterInputs>) {
		if (typeof sources["string"] === "object") {
			this.sockets.inputs["string"].connectTo(sources["string"])
		} else {
			this.sockets.inputs["string"].value = sources["string"]
		}

		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}

	}
}

type CaseConverterInputs = {
			"string": ComfyNodeTypedInputRef<string>
			"mode": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class StringTrim extends ComfyNode {
	classType: string = "StringTrim"

	sockets: {
		inputs: Required<StringTrimInputs>
		outputs: {
			STRING: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"string": new ComfyNodeTypedInputRef<string>(this, "string"),
				"mode": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "mode"),
			},
			outputs: Object.create(Object.prototype, {
				"STRING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<StringTrimInputs>) {
		if (typeof sources["string"] === "object") {
			this.sockets.inputs["string"].connectTo(sources["string"])
		} else {
			this.sockets.inputs["string"].value = sources["string"]
		}

		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}

	}
}

type StringTrimInputs = {
			"string": ComfyNodeTypedInputRef<string>
			"mode": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class StringReplace extends ComfyNode {
	classType: string = "StringReplace"

	sockets: {
		inputs: Required<StringReplaceInputs>
		outputs: {
			STRING: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"string": new ComfyNodeTypedInputRef<string>(this, "string"),
				"find": new ComfyNodeTypedInputRef<string>(this, "find"),
				"replace": new ComfyNodeTypedInputRef<string>(this, "replace"),
			},
			outputs: Object.create(Object.prototype, {
				"STRING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<StringReplaceInputs>) {
		if (typeof sources["string"] === "object") {
			this.sockets.inputs["string"].connectTo(sources["string"])
		} else {
			this.sockets.inputs["string"].value = sources["string"]
		}

		if (typeof sources["find"] === "object") {
			this.sockets.inputs["find"].connectTo(sources["find"])
		} else {
			this.sockets.inputs["find"].value = sources["find"]
		}

		if (typeof sources["replace"] === "object") {
			this.sockets.inputs["replace"].connectTo(sources["replace"])
		} else {
			this.sockets.inputs["replace"].value = sources["replace"]
		}

	}
}

type StringReplaceInputs = {
			"string": ComfyNodeTypedInputRef<string>
			"find": ComfyNodeTypedInputRef<string>
			"replace": ComfyNodeTypedInputRef<string>
}


export class StringContains extends ComfyNode {
	classType: string = "StringContains"

	sockets: {
		inputs: Required<StringContainsInputs>
		outputs: {
			contains: ComfyNodeTypedSourceRef<boolean>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"string": new ComfyNodeTypedInputRef<string>(this, "string"),
				"substring": new ComfyNodeTypedInputRef<string>(this, "substring"),
				"case_sensitive": new ComfyNodeTypedInputRef<boolean>(this, "case_sensitive"),
			},
			outputs: Object.create(Object.prototype, {
				"contains": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<StringContainsInputs>) {
		if (typeof sources["string"] === "object") {
			this.sockets.inputs["string"].connectTo(sources["string"])
		} else {
			this.sockets.inputs["string"].value = sources["string"]
		}

		if (typeof sources["substring"] === "object") {
			this.sockets.inputs["substring"].connectTo(sources["substring"])
		} else {
			this.sockets.inputs["substring"].value = sources["substring"]
		}

		if (typeof sources["case_sensitive"] === "object") {
			this.sockets.inputs["case_sensitive"].connectTo(sources["case_sensitive"])
		} else {
			this.sockets.inputs["case_sensitive"].value = sources["case_sensitive"]
		}

	}
}

type StringContainsInputs = {
			"string": ComfyNodeTypedInputRef<string>
			"substring": ComfyNodeTypedInputRef<string>
			"case_sensitive": ComfyNodeTypedInputRef<boolean>
}


export class StringCompare extends ComfyNode {
	classType: string = "StringCompare"

	sockets: {
		inputs: Required<StringCompareInputs>
		outputs: {
			BOOLEAN: ComfyNodeTypedSourceRef<boolean>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"string_a": new ComfyNodeTypedInputRef<string>(this, "string_a"),
				"string_b": new ComfyNodeTypedInputRef<string>(this, "string_b"),
				"mode": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "mode"),
				"case_sensitive": new ComfyNodeTypedInputRef<boolean>(this, "case_sensitive"),
			},
			outputs: Object.create(Object.prototype, {
				"BOOLEAN": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<StringCompareInputs>) {
		if (typeof sources["string_a"] === "object") {
			this.sockets.inputs["string_a"].connectTo(sources["string_a"])
		} else {
			this.sockets.inputs["string_a"].value = sources["string_a"]
		}

		if (typeof sources["string_b"] === "object") {
			this.sockets.inputs["string_b"].connectTo(sources["string_b"])
		} else {
			this.sockets.inputs["string_b"].value = sources["string_b"]
		}

		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}

		if (typeof sources["case_sensitive"] === "object") {
			this.sockets.inputs["case_sensitive"].connectTo(sources["case_sensitive"])
		} else {
			this.sockets.inputs["case_sensitive"].value = sources["case_sensitive"]
		}

	}
}

type StringCompareInputs = {
			"string_a": ComfyNodeTypedInputRef<string>
			"string_b": ComfyNodeTypedInputRef<string>
			"mode": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"case_sensitive": ComfyNodeTypedInputRef<boolean>
}


export class RegexMatch extends ComfyNode {
	classType: string = "RegexMatch"

	sockets: {
		inputs: Required<RegexMatchInputs>
		outputs: {
			matches: ComfyNodeTypedSourceRef<boolean>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"string": new ComfyNodeTypedInputRef<string>(this, "string"),
				"regex_pattern": new ComfyNodeTypedInputRef<string>(this, "regex_pattern"),
				"case_insensitive": new ComfyNodeTypedInputRef<boolean>(this, "case_insensitive"),
				"multiline": new ComfyNodeTypedInputRef<boolean>(this, "multiline"),
				"dotall": new ComfyNodeTypedInputRef<boolean>(this, "dotall"),
			},
			outputs: Object.create(Object.prototype, {
				"matches": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<RegexMatchInputs>) {
		if (typeof sources["string"] === "object") {
			this.sockets.inputs["string"].connectTo(sources["string"])
		} else {
			this.sockets.inputs["string"].value = sources["string"]
		}

		if (typeof sources["regex_pattern"] === "object") {
			this.sockets.inputs["regex_pattern"].connectTo(sources["regex_pattern"])
		} else {
			this.sockets.inputs["regex_pattern"].value = sources["regex_pattern"]
		}

		if (typeof sources["case_insensitive"] === "object") {
			this.sockets.inputs["case_insensitive"].connectTo(sources["case_insensitive"])
		} else {
			this.sockets.inputs["case_insensitive"].value = sources["case_insensitive"]
		}

		if (typeof sources["multiline"] === "object") {
			this.sockets.inputs["multiline"].connectTo(sources["multiline"])
		} else {
			this.sockets.inputs["multiline"].value = sources["multiline"]
		}

		if (typeof sources["dotall"] === "object") {
			this.sockets.inputs["dotall"].connectTo(sources["dotall"])
		} else {
			this.sockets.inputs["dotall"].value = sources["dotall"]
		}

	}
}

type RegexMatchInputs = {
			"string": ComfyNodeTypedInputRef<string>
			"regex_pattern": ComfyNodeTypedInputRef<string>
			"case_insensitive": ComfyNodeTypedInputRef<boolean>
			"multiline": ComfyNodeTypedInputRef<boolean>
			"dotall": ComfyNodeTypedInputRef<boolean>
}


export class RegexExtract extends ComfyNode {
	classType: string = "RegexExtract"

	sockets: {
		inputs: Required<RegexExtractInputs>
		outputs: {
			STRING: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"string": new ComfyNodeTypedInputRef<string>(this, "string"),
				"regex_pattern": new ComfyNodeTypedInputRef<string>(this, "regex_pattern"),
				"mode": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "mode"),
				"case_insensitive": new ComfyNodeTypedInputRef<boolean>(this, "case_insensitive"),
				"multiline": new ComfyNodeTypedInputRef<boolean>(this, "multiline"),
				"dotall": new ComfyNodeTypedInputRef<boolean>(this, "dotall"),
				"group_index": new ComfyNodeTypedInputRef<number>(this, "group_index"),
			},
			outputs: Object.create(Object.prototype, {
				"STRING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<RegexExtractInputs>) {
		if (typeof sources["string"] === "object") {
			this.sockets.inputs["string"].connectTo(sources["string"])
		} else {
			this.sockets.inputs["string"].value = sources["string"]
		}

		if (typeof sources["regex_pattern"] === "object") {
			this.sockets.inputs["regex_pattern"].connectTo(sources["regex_pattern"])
		} else {
			this.sockets.inputs["regex_pattern"].value = sources["regex_pattern"]
		}

		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}

		if (typeof sources["case_insensitive"] === "object") {
			this.sockets.inputs["case_insensitive"].connectTo(sources["case_insensitive"])
		} else {
			this.sockets.inputs["case_insensitive"].value = sources["case_insensitive"]
		}

		if (typeof sources["multiline"] === "object") {
			this.sockets.inputs["multiline"].connectTo(sources["multiline"])
		} else {
			this.sockets.inputs["multiline"].value = sources["multiline"]
		}

		if (typeof sources["dotall"] === "object") {
			this.sockets.inputs["dotall"].connectTo(sources["dotall"])
		} else {
			this.sockets.inputs["dotall"].value = sources["dotall"]
		}

		if (typeof sources["group_index"] === "object") {
			this.sockets.inputs["group_index"].connectTo(sources["group_index"])
		} else {
			this.sockets.inputs["group_index"].value = sources["group_index"]
		}

	}
}

type RegexExtractInputs = {
			"string": ComfyNodeTypedInputRef<string>
			"regex_pattern": ComfyNodeTypedInputRef<string>
			"mode": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"case_insensitive": ComfyNodeTypedInputRef<boolean>
			"multiline": ComfyNodeTypedInputRef<boolean>
			"dotall": ComfyNodeTypedInputRef<boolean>
			"group_index": ComfyNodeTypedInputRef<number>
}


export class RegexReplace extends ComfyNode {
	classType: string = "RegexReplace"

	sockets: {
		inputs: Required<RegexReplaceInputs>
		outputs: {
			STRING: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"string": new ComfyNodeTypedInputRef<string>(this, "string"),
				"regex_pattern": new ComfyNodeTypedInputRef<string>(this, "regex_pattern"),
				"replace": new ComfyNodeTypedInputRef<string>(this, "replace"),
				"case_insensitive": new ComfyNodeTypedInputRef<boolean>(this, "case_insensitive"),
				"multiline": new ComfyNodeTypedInputRef<boolean>(this, "multiline"),
				"dotall": new ComfyNodeTypedInputRef<boolean>(this, "dotall"),
				"count": new ComfyNodeTypedInputRef<number>(this, "count"),
			},
			outputs: Object.create(Object.prototype, {
				"STRING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<RegexReplaceInputs>) {
		if (typeof sources["string"] === "object") {
			this.sockets.inputs["string"].connectTo(sources["string"])
		} else {
			this.sockets.inputs["string"].value = sources["string"]
		}

		if (typeof sources["regex_pattern"] === "object") {
			this.sockets.inputs["regex_pattern"].connectTo(sources["regex_pattern"])
		} else {
			this.sockets.inputs["regex_pattern"].value = sources["regex_pattern"]
		}

		if (typeof sources["replace"] === "object") {
			this.sockets.inputs["replace"].connectTo(sources["replace"])
		} else {
			this.sockets.inputs["replace"].value = sources["replace"]
		}

		if (sources["case_insensitive"] !== undefined) {
		if (typeof sources["case_insensitive"] === "object") {
			this.sockets.inputs["case_insensitive"].connectTo(sources["case_insensitive"])
		} else {
			this.sockets.inputs["case_insensitive"].value = sources["case_insensitive"]
		}
		}

		if (sources["multiline"] !== undefined) {
		if (typeof sources["multiline"] === "object") {
			this.sockets.inputs["multiline"].connectTo(sources["multiline"])
		} else {
			this.sockets.inputs["multiline"].value = sources["multiline"]
		}
		}

		if (sources["dotall"] !== undefined) {
		if (typeof sources["dotall"] === "object") {
			this.sockets.inputs["dotall"].connectTo(sources["dotall"])
		} else {
			this.sockets.inputs["dotall"].value = sources["dotall"]
		}
		}

		if (sources["count"] !== undefined) {
		if (typeof sources["count"] === "object") {
			this.sockets.inputs["count"].connectTo(sources["count"])
		} else {
			this.sockets.inputs["count"].value = sources["count"]
		}
		}

	}
}

type RegexReplaceInputs = {
			"string": ComfyNodeTypedInputRef<string>
			"regex_pattern": ComfyNodeTypedInputRef<string>
			"replace": ComfyNodeTypedInputRef<string>
			"case_insensitive"?: ComfyNodeTypedInputRef<boolean>
			"multiline"?: ComfyNodeTypedInputRef<boolean>
			/** When enabled, the dot (.) character will match any character including newline characters. When disabled, dots won't match newlines.*/
			"dotall"?: ComfyNodeTypedInputRef<boolean>
			/** Maximum number of replacements to make. Set to 0 to replace all occurrences (default). Set to 1 to replace only the first match, 2 for the first two matches, etc.*/
			"count"?: ComfyNodeTypedInputRef<number>
}


export class WanCameraEmbedding extends ComfyNode {
	classType: string = "WanCameraEmbedding"

	sockets: {
		inputs: Required<WanCameraEmbeddingInputs>
		outputs: {
			camera_embedding: ComfyNodeTypedSourceRef<ComfyValueType_WAN_CAMERA_EMBEDDING>
			width: ComfyNodeTypedSourceRef<number>
			height: ComfyNodeTypedSourceRef<number>
			length: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"camera_pose": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "camera_pose"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"length": new ComfyNodeTypedInputRef<number>(this, "length"),
				"speed": new ComfyNodeTypedInputRef<number>(this, "speed"),
				"fx": new ComfyNodeTypedInputRef<number>(this, "fx"),
				"fy": new ComfyNodeTypedInputRef<number>(this, "fy"),
				"cx": new ComfyNodeTypedInputRef<number>(this, "cx"),
				"cy": new ComfyNodeTypedInputRef<number>(this, "cy"),
			},
			outputs: Object.create(Object.prototype, {
				"camera_embedding": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"length": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanCameraEmbeddingInputs>) {
		if (typeof sources["camera_pose"] === "object") {
			this.sockets.inputs["camera_pose"].connectTo(sources["camera_pose"])
		} else {
			this.sockets.inputs["camera_pose"].value = sources["camera_pose"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["length"] === "object") {
			this.sockets.inputs["length"].connectTo(sources["length"])
		} else {
			this.sockets.inputs["length"].value = sources["length"]
		}

		if (sources["speed"] !== undefined) {
		if (typeof sources["speed"] === "object") {
			this.sockets.inputs["speed"].connectTo(sources["speed"])
		} else {
			this.sockets.inputs["speed"].value = sources["speed"]
		}
		}

		if (sources["fx"] !== undefined) {
		if (typeof sources["fx"] === "object") {
			this.sockets.inputs["fx"].connectTo(sources["fx"])
		} else {
			this.sockets.inputs["fx"].value = sources["fx"]
		}
		}

		if (sources["fy"] !== undefined) {
		if (typeof sources["fy"] === "object") {
			this.sockets.inputs["fy"].connectTo(sources["fy"])
		} else {
			this.sockets.inputs["fy"].value = sources["fy"]
		}
		}

		if (sources["cx"] !== undefined) {
		if (typeof sources["cx"] === "object") {
			this.sockets.inputs["cx"].connectTo(sources["cx"])
		} else {
			this.sockets.inputs["cx"].value = sources["cx"]
		}
		}

		if (sources["cy"] !== undefined) {
		if (typeof sources["cy"] === "object") {
			this.sockets.inputs["cy"].connectTo(sources["cy"])
		} else {
			this.sockets.inputs["cy"].value = sources["cy"]
		}
		}

	}
}

type WanCameraEmbeddingInputs = {
			"camera_pose": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"length": ComfyNodeTypedInputRef<number>
			"speed"?: ComfyNodeTypedInputRef<number>
			"fx"?: ComfyNodeTypedInputRef<number>
			"fy"?: ComfyNodeTypedInputRef<number>
			"cx"?: ComfyNodeTypedInputRef<number>
			"cy"?: ComfyNodeTypedInputRef<number>
}


export class ReferenceLatent extends ComfyNode {
	classType: string = "ReferenceLatent"

	sockets: {
		inputs: Required<ReferenceLatentInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning"),
				"latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latent"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ReferenceLatentInputs>) {
		if (typeof sources["conditioning"] === "object") {
			this.sockets.inputs["conditioning"].connectTo(sources["conditioning"])
		} else {
			this.sockets.inputs["conditioning"].value = sources["conditioning"]
		}

		if (sources["latent"] !== undefined) {
		if (typeof sources["latent"] === "object") {
			this.sockets.inputs["latent"].connectTo(sources["latent"])
		} else {
			this.sockets.inputs["latent"].value = sources["latent"]
		}
		}

	}
}

type ReferenceLatentInputs = {
			"conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"latent"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class TCFG extends ComfyNode {
	classType: string = "TCFG"

	sockets: {
		inputs: Required<TCFGInputs>
		outputs: {
			patched_model: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
			},
			outputs: Object.create(Object.prototype, {
				"patched_model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TCFGInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

	}
}

type TCFGInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
}


export class ContextWindowsManual extends ComfyNode {
	classType: string = "ContextWindowsManual"

	sockets: {
		inputs: Required<ContextWindowsManualInputs>
		outputs: {
			/** The model with context windows applied during sampling.*/
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"context_length": new ComfyNodeTypedInputRef<number>(this, "context_length"),
				"context_overlap": new ComfyNodeTypedInputRef<number>(this, "context_overlap"),
				"context_schedule": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "context_schedule"),
				"context_stride": new ComfyNodeTypedInputRef<number>(this, "context_stride"),
				"closed_loop": new ComfyNodeTypedInputRef<boolean>(this, "closed_loop"),
				"fuse_method": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "fuse_method"),
				"dim": new ComfyNodeTypedInputRef<number>(this, "dim"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ContextWindowsManualInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["context_length"] === "object") {
			this.sockets.inputs["context_length"].connectTo(sources["context_length"])
		} else {
			this.sockets.inputs["context_length"].value = sources["context_length"]
		}

		if (typeof sources["context_overlap"] === "object") {
			this.sockets.inputs["context_overlap"].connectTo(sources["context_overlap"])
		} else {
			this.sockets.inputs["context_overlap"].value = sources["context_overlap"]
		}

		if (typeof sources["context_schedule"] === "object") {
			this.sockets.inputs["context_schedule"].connectTo(sources["context_schedule"])
		} else {
			this.sockets.inputs["context_schedule"].value = sources["context_schedule"]
		}

		if (typeof sources["context_stride"] === "object") {
			this.sockets.inputs["context_stride"].connectTo(sources["context_stride"])
		} else {
			this.sockets.inputs["context_stride"].value = sources["context_stride"]
		}

		if (typeof sources["closed_loop"] === "object") {
			this.sockets.inputs["closed_loop"].connectTo(sources["closed_loop"])
		} else {
			this.sockets.inputs["closed_loop"].value = sources["closed_loop"]
		}

		if (typeof sources["fuse_method"] === "object") {
			this.sockets.inputs["fuse_method"].connectTo(sources["fuse_method"])
		} else {
			this.sockets.inputs["fuse_method"].value = sources["fuse_method"]
		}

		if (typeof sources["dim"] === "object") {
			this.sockets.inputs["dim"].connectTo(sources["dim"])
		} else {
			this.sockets.inputs["dim"].value = sources["dim"]
		}

	}
}

type ContextWindowsManualInputs = {
			/** The model to apply context windows to during sampling.*/
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** The length of the context window.*/
			"context_length": ComfyNodeTypedInputRef<number>
			/** The overlap of the context window.*/
			"context_overlap": ComfyNodeTypedInputRef<number>
			/** The stride of the context window.*/
			"context_schedule": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			/** The stride of the context window; only applicable to uniform schedules.*/
			"context_stride": ComfyNodeTypedInputRef<number>
			/** Whether to close the context window loop; only applicable to looped schedules.*/
			"closed_loop": ComfyNodeTypedInputRef<boolean>
			/** The method to use to fuse the context windows.*/
			"fuse_method": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			/** The dimension to apply the context windows to.*/
			"dim": ComfyNodeTypedInputRef<number>
}


export class WanContextWindowsManual extends ComfyNode {
	classType: string = "WanContextWindowsManual"

	sockets: {
		inputs: Required<WanContextWindowsManualInputs>
		outputs: {
			/** The model with context windows applied during sampling.*/
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"context_length": new ComfyNodeTypedInputRef<number>(this, "context_length"),
				"context_overlap": new ComfyNodeTypedInputRef<number>(this, "context_overlap"),
				"context_schedule": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "context_schedule"),
				"context_stride": new ComfyNodeTypedInputRef<number>(this, "context_stride"),
				"closed_loop": new ComfyNodeTypedInputRef<boolean>(this, "closed_loop"),
				"fuse_method": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "fuse_method"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanContextWindowsManualInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["context_length"] === "object") {
			this.sockets.inputs["context_length"].connectTo(sources["context_length"])
		} else {
			this.sockets.inputs["context_length"].value = sources["context_length"]
		}

		if (typeof sources["context_overlap"] === "object") {
			this.sockets.inputs["context_overlap"].connectTo(sources["context_overlap"])
		} else {
			this.sockets.inputs["context_overlap"].value = sources["context_overlap"]
		}

		if (typeof sources["context_schedule"] === "object") {
			this.sockets.inputs["context_schedule"].connectTo(sources["context_schedule"])
		} else {
			this.sockets.inputs["context_schedule"].value = sources["context_schedule"]
		}

		if (typeof sources["context_stride"] === "object") {
			this.sockets.inputs["context_stride"].connectTo(sources["context_stride"])
		} else {
			this.sockets.inputs["context_stride"].value = sources["context_stride"]
		}

		if (typeof sources["closed_loop"] === "object") {
			this.sockets.inputs["closed_loop"].connectTo(sources["closed_loop"])
		} else {
			this.sockets.inputs["closed_loop"].value = sources["closed_loop"]
		}

		if (typeof sources["fuse_method"] === "object") {
			this.sockets.inputs["fuse_method"].connectTo(sources["fuse_method"])
		} else {
			this.sockets.inputs["fuse_method"].value = sources["fuse_method"]
		}

	}
}

type WanContextWindowsManualInputs = {
			/** The model to apply context windows to during sampling.*/
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** The length of the context window.*/
			"context_length": ComfyNodeTypedInputRef<number>
			/** The overlap of the context window.*/
			"context_overlap": ComfyNodeTypedInputRef<number>
			/** The stride of the context window.*/
			"context_schedule": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			/** The stride of the context window; only applicable to uniform schedules.*/
			"context_stride": ComfyNodeTypedInputRef<number>
			/** Whether to close the context window loop; only applicable to looped schedules.*/
			"closed_loop": ComfyNodeTypedInputRef<boolean>
			/** The method to use to fuse the context windows.*/
			"fuse_method": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class TextEncodeQwenImageEdit extends ComfyNode {
	classType: string = "TextEncodeQwenImageEdit"

	sockets: {
		inputs: Required<TextEncodeQwenImageEditInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"prompt": new ComfyNodeTypedInputRef<string>(this, "prompt"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TextEncodeQwenImageEditInputs>) {
		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}

		if (sources["vae"] !== undefined) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}
		}

		if (sources["image"] !== undefined) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}
		}

	}
}

type TextEncodeQwenImageEditInputs = {
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"prompt": ComfyNodeTypedInputRef<string>
			"vae"?: ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class TextEncodeQwenImageEditPlus extends ComfyNode {
	classType: string = "TextEncodeQwenImageEditPlus"

	sockets: {
		inputs: Required<TextEncodeQwenImageEditPlusInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"prompt": new ComfyNodeTypedInputRef<string>(this, "prompt"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"image1": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image1"),
				"image2": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image2"),
				"image3": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image3"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TextEncodeQwenImageEditPlusInputs>) {
		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}

		if (sources["vae"] !== undefined) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}
		}

		if (sources["image1"] !== undefined) {
		if (typeof sources["image1"] === "object") {
			this.sockets.inputs["image1"].connectTo(sources["image1"])
		} else {
			this.sockets.inputs["image1"].value = sources["image1"]
		}
		}

		if (sources["image2"] !== undefined) {
		if (typeof sources["image2"] === "object") {
			this.sockets.inputs["image2"].connectTo(sources["image2"])
		} else {
			this.sockets.inputs["image2"].value = sources["image2"]
		}
		}

		if (sources["image3"] !== undefined) {
		if (typeof sources["image3"] === "object") {
			this.sockets.inputs["image3"].connectTo(sources["image3"])
		} else {
			this.sockets.inputs["image3"].value = sources["image3"]
		}
		}

	}
}

type TextEncodeQwenImageEditPlusInputs = {
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"prompt": ComfyNodeTypedInputRef<string>
			"vae"?: ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"image1"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"image2"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"image3"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class EmptyChromaRadianceLatentImage extends ComfyNode {
	classType: string = "EmptyChromaRadianceLatentImage"

	sockets: {
		inputs: Required<EmptyChromaRadianceLatentImageInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<EmptyChromaRadianceLatentImageInputs>) {
		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

	}
}

type EmptyChromaRadianceLatentImageInputs = {
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
}


export class ChromaRadianceOptions extends ComfyNode {
	classType: string = "ChromaRadianceOptions"

	sockets: {
		inputs: Required<ChromaRadianceOptionsInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"preserve_wrapper": new ComfyNodeTypedInputRef<boolean>(this, "preserve_wrapper"),
				"start_sigma": new ComfyNodeTypedInputRef<number>(this, "start_sigma"),
				"end_sigma": new ComfyNodeTypedInputRef<number>(this, "end_sigma"),
				"nerf_tile_size": new ComfyNodeTypedInputRef<number>(this, "nerf_tile_size"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ChromaRadianceOptionsInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["preserve_wrapper"] === "object") {
			this.sockets.inputs["preserve_wrapper"].connectTo(sources["preserve_wrapper"])
		} else {
			this.sockets.inputs["preserve_wrapper"].value = sources["preserve_wrapper"]
		}

		if (typeof sources["start_sigma"] === "object") {
			this.sockets.inputs["start_sigma"].connectTo(sources["start_sigma"])
		} else {
			this.sockets.inputs["start_sigma"].value = sources["start_sigma"]
		}

		if (typeof sources["end_sigma"] === "object") {
			this.sockets.inputs["end_sigma"].connectTo(sources["end_sigma"])
		} else {
			this.sockets.inputs["end_sigma"].value = sources["end_sigma"]
		}

		if (typeof sources["nerf_tile_size"] === "object") {
			this.sockets.inputs["nerf_tile_size"].connectTo(sources["nerf_tile_size"])
		} else {
			this.sockets.inputs["nerf_tile_size"].value = sources["nerf_tile_size"]
		}

	}
}

type ChromaRadianceOptionsInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** When enabled, will delegate to an existing model function wrapper if it exists. Generally should be left enabled.*/
			"preserve_wrapper": ComfyNodeTypedInputRef<boolean>
			/** First sigma that these options will be in effect.*/
			"start_sigma": ComfyNodeTypedInputRef<number>
			/** Last sigma that these options will be in effect.*/
			"end_sigma": ComfyNodeTypedInputRef<number>
			/** Allows overriding the default NeRF tile size. -1 means use the default (32). 0 means use non-tiling mode (may require a lot of VRAM).*/
			"nerf_tile_size": ComfyNodeTypedInputRef<number>
}


export class ModelPatchLoader extends ComfyNode {
	classType: string = "ModelPatchLoader"

	sockets: {
		inputs: Required<ModelPatchLoaderInputs>
		outputs: {
			MODEL_PATCH: ComfyNodeTypedSourceRef<ComfyValueType_MODEL_PATCH>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"name": new ComfyNodeTypedInputRef<void>(this, "name"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL_PATCH": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelPatchLoaderInputs>) {
		if (typeof sources["name"] === "object") {
			this.sockets.inputs["name"].connectTo(sources["name"])
		} else {
			this.sockets.inputs["name"].value = sources["name"]
		}

	}
}

type ModelPatchLoaderInputs = {
			"name": ComfyNodeTypedInputRef<void>
}


export class QwenImageDiffsynthControlnet extends ComfyNode {
	classType: string = "QwenImageDiffsynthControlnet"

	sockets: {
		inputs: Required<QwenImageDiffsynthControlnetInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"model_patch": new ComfyNodeTypedInputRef<ComfyValueType_MODEL_PATCH>(this, "model_patch"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<QwenImageDiffsynthControlnetInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["model_patch"] === "object") {
			this.sockets.inputs["model_patch"].connectTo(sources["model_patch"])
		} else {
			this.sockets.inputs["model_patch"].value = sources["model_patch"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (sources["mask"] !== undefined) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}
		}

	}
}

type QwenImageDiffsynthControlnetInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model_patch": ComfyNodeTypedInputRef<ComfyValueType_MODEL_PATCH>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"strength": ComfyNodeTypedInputRef<number>
			"mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class USOStyleReference extends ComfyNode {
	classType: string = "USOStyleReference"

	sockets: {
		inputs: Required<USOStyleReferenceInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"model_patch": new ComfyNodeTypedInputRef<ComfyValueType_MODEL_PATCH>(this, "model_patch"),
				"clip_vision_output": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>(this, "clip_vision_output"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<USOStyleReferenceInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["model_patch"] === "object") {
			this.sockets.inputs["model_patch"].connectTo(sources["model_patch"])
		} else {
			this.sockets.inputs["model_patch"].value = sources["model_patch"]
		}

		if (typeof sources["clip_vision_output"] === "object") {
			this.sockets.inputs["clip_vision_output"].connectTo(sources["clip_vision_output"])
		} else {
			this.sockets.inputs["clip_vision_output"].value = sources["clip_vision_output"]
		}

	}
}

type USOStyleReferenceInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"model_patch": ComfyNodeTypedInputRef<ComfyValueType_MODEL_PATCH>
			"clip_vision_output": ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>
}


export class EasyCache extends ComfyNode {
	classType: string = "EasyCache"

	sockets: {
		inputs: Required<EasyCacheInputs>
		outputs: {
			/** The model with EasyCache.*/
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"reuse_threshold": new ComfyNodeTypedInputRef<number>(this, "reuse_threshold"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
				"verbose": new ComfyNodeTypedInputRef<boolean>(this, "verbose"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<EasyCacheInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["reuse_threshold"] === "object") {
			this.sockets.inputs["reuse_threshold"].connectTo(sources["reuse_threshold"])
		} else {
			this.sockets.inputs["reuse_threshold"].value = sources["reuse_threshold"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

		if (typeof sources["verbose"] === "object") {
			this.sockets.inputs["verbose"].connectTo(sources["verbose"])
		} else {
			this.sockets.inputs["verbose"].value = sources["verbose"]
		}

	}
}

type EasyCacheInputs = {
			/** The model to add EasyCache to.*/
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** The threshold for reusing cached steps.*/
			"reuse_threshold": ComfyNodeTypedInputRef<number>
			/** The relative sampling step to begin use of EasyCache.*/
			"start_percent": ComfyNodeTypedInputRef<number>
			/** The relative sampling step to end use of EasyCache.*/
			"end_percent": ComfyNodeTypedInputRef<number>
			/** Whether to log verbose information.*/
			"verbose": ComfyNodeTypedInputRef<boolean>
}


export class LazyCache extends ComfyNode {
	classType: string = "LazyCache"

	sockets: {
		inputs: Required<LazyCacheInputs>
		outputs: {
			/** The model with LazyCache.*/
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"reuse_threshold": new ComfyNodeTypedInputRef<number>(this, "reuse_threshold"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
				"verbose": new ComfyNodeTypedInputRef<boolean>(this, "verbose"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LazyCacheInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["reuse_threshold"] === "object") {
			this.sockets.inputs["reuse_threshold"].connectTo(sources["reuse_threshold"])
		} else {
			this.sockets.inputs["reuse_threshold"].value = sources["reuse_threshold"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

		if (typeof sources["verbose"] === "object") {
			this.sockets.inputs["verbose"].connectTo(sources["verbose"])
		} else {
			this.sockets.inputs["verbose"].value = sources["verbose"]
		}

	}
}

type LazyCacheInputs = {
			/** The model to add LazyCache to.*/
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** The threshold for reusing cached steps.*/
			"reuse_threshold": ComfyNodeTypedInputRef<number>
			/** The relative sampling step to begin use of LazyCache.*/
			"start_percent": ComfyNodeTypedInputRef<number>
			/** The relative sampling step to end use of LazyCache.*/
			"end_percent": ComfyNodeTypedInputRef<number>
			/** Whether to log verbose information.*/
			"verbose": ComfyNodeTypedInputRef<boolean>
}


export class ScaleROPE extends ComfyNode {
	classType: string = "ScaleROPE"

	sockets: {
		inputs: Required<ScaleROPEInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"scale_x": new ComfyNodeTypedInputRef<number>(this, "scale_x"),
				"shift_x": new ComfyNodeTypedInputRef<number>(this, "shift_x"),
				"scale_y": new ComfyNodeTypedInputRef<number>(this, "scale_y"),
				"shift_y": new ComfyNodeTypedInputRef<number>(this, "shift_y"),
				"scale_t": new ComfyNodeTypedInputRef<number>(this, "scale_t"),
				"shift_t": new ComfyNodeTypedInputRef<number>(this, "shift_t"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ScaleROPEInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["scale_x"] === "object") {
			this.sockets.inputs["scale_x"].connectTo(sources["scale_x"])
		} else {
			this.sockets.inputs["scale_x"].value = sources["scale_x"]
		}

		if (typeof sources["shift_x"] === "object") {
			this.sockets.inputs["shift_x"].connectTo(sources["shift_x"])
		} else {
			this.sockets.inputs["shift_x"].value = sources["shift_x"]
		}

		if (typeof sources["scale_y"] === "object") {
			this.sockets.inputs["scale_y"].connectTo(sources["scale_y"])
		} else {
			this.sockets.inputs["scale_y"].value = sources["scale_y"]
		}

		if (typeof sources["shift_y"] === "object") {
			this.sockets.inputs["shift_y"].connectTo(sources["shift_y"])
		} else {
			this.sockets.inputs["shift_y"].value = sources["shift_y"]
		}

		if (typeof sources["scale_t"] === "object") {
			this.sockets.inputs["scale_t"].connectTo(sources["scale_t"])
		} else {
			this.sockets.inputs["scale_t"].value = sources["scale_t"]
		}

		if (typeof sources["shift_t"] === "object") {
			this.sockets.inputs["shift_t"].connectTo(sources["shift_t"])
		} else {
			this.sockets.inputs["shift_t"].value = sources["shift_t"]
		}

	}
}

type ScaleROPEInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"scale_x": ComfyNodeTypedInputRef<number>
			"shift_x": ComfyNodeTypedInputRef<number>
			"scale_y": ComfyNodeTypedInputRef<number>
			"shift_y": ComfyNodeTypedInputRef<number>
			"scale_t": ComfyNodeTypedInputRef<number>
			"shift_t": ComfyNodeTypedInputRef<number>
}


export class SaveImageWebsocket extends ComfyNode {
	classType: string = "SaveImageWebsocket"

	sockets: {
		inputs: Required<SaveImageWebsocketInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<SaveImageWebsocketInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

	}
}

type SaveImageWebsocketInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class KSamplerProf extends ComfyNode {
	classType: string = "KSamplerProf"

	sockets: {
		inputs: Required<KSamplerProfInputs>
		outputs: {
			/** The denoised latent.*/
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"seed": new ComfyNodeTypedInputRef<number>(this, "seed"),
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"cfg": new ComfyNodeTypedInputRef<number>(this, "cfg"),
				"sampler_name": new ComfyNodeTypedInputRef<string>(this, "sampler_name"),
				"scheduler": new ComfyNodeTypedInputRef<string>(this, "scheduler"),
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"latent_image": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latent_image"),
				"denoise": new ComfyNodeTypedInputRef<number>(this, "denoise"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<KSamplerProfInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["seed"] === "object") {
			this.sockets.inputs["seed"].connectTo(sources["seed"])
		} else {
			this.sockets.inputs["seed"].value = sources["seed"]
		}

		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["cfg"] === "object") {
			this.sockets.inputs["cfg"].connectTo(sources["cfg"])
		} else {
			this.sockets.inputs["cfg"].value = sources["cfg"]
		}

		if (typeof sources["sampler_name"] === "object") {
			this.sockets.inputs["sampler_name"].connectTo(sources["sampler_name"])
		} else {
			this.sockets.inputs["sampler_name"].value = sources["sampler_name"]
		}

		if (typeof sources["scheduler"] === "object") {
			this.sockets.inputs["scheduler"].connectTo(sources["scheduler"])
		} else {
			this.sockets.inputs["scheduler"].value = sources["scheduler"]
		}

		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["latent_image"] === "object") {
			this.sockets.inputs["latent_image"].connectTo(sources["latent_image"])
		} else {
			this.sockets.inputs["latent_image"].value = sources["latent_image"]
		}

		if (typeof sources["denoise"] === "object") {
			this.sockets.inputs["denoise"].connectTo(sources["denoise"])
		} else {
			this.sockets.inputs["denoise"].value = sources["denoise"]
		}

	}
}

type KSamplerProfInputs = {
			/** The model used for denoising the input latent.*/
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** The random seed used for creating the noise.*/
			"seed": ComfyNodeTypedInputRef<number>
			/** The number of steps used in the denoising process.*/
			"steps": ComfyNodeTypedInputRef<number>
			/** The Classifier-Free Guidance scale balances creativity and adherence to the prompt. Higher values result in images more closely matching the prompt however too high values will negatively impact quality.*/
			"cfg": ComfyNodeTypedInputRef<number>
			/** The algorithm used when sampling, this can affect the quality, speed, and style of the generated output.*/
			"sampler_name": ComfyNodeTypedInputRef<string>
			/** The scheduler controls how noise is gradually removed to form the image.*/
			"scheduler": ComfyNodeTypedInputRef<string>
			/** The conditioning describing the attributes you want to include in the image.*/
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			/** The conditioning describing the attributes you want to exclude from the image.*/
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			/** The latent image to denoise.*/
			"latent_image": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** The amount of denoising applied, lower values will maintain the structure of the initial image allowing for image to image sampling.*/
			"denoise": ComfyNodeTypedInputRef<number>
}


export class VAEDecodeProf extends ComfyNode {
	classType: string = "VAEDecodeProf"

	sockets: {
		inputs: Required<VAEDecodeProfInputs>
		outputs: {
			/** The decoded image.*/
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VAEDecodeProfInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

	}
}

type VAEDecodeProfInputs = {
			/** The latent to be decoded.*/
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** The VAE model used for decoding the latent.*/
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
}


export class VAEDecodeTiledProf extends ComfyNode {
	classType: string = "VAEDecodeTiledProf"

	sockets: {
		inputs: Required<VAEDecodeTiledProfInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"tile_size": new ComfyNodeTypedInputRef<number>(this, "tile_size"),
				"overlap": new ComfyNodeTypedInputRef<number>(this, "overlap"),
				"temporal_size": new ComfyNodeTypedInputRef<number>(this, "temporal_size"),
				"temporal_overlap": new ComfyNodeTypedInputRef<number>(this, "temporal_overlap"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VAEDecodeTiledProfInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["tile_size"] === "object") {
			this.sockets.inputs["tile_size"].connectTo(sources["tile_size"])
		} else {
			this.sockets.inputs["tile_size"].value = sources["tile_size"]
		}

		if (typeof sources["overlap"] === "object") {
			this.sockets.inputs["overlap"].connectTo(sources["overlap"])
		} else {
			this.sockets.inputs["overlap"].value = sources["overlap"]
		}

		if (typeof sources["temporal_size"] === "object") {
			this.sockets.inputs["temporal_size"].connectTo(sources["temporal_size"])
		} else {
			this.sockets.inputs["temporal_size"].value = sources["temporal_size"]
		}

		if (typeof sources["temporal_overlap"] === "object") {
			this.sockets.inputs["temporal_overlap"].connectTo(sources["temporal_overlap"])
		} else {
			this.sockets.inputs["temporal_overlap"].value = sources["temporal_overlap"]
		}

	}
}

type VAEDecodeTiledProfInputs = {
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"tile_size": ComfyNodeTypedInputRef<number>
			"overlap": ComfyNodeTypedInputRef<number>
			/** Only used for video VAEs: Amount of frames to decode at a time.*/
			"temporal_size": ComfyNodeTypedInputRef<number>
			/** Only used for video VAEs: Amount of frames to overlap.*/
			"temporal_overlap": ComfyNodeTypedInputRef<number>
}


export class CLIPTextEncodeProf extends ComfyNode {
	classType: string = "CLIPTextEncodeProf"

	sockets: {
		inputs: Required<CLIPTextEncodeProfInputs>
		outputs: {
			/** A conditioning containing the embedded text used to guide the diffusion model.*/
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"text": new ComfyNodeTypedInputRef<string>(this, "text"),
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPTextEncodeProfInputs>) {
		if (typeof sources["text"] === "object") {
			this.sockets.inputs["text"].connectTo(sources["text"])
		} else {
			this.sockets.inputs["text"].value = sources["text"]
		}

		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

	}
}

type CLIPTextEncodeProfInputs = {
			/** The text to be encoded.*/
			"text": ComfyNodeTypedInputRef<string>
			/** The CLIP model used for encoding the text.*/
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
}


export class LoaderGGUF extends ComfyNode {
	classType: string = "LoaderGGUF"

	sockets: {
		inputs: Required<LoaderGGUFInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"gguf_name": new ComfyNodeTypedInputRef<string>(this, "gguf_name"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoaderGGUFInputs>) {
		if (typeof sources["gguf_name"] === "object") {
			this.sockets.inputs["gguf_name"].connectTo(sources["gguf_name"])
		} else {
			this.sockets.inputs["gguf_name"].value = sources["gguf_name"]
		}

	}
}

type LoaderGGUFInputs = {
			"gguf_name": ComfyNodeTypedInputRef<string>
}


export class ClipLoaderGGUF extends ComfyNode {
	classType: string = "ClipLoaderGGUF"

	sockets: {
		inputs: Required<ClipLoaderGGUFInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name": new ComfyNodeTypedInputRef<string>(this, "clip_name"),
				"type": new ComfyNodeTypedInputRef<string>(this, "type"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ClipLoaderGGUFInputs>) {
		if (typeof sources["clip_name"] === "object") {
			this.sockets.inputs["clip_name"].connectTo(sources["clip_name"])
		} else {
			this.sockets.inputs["clip_name"].value = sources["clip_name"]
		}

		if (typeof sources["type"] === "object") {
			this.sockets.inputs["type"].connectTo(sources["type"])
		} else {
			this.sockets.inputs["type"].value = sources["type"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type ClipLoaderGGUFInputs = {
			"clip_name": ComfyNodeTypedInputRef<string>
			"type": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
}


export class DualClipLoaderGGUF extends ComfyNode {
	classType: string = "DualClipLoaderGGUF"

	sockets: {
		inputs: Required<DualClipLoaderGGUFInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<string>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<string>(this, "clip_name2"),
				"type": new ComfyNodeTypedInputRef<string>(this, "type"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DualClipLoaderGGUFInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["type"] === "object") {
			this.sockets.inputs["type"].connectTo(sources["type"])
		} else {
			this.sockets.inputs["type"].value = sources["type"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type DualClipLoaderGGUFInputs = {
			"clip_name1": ComfyNodeTypedInputRef<string>
			"clip_name2": ComfyNodeTypedInputRef<string>
			"type": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
}


export class TripleClipLoaderGGUF extends ComfyNode {
	classType: string = "TripleClipLoaderGGUF"

	sockets: {
		inputs: Required<TripleClipLoaderGGUFInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<string>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<string>(this, "clip_name2"),
				"clip_name3": new ComfyNodeTypedInputRef<string>(this, "clip_name3"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TripleClipLoaderGGUFInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["clip_name3"] === "object") {
			this.sockets.inputs["clip_name3"].connectTo(sources["clip_name3"])
		} else {
			this.sockets.inputs["clip_name3"].value = sources["clip_name3"]
		}

	}
}

type TripleClipLoaderGGUFInputs = {
			"clip_name1": ComfyNodeTypedInputRef<string>
			"clip_name2": ComfyNodeTypedInputRef<string>
			"clip_name3": ComfyNodeTypedInputRef<string>
}


export class QuadrupleClipLoaderGGUF extends ComfyNode {
	classType: string = "QuadrupleClipLoaderGGUF"

	sockets: {
		inputs: Required<QuadrupleClipLoaderGGUFInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<string>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<string>(this, "clip_name2"),
				"clip_name3": new ComfyNodeTypedInputRef<string>(this, "clip_name3"),
				"clip_name4": new ComfyNodeTypedInputRef<string>(this, "clip_name4"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<QuadrupleClipLoaderGGUFInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["clip_name3"] === "object") {
			this.sockets.inputs["clip_name3"].connectTo(sources["clip_name3"])
		} else {
			this.sockets.inputs["clip_name3"].value = sources["clip_name3"]
		}

		if (typeof sources["clip_name4"] === "object") {
			this.sockets.inputs["clip_name4"].connectTo(sources["clip_name4"])
		} else {
			this.sockets.inputs["clip_name4"].value = sources["clip_name4"]
		}

	}
}

type QuadrupleClipLoaderGGUFInputs = {
			"clip_name1": ComfyNodeTypedInputRef<string>
			"clip_name2": ComfyNodeTypedInputRef<string>
			"clip_name3": ComfyNodeTypedInputRef<string>
			"clip_name4": ComfyNodeTypedInputRef<string>
}


export class AudioEncoderLoaderGGUF extends ComfyNode {
	classType: string = "AudioEncoderLoaderGGUF"

	sockets: {
		inputs: Required<AudioEncoderLoaderGGUFInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"audio_encoder_name": new ComfyNodeTypedInputRef<void>(this, "audio_encoder_name"),
			},
			outputs: Object.create(Object.prototype, {
				"AUDIO_ENCODER": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<AudioEncoderLoaderGGUFInputs>) {
		if (typeof sources["audio_encoder_name"] === "object") {
			this.sockets.inputs["audio_encoder_name"].connectTo(sources["audio_encoder_name"])
		} else {
			this.sockets.inputs["audio_encoder_name"].value = sources["audio_encoder_name"]
		}

	}
}

type AudioEncoderLoaderGGUFInputs = {
			"audio_encoder_name": ComfyNodeTypedInputRef<void>
}


export class LoaderGGUFAdvanced extends ComfyNode {
	classType: string = "LoaderGGUFAdvanced"

	sockets: {
		inputs: Required<LoaderGGUFAdvancedInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"gguf_name": new ComfyNodeTypedInputRef<string>(this, "gguf_name"),
				"dequant_dtype": new ComfyNodeTypedInputRef<string>(this, "dequant_dtype"),
				"patch_dtype": new ComfyNodeTypedInputRef<string>(this, "patch_dtype"),
				"patch_on_device": new ComfyNodeTypedInputRef<boolean>(this, "patch_on_device"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoaderGGUFAdvancedInputs>) {
		if (typeof sources["gguf_name"] === "object") {
			this.sockets.inputs["gguf_name"].connectTo(sources["gguf_name"])
		} else {
			this.sockets.inputs["gguf_name"].value = sources["gguf_name"]
		}

		if (typeof sources["dequant_dtype"] === "object") {
			this.sockets.inputs["dequant_dtype"].connectTo(sources["dequant_dtype"])
		} else {
			this.sockets.inputs["dequant_dtype"].value = sources["dequant_dtype"]
		}

		if (typeof sources["patch_dtype"] === "object") {
			this.sockets.inputs["patch_dtype"].connectTo(sources["patch_dtype"])
		} else {
			this.sockets.inputs["patch_dtype"].value = sources["patch_dtype"]
		}

		if (typeof sources["patch_on_device"] === "object") {
			this.sockets.inputs["patch_on_device"].connectTo(sources["patch_on_device"])
		} else {
			this.sockets.inputs["patch_on_device"].value = sources["patch_on_device"]
		}

	}
}

type LoaderGGUFAdvancedInputs = {
			"gguf_name": ComfyNodeTypedInputRef<string>
			"dequant_dtype": ComfyNodeTypedInputRef<string>
			"patch_dtype": ComfyNodeTypedInputRef<string>
			"patch_on_device": ComfyNodeTypedInputRef<boolean>
}


export class VaeGGUF extends ComfyNode {
	classType: string = "VaeGGUF"

	sockets: {
		inputs: Required<VaeGGUFInputs>
		outputs: {
			VAE: ComfyNodeTypedSourceRef<ComfyValueType_VAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vae_name": new ComfyNodeTypedInputRef<string>(this, "vae_name"),
			},
			outputs: Object.create(Object.prototype, {
				"VAE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VaeGGUFInputs>) {
		if (typeof sources["vae_name"] === "object") {
			this.sockets.inputs["vae_name"].connectTo(sources["vae_name"])
		} else {
			this.sockets.inputs["vae_name"].value = sources["vae_name"]
		}

	}
}

type VaeGGUFInputs = {
			"vae_name": ComfyNodeTypedInputRef<string>
}


export class GGUFUndo extends ComfyNode {
	classType: string = "GGUFUndo"

	sockets: {
		inputs: Required<GGUFUndoInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"select_gguf": new ComfyNodeTypedInputRef<string>(this, "select_gguf"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<GGUFUndoInputs>) {
		if (typeof sources["select_gguf"] === "object") {
			this.sockets.inputs["select_gguf"].connectTo(sources["select_gguf"])
		} else {
			this.sockets.inputs["select_gguf"].value = sources["select_gguf"]
		}

	}
}

type GGUFUndoInputs = {
			"select_gguf": ComfyNodeTypedInputRef<string>
}


export class GGUFSave extends ComfyNode {
	classType: string = "GGUFSave"

	sockets: {
		inputs: Required<GGUFSaveInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"select_safetensors": new ComfyNodeTypedInputRef<string>(this, "select_safetensors"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<GGUFSaveInputs>) {
		if (typeof sources["select_safetensors"] === "object") {
			this.sockets.inputs["select_safetensors"].connectTo(sources["select_safetensors"])
		} else {
			this.sockets.inputs["select_safetensors"].value = sources["select_safetensors"]
		}

	}
}

type GGUFSaveInputs = {
			"select_safetensors": ComfyNodeTypedInputRef<string>
}


export class GGUFRun extends ComfyNode {
	classType: string = "GGUFRun"

	sockets: {
		inputs: Required<GGUFRunInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"select_safetensors": new ComfyNodeTypedInputRef<string>(this, "select_safetensors"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<GGUFRunInputs>) {
		if (typeof sources["select_safetensors"] === "object") {
			this.sockets.inputs["select_safetensors"].connectTo(sources["select_safetensors"])
		} else {
			this.sockets.inputs["select_safetensors"].value = sources["select_safetensors"]
		}

	}
}

type GGUFRunInputs = {
			"select_safetensors": ComfyNodeTypedInputRef<string>
}


export class TENSORCut extends ComfyNode {
	classType: string = "TENSORCut"

	sockets: {
		inputs: Required<TENSORCutInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"select_safetensors": new ComfyNodeTypedInputRef<string>(this, "select_safetensors"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<TENSORCutInputs>) {
		if (typeof sources["select_safetensors"] === "object") {
			this.sockets.inputs["select_safetensors"].connectTo(sources["select_safetensors"])
		} else {
			this.sockets.inputs["select_safetensors"].value = sources["select_safetensors"]
		}

	}
}

type TENSORCutInputs = {
			"select_safetensors": ComfyNodeTypedInputRef<string>
}


export class TENSORBoost extends ComfyNode {
	classType: string = "TENSORBoost"

	sockets: {
		inputs: Required<TENSORBoostInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"select_safetensors": new ComfyNodeTypedInputRef<string>(this, "select_safetensors"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<TENSORBoostInputs>) {
		if (typeof sources["select_safetensors"] === "object") {
			this.sockets.inputs["select_safetensors"].connectTo(sources["select_safetensors"])
		} else {
			this.sockets.inputs["select_safetensors"].value = sources["select_safetensors"]
		}

	}
}

type TENSORBoostInputs = {
			"select_safetensors": ComfyNodeTypedInputRef<string>
}


export class BOOLConstant extends ComfyNode {
	classType: string = "BOOLConstant"

	sockets: {
		inputs: Required<BOOLConstantInputs>
		outputs: {
			value: ComfyNodeTypedSourceRef<boolean>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"value": new ComfyNodeTypedInputRef<boolean>(this, "value"),
			},
			outputs: Object.create(Object.prototype, {
				"value": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<BOOLConstantInputs>) {
		if (typeof sources["value"] === "object") {
			this.sockets.inputs["value"].connectTo(sources["value"])
		} else {
			this.sockets.inputs["value"].value = sources["value"]
		}

	}
}

type BOOLConstantInputs = {
			"value": ComfyNodeTypedInputRef<boolean>
}


export class INTConstant extends ComfyNode {
	classType: string = "INTConstant"

	sockets: {
		inputs: Required<INTConstantInputs>
		outputs: {
			value: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"value": new ComfyNodeTypedInputRef<number>(this, "value"),
			},
			outputs: Object.create(Object.prototype, {
				"value": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<INTConstantInputs>) {
		if (typeof sources["value"] === "object") {
			this.sockets.inputs["value"].connectTo(sources["value"])
		} else {
			this.sockets.inputs["value"].value = sources["value"]
		}

	}
}

type INTConstantInputs = {
			"value": ComfyNodeTypedInputRef<number>
}


export class FloatConstant extends ComfyNode {
	classType: string = "FloatConstant"

	sockets: {
		inputs: Required<FloatConstantInputs>
		outputs: {
			value: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"value": new ComfyNodeTypedInputRef<number>(this, "value"),
			},
			outputs: Object.create(Object.prototype, {
				"value": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<FloatConstantInputs>) {
		if (typeof sources["value"] === "object") {
			this.sockets.inputs["value"].connectTo(sources["value"])
		} else {
			this.sockets.inputs["value"].value = sources["value"]
		}

	}
}

type FloatConstantInputs = {
			"value": ComfyNodeTypedInputRef<number>
}


export class StringConstant extends ComfyNode {
	classType: string = "StringConstant"

	sockets: {
		inputs: Required<StringConstantInputs>
		outputs: {
			STRING: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"string": new ComfyNodeTypedInputRef<string>(this, "string"),
			},
			outputs: Object.create(Object.prototype, {
				"STRING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<StringConstantInputs>) {
		if (typeof sources["string"] === "object") {
			this.sockets.inputs["string"].connectTo(sources["string"])
		} else {
			this.sockets.inputs["string"].value = sources["string"]
		}

	}
}

type StringConstantInputs = {
			"string": ComfyNodeTypedInputRef<string>
}


export class StringConstantMultiline extends ComfyNode {
	classType: string = "StringConstantMultiline"

	sockets: {
		inputs: Required<StringConstantMultilineInputs>
		outputs: {
			STRING: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"string": new ComfyNodeTypedInputRef<string>(this, "string"),
				"strip_newlines": new ComfyNodeTypedInputRef<boolean>(this, "strip_newlines"),
			},
			outputs: Object.create(Object.prototype, {
				"STRING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<StringConstantMultilineInputs>) {
		if (typeof sources["string"] === "object") {
			this.sockets.inputs["string"].connectTo(sources["string"])
		} else {
			this.sockets.inputs["string"].value = sources["string"]
		}

		if (typeof sources["strip_newlines"] === "object") {
			this.sockets.inputs["strip_newlines"].connectTo(sources["strip_newlines"])
		} else {
			this.sockets.inputs["strip_newlines"].value = sources["strip_newlines"]
		}

	}
}

type StringConstantMultilineInputs = {
			"string": ComfyNodeTypedInputRef<string>
			"strip_newlines": ComfyNodeTypedInputRef<boolean>
}


export class ConditioningMultiCombine extends ComfyNode {
	classType: string = "ConditioningMultiCombine"

	sockets: {
		inputs: Required<ConditioningMultiCombineInputs>
		outputs: {
			combined: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			inputcount: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"inputcount": new ComfyNodeTypedInputRef<number>(this, "inputcount"),
				"operation": new ComfyNodeTypedInputRef<string>(this, "operation"),
				"conditioning_1": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning_1"),
				"conditioning_2": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning_2"),
			},
			outputs: Object.create(Object.prototype, {
				"combined": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"inputcount": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ConditioningMultiCombineInputs>) {
		if (typeof sources["inputcount"] === "object") {
			this.sockets.inputs["inputcount"].connectTo(sources["inputcount"])
		} else {
			this.sockets.inputs["inputcount"].value = sources["inputcount"]
		}

		if (typeof sources["operation"] === "object") {
			this.sockets.inputs["operation"].connectTo(sources["operation"])
		} else {
			this.sockets.inputs["operation"].value = sources["operation"]
		}

		if (typeof sources["conditioning_1"] === "object") {
			this.sockets.inputs["conditioning_1"].connectTo(sources["conditioning_1"])
		} else {
			this.sockets.inputs["conditioning_1"].value = sources["conditioning_1"]
		}

		if (typeof sources["conditioning_2"] === "object") {
			this.sockets.inputs["conditioning_2"].connectTo(sources["conditioning_2"])
		} else {
			this.sockets.inputs["conditioning_2"].value = sources["conditioning_2"]
		}

	}
}

type ConditioningMultiCombineInputs = {
			"inputcount": ComfyNodeTypedInputRef<number>
			"operation": ComfyNodeTypedInputRef<string>
			"conditioning_1": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"conditioning_2": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
}


export class ConditioningSetMaskAndCombine extends ComfyNode {
	classType: string = "ConditioningSetMaskAndCombine"

	sockets: {
		inputs: Required<ConditioningSetMaskAndCombineInputs>
		outputs: {
			combined_positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			combined_negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive_1": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive_1"),
				"negative_1": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative_1"),
				"positive_2": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive_2"),
				"negative_2": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative_2"),
				"mask_1": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask_1"),
				"mask_2": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask_2"),
				"mask_1_strength": new ComfyNodeTypedInputRef<number>(this, "mask_1_strength"),
				"mask_2_strength": new ComfyNodeTypedInputRef<number>(this, "mask_2_strength"),
				"set_cond_area": new ComfyNodeTypedInputRef<string>(this, "set_cond_area"),
			},
			outputs: Object.create(Object.prototype, {
				"combined_positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"combined_negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ConditioningSetMaskAndCombineInputs>) {
		if (typeof sources["positive_1"] === "object") {
			this.sockets.inputs["positive_1"].connectTo(sources["positive_1"])
		} else {
			this.sockets.inputs["positive_1"].value = sources["positive_1"]
		}

		if (typeof sources["negative_1"] === "object") {
			this.sockets.inputs["negative_1"].connectTo(sources["negative_1"])
		} else {
			this.sockets.inputs["negative_1"].value = sources["negative_1"]
		}

		if (typeof sources["positive_2"] === "object") {
			this.sockets.inputs["positive_2"].connectTo(sources["positive_2"])
		} else {
			this.sockets.inputs["positive_2"].value = sources["positive_2"]
		}

		if (typeof sources["negative_2"] === "object") {
			this.sockets.inputs["negative_2"].connectTo(sources["negative_2"])
		} else {
			this.sockets.inputs["negative_2"].value = sources["negative_2"]
		}

		if (typeof sources["mask_1"] === "object") {
			this.sockets.inputs["mask_1"].connectTo(sources["mask_1"])
		} else {
			this.sockets.inputs["mask_1"].value = sources["mask_1"]
		}

		if (typeof sources["mask_2"] === "object") {
			this.sockets.inputs["mask_2"].connectTo(sources["mask_2"])
		} else {
			this.sockets.inputs["mask_2"].value = sources["mask_2"]
		}

		if (typeof sources["mask_1_strength"] === "object") {
			this.sockets.inputs["mask_1_strength"].connectTo(sources["mask_1_strength"])
		} else {
			this.sockets.inputs["mask_1_strength"].value = sources["mask_1_strength"]
		}

		if (typeof sources["mask_2_strength"] === "object") {
			this.sockets.inputs["mask_2_strength"].connectTo(sources["mask_2_strength"])
		} else {
			this.sockets.inputs["mask_2_strength"].value = sources["mask_2_strength"]
		}

		if (typeof sources["set_cond_area"] === "object") {
			this.sockets.inputs["set_cond_area"].connectTo(sources["set_cond_area"])
		} else {
			this.sockets.inputs["set_cond_area"].value = sources["set_cond_area"]
		}

	}
}

type ConditioningSetMaskAndCombineInputs = {
			"positive_1": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative_1": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"positive_2": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative_2": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"mask_1": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"mask_2": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"mask_1_strength": ComfyNodeTypedInputRef<number>
			"mask_2_strength": ComfyNodeTypedInputRef<number>
			"set_cond_area": ComfyNodeTypedInputRef<string>
}


export class ConditioningSetMaskAndCombine3 extends ComfyNode {
	classType: string = "ConditioningSetMaskAndCombine3"

	sockets: {
		inputs: Required<ConditioningSetMaskAndCombine3Inputs>
		outputs: {
			combined_positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			combined_negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive_1": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive_1"),
				"negative_1": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative_1"),
				"positive_2": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive_2"),
				"negative_2": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative_2"),
				"positive_3": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive_3"),
				"negative_3": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative_3"),
				"mask_1": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask_1"),
				"mask_2": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask_2"),
				"mask_3": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask_3"),
				"mask_1_strength": new ComfyNodeTypedInputRef<number>(this, "mask_1_strength"),
				"mask_2_strength": new ComfyNodeTypedInputRef<number>(this, "mask_2_strength"),
				"mask_3_strength": new ComfyNodeTypedInputRef<number>(this, "mask_3_strength"),
				"set_cond_area": new ComfyNodeTypedInputRef<string>(this, "set_cond_area"),
			},
			outputs: Object.create(Object.prototype, {
				"combined_positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"combined_negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ConditioningSetMaskAndCombine3Inputs>) {
		if (typeof sources["positive_1"] === "object") {
			this.sockets.inputs["positive_1"].connectTo(sources["positive_1"])
		} else {
			this.sockets.inputs["positive_1"].value = sources["positive_1"]
		}

		if (typeof sources["negative_1"] === "object") {
			this.sockets.inputs["negative_1"].connectTo(sources["negative_1"])
		} else {
			this.sockets.inputs["negative_1"].value = sources["negative_1"]
		}

		if (typeof sources["positive_2"] === "object") {
			this.sockets.inputs["positive_2"].connectTo(sources["positive_2"])
		} else {
			this.sockets.inputs["positive_2"].value = sources["positive_2"]
		}

		if (typeof sources["negative_2"] === "object") {
			this.sockets.inputs["negative_2"].connectTo(sources["negative_2"])
		} else {
			this.sockets.inputs["negative_2"].value = sources["negative_2"]
		}

		if (typeof sources["positive_3"] === "object") {
			this.sockets.inputs["positive_3"].connectTo(sources["positive_3"])
		} else {
			this.sockets.inputs["positive_3"].value = sources["positive_3"]
		}

		if (typeof sources["negative_3"] === "object") {
			this.sockets.inputs["negative_3"].connectTo(sources["negative_3"])
		} else {
			this.sockets.inputs["negative_3"].value = sources["negative_3"]
		}

		if (typeof sources["mask_1"] === "object") {
			this.sockets.inputs["mask_1"].connectTo(sources["mask_1"])
		} else {
			this.sockets.inputs["mask_1"].value = sources["mask_1"]
		}

		if (typeof sources["mask_2"] === "object") {
			this.sockets.inputs["mask_2"].connectTo(sources["mask_2"])
		} else {
			this.sockets.inputs["mask_2"].value = sources["mask_2"]
		}

		if (typeof sources["mask_3"] === "object") {
			this.sockets.inputs["mask_3"].connectTo(sources["mask_3"])
		} else {
			this.sockets.inputs["mask_3"].value = sources["mask_3"]
		}

		if (typeof sources["mask_1_strength"] === "object") {
			this.sockets.inputs["mask_1_strength"].connectTo(sources["mask_1_strength"])
		} else {
			this.sockets.inputs["mask_1_strength"].value = sources["mask_1_strength"]
		}

		if (typeof sources["mask_2_strength"] === "object") {
			this.sockets.inputs["mask_2_strength"].connectTo(sources["mask_2_strength"])
		} else {
			this.sockets.inputs["mask_2_strength"].value = sources["mask_2_strength"]
		}

		if (typeof sources["mask_3_strength"] === "object") {
			this.sockets.inputs["mask_3_strength"].connectTo(sources["mask_3_strength"])
		} else {
			this.sockets.inputs["mask_3_strength"].value = sources["mask_3_strength"]
		}

		if (typeof sources["set_cond_area"] === "object") {
			this.sockets.inputs["set_cond_area"].connectTo(sources["set_cond_area"])
		} else {
			this.sockets.inputs["set_cond_area"].value = sources["set_cond_area"]
		}

	}
}

type ConditioningSetMaskAndCombine3Inputs = {
			"positive_1": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative_1": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"positive_2": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative_2": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"positive_3": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative_3": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"mask_1": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"mask_2": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"mask_3": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"mask_1_strength": ComfyNodeTypedInputRef<number>
			"mask_2_strength": ComfyNodeTypedInputRef<number>
			"mask_3_strength": ComfyNodeTypedInputRef<number>
			"set_cond_area": ComfyNodeTypedInputRef<string>
}


export class ConditioningSetMaskAndCombine4 extends ComfyNode {
	classType: string = "ConditioningSetMaskAndCombine4"

	sockets: {
		inputs: Required<ConditioningSetMaskAndCombine4Inputs>
		outputs: {
			combined_positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			combined_negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive_1": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive_1"),
				"negative_1": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative_1"),
				"positive_2": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive_2"),
				"negative_2": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative_2"),
				"positive_3": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive_3"),
				"negative_3": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative_3"),
				"positive_4": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive_4"),
				"negative_4": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative_4"),
				"mask_1": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask_1"),
				"mask_2": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask_2"),
				"mask_3": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask_3"),
				"mask_4": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask_4"),
				"mask_1_strength": new ComfyNodeTypedInputRef<number>(this, "mask_1_strength"),
				"mask_2_strength": new ComfyNodeTypedInputRef<number>(this, "mask_2_strength"),
				"mask_3_strength": new ComfyNodeTypedInputRef<number>(this, "mask_3_strength"),
				"mask_4_strength": new ComfyNodeTypedInputRef<number>(this, "mask_4_strength"),
				"set_cond_area": new ComfyNodeTypedInputRef<string>(this, "set_cond_area"),
			},
			outputs: Object.create(Object.prototype, {
				"combined_positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"combined_negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ConditioningSetMaskAndCombine4Inputs>) {
		if (typeof sources["positive_1"] === "object") {
			this.sockets.inputs["positive_1"].connectTo(sources["positive_1"])
		} else {
			this.sockets.inputs["positive_1"].value = sources["positive_1"]
		}

		if (typeof sources["negative_1"] === "object") {
			this.sockets.inputs["negative_1"].connectTo(sources["negative_1"])
		} else {
			this.sockets.inputs["negative_1"].value = sources["negative_1"]
		}

		if (typeof sources["positive_2"] === "object") {
			this.sockets.inputs["positive_2"].connectTo(sources["positive_2"])
		} else {
			this.sockets.inputs["positive_2"].value = sources["positive_2"]
		}

		if (typeof sources["negative_2"] === "object") {
			this.sockets.inputs["negative_2"].connectTo(sources["negative_2"])
		} else {
			this.sockets.inputs["negative_2"].value = sources["negative_2"]
		}

		if (typeof sources["positive_3"] === "object") {
			this.sockets.inputs["positive_3"].connectTo(sources["positive_3"])
		} else {
			this.sockets.inputs["positive_3"].value = sources["positive_3"]
		}

		if (typeof sources["negative_3"] === "object") {
			this.sockets.inputs["negative_3"].connectTo(sources["negative_3"])
		} else {
			this.sockets.inputs["negative_3"].value = sources["negative_3"]
		}

		if (typeof sources["positive_4"] === "object") {
			this.sockets.inputs["positive_4"].connectTo(sources["positive_4"])
		} else {
			this.sockets.inputs["positive_4"].value = sources["positive_4"]
		}

		if (typeof sources["negative_4"] === "object") {
			this.sockets.inputs["negative_4"].connectTo(sources["negative_4"])
		} else {
			this.sockets.inputs["negative_4"].value = sources["negative_4"]
		}

		if (typeof sources["mask_1"] === "object") {
			this.sockets.inputs["mask_1"].connectTo(sources["mask_1"])
		} else {
			this.sockets.inputs["mask_1"].value = sources["mask_1"]
		}

		if (typeof sources["mask_2"] === "object") {
			this.sockets.inputs["mask_2"].connectTo(sources["mask_2"])
		} else {
			this.sockets.inputs["mask_2"].value = sources["mask_2"]
		}

		if (typeof sources["mask_3"] === "object") {
			this.sockets.inputs["mask_3"].connectTo(sources["mask_3"])
		} else {
			this.sockets.inputs["mask_3"].value = sources["mask_3"]
		}

		if (typeof sources["mask_4"] === "object") {
			this.sockets.inputs["mask_4"].connectTo(sources["mask_4"])
		} else {
			this.sockets.inputs["mask_4"].value = sources["mask_4"]
		}

		if (typeof sources["mask_1_strength"] === "object") {
			this.sockets.inputs["mask_1_strength"].connectTo(sources["mask_1_strength"])
		} else {
			this.sockets.inputs["mask_1_strength"].value = sources["mask_1_strength"]
		}

		if (typeof sources["mask_2_strength"] === "object") {
			this.sockets.inputs["mask_2_strength"].connectTo(sources["mask_2_strength"])
		} else {
			this.sockets.inputs["mask_2_strength"].value = sources["mask_2_strength"]
		}

		if (typeof sources["mask_3_strength"] === "object") {
			this.sockets.inputs["mask_3_strength"].connectTo(sources["mask_3_strength"])
		} else {
			this.sockets.inputs["mask_3_strength"].value = sources["mask_3_strength"]
		}

		if (typeof sources["mask_4_strength"] === "object") {
			this.sockets.inputs["mask_4_strength"].connectTo(sources["mask_4_strength"])
		} else {
			this.sockets.inputs["mask_4_strength"].value = sources["mask_4_strength"]
		}

		if (typeof sources["set_cond_area"] === "object") {
			this.sockets.inputs["set_cond_area"].connectTo(sources["set_cond_area"])
		} else {
			this.sockets.inputs["set_cond_area"].value = sources["set_cond_area"]
		}

	}
}

type ConditioningSetMaskAndCombine4Inputs = {
			"positive_1": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative_1": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"positive_2": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative_2": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"positive_3": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative_3": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"positive_4": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative_4": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"mask_1": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"mask_2": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"mask_3": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"mask_4": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"mask_1_strength": ComfyNodeTypedInputRef<number>
			"mask_2_strength": ComfyNodeTypedInputRef<number>
			"mask_3_strength": ComfyNodeTypedInputRef<number>
			"mask_4_strength": ComfyNodeTypedInputRef<number>
			"set_cond_area": ComfyNodeTypedInputRef<string>
}


export class ConditioningSetMaskAndCombine5 extends ComfyNode {
	classType: string = "ConditioningSetMaskAndCombine5"

	sockets: {
		inputs: Required<ConditioningSetMaskAndCombine5Inputs>
		outputs: {
			combined_positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			combined_negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive_1": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive_1"),
				"negative_1": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative_1"),
				"positive_2": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive_2"),
				"negative_2": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative_2"),
				"positive_3": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive_3"),
				"negative_3": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative_3"),
				"positive_4": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive_4"),
				"negative_4": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative_4"),
				"positive_5": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive_5"),
				"negative_5": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative_5"),
				"mask_1": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask_1"),
				"mask_2": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask_2"),
				"mask_3": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask_3"),
				"mask_4": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask_4"),
				"mask_5": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask_5"),
				"mask_1_strength": new ComfyNodeTypedInputRef<number>(this, "mask_1_strength"),
				"mask_2_strength": new ComfyNodeTypedInputRef<number>(this, "mask_2_strength"),
				"mask_3_strength": new ComfyNodeTypedInputRef<number>(this, "mask_3_strength"),
				"mask_4_strength": new ComfyNodeTypedInputRef<number>(this, "mask_4_strength"),
				"mask_5_strength": new ComfyNodeTypedInputRef<number>(this, "mask_5_strength"),
				"set_cond_area": new ComfyNodeTypedInputRef<string>(this, "set_cond_area"),
			},
			outputs: Object.create(Object.prototype, {
				"combined_positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"combined_negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ConditioningSetMaskAndCombine5Inputs>) {
		if (typeof sources["positive_1"] === "object") {
			this.sockets.inputs["positive_1"].connectTo(sources["positive_1"])
		} else {
			this.sockets.inputs["positive_1"].value = sources["positive_1"]
		}

		if (typeof sources["negative_1"] === "object") {
			this.sockets.inputs["negative_1"].connectTo(sources["negative_1"])
		} else {
			this.sockets.inputs["negative_1"].value = sources["negative_1"]
		}

		if (typeof sources["positive_2"] === "object") {
			this.sockets.inputs["positive_2"].connectTo(sources["positive_2"])
		} else {
			this.sockets.inputs["positive_2"].value = sources["positive_2"]
		}

		if (typeof sources["negative_2"] === "object") {
			this.sockets.inputs["negative_2"].connectTo(sources["negative_2"])
		} else {
			this.sockets.inputs["negative_2"].value = sources["negative_2"]
		}

		if (typeof sources["positive_3"] === "object") {
			this.sockets.inputs["positive_3"].connectTo(sources["positive_3"])
		} else {
			this.sockets.inputs["positive_3"].value = sources["positive_3"]
		}

		if (typeof sources["negative_3"] === "object") {
			this.sockets.inputs["negative_3"].connectTo(sources["negative_3"])
		} else {
			this.sockets.inputs["negative_3"].value = sources["negative_3"]
		}

		if (typeof sources["positive_4"] === "object") {
			this.sockets.inputs["positive_4"].connectTo(sources["positive_4"])
		} else {
			this.sockets.inputs["positive_4"].value = sources["positive_4"]
		}

		if (typeof sources["negative_4"] === "object") {
			this.sockets.inputs["negative_4"].connectTo(sources["negative_4"])
		} else {
			this.sockets.inputs["negative_4"].value = sources["negative_4"]
		}

		if (typeof sources["positive_5"] === "object") {
			this.sockets.inputs["positive_5"].connectTo(sources["positive_5"])
		} else {
			this.sockets.inputs["positive_5"].value = sources["positive_5"]
		}

		if (typeof sources["negative_5"] === "object") {
			this.sockets.inputs["negative_5"].connectTo(sources["negative_5"])
		} else {
			this.sockets.inputs["negative_5"].value = sources["negative_5"]
		}

		if (typeof sources["mask_1"] === "object") {
			this.sockets.inputs["mask_1"].connectTo(sources["mask_1"])
		} else {
			this.sockets.inputs["mask_1"].value = sources["mask_1"]
		}

		if (typeof sources["mask_2"] === "object") {
			this.sockets.inputs["mask_2"].connectTo(sources["mask_2"])
		} else {
			this.sockets.inputs["mask_2"].value = sources["mask_2"]
		}

		if (typeof sources["mask_3"] === "object") {
			this.sockets.inputs["mask_3"].connectTo(sources["mask_3"])
		} else {
			this.sockets.inputs["mask_3"].value = sources["mask_3"]
		}

		if (typeof sources["mask_4"] === "object") {
			this.sockets.inputs["mask_4"].connectTo(sources["mask_4"])
		} else {
			this.sockets.inputs["mask_4"].value = sources["mask_4"]
		}

		if (typeof sources["mask_5"] === "object") {
			this.sockets.inputs["mask_5"].connectTo(sources["mask_5"])
		} else {
			this.sockets.inputs["mask_5"].value = sources["mask_5"]
		}

		if (typeof sources["mask_1_strength"] === "object") {
			this.sockets.inputs["mask_1_strength"].connectTo(sources["mask_1_strength"])
		} else {
			this.sockets.inputs["mask_1_strength"].value = sources["mask_1_strength"]
		}

		if (typeof sources["mask_2_strength"] === "object") {
			this.sockets.inputs["mask_2_strength"].connectTo(sources["mask_2_strength"])
		} else {
			this.sockets.inputs["mask_2_strength"].value = sources["mask_2_strength"]
		}

		if (typeof sources["mask_3_strength"] === "object") {
			this.sockets.inputs["mask_3_strength"].connectTo(sources["mask_3_strength"])
		} else {
			this.sockets.inputs["mask_3_strength"].value = sources["mask_3_strength"]
		}

		if (typeof sources["mask_4_strength"] === "object") {
			this.sockets.inputs["mask_4_strength"].connectTo(sources["mask_4_strength"])
		} else {
			this.sockets.inputs["mask_4_strength"].value = sources["mask_4_strength"]
		}

		if (typeof sources["mask_5_strength"] === "object") {
			this.sockets.inputs["mask_5_strength"].connectTo(sources["mask_5_strength"])
		} else {
			this.sockets.inputs["mask_5_strength"].value = sources["mask_5_strength"]
		}

		if (typeof sources["set_cond_area"] === "object") {
			this.sockets.inputs["set_cond_area"].connectTo(sources["set_cond_area"])
		} else {
			this.sockets.inputs["set_cond_area"].value = sources["set_cond_area"]
		}

	}
}

type ConditioningSetMaskAndCombine5Inputs = {
			"positive_1": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative_1": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"positive_2": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative_2": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"positive_3": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative_3": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"positive_4": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative_4": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"positive_5": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative_5": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"mask_1": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"mask_2": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"mask_3": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"mask_4": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"mask_5": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"mask_1_strength": ComfyNodeTypedInputRef<number>
			"mask_2_strength": ComfyNodeTypedInputRef<number>
			"mask_3_strength": ComfyNodeTypedInputRef<number>
			"mask_4_strength": ComfyNodeTypedInputRef<number>
			"mask_5_strength": ComfyNodeTypedInputRef<number>
			"set_cond_area": ComfyNodeTypedInputRef<string>
}


export class CondPassThrough extends ComfyNode {
	classType: string = "CondPassThrough"

	sockets: {
		inputs: Required<CondPassThroughInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CondPassThroughInputs>) {
		if (sources["positive"] !== undefined) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}
		}

		if (sources["negative"] !== undefined) {
		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}
		}

	}
}

type CondPassThroughInputs = {
			"positive"?: ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative"?: ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
}


export class DrawMaskOnImage extends ComfyNode {
	classType: string = "DrawMaskOnImage"

	sockets: {
		inputs: Required<DrawMaskOnImageInputs>
		outputs: {
			images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"color": new ComfyNodeTypedInputRef<string>(this, "color"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DrawMaskOnImageInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["color"] === "object") {
			this.sockets.inputs["color"].connectTo(sources["color"])
		} else {
			this.sockets.inputs["color"].value = sources["color"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type DrawMaskOnImageInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			/** Color as RGB values in range 0-255 or 0.0-1.0, separated by commas.*/
			"color": ComfyNodeTypedInputRef<string>
			/** Device to use for processing*/
			"device"?: ComfyNodeTypedInputRef<string>
}


export class DownloadAndLoadCLIPSeg extends ComfyNode {
	classType: string = "DownloadAndLoadCLIPSeg"

	sockets: {
		inputs: Required<DownloadAndLoadCLIPSegInputs>
		outputs: {
			clipseg_model: ComfyNodeTypedSourceRef<ComfyValueType_CLIPSEGMODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<string>(this, "model"),
			},
			outputs: Object.create(Object.prototype, {
				"clipseg_model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DownloadAndLoadCLIPSegInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

	}
}

type DownloadAndLoadCLIPSegInputs = {
			"model": ComfyNodeTypedInputRef<string>
}


export class BatchCLIPSeg extends ComfyNode {
	classType: string = "BatchCLIPSeg"

	sockets: {
		inputs: Required<BatchCLIPSegInputs>
		outputs: {
			Mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			Image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"text": new ComfyNodeTypedInputRef<string>(this, "text"),
				"threshold": new ComfyNodeTypedInputRef<number>(this, "threshold"),
				"binary_mask": new ComfyNodeTypedInputRef<boolean>(this, "binary_mask"),
				"combine_mask": new ComfyNodeTypedInputRef<boolean>(this, "combine_mask"),
				"use_cuda": new ComfyNodeTypedInputRef<boolean>(this, "use_cuda"),
				"blur_sigma": new ComfyNodeTypedInputRef<number>(this, "blur_sigma"),
				"opt_model": new ComfyNodeTypedInputRef<ComfyValueType_CLIPSEGMODEL>(this, "opt_model"),
				"prev_mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "prev_mask"),
				"image_bg_level": new ComfyNodeTypedInputRef<number>(this, "image_bg_level"),
				"invert": new ComfyNodeTypedInputRef<boolean>(this, "invert"),
			},
			outputs: Object.create(Object.prototype, {
				"Mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"Image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<BatchCLIPSegInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["text"] === "object") {
			this.sockets.inputs["text"].connectTo(sources["text"])
		} else {
			this.sockets.inputs["text"].value = sources["text"]
		}

		if (typeof sources["threshold"] === "object") {
			this.sockets.inputs["threshold"].connectTo(sources["threshold"])
		} else {
			this.sockets.inputs["threshold"].value = sources["threshold"]
		}

		if (typeof sources["binary_mask"] === "object") {
			this.sockets.inputs["binary_mask"].connectTo(sources["binary_mask"])
		} else {
			this.sockets.inputs["binary_mask"].value = sources["binary_mask"]
		}

		if (typeof sources["combine_mask"] === "object") {
			this.sockets.inputs["combine_mask"].connectTo(sources["combine_mask"])
		} else {
			this.sockets.inputs["combine_mask"].value = sources["combine_mask"]
		}

		if (typeof sources["use_cuda"] === "object") {
			this.sockets.inputs["use_cuda"].connectTo(sources["use_cuda"])
		} else {
			this.sockets.inputs["use_cuda"].value = sources["use_cuda"]
		}

		if (sources["blur_sigma"] !== undefined) {
		if (typeof sources["blur_sigma"] === "object") {
			this.sockets.inputs["blur_sigma"].connectTo(sources["blur_sigma"])
		} else {
			this.sockets.inputs["blur_sigma"].value = sources["blur_sigma"]
		}
		}

		if (sources["opt_model"] !== undefined) {
		if (typeof sources["opt_model"] === "object") {
			this.sockets.inputs["opt_model"].connectTo(sources["opt_model"])
		} else {
			this.sockets.inputs["opt_model"].value = sources["opt_model"]
		}
		}

		if (sources["prev_mask"] !== undefined) {
		if (typeof sources["prev_mask"] === "object") {
			this.sockets.inputs["prev_mask"].connectTo(sources["prev_mask"])
		} else {
			this.sockets.inputs["prev_mask"].value = sources["prev_mask"]
		}
		}

		if (sources["image_bg_level"] !== undefined) {
		if (typeof sources["image_bg_level"] === "object") {
			this.sockets.inputs["image_bg_level"].connectTo(sources["image_bg_level"])
		} else {
			this.sockets.inputs["image_bg_level"].value = sources["image_bg_level"]
		}
		}

		if (sources["invert"] !== undefined) {
		if (typeof sources["invert"] === "object") {
			this.sockets.inputs["invert"].connectTo(sources["invert"])
		} else {
			this.sockets.inputs["invert"].value = sources["invert"]
		}
		}

	}
}

type BatchCLIPSegInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"text": ComfyNodeTypedInputRef<string>
			"threshold": ComfyNodeTypedInputRef<number>
			"binary_mask": ComfyNodeTypedInputRef<boolean>
			"combine_mask": ComfyNodeTypedInputRef<boolean>
			"use_cuda": ComfyNodeTypedInputRef<boolean>
			"blur_sigma"?: ComfyNodeTypedInputRef<number>
			"opt_model"?: ComfyNodeTypedInputRef<ComfyValueType_CLIPSEGMODEL>
			"prev_mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"image_bg_level"?: ComfyNodeTypedInputRef<number>
			"invert"?: ComfyNodeTypedInputRef<boolean>
}


export class BlockifyMask extends ComfyNode {
	classType: string = "BlockifyMask"

	sockets: {
		inputs: Required<BlockifyMaskInputs>
		outputs: {
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"masks": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "masks"),
				"block_size": new ComfyNodeTypedInputRef<number>(this, "block_size"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<BlockifyMaskInputs>) {
		if (typeof sources["masks"] === "object") {
			this.sockets.inputs["masks"].connectTo(sources["masks"])
		} else {
			this.sockets.inputs["masks"].value = sources["masks"]
		}

		if (typeof sources["block_size"] === "object") {
			this.sockets.inputs["block_size"].connectTo(sources["block_size"])
		} else {
			this.sockets.inputs["block_size"].value = sources["block_size"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type BlockifyMaskInputs = {
			"masks": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			/** Size of blocks in pixels (smaller = smaller blocks)*/
			"block_size": ComfyNodeTypedInputRef<number>
			/** Device to use for processing*/
			"device"?: ComfyNodeTypedInputRef<string>
}


export class ColorToMask extends ComfyNode {
	classType: string = "ColorToMask"

	sockets: {
		inputs: Required<ColorToMaskInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"invert": new ComfyNodeTypedInputRef<boolean>(this, "invert"),
				"red": new ComfyNodeTypedInputRef<number>(this, "red"),
				"green": new ComfyNodeTypedInputRef<number>(this, "green"),
				"blue": new ComfyNodeTypedInputRef<number>(this, "blue"),
				"threshold": new ComfyNodeTypedInputRef<number>(this, "threshold"),
				"per_batch": new ComfyNodeTypedInputRef<number>(this, "per_batch"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ColorToMaskInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["invert"] === "object") {
			this.sockets.inputs["invert"].connectTo(sources["invert"])
		} else {
			this.sockets.inputs["invert"].value = sources["invert"]
		}

		if (typeof sources["red"] === "object") {
			this.sockets.inputs["red"].connectTo(sources["red"])
		} else {
			this.sockets.inputs["red"].value = sources["red"]
		}

		if (typeof sources["green"] === "object") {
			this.sockets.inputs["green"].connectTo(sources["green"])
		} else {
			this.sockets.inputs["green"].value = sources["green"]
		}

		if (typeof sources["blue"] === "object") {
			this.sockets.inputs["blue"].connectTo(sources["blue"])
		} else {
			this.sockets.inputs["blue"].value = sources["blue"]
		}

		if (typeof sources["threshold"] === "object") {
			this.sockets.inputs["threshold"].connectTo(sources["threshold"])
		} else {
			this.sockets.inputs["threshold"].value = sources["threshold"]
		}

		if (typeof sources["per_batch"] === "object") {
			this.sockets.inputs["per_batch"].connectTo(sources["per_batch"])
		} else {
			this.sockets.inputs["per_batch"].value = sources["per_batch"]
		}

	}
}

type ColorToMaskInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"invert": ComfyNodeTypedInputRef<boolean>
			"red": ComfyNodeTypedInputRef<number>
			"green": ComfyNodeTypedInputRef<number>
			"blue": ComfyNodeTypedInputRef<number>
			"threshold": ComfyNodeTypedInputRef<number>
			"per_batch": ComfyNodeTypedInputRef<number>
}


export class CreateGradientMask extends ComfyNode {
	classType: string = "CreateGradientMask"

	sockets: {
		inputs: Required<CreateGradientMaskInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"invert": new ComfyNodeTypedInputRef<boolean>(this, "invert"),
				"frames": new ComfyNodeTypedInputRef<number>(this, "frames"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateGradientMaskInputs>) {
		if (typeof sources["invert"] === "object") {
			this.sockets.inputs["invert"].connectTo(sources["invert"])
		} else {
			this.sockets.inputs["invert"].value = sources["invert"]
		}

		if (typeof sources["frames"] === "object") {
			this.sockets.inputs["frames"].connectTo(sources["frames"])
		} else {
			this.sockets.inputs["frames"].value = sources["frames"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

	}
}

type CreateGradientMaskInputs = {
			"invert": ComfyNodeTypedInputRef<boolean>
			"frames": ComfyNodeTypedInputRef<number>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
}


export class CreateTextMask extends ComfyNode {
	classType: string = "CreateTextMask"

	sockets: {
		inputs: Required<CreateTextMaskInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"invert": new ComfyNodeTypedInputRef<boolean>(this, "invert"),
				"frames": new ComfyNodeTypedInputRef<number>(this, "frames"),
				"text_x": new ComfyNodeTypedInputRef<number>(this, "text_x"),
				"text_y": new ComfyNodeTypedInputRef<number>(this, "text_y"),
				"font_size": new ComfyNodeTypedInputRef<number>(this, "font_size"),
				"font_color": new ComfyNodeTypedInputRef<string>(this, "font_color"),
				"text": new ComfyNodeTypedInputRef<string>(this, "text"),
				"font": new ComfyNodeTypedInputRef<string>(this, "font"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"start_rotation": new ComfyNodeTypedInputRef<number>(this, "start_rotation"),
				"end_rotation": new ComfyNodeTypedInputRef<number>(this, "end_rotation"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateTextMaskInputs>) {
		if (typeof sources["invert"] === "object") {
			this.sockets.inputs["invert"].connectTo(sources["invert"])
		} else {
			this.sockets.inputs["invert"].value = sources["invert"]
		}

		if (typeof sources["frames"] === "object") {
			this.sockets.inputs["frames"].connectTo(sources["frames"])
		} else {
			this.sockets.inputs["frames"].value = sources["frames"]
		}

		if (typeof sources["text_x"] === "object") {
			this.sockets.inputs["text_x"].connectTo(sources["text_x"])
		} else {
			this.sockets.inputs["text_x"].value = sources["text_x"]
		}

		if (typeof sources["text_y"] === "object") {
			this.sockets.inputs["text_y"].connectTo(sources["text_y"])
		} else {
			this.sockets.inputs["text_y"].value = sources["text_y"]
		}

		if (typeof sources["font_size"] === "object") {
			this.sockets.inputs["font_size"].connectTo(sources["font_size"])
		} else {
			this.sockets.inputs["font_size"].value = sources["font_size"]
		}

		if (typeof sources["font_color"] === "object") {
			this.sockets.inputs["font_color"].connectTo(sources["font_color"])
		} else {
			this.sockets.inputs["font_color"].value = sources["font_color"]
		}

		if (typeof sources["text"] === "object") {
			this.sockets.inputs["text"].connectTo(sources["text"])
		} else {
			this.sockets.inputs["text"].value = sources["text"]
		}

		if (typeof sources["font"] === "object") {
			this.sockets.inputs["font"].connectTo(sources["font"])
		} else {
			this.sockets.inputs["font"].value = sources["font"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["start_rotation"] === "object") {
			this.sockets.inputs["start_rotation"].connectTo(sources["start_rotation"])
		} else {
			this.sockets.inputs["start_rotation"].value = sources["start_rotation"]
		}

		if (typeof sources["end_rotation"] === "object") {
			this.sockets.inputs["end_rotation"].connectTo(sources["end_rotation"])
		} else {
			this.sockets.inputs["end_rotation"].value = sources["end_rotation"]
		}

	}
}

type CreateTextMaskInputs = {
			"invert": ComfyNodeTypedInputRef<boolean>
			"frames": ComfyNodeTypedInputRef<number>
			"text_x": ComfyNodeTypedInputRef<number>
			"text_y": ComfyNodeTypedInputRef<number>
			"font_size": ComfyNodeTypedInputRef<number>
			"font_color": ComfyNodeTypedInputRef<string>
			"text": ComfyNodeTypedInputRef<string>
			"font": ComfyNodeTypedInputRef<string>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"start_rotation": ComfyNodeTypedInputRef<number>
			"end_rotation": ComfyNodeTypedInputRef<number>
}


export class CreateAudioMask extends ComfyNode {
	classType: string = "CreateAudioMask"

	sockets: {
		inputs: Required<CreateAudioMaskInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"invert": new ComfyNodeTypedInputRef<boolean>(this, "invert"),
				"frames": new ComfyNodeTypedInputRef<number>(this, "frames"),
				"scale": new ComfyNodeTypedInputRef<number>(this, "scale"),
				"audio_path": new ComfyNodeTypedInputRef<string>(this, "audio_path"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateAudioMaskInputs>) {
		if (typeof sources["invert"] === "object") {
			this.sockets.inputs["invert"].connectTo(sources["invert"])
		} else {
			this.sockets.inputs["invert"].value = sources["invert"]
		}

		if (typeof sources["frames"] === "object") {
			this.sockets.inputs["frames"].connectTo(sources["frames"])
		} else {
			this.sockets.inputs["frames"].value = sources["frames"]
		}

		if (typeof sources["scale"] === "object") {
			this.sockets.inputs["scale"].connectTo(sources["scale"])
		} else {
			this.sockets.inputs["scale"].value = sources["scale"]
		}

		if (typeof sources["audio_path"] === "object") {
			this.sockets.inputs["audio_path"].connectTo(sources["audio_path"])
		} else {
			this.sockets.inputs["audio_path"].value = sources["audio_path"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

	}
}

type CreateAudioMaskInputs = {
			"invert": ComfyNodeTypedInputRef<boolean>
			"frames": ComfyNodeTypedInputRef<number>
			"scale": ComfyNodeTypedInputRef<number>
			"audio_path": ComfyNodeTypedInputRef<string>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
}


export class CreateFadeMask extends ComfyNode {
	classType: string = "CreateFadeMask"

	sockets: {
		inputs: Required<CreateFadeMaskInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"invert": new ComfyNodeTypedInputRef<boolean>(this, "invert"),
				"frames": new ComfyNodeTypedInputRef<number>(this, "frames"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"interpolation": new ComfyNodeTypedInputRef<string>(this, "interpolation"),
				"start_level": new ComfyNodeTypedInputRef<number>(this, "start_level"),
				"midpoint_level": new ComfyNodeTypedInputRef<number>(this, "midpoint_level"),
				"end_level": new ComfyNodeTypedInputRef<number>(this, "end_level"),
				"midpoint_frame": new ComfyNodeTypedInputRef<number>(this, "midpoint_frame"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateFadeMaskInputs>) {
		if (typeof sources["invert"] === "object") {
			this.sockets.inputs["invert"].connectTo(sources["invert"])
		} else {
			this.sockets.inputs["invert"].value = sources["invert"]
		}

		if (typeof sources["frames"] === "object") {
			this.sockets.inputs["frames"].connectTo(sources["frames"])
		} else {
			this.sockets.inputs["frames"].value = sources["frames"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["interpolation"] === "object") {
			this.sockets.inputs["interpolation"].connectTo(sources["interpolation"])
		} else {
			this.sockets.inputs["interpolation"].value = sources["interpolation"]
		}

		if (typeof sources["start_level"] === "object") {
			this.sockets.inputs["start_level"].connectTo(sources["start_level"])
		} else {
			this.sockets.inputs["start_level"].value = sources["start_level"]
		}

		if (typeof sources["midpoint_level"] === "object") {
			this.sockets.inputs["midpoint_level"].connectTo(sources["midpoint_level"])
		} else {
			this.sockets.inputs["midpoint_level"].value = sources["midpoint_level"]
		}

		if (typeof sources["end_level"] === "object") {
			this.sockets.inputs["end_level"].connectTo(sources["end_level"])
		} else {
			this.sockets.inputs["end_level"].value = sources["end_level"]
		}

		if (typeof sources["midpoint_frame"] === "object") {
			this.sockets.inputs["midpoint_frame"].connectTo(sources["midpoint_frame"])
		} else {
			this.sockets.inputs["midpoint_frame"].value = sources["midpoint_frame"]
		}

	}
}

type CreateFadeMaskInputs = {
			"invert": ComfyNodeTypedInputRef<boolean>
			"frames": ComfyNodeTypedInputRef<number>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"interpolation": ComfyNodeTypedInputRef<string>
			"start_level": ComfyNodeTypedInputRef<number>
			"midpoint_level": ComfyNodeTypedInputRef<number>
			"end_level": ComfyNodeTypedInputRef<number>
			"midpoint_frame": ComfyNodeTypedInputRef<number>
}


export class CreateFadeMaskAdvanced extends ComfyNode {
	classType: string = "CreateFadeMaskAdvanced"

	sockets: {
		inputs: Required<CreateFadeMaskAdvancedInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"points_string": new ComfyNodeTypedInputRef<string>(this, "points_string"),
				"invert": new ComfyNodeTypedInputRef<boolean>(this, "invert"),
				"frames": new ComfyNodeTypedInputRef<number>(this, "frames"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"interpolation": new ComfyNodeTypedInputRef<string>(this, "interpolation"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateFadeMaskAdvancedInputs>) {
		if (typeof sources["points_string"] === "object") {
			this.sockets.inputs["points_string"].connectTo(sources["points_string"])
		} else {
			this.sockets.inputs["points_string"].value = sources["points_string"]
		}

		if (typeof sources["invert"] === "object") {
			this.sockets.inputs["invert"].connectTo(sources["invert"])
		} else {
			this.sockets.inputs["invert"].value = sources["invert"]
		}

		if (typeof sources["frames"] === "object") {
			this.sockets.inputs["frames"].connectTo(sources["frames"])
		} else {
			this.sockets.inputs["frames"].value = sources["frames"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["interpolation"] === "object") {
			this.sockets.inputs["interpolation"].connectTo(sources["interpolation"])
		} else {
			this.sockets.inputs["interpolation"].value = sources["interpolation"]
		}

	}
}

type CreateFadeMaskAdvancedInputs = {
			"points_string": ComfyNodeTypedInputRef<string>
			"invert": ComfyNodeTypedInputRef<boolean>
			"frames": ComfyNodeTypedInputRef<number>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"interpolation": ComfyNodeTypedInputRef<string>
}


export class CreateFluidMask extends ComfyNode {
	classType: string = "CreateFluidMask"

	sockets: {
		inputs: Required<CreateFluidMaskInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"invert": new ComfyNodeTypedInputRef<boolean>(this, "invert"),
				"frames": new ComfyNodeTypedInputRef<number>(this, "frames"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"inflow_count": new ComfyNodeTypedInputRef<number>(this, "inflow_count"),
				"inflow_velocity": new ComfyNodeTypedInputRef<number>(this, "inflow_velocity"),
				"inflow_radius": new ComfyNodeTypedInputRef<number>(this, "inflow_radius"),
				"inflow_padding": new ComfyNodeTypedInputRef<number>(this, "inflow_padding"),
				"inflow_duration": new ComfyNodeTypedInputRef<number>(this, "inflow_duration"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateFluidMaskInputs>) {
		if (typeof sources["invert"] === "object") {
			this.sockets.inputs["invert"].connectTo(sources["invert"])
		} else {
			this.sockets.inputs["invert"].value = sources["invert"]
		}

		if (typeof sources["frames"] === "object") {
			this.sockets.inputs["frames"].connectTo(sources["frames"])
		} else {
			this.sockets.inputs["frames"].value = sources["frames"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["inflow_count"] === "object") {
			this.sockets.inputs["inflow_count"].connectTo(sources["inflow_count"])
		} else {
			this.sockets.inputs["inflow_count"].value = sources["inflow_count"]
		}

		if (typeof sources["inflow_velocity"] === "object") {
			this.sockets.inputs["inflow_velocity"].connectTo(sources["inflow_velocity"])
		} else {
			this.sockets.inputs["inflow_velocity"].value = sources["inflow_velocity"]
		}

		if (typeof sources["inflow_radius"] === "object") {
			this.sockets.inputs["inflow_radius"].connectTo(sources["inflow_radius"])
		} else {
			this.sockets.inputs["inflow_radius"].value = sources["inflow_radius"]
		}

		if (typeof sources["inflow_padding"] === "object") {
			this.sockets.inputs["inflow_padding"].connectTo(sources["inflow_padding"])
		} else {
			this.sockets.inputs["inflow_padding"].value = sources["inflow_padding"]
		}

		if (typeof sources["inflow_duration"] === "object") {
			this.sockets.inputs["inflow_duration"].connectTo(sources["inflow_duration"])
		} else {
			this.sockets.inputs["inflow_duration"].value = sources["inflow_duration"]
		}

	}
}

type CreateFluidMaskInputs = {
			"invert": ComfyNodeTypedInputRef<boolean>
			"frames": ComfyNodeTypedInputRef<number>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"inflow_count": ComfyNodeTypedInputRef<number>
			"inflow_velocity": ComfyNodeTypedInputRef<number>
			"inflow_radius": ComfyNodeTypedInputRef<number>
			"inflow_padding": ComfyNodeTypedInputRef<number>
			"inflow_duration": ComfyNodeTypedInputRef<number>
}


export class CreateShapeMask extends ComfyNode {
	classType: string = "CreateShapeMask"

	sockets: {
		inputs: Required<CreateShapeMaskInputs>
		outputs: {
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			mask_inverted: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"shape": new ComfyNodeTypedInputRef<string>(this, "shape"),
				"frames": new ComfyNodeTypedInputRef<number>(this, "frames"),
				"location_x": new ComfyNodeTypedInputRef<number>(this, "location_x"),
				"location_y": new ComfyNodeTypedInputRef<number>(this, "location_y"),
				"grow": new ComfyNodeTypedInputRef<number>(this, "grow"),
				"frame_width": new ComfyNodeTypedInputRef<number>(this, "frame_width"),
				"frame_height": new ComfyNodeTypedInputRef<number>(this, "frame_height"),
				"shape_width": new ComfyNodeTypedInputRef<number>(this, "shape_width"),
				"shape_height": new ComfyNodeTypedInputRef<number>(this, "shape_height"),
			},
			outputs: Object.create(Object.prototype, {
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"mask_inverted": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateShapeMaskInputs>) {
		if (typeof sources["shape"] === "object") {
			this.sockets.inputs["shape"].connectTo(sources["shape"])
		} else {
			this.sockets.inputs["shape"].value = sources["shape"]
		}

		if (typeof sources["frames"] === "object") {
			this.sockets.inputs["frames"].connectTo(sources["frames"])
		} else {
			this.sockets.inputs["frames"].value = sources["frames"]
		}

		if (typeof sources["location_x"] === "object") {
			this.sockets.inputs["location_x"].connectTo(sources["location_x"])
		} else {
			this.sockets.inputs["location_x"].value = sources["location_x"]
		}

		if (typeof sources["location_y"] === "object") {
			this.sockets.inputs["location_y"].connectTo(sources["location_y"])
		} else {
			this.sockets.inputs["location_y"].value = sources["location_y"]
		}

		if (typeof sources["grow"] === "object") {
			this.sockets.inputs["grow"].connectTo(sources["grow"])
		} else {
			this.sockets.inputs["grow"].value = sources["grow"]
		}

		if (typeof sources["frame_width"] === "object") {
			this.sockets.inputs["frame_width"].connectTo(sources["frame_width"])
		} else {
			this.sockets.inputs["frame_width"].value = sources["frame_width"]
		}

		if (typeof sources["frame_height"] === "object") {
			this.sockets.inputs["frame_height"].connectTo(sources["frame_height"])
		} else {
			this.sockets.inputs["frame_height"].value = sources["frame_height"]
		}

		if (typeof sources["shape_width"] === "object") {
			this.sockets.inputs["shape_width"].connectTo(sources["shape_width"])
		} else {
			this.sockets.inputs["shape_width"].value = sources["shape_width"]
		}

		if (typeof sources["shape_height"] === "object") {
			this.sockets.inputs["shape_height"].connectTo(sources["shape_height"])
		} else {
			this.sockets.inputs["shape_height"].value = sources["shape_height"]
		}

	}
}

type CreateShapeMaskInputs = {
			"shape": ComfyNodeTypedInputRef<string>
			"frames": ComfyNodeTypedInputRef<number>
			"location_x": ComfyNodeTypedInputRef<number>
			"location_y": ComfyNodeTypedInputRef<number>
			"grow": ComfyNodeTypedInputRef<number>
			"frame_width": ComfyNodeTypedInputRef<number>
			"frame_height": ComfyNodeTypedInputRef<number>
			"shape_width": ComfyNodeTypedInputRef<number>
			"shape_height": ComfyNodeTypedInputRef<number>
}


export class CreateVoronoiMask extends ComfyNode {
	classType: string = "CreateVoronoiMask"

	sockets: {
		inputs: Required<CreateVoronoiMaskInputs>
		outputs: {
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			mask_inverted: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"frames": new ComfyNodeTypedInputRef<number>(this, "frames"),
				"num_points": new ComfyNodeTypedInputRef<number>(this, "num_points"),
				"line_width": new ComfyNodeTypedInputRef<number>(this, "line_width"),
				"speed": new ComfyNodeTypedInputRef<number>(this, "speed"),
				"frame_width": new ComfyNodeTypedInputRef<number>(this, "frame_width"),
				"frame_height": new ComfyNodeTypedInputRef<number>(this, "frame_height"),
			},
			outputs: Object.create(Object.prototype, {
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"mask_inverted": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateVoronoiMaskInputs>) {
		if (typeof sources["frames"] === "object") {
			this.sockets.inputs["frames"].connectTo(sources["frames"])
		} else {
			this.sockets.inputs["frames"].value = sources["frames"]
		}

		if (typeof sources["num_points"] === "object") {
			this.sockets.inputs["num_points"].connectTo(sources["num_points"])
		} else {
			this.sockets.inputs["num_points"].value = sources["num_points"]
		}

		if (typeof sources["line_width"] === "object") {
			this.sockets.inputs["line_width"].connectTo(sources["line_width"])
		} else {
			this.sockets.inputs["line_width"].value = sources["line_width"]
		}

		if (typeof sources["speed"] === "object") {
			this.sockets.inputs["speed"].connectTo(sources["speed"])
		} else {
			this.sockets.inputs["speed"].value = sources["speed"]
		}

		if (typeof sources["frame_width"] === "object") {
			this.sockets.inputs["frame_width"].connectTo(sources["frame_width"])
		} else {
			this.sockets.inputs["frame_width"].value = sources["frame_width"]
		}

		if (typeof sources["frame_height"] === "object") {
			this.sockets.inputs["frame_height"].connectTo(sources["frame_height"])
		} else {
			this.sockets.inputs["frame_height"].value = sources["frame_height"]
		}

	}
}

type CreateVoronoiMaskInputs = {
			"frames": ComfyNodeTypedInputRef<number>
			"num_points": ComfyNodeTypedInputRef<number>
			"line_width": ComfyNodeTypedInputRef<number>
			"speed": ComfyNodeTypedInputRef<number>
			"frame_width": ComfyNodeTypedInputRef<number>
			"frame_height": ComfyNodeTypedInputRef<number>
}


export class CreateMagicMask extends ComfyNode {
	classType: string = "CreateMagicMask"

	sockets: {
		inputs: Required<CreateMagicMaskInputs>
		outputs: {
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			mask_inverted: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"frames": new ComfyNodeTypedInputRef<number>(this, "frames"),
				"depth": new ComfyNodeTypedInputRef<number>(this, "depth"),
				"distortion": new ComfyNodeTypedInputRef<number>(this, "distortion"),
				"seed": new ComfyNodeTypedInputRef<number>(this, "seed"),
				"transitions": new ComfyNodeTypedInputRef<number>(this, "transitions"),
				"frame_width": new ComfyNodeTypedInputRef<number>(this, "frame_width"),
				"frame_height": new ComfyNodeTypedInputRef<number>(this, "frame_height"),
			},
			outputs: Object.create(Object.prototype, {
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"mask_inverted": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateMagicMaskInputs>) {
		if (typeof sources["frames"] === "object") {
			this.sockets.inputs["frames"].connectTo(sources["frames"])
		} else {
			this.sockets.inputs["frames"].value = sources["frames"]
		}

		if (typeof sources["depth"] === "object") {
			this.sockets.inputs["depth"].connectTo(sources["depth"])
		} else {
			this.sockets.inputs["depth"].value = sources["depth"]
		}

		if (typeof sources["distortion"] === "object") {
			this.sockets.inputs["distortion"].connectTo(sources["distortion"])
		} else {
			this.sockets.inputs["distortion"].value = sources["distortion"]
		}

		if (typeof sources["seed"] === "object") {
			this.sockets.inputs["seed"].connectTo(sources["seed"])
		} else {
			this.sockets.inputs["seed"].value = sources["seed"]
		}

		if (typeof sources["transitions"] === "object") {
			this.sockets.inputs["transitions"].connectTo(sources["transitions"])
		} else {
			this.sockets.inputs["transitions"].value = sources["transitions"]
		}

		if (typeof sources["frame_width"] === "object") {
			this.sockets.inputs["frame_width"].connectTo(sources["frame_width"])
		} else {
			this.sockets.inputs["frame_width"].value = sources["frame_width"]
		}

		if (typeof sources["frame_height"] === "object") {
			this.sockets.inputs["frame_height"].connectTo(sources["frame_height"])
		} else {
			this.sockets.inputs["frame_height"].value = sources["frame_height"]
		}

	}
}

type CreateMagicMaskInputs = {
			"frames": ComfyNodeTypedInputRef<number>
			"depth": ComfyNodeTypedInputRef<number>
			"distortion": ComfyNodeTypedInputRef<number>
			"seed": ComfyNodeTypedInputRef<number>
			"transitions": ComfyNodeTypedInputRef<number>
			"frame_width": ComfyNodeTypedInputRef<number>
			"frame_height": ComfyNodeTypedInputRef<number>
}


export class GetMaskSizeAndCount extends ComfyNode {
	classType: string = "GetMaskSizeAndCount"

	sockets: {
		inputs: Required<GetMaskSizeAndCountInputs>
		outputs: {
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			width: ComfyNodeTypedSourceRef<number>
			height: ComfyNodeTypedSourceRef<number>
			count: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
			},
			outputs: Object.create(Object.prototype, {
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<GetMaskSizeAndCountInputs>) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

	}
}

type GetMaskSizeAndCountInputs = {
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class GrowMaskWithBlur extends ComfyNode {
	classType: string = "GrowMaskWithBlur"

	sockets: {
		inputs: Required<GrowMaskWithBlurInputs>
		outputs: {
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			mask_inverted: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"expand": new ComfyNodeTypedInputRef<number>(this, "expand"),
				"incremental_expandrate": new ComfyNodeTypedInputRef<number>(this, "incremental_expandrate"),
				"tapered_corners": new ComfyNodeTypedInputRef<boolean>(this, "tapered_corners"),
				"flip_input": new ComfyNodeTypedInputRef<boolean>(this, "flip_input"),
				"blur_radius": new ComfyNodeTypedInputRef<number>(this, "blur_radius"),
				"lerp_alpha": new ComfyNodeTypedInputRef<number>(this, "lerp_alpha"),
				"decay_factor": new ComfyNodeTypedInputRef<number>(this, "decay_factor"),
				"fill_holes": new ComfyNodeTypedInputRef<boolean>(this, "fill_holes"),
			},
			outputs: Object.create(Object.prototype, {
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"mask_inverted": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<GrowMaskWithBlurInputs>) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["expand"] === "object") {
			this.sockets.inputs["expand"].connectTo(sources["expand"])
		} else {
			this.sockets.inputs["expand"].value = sources["expand"]
		}

		if (typeof sources["incremental_expandrate"] === "object") {
			this.sockets.inputs["incremental_expandrate"].connectTo(sources["incremental_expandrate"])
		} else {
			this.sockets.inputs["incremental_expandrate"].value = sources["incremental_expandrate"]
		}

		if (typeof sources["tapered_corners"] === "object") {
			this.sockets.inputs["tapered_corners"].connectTo(sources["tapered_corners"])
		} else {
			this.sockets.inputs["tapered_corners"].value = sources["tapered_corners"]
		}

		if (typeof sources["flip_input"] === "object") {
			this.sockets.inputs["flip_input"].connectTo(sources["flip_input"])
		} else {
			this.sockets.inputs["flip_input"].value = sources["flip_input"]
		}

		if (typeof sources["blur_radius"] === "object") {
			this.sockets.inputs["blur_radius"].connectTo(sources["blur_radius"])
		} else {
			this.sockets.inputs["blur_radius"].value = sources["blur_radius"]
		}

		if (typeof sources["lerp_alpha"] === "object") {
			this.sockets.inputs["lerp_alpha"].connectTo(sources["lerp_alpha"])
		} else {
			this.sockets.inputs["lerp_alpha"].value = sources["lerp_alpha"]
		}

		if (typeof sources["decay_factor"] === "object") {
			this.sockets.inputs["decay_factor"].connectTo(sources["decay_factor"])
		} else {
			this.sockets.inputs["decay_factor"].value = sources["decay_factor"]
		}

		if (sources["fill_holes"] !== undefined) {
		if (typeof sources["fill_holes"] === "object") {
			this.sockets.inputs["fill_holes"].connectTo(sources["fill_holes"])
		} else {
			this.sockets.inputs["fill_holes"].value = sources["fill_holes"]
		}
		}

	}
}

type GrowMaskWithBlurInputs = {
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"expand": ComfyNodeTypedInputRef<number>
			"incremental_expandrate": ComfyNodeTypedInputRef<number>
			"tapered_corners": ComfyNodeTypedInputRef<boolean>
			"flip_input": ComfyNodeTypedInputRef<boolean>
			"blur_radius": ComfyNodeTypedInputRef<number>
			"lerp_alpha": ComfyNodeTypedInputRef<number>
			"decay_factor": ComfyNodeTypedInputRef<number>
			"fill_holes"?: ComfyNodeTypedInputRef<boolean>
}


export class MaskBatchMulti extends ComfyNode {
	classType: string = "MaskBatchMulti"

	sockets: {
		inputs: Required<MaskBatchMultiInputs>
		outputs: {
			masks: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"inputcount": new ComfyNodeTypedInputRef<number>(this, "inputcount"),
				"mask_1": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask_1"),
				"mask_2": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask_2"),
			},
			outputs: Object.create(Object.prototype, {
				"masks": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<MaskBatchMultiInputs>) {
		if (typeof sources["inputcount"] === "object") {
			this.sockets.inputs["inputcount"].connectTo(sources["inputcount"])
		} else {
			this.sockets.inputs["inputcount"].value = sources["inputcount"]
		}

		if (typeof sources["mask_1"] === "object") {
			this.sockets.inputs["mask_1"].connectTo(sources["mask_1"])
		} else {
			this.sockets.inputs["mask_1"].value = sources["mask_1"]
		}

		if (typeof sources["mask_2"] === "object") {
			this.sockets.inputs["mask_2"].connectTo(sources["mask_2"])
		} else {
			this.sockets.inputs["mask_2"].value = sources["mask_2"]
		}

	}
}

type MaskBatchMultiInputs = {
			"inputcount": ComfyNodeTypedInputRef<number>
			"mask_1": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"mask_2": ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class OffsetMask extends ComfyNode {
	classType: string = "OffsetMask"

	sockets: {
		inputs: Required<OffsetMaskInputs>
		outputs: {
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"x": new ComfyNodeTypedInputRef<number>(this, "x"),
				"y": new ComfyNodeTypedInputRef<number>(this, "y"),
				"angle": new ComfyNodeTypedInputRef<number>(this, "angle"),
				"duplication_factor": new ComfyNodeTypedInputRef<number>(this, "duplication_factor"),
				"roll": new ComfyNodeTypedInputRef<boolean>(this, "roll"),
				"incremental": new ComfyNodeTypedInputRef<boolean>(this, "incremental"),
				"padding_mode": new ComfyNodeTypedInputRef<string>(this, "padding_mode"),
			},
			outputs: Object.create(Object.prototype, {
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<OffsetMaskInputs>) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["x"] === "object") {
			this.sockets.inputs["x"].connectTo(sources["x"])
		} else {
			this.sockets.inputs["x"].value = sources["x"]
		}

		if (typeof sources["y"] === "object") {
			this.sockets.inputs["y"].connectTo(sources["y"])
		} else {
			this.sockets.inputs["y"].value = sources["y"]
		}

		if (typeof sources["angle"] === "object") {
			this.sockets.inputs["angle"].connectTo(sources["angle"])
		} else {
			this.sockets.inputs["angle"].value = sources["angle"]
		}

		if (typeof sources["duplication_factor"] === "object") {
			this.sockets.inputs["duplication_factor"].connectTo(sources["duplication_factor"])
		} else {
			this.sockets.inputs["duplication_factor"].value = sources["duplication_factor"]
		}

		if (typeof sources["roll"] === "object") {
			this.sockets.inputs["roll"].connectTo(sources["roll"])
		} else {
			this.sockets.inputs["roll"].value = sources["roll"]
		}

		if (typeof sources["incremental"] === "object") {
			this.sockets.inputs["incremental"].connectTo(sources["incremental"])
		} else {
			this.sockets.inputs["incremental"].value = sources["incremental"]
		}

		if (typeof sources["padding_mode"] === "object") {
			this.sockets.inputs["padding_mode"].connectTo(sources["padding_mode"])
		} else {
			this.sockets.inputs["padding_mode"].value = sources["padding_mode"]
		}

	}
}

type OffsetMaskInputs = {
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"x": ComfyNodeTypedInputRef<number>
			"y": ComfyNodeTypedInputRef<number>
			"angle": ComfyNodeTypedInputRef<number>
			"duplication_factor": ComfyNodeTypedInputRef<number>
			"roll": ComfyNodeTypedInputRef<boolean>
			"incremental": ComfyNodeTypedInputRef<boolean>
			"padding_mode": ComfyNodeTypedInputRef<string>
}


export class RemapMaskRange extends ComfyNode {
	classType: string = "RemapMaskRange"

	sockets: {
		inputs: Required<RemapMaskRangeInputs>
		outputs: {
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"min": new ComfyNodeTypedInputRef<number>(this, "min"),
				"max": new ComfyNodeTypedInputRef<number>(this, "max"),
			},
			outputs: Object.create(Object.prototype, {
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<RemapMaskRangeInputs>) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["min"] === "object") {
			this.sockets.inputs["min"].connectTo(sources["min"])
		} else {
			this.sockets.inputs["min"].value = sources["min"]
		}

		if (typeof sources["max"] === "object") {
			this.sockets.inputs["max"].connectTo(sources["max"])
		} else {
			this.sockets.inputs["max"].value = sources["max"]
		}

	}
}

type RemapMaskRangeInputs = {
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"min": ComfyNodeTypedInputRef<number>
			"max": ComfyNodeTypedInputRef<number>
}


export class ResizeMask extends ComfyNode {
	classType: string = "ResizeMask"

	sockets: {
		inputs: Required<ResizeMaskInputs>
		outputs: {
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			width: ComfyNodeTypedSourceRef<number>
			height: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"keep_proportions": new ComfyNodeTypedInputRef<boolean>(this, "keep_proportions"),
				"upscale_method": new ComfyNodeTypedInputRef<string>(this, "upscale_method"),
				"crop": new ComfyNodeTypedInputRef<string>(this, "crop"),
			},
			outputs: Object.create(Object.prototype, {
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ResizeMaskInputs>) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["keep_proportions"] === "object") {
			this.sockets.inputs["keep_proportions"].connectTo(sources["keep_proportions"])
		} else {
			this.sockets.inputs["keep_proportions"].value = sources["keep_proportions"]
		}

		if (typeof sources["upscale_method"] === "object") {
			this.sockets.inputs["upscale_method"].connectTo(sources["upscale_method"])
		} else {
			this.sockets.inputs["upscale_method"].value = sources["upscale_method"]
		}

		if (typeof sources["crop"] === "object") {
			this.sockets.inputs["crop"].connectTo(sources["crop"])
		} else {
			this.sockets.inputs["crop"].value = sources["crop"]
		}

	}
}

type ResizeMaskInputs = {
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"keep_proportions": ComfyNodeTypedInputRef<boolean>
			"upscale_method": ComfyNodeTypedInputRef<string>
			"crop": ComfyNodeTypedInputRef<string>
}


export class RoundMask extends ComfyNode {
	classType: string = "RoundMask"

	sockets: {
		inputs: Required<RoundMaskInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<RoundMaskInputs>) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

	}
}

type RoundMaskInputs = {
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class SeparateMasks extends ComfyNode {
	classType: string = "SeparateMasks"

	sockets: {
		inputs: Required<SeparateMasksInputs>
		outputs: {
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"size_threshold_width": new ComfyNodeTypedInputRef<number>(this, "size_threshold_width"),
				"size_threshold_height": new ComfyNodeTypedInputRef<number>(this, "size_threshold_height"),
				"mode": new ComfyNodeTypedInputRef<string>(this, "mode"),
				"max_poly_points": new ComfyNodeTypedInputRef<number>(this, "max_poly_points"),
			},
			outputs: Object.create(Object.prototype, {
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SeparateMasksInputs>) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["size_threshold_width"] === "object") {
			this.sockets.inputs["size_threshold_width"].connectTo(sources["size_threshold_width"])
		} else {
			this.sockets.inputs["size_threshold_width"].value = sources["size_threshold_width"]
		}

		if (typeof sources["size_threshold_height"] === "object") {
			this.sockets.inputs["size_threshold_height"].connectTo(sources["size_threshold_height"])
		} else {
			this.sockets.inputs["size_threshold_height"].value = sources["size_threshold_height"]
		}

		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}

		if (typeof sources["max_poly_points"] === "object") {
			this.sockets.inputs["max_poly_points"].connectTo(sources["max_poly_points"])
		} else {
			this.sockets.inputs["max_poly_points"].value = sources["max_poly_points"]
		}

	}
}

type SeparateMasksInputs = {
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"size_threshold_width": ComfyNodeTypedInputRef<number>
			"size_threshold_height": ComfyNodeTypedInputRef<number>
			"mode": ComfyNodeTypedInputRef<string>
			"max_poly_points": ComfyNodeTypedInputRef<number>
}


export class ConsolidateMasksKJ extends ComfyNode {
	classType: string = "ConsolidateMasksKJ"

	sockets: {
		inputs: Required<ConsolidateMasksKJInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"masks": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "masks"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"padding": new ComfyNodeTypedInputRef<number>(this, "padding"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ConsolidateMasksKJInputs>) {
		if (typeof sources["masks"] === "object") {
			this.sockets.inputs["masks"].connectTo(sources["masks"])
		} else {
			this.sockets.inputs["masks"].value = sources["masks"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["padding"] === "object") {
			this.sockets.inputs["padding"].connectTo(sources["padding"])
		} else {
			this.sockets.inputs["padding"].value = sources["padding"]
		}

	}
}

type ConsolidateMasksKJInputs = {
			"masks": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"padding": ComfyNodeTypedInputRef<number>
}


export class AddLabel extends ComfyNode {
	classType: string = "AddLabel"

	sockets: {
		inputs: Required<AddLabelInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"text_x": new ComfyNodeTypedInputRef<number>(this, "text_x"),
				"text_y": new ComfyNodeTypedInputRef<number>(this, "text_y"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"font_size": new ComfyNodeTypedInputRef<number>(this, "font_size"),
				"font_color": new ComfyNodeTypedInputRef<string>(this, "font_color"),
				"label_color": new ComfyNodeTypedInputRef<string>(this, "label_color"),
				"font": new ComfyNodeTypedInputRef<string>(this, "font"),
				"text": new ComfyNodeTypedInputRef<string>(this, "text"),
				"direction": new ComfyNodeTypedInputRef<string>(this, "direction"),
				"caption": new ComfyNodeTypedInputRef<string>(this, "caption"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<AddLabelInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["text_x"] === "object") {
			this.sockets.inputs["text_x"].connectTo(sources["text_x"])
		} else {
			this.sockets.inputs["text_x"].value = sources["text_x"]
		}

		if (typeof sources["text_y"] === "object") {
			this.sockets.inputs["text_y"].connectTo(sources["text_y"])
		} else {
			this.sockets.inputs["text_y"].value = sources["text_y"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["font_size"] === "object") {
			this.sockets.inputs["font_size"].connectTo(sources["font_size"])
		} else {
			this.sockets.inputs["font_size"].value = sources["font_size"]
		}

		if (typeof sources["font_color"] === "object") {
			this.sockets.inputs["font_color"].connectTo(sources["font_color"])
		} else {
			this.sockets.inputs["font_color"].value = sources["font_color"]
		}

		if (typeof sources["label_color"] === "object") {
			this.sockets.inputs["label_color"].connectTo(sources["label_color"])
		} else {
			this.sockets.inputs["label_color"].value = sources["label_color"]
		}

		if (typeof sources["font"] === "object") {
			this.sockets.inputs["font"].connectTo(sources["font"])
		} else {
			this.sockets.inputs["font"].value = sources["font"]
		}

		if (typeof sources["text"] === "object") {
			this.sockets.inputs["text"].connectTo(sources["text"])
		} else {
			this.sockets.inputs["text"].value = sources["text"]
		}

		if (typeof sources["direction"] === "object") {
			this.sockets.inputs["direction"].connectTo(sources["direction"])
		} else {
			this.sockets.inputs["direction"].value = sources["direction"]
		}

		if (sources["caption"] !== undefined) {
		if (typeof sources["caption"] === "object") {
			this.sockets.inputs["caption"].connectTo(sources["caption"])
		} else {
			this.sockets.inputs["caption"].value = sources["caption"]
		}
		}

	}
}

type AddLabelInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"text_x": ComfyNodeTypedInputRef<number>
			"text_y": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"font_size": ComfyNodeTypedInputRef<number>
			"font_color": ComfyNodeTypedInputRef<string>
			"label_color": ComfyNodeTypedInputRef<string>
			"font": ComfyNodeTypedInputRef<string>
			"text": ComfyNodeTypedInputRef<string>
			"direction": ComfyNodeTypedInputRef<string>
			"caption"?: ComfyNodeTypedInputRef<string>
}


export class ColorMatch extends ComfyNode {
	classType: string = "ColorMatch"

	sockets: {
		inputs: Required<ColorMatchInputs>
		outputs: {
			image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image_ref": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image_ref"),
				"image_target": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image_target"),
				"method": new ComfyNodeTypedInputRef<string>(this, "method"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"multithread": new ComfyNodeTypedInputRef<boolean>(this, "multithread"),
			},
			outputs: Object.create(Object.prototype, {
				"image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ColorMatchInputs>) {
		if (typeof sources["image_ref"] === "object") {
			this.sockets.inputs["image_ref"].connectTo(sources["image_ref"])
		} else {
			this.sockets.inputs["image_ref"].value = sources["image_ref"]
		}

		if (typeof sources["image_target"] === "object") {
			this.sockets.inputs["image_target"].connectTo(sources["image_target"])
		} else {
			this.sockets.inputs["image_target"].value = sources["image_target"]
		}

		if (typeof sources["method"] === "object") {
			this.sockets.inputs["method"].connectTo(sources["method"])
		} else {
			this.sockets.inputs["method"].value = sources["method"]
		}

		if (sources["strength"] !== undefined) {
		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}
		}

		if (sources["multithread"] !== undefined) {
		if (typeof sources["multithread"] === "object") {
			this.sockets.inputs["multithread"].connectTo(sources["multithread"])
		} else {
			this.sockets.inputs["multithread"].value = sources["multithread"]
		}
		}

	}
}

type ColorMatchInputs = {
			"image_ref": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"image_target": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"method": ComfyNodeTypedInputRef<string>
			"strength"?: ComfyNodeTypedInputRef<number>
			"multithread"?: ComfyNodeTypedInputRef<boolean>
}


export class ImageTensorList extends ComfyNode {
	classType: string = "ImageTensorList"

	sockets: {
		inputs: Required<ImageTensorListInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image1": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image1"),
				"image2": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image2"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageTensorListInputs>) {
		if (typeof sources["image1"] === "object") {
			this.sockets.inputs["image1"].connectTo(sources["image1"])
		} else {
			this.sockets.inputs["image1"].value = sources["image1"]
		}

		if (typeof sources["image2"] === "object") {
			this.sockets.inputs["image2"].connectTo(sources["image2"])
		} else {
			this.sockets.inputs["image2"].value = sources["image2"]
		}

	}
}

type ImageTensorListInputs = {
			"image1": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"image2": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class CrossFadeImages extends ComfyNode {
	classType: string = "CrossFadeImages"

	sockets: {
		inputs: Required<CrossFadeImagesInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images_1": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images_1"),
				"images_2": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images_2"),
				"interpolation": new ComfyNodeTypedInputRef<string>(this, "interpolation"),
				"transition_start_index": new ComfyNodeTypedInputRef<number>(this, "transition_start_index"),
				"transitioning_frames": new ComfyNodeTypedInputRef<number>(this, "transitioning_frames"),
				"start_level": new ComfyNodeTypedInputRef<number>(this, "start_level"),
				"end_level": new ComfyNodeTypedInputRef<number>(this, "end_level"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CrossFadeImagesInputs>) {
		if (typeof sources["images_1"] === "object") {
			this.sockets.inputs["images_1"].connectTo(sources["images_1"])
		} else {
			this.sockets.inputs["images_1"].value = sources["images_1"]
		}

		if (typeof sources["images_2"] === "object") {
			this.sockets.inputs["images_2"].connectTo(sources["images_2"])
		} else {
			this.sockets.inputs["images_2"].value = sources["images_2"]
		}

		if (typeof sources["interpolation"] === "object") {
			this.sockets.inputs["interpolation"].connectTo(sources["interpolation"])
		} else {
			this.sockets.inputs["interpolation"].value = sources["interpolation"]
		}

		if (typeof sources["transition_start_index"] === "object") {
			this.sockets.inputs["transition_start_index"].connectTo(sources["transition_start_index"])
		} else {
			this.sockets.inputs["transition_start_index"].value = sources["transition_start_index"]
		}

		if (typeof sources["transitioning_frames"] === "object") {
			this.sockets.inputs["transitioning_frames"].connectTo(sources["transitioning_frames"])
		} else {
			this.sockets.inputs["transitioning_frames"].value = sources["transitioning_frames"]
		}

		if (typeof sources["start_level"] === "object") {
			this.sockets.inputs["start_level"].connectTo(sources["start_level"])
		} else {
			this.sockets.inputs["start_level"].value = sources["start_level"]
		}

		if (typeof sources["end_level"] === "object") {
			this.sockets.inputs["end_level"].connectTo(sources["end_level"])
		} else {
			this.sockets.inputs["end_level"].value = sources["end_level"]
		}

	}
}

type CrossFadeImagesInputs = {
			"images_1": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"images_2": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"interpolation": ComfyNodeTypedInputRef<string>
			"transition_start_index": ComfyNodeTypedInputRef<number>
			"transitioning_frames": ComfyNodeTypedInputRef<number>
			"start_level": ComfyNodeTypedInputRef<number>
			"end_level": ComfyNodeTypedInputRef<number>
}


export class CrossFadeImagesMulti extends ComfyNode {
	classType: string = "CrossFadeImagesMulti"

	sockets: {
		inputs: Required<CrossFadeImagesMultiInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"inputcount": new ComfyNodeTypedInputRef<number>(this, "inputcount"),
				"image_1": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image_1"),
				"interpolation": new ComfyNodeTypedInputRef<string>(this, "interpolation"),
				"transitioning_frames": new ComfyNodeTypedInputRef<number>(this, "transitioning_frames"),
				"image_2": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image_2"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CrossFadeImagesMultiInputs>) {
		if (typeof sources["inputcount"] === "object") {
			this.sockets.inputs["inputcount"].connectTo(sources["inputcount"])
		} else {
			this.sockets.inputs["inputcount"].value = sources["inputcount"]
		}

		if (typeof sources["image_1"] === "object") {
			this.sockets.inputs["image_1"].connectTo(sources["image_1"])
		} else {
			this.sockets.inputs["image_1"].value = sources["image_1"]
		}

		if (typeof sources["interpolation"] === "object") {
			this.sockets.inputs["interpolation"].connectTo(sources["interpolation"])
		} else {
			this.sockets.inputs["interpolation"].value = sources["interpolation"]
		}

		if (typeof sources["transitioning_frames"] === "object") {
			this.sockets.inputs["transitioning_frames"].connectTo(sources["transitioning_frames"])
		} else {
			this.sockets.inputs["transitioning_frames"].value = sources["transitioning_frames"]
		}

		if (sources["image_2"] !== undefined) {
		if (typeof sources["image_2"] === "object") {
			this.sockets.inputs["image_2"].connectTo(sources["image_2"])
		} else {
			this.sockets.inputs["image_2"].value = sources["image_2"]
		}
		}

	}
}

type CrossFadeImagesMultiInputs = {
			"inputcount": ComfyNodeTypedInputRef<number>
			"image_1": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"interpolation": ComfyNodeTypedInputRef<string>
			"transitioning_frames": ComfyNodeTypedInputRef<number>
			"image_2"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class GetImagesFromBatchIndexed extends ComfyNode {
	classType: string = "GetImagesFromBatchIndexed"

	sockets: {
		inputs: Required<GetImagesFromBatchIndexedInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"indexes": new ComfyNodeTypedInputRef<string>(this, "indexes"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<GetImagesFromBatchIndexedInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["indexes"] === "object") {
			this.sockets.inputs["indexes"].connectTo(sources["indexes"])
		} else {
			this.sockets.inputs["indexes"].value = sources["indexes"]
		}

	}
}

type GetImagesFromBatchIndexedInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"indexes": ComfyNodeTypedInputRef<string>
}


export class GetImageRangeFromBatch extends ComfyNode {
	classType: string = "GetImageRangeFromBatch"

	sockets: {
		inputs: Required<GetImageRangeFromBatchInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"start_index": new ComfyNodeTypedInputRef<number>(this, "start_index"),
				"num_frames": new ComfyNodeTypedInputRef<number>(this, "num_frames"),
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"masks": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "masks"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<GetImageRangeFromBatchInputs>) {
		if (typeof sources["start_index"] === "object") {
			this.sockets.inputs["start_index"].connectTo(sources["start_index"])
		} else {
			this.sockets.inputs["start_index"].value = sources["start_index"]
		}

		if (typeof sources["num_frames"] === "object") {
			this.sockets.inputs["num_frames"].connectTo(sources["num_frames"])
		} else {
			this.sockets.inputs["num_frames"].value = sources["num_frames"]
		}

		if (sources["images"] !== undefined) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}
		}

		if (sources["masks"] !== undefined) {
		if (typeof sources["masks"] === "object") {
			this.sockets.inputs["masks"].connectTo(sources["masks"])
		} else {
			this.sockets.inputs["masks"].value = sources["masks"]
		}
		}

	}
}

type GetImageRangeFromBatchInputs = {
			"start_index": ComfyNodeTypedInputRef<number>
			"num_frames": ComfyNodeTypedInputRef<number>
			"images"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"masks"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class GetLatentRangeFromBatch extends ComfyNode {
	classType: string = "GetLatentRangeFromBatch"

	sockets: {
		inputs: Required<GetLatentRangeFromBatchInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latents"),
				"start_index": new ComfyNodeTypedInputRef<number>(this, "start_index"),
				"num_frames": new ComfyNodeTypedInputRef<number>(this, "num_frames"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<GetLatentRangeFromBatchInputs>) {
		if (typeof sources["latents"] === "object") {
			this.sockets.inputs["latents"].connectTo(sources["latents"])
		} else {
			this.sockets.inputs["latents"].value = sources["latents"]
		}

		if (typeof sources["start_index"] === "object") {
			this.sockets.inputs["start_index"].connectTo(sources["start_index"])
		} else {
			this.sockets.inputs["start_index"].value = sources["start_index"]
		}

		if (typeof sources["num_frames"] === "object") {
			this.sockets.inputs["num_frames"].connectTo(sources["num_frames"])
		} else {
			this.sockets.inputs["num_frames"].value = sources["num_frames"]
		}

	}
}

type GetLatentRangeFromBatchInputs = {
			"latents": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"start_index": ComfyNodeTypedInputRef<number>
			"num_frames": ComfyNodeTypedInputRef<number>
}


export class GetLatentSizeAndCount extends ComfyNode {
	classType: string = "GetLatentSizeAndCount"

	sockets: {
		inputs: Required<GetLatentSizeAndCountInputs>
		outputs: {
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
			batch_size: ComfyNodeTypedSourceRef<number>
			channels: ComfyNodeTypedSourceRef<number>
			frames: ComfyNodeTypedSourceRef<number>
			width: ComfyNodeTypedSourceRef<number>
			height: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latent"),
			},
			outputs: Object.create(Object.prototype, {
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"batch_size": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"channels": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"frames": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
				"width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 4 }
					}
				},
				"height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 5 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<GetLatentSizeAndCountInputs>) {
		if (typeof sources["latent"] === "object") {
			this.sockets.inputs["latent"].connectTo(sources["latent"])
		} else {
			this.sockets.inputs["latent"].value = sources["latent"]
		}

	}
}

type GetLatentSizeAndCountInputs = {
			"latent": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class GetImageSizeAndCount extends ComfyNode {
	classType: string = "GetImageSizeAndCount"

	sockets: {
		inputs: Required<GetImageSizeAndCountInputs>
		outputs: {
			image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			width: ComfyNodeTypedSourceRef<number>
			height: ComfyNodeTypedSourceRef<number>
			count: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
			},
			outputs: Object.create(Object.prototype, {
				"image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<GetImageSizeAndCountInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

	}
}

type GetImageSizeAndCountInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class FastPreview extends ComfyNode {
	classType: string = "FastPreview"

	sockets: {
		inputs: Required<FastPreviewInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"format": new ComfyNodeTypedInputRef<string>(this, "format"),
				"quality": new ComfyNodeTypedInputRef<number>(this, "quality"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<FastPreviewInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["format"] === "object") {
			this.sockets.inputs["format"].connectTo(sources["format"])
		} else {
			this.sockets.inputs["format"].value = sources["format"]
		}

		if (typeof sources["quality"] === "object") {
			this.sockets.inputs["quality"].connectTo(sources["quality"])
		} else {
			this.sockets.inputs["quality"].value = sources["quality"]
		}

	}
}

type FastPreviewInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"format": ComfyNodeTypedInputRef<string>
			"quality": ComfyNodeTypedInputRef<number>
}


export class ImageBatchFilter extends ComfyNode {
	classType: string = "ImageBatchFilter"

	sockets: {
		inputs: Required<ImageBatchFilterInputs>
		outputs: {
			images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			removed_indices: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"empty_color": new ComfyNodeTypedInputRef<string>(this, "empty_color"),
				"empty_threshold": new ComfyNodeTypedInputRef<number>(this, "empty_threshold"),
				"replacement_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "replacement_image"),
			},
			outputs: Object.create(Object.prototype, {
				"images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"removed_indices": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageBatchFilterInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["empty_color"] === "object") {
			this.sockets.inputs["empty_color"].connectTo(sources["empty_color"])
		} else {
			this.sockets.inputs["empty_color"].value = sources["empty_color"]
		}

		if (typeof sources["empty_threshold"] === "object") {
			this.sockets.inputs["empty_threshold"].connectTo(sources["empty_threshold"])
		} else {
			this.sockets.inputs["empty_threshold"].value = sources["empty_threshold"]
		}

		if (sources["replacement_image"] !== undefined) {
		if (typeof sources["replacement_image"] === "object") {
			this.sockets.inputs["replacement_image"].connectTo(sources["replacement_image"])
		} else {
			this.sockets.inputs["replacement_image"].value = sources["replacement_image"]
		}
		}

	}
}

type ImageBatchFilterInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"empty_color": ComfyNodeTypedInputRef<string>
			"empty_threshold": ComfyNodeTypedInputRef<number>
			"replacement_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class ImageAndMaskPreview extends ComfyNode {
	classType: string = "ImageAndMaskPreview"

	sockets: {
		inputs: Required<ImageAndMaskPreviewInputs>
		outputs: {
			composite: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask_opacity": new ComfyNodeTypedInputRef<number>(this, "mask_opacity"),
				"mask_color": new ComfyNodeTypedInputRef<string>(this, "mask_color"),
				"pass_through": new ComfyNodeTypedInputRef<boolean>(this, "pass_through"),
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_E>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
				"composite": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageAndMaskPreviewInputs>) {
		if (typeof sources["mask_opacity"] === "object") {
			this.sockets.inputs["mask_opacity"].connectTo(sources["mask_opacity"])
		} else {
			this.sockets.inputs["mask_opacity"].value = sources["mask_opacity"]
		}

		if (typeof sources["mask_color"] === "object") {
			this.sockets.inputs["mask_color"].connectTo(sources["mask_color"])
		} else {
			this.sockets.inputs["mask_color"].value = sources["mask_color"]
		}

		if (typeof sources["pass_through"] === "object") {
			this.sockets.inputs["pass_through"].connectTo(sources["pass_through"])
		} else {
			this.sockets.inputs["pass_through"].value = sources["pass_through"]
		}

		if (sources["image"] !== undefined) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}
		}

		if (sources["mask"] !== undefined) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type ImageAndMaskPreviewInputs = {
			"mask_opacity": ComfyNodeTypedInputRef<number>
			"mask_color": ComfyNodeTypedInputRef<string>
			"pass_through": ComfyNodeTypedInputRef<boolean>
			"image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_E>
}


export class ImageAddMulti extends ComfyNode {
	classType: string = "ImageAddMulti"

	sockets: {
		inputs: Required<ImageAddMultiInputs>
		outputs: {
			images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"inputcount": new ComfyNodeTypedInputRef<number>(this, "inputcount"),
				"image_1": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image_1"),
				"image_2": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image_2"),
				"blending": new ComfyNodeTypedInputRef<string>(this, "blending"),
				"blend_amount": new ComfyNodeTypedInputRef<number>(this, "blend_amount"),
			},
			outputs: Object.create(Object.prototype, {
				"images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageAddMultiInputs>) {
		if (typeof sources["inputcount"] === "object") {
			this.sockets.inputs["inputcount"].connectTo(sources["inputcount"])
		} else {
			this.sockets.inputs["inputcount"].value = sources["inputcount"]
		}

		if (typeof sources["image_1"] === "object") {
			this.sockets.inputs["image_1"].connectTo(sources["image_1"])
		} else {
			this.sockets.inputs["image_1"].value = sources["image_1"]
		}

		if (typeof sources["image_2"] === "object") {
			this.sockets.inputs["image_2"].connectTo(sources["image_2"])
		} else {
			this.sockets.inputs["image_2"].value = sources["image_2"]
		}

		if (typeof sources["blending"] === "object") {
			this.sockets.inputs["blending"].connectTo(sources["blending"])
		} else {
			this.sockets.inputs["blending"].value = sources["blending"]
		}

		if (typeof sources["blend_amount"] === "object") {
			this.sockets.inputs["blend_amount"].connectTo(sources["blend_amount"])
		} else {
			this.sockets.inputs["blend_amount"].value = sources["blend_amount"]
		}

	}
}

type ImageAddMultiInputs = {
			"inputcount": ComfyNodeTypedInputRef<number>
			"image_1": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"image_2": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"blending": ComfyNodeTypedInputRef<string>
			"blend_amount": ComfyNodeTypedInputRef<number>
}


export class ImageBatchJoinWithTransition extends ComfyNode {
	classType: string = "ImageBatchJoinWithTransition"

	sockets: {
		inputs: Required<ImageBatchJoinWithTransitionInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images_1": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images_1"),
				"images_2": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images_2"),
				"start_index": new ComfyNodeTypedInputRef<number>(this, "start_index"),
				"interpolation": new ComfyNodeTypedInputRef<string>(this, "interpolation"),
				"transition_type": new ComfyNodeTypedInputRef<string>(this, "transition_type"),
				"transitioning_frames": new ComfyNodeTypedInputRef<number>(this, "transitioning_frames"),
				"blur_radius": new ComfyNodeTypedInputRef<number>(this, "blur_radius"),
				"reverse": new ComfyNodeTypedInputRef<boolean>(this, "reverse"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageBatchJoinWithTransitionInputs>) {
		if (typeof sources["images_1"] === "object") {
			this.sockets.inputs["images_1"].connectTo(sources["images_1"])
		} else {
			this.sockets.inputs["images_1"].value = sources["images_1"]
		}

		if (typeof sources["images_2"] === "object") {
			this.sockets.inputs["images_2"].connectTo(sources["images_2"])
		} else {
			this.sockets.inputs["images_2"].value = sources["images_2"]
		}

		if (typeof sources["start_index"] === "object") {
			this.sockets.inputs["start_index"].connectTo(sources["start_index"])
		} else {
			this.sockets.inputs["start_index"].value = sources["start_index"]
		}

		if (typeof sources["interpolation"] === "object") {
			this.sockets.inputs["interpolation"].connectTo(sources["interpolation"])
		} else {
			this.sockets.inputs["interpolation"].value = sources["interpolation"]
		}

		if (typeof sources["transition_type"] === "object") {
			this.sockets.inputs["transition_type"].connectTo(sources["transition_type"])
		} else {
			this.sockets.inputs["transition_type"].value = sources["transition_type"]
		}

		if (typeof sources["transitioning_frames"] === "object") {
			this.sockets.inputs["transitioning_frames"].connectTo(sources["transitioning_frames"])
		} else {
			this.sockets.inputs["transitioning_frames"].value = sources["transitioning_frames"]
		}

		if (typeof sources["blur_radius"] === "object") {
			this.sockets.inputs["blur_radius"].connectTo(sources["blur_radius"])
		} else {
			this.sockets.inputs["blur_radius"].value = sources["blur_radius"]
		}

		if (typeof sources["reverse"] === "object") {
			this.sockets.inputs["reverse"].connectTo(sources["reverse"])
		} else {
			this.sockets.inputs["reverse"].value = sources["reverse"]
		}

		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}

	}
}

type ImageBatchJoinWithTransitionInputs = {
			"images_1": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"images_2": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"start_index": ComfyNodeTypedInputRef<number>
			"interpolation": ComfyNodeTypedInputRef<string>
			"transition_type": ComfyNodeTypedInputRef<string>
			"transitioning_frames": ComfyNodeTypedInputRef<number>
			"blur_radius": ComfyNodeTypedInputRef<number>
			"reverse": ComfyNodeTypedInputRef<boolean>
			"device": ComfyNodeTypedInputRef<string>
}


export class ImageBatchMulti extends ComfyNode {
	classType: string = "ImageBatchMulti"

	sockets: {
		inputs: Required<ImageBatchMultiInputs>
		outputs: {
			images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"inputcount": new ComfyNodeTypedInputRef<number>(this, "inputcount"),
				"image_1": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image_1"),
				"image_2": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image_2"),
			},
			outputs: Object.create(Object.prototype, {
				"images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageBatchMultiInputs>) {
		if (typeof sources["inputcount"] === "object") {
			this.sockets.inputs["inputcount"].connectTo(sources["inputcount"])
		} else {
			this.sockets.inputs["inputcount"].value = sources["inputcount"]
		}

		if (typeof sources["image_1"] === "object") {
			this.sockets.inputs["image_1"].connectTo(sources["image_1"])
		} else {
			this.sockets.inputs["image_1"].value = sources["image_1"]
		}

		if (sources["image_2"] !== undefined) {
		if (typeof sources["image_2"] === "object") {
			this.sockets.inputs["image_2"].connectTo(sources["image_2"])
		} else {
			this.sockets.inputs["image_2"].value = sources["image_2"]
		}
		}

	}
}

type ImageBatchMultiInputs = {
			"inputcount": ComfyNodeTypedInputRef<number>
			"image_1": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"image_2"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class ImageBatchRepeatInterleaving extends ComfyNode {
	classType: string = "ImageBatchRepeatInterleaving"

	sockets: {
		inputs: Required<ImageBatchRepeatInterleavingInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"repeats": new ComfyNodeTypedInputRef<number>(this, "repeats"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageBatchRepeatInterleavingInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["repeats"] === "object") {
			this.sockets.inputs["repeats"].connectTo(sources["repeats"])
		} else {
			this.sockets.inputs["repeats"].value = sources["repeats"]
		}

		if (sources["mask"] !== undefined) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}
		}

	}
}

type ImageBatchRepeatInterleavingInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"repeats": ComfyNodeTypedInputRef<number>
			"mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class ImageBatchTestPattern extends ComfyNode {
	classType: string = "ImageBatchTestPattern"

	sockets: {
		inputs: Required<ImageBatchTestPatternInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"start_from": new ComfyNodeTypedInputRef<number>(this, "start_from"),
				"text_x": new ComfyNodeTypedInputRef<number>(this, "text_x"),
				"text_y": new ComfyNodeTypedInputRef<number>(this, "text_y"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"font": new ComfyNodeTypedInputRef<string>(this, "font"),
				"font_size": new ComfyNodeTypedInputRef<number>(this, "font_size"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageBatchTestPatternInputs>) {
		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (typeof sources["start_from"] === "object") {
			this.sockets.inputs["start_from"].connectTo(sources["start_from"])
		} else {
			this.sockets.inputs["start_from"].value = sources["start_from"]
		}

		if (typeof sources["text_x"] === "object") {
			this.sockets.inputs["text_x"].connectTo(sources["text_x"])
		} else {
			this.sockets.inputs["text_x"].value = sources["text_x"]
		}

		if (typeof sources["text_y"] === "object") {
			this.sockets.inputs["text_y"].connectTo(sources["text_y"])
		} else {
			this.sockets.inputs["text_y"].value = sources["text_y"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["font"] === "object") {
			this.sockets.inputs["font"].connectTo(sources["font"])
		} else {
			this.sockets.inputs["font"].value = sources["font"]
		}

		if (typeof sources["font_size"] === "object") {
			this.sockets.inputs["font_size"].connectTo(sources["font_size"])
		} else {
			this.sockets.inputs["font_size"].value = sources["font_size"]
		}

	}
}

type ImageBatchTestPatternInputs = {
			"batch_size": ComfyNodeTypedInputRef<number>
			"start_from": ComfyNodeTypedInputRef<number>
			"text_x": ComfyNodeTypedInputRef<number>
			"text_y": ComfyNodeTypedInputRef<number>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"font": ComfyNodeTypedInputRef<string>
			"font_size": ComfyNodeTypedInputRef<number>
}


export class ImageConcanate extends ComfyNode {
	classType: string = "ImageConcanate"

	sockets: {
		inputs: Required<ImageConcanateInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image1": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image1"),
				"image2": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image2"),
				"direction": new ComfyNodeTypedInputRef<string>(this, "direction"),
				"match_image_size": new ComfyNodeTypedInputRef<boolean>(this, "match_image_size"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageConcanateInputs>) {
		if (typeof sources["image1"] === "object") {
			this.sockets.inputs["image1"].connectTo(sources["image1"])
		} else {
			this.sockets.inputs["image1"].value = sources["image1"]
		}

		if (typeof sources["image2"] === "object") {
			this.sockets.inputs["image2"].connectTo(sources["image2"])
		} else {
			this.sockets.inputs["image2"].value = sources["image2"]
		}

		if (typeof sources["direction"] === "object") {
			this.sockets.inputs["direction"].connectTo(sources["direction"])
		} else {
			this.sockets.inputs["direction"].value = sources["direction"]
		}

		if (typeof sources["match_image_size"] === "object") {
			this.sockets.inputs["match_image_size"].connectTo(sources["match_image_size"])
		} else {
			this.sockets.inputs["match_image_size"].value = sources["match_image_size"]
		}

	}
}

type ImageConcanateInputs = {
			"image1": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"image2": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"direction": ComfyNodeTypedInputRef<string>
			"match_image_size": ComfyNodeTypedInputRef<boolean>
}


export class ImageConcatFromBatch extends ComfyNode {
	classType: string = "ImageConcatFromBatch"

	sockets: {
		inputs: Required<ImageConcatFromBatchInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"num_columns": new ComfyNodeTypedInputRef<number>(this, "num_columns"),
				"match_image_size": new ComfyNodeTypedInputRef<boolean>(this, "match_image_size"),
				"max_resolution": new ComfyNodeTypedInputRef<number>(this, "max_resolution"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageConcatFromBatchInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["num_columns"] === "object") {
			this.sockets.inputs["num_columns"].connectTo(sources["num_columns"])
		} else {
			this.sockets.inputs["num_columns"].value = sources["num_columns"]
		}

		if (typeof sources["match_image_size"] === "object") {
			this.sockets.inputs["match_image_size"].connectTo(sources["match_image_size"])
		} else {
			this.sockets.inputs["match_image_size"].value = sources["match_image_size"]
		}

		if (typeof sources["max_resolution"] === "object") {
			this.sockets.inputs["max_resolution"].connectTo(sources["max_resolution"])
		} else {
			this.sockets.inputs["max_resolution"].value = sources["max_resolution"]
		}

	}
}

type ImageConcatFromBatchInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"num_columns": ComfyNodeTypedInputRef<number>
			"match_image_size": ComfyNodeTypedInputRef<boolean>
			"max_resolution": ComfyNodeTypedInputRef<number>
}


export class ImageConcatMulti extends ComfyNode {
	classType: string = "ImageConcatMulti"

	sockets: {
		inputs: Required<ImageConcatMultiInputs>
		outputs: {
			images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"inputcount": new ComfyNodeTypedInputRef<number>(this, "inputcount"),
				"image_1": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image_1"),
				"direction": new ComfyNodeTypedInputRef<string>(this, "direction"),
				"match_image_size": new ComfyNodeTypedInputRef<boolean>(this, "match_image_size"),
				"image_2": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image_2"),
			},
			outputs: Object.create(Object.prototype, {
				"images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageConcatMultiInputs>) {
		if (typeof sources["inputcount"] === "object") {
			this.sockets.inputs["inputcount"].connectTo(sources["inputcount"])
		} else {
			this.sockets.inputs["inputcount"].value = sources["inputcount"]
		}

		if (typeof sources["image_1"] === "object") {
			this.sockets.inputs["image_1"].connectTo(sources["image_1"])
		} else {
			this.sockets.inputs["image_1"].value = sources["image_1"]
		}

		if (typeof sources["direction"] === "object") {
			this.sockets.inputs["direction"].connectTo(sources["direction"])
		} else {
			this.sockets.inputs["direction"].value = sources["direction"]
		}

		if (typeof sources["match_image_size"] === "object") {
			this.sockets.inputs["match_image_size"].connectTo(sources["match_image_size"])
		} else {
			this.sockets.inputs["match_image_size"].value = sources["match_image_size"]
		}

		if (sources["image_2"] !== undefined) {
		if (typeof sources["image_2"] === "object") {
			this.sockets.inputs["image_2"].connectTo(sources["image_2"])
		} else {
			this.sockets.inputs["image_2"].value = sources["image_2"]
		}
		}

	}
}

type ImageConcatMultiInputs = {
			"inputcount": ComfyNodeTypedInputRef<number>
			"image_1": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"direction": ComfyNodeTypedInputRef<string>
			"match_image_size": ComfyNodeTypedInputRef<boolean>
			"image_2"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class ImageCropByMask extends ComfyNode {
	classType: string = "ImageCropByMask"

	sockets: {
		inputs: Required<ImageCropByMaskInputs>
		outputs: {
			image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
			},
			outputs: Object.create(Object.prototype, {
				"image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageCropByMaskInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

	}
}

type ImageCropByMaskInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class ImageCropByMaskAndResize extends ComfyNode {
	classType: string = "ImageCropByMaskAndResize"

	sockets: {
		inputs: Required<ImageCropByMaskAndResizeInputs>
		outputs: {
			images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			masks: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			bbox: ComfyNodeTypedSourceRef<ComfyValueType_BBOX>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"base_resolution": new ComfyNodeTypedInputRef<number>(this, "base_resolution"),
				"padding": new ComfyNodeTypedInputRef<number>(this, "padding"),
				"min_crop_resolution": new ComfyNodeTypedInputRef<number>(this, "min_crop_resolution"),
				"max_crop_resolution": new ComfyNodeTypedInputRef<number>(this, "max_crop_resolution"),
			},
			outputs: Object.create(Object.prototype, {
				"images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"masks": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"bbox": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageCropByMaskAndResizeInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["base_resolution"] === "object") {
			this.sockets.inputs["base_resolution"].connectTo(sources["base_resolution"])
		} else {
			this.sockets.inputs["base_resolution"].value = sources["base_resolution"]
		}

		if (typeof sources["padding"] === "object") {
			this.sockets.inputs["padding"].connectTo(sources["padding"])
		} else {
			this.sockets.inputs["padding"].value = sources["padding"]
		}

		if (typeof sources["min_crop_resolution"] === "object") {
			this.sockets.inputs["min_crop_resolution"].connectTo(sources["min_crop_resolution"])
		} else {
			this.sockets.inputs["min_crop_resolution"].value = sources["min_crop_resolution"]
		}

		if (typeof sources["max_crop_resolution"] === "object") {
			this.sockets.inputs["max_crop_resolution"].connectTo(sources["max_crop_resolution"])
		} else {
			this.sockets.inputs["max_crop_resolution"].value = sources["max_crop_resolution"]
		}

	}
}

type ImageCropByMaskAndResizeInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"base_resolution": ComfyNodeTypedInputRef<number>
			"padding": ComfyNodeTypedInputRef<number>
			"min_crop_resolution": ComfyNodeTypedInputRef<number>
			"max_crop_resolution": ComfyNodeTypedInputRef<number>
}


export class ImageCropByMaskBatch extends ComfyNode {
	classType: string = "ImageCropByMaskBatch"

	sockets: {
		inputs: Required<ImageCropByMaskBatchInputs>
		outputs: {
			images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			masks: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"masks": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "masks"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"padding": new ComfyNodeTypedInputRef<number>(this, "padding"),
				"preserve_size": new ComfyNodeTypedInputRef<boolean>(this, "preserve_size"),
				"bg_color": new ComfyNodeTypedInputRef<string>(this, "bg_color"),
			},
			outputs: Object.create(Object.prototype, {
				"images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"masks": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageCropByMaskBatchInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["masks"] === "object") {
			this.sockets.inputs["masks"].connectTo(sources["masks"])
		} else {
			this.sockets.inputs["masks"].value = sources["masks"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["padding"] === "object") {
			this.sockets.inputs["padding"].connectTo(sources["padding"])
		} else {
			this.sockets.inputs["padding"].value = sources["padding"]
		}

		if (typeof sources["preserve_size"] === "object") {
			this.sockets.inputs["preserve_size"].connectTo(sources["preserve_size"])
		} else {
			this.sockets.inputs["preserve_size"].value = sources["preserve_size"]
		}

		if (typeof sources["bg_color"] === "object") {
			this.sockets.inputs["bg_color"].connectTo(sources["bg_color"])
		} else {
			this.sockets.inputs["bg_color"].value = sources["bg_color"]
		}

	}
}

type ImageCropByMaskBatchInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"masks": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"padding": ComfyNodeTypedInputRef<number>
			"preserve_size": ComfyNodeTypedInputRef<boolean>
			/** Color as RGB values in range 0-255, separated by commas.*/
			"bg_color": ComfyNodeTypedInputRef<string>
}


export class ImageUncropByMask extends ComfyNode {
	classType: string = "ImageUncropByMask"

	sockets: {
		inputs: Required<ImageUncropByMaskInputs>
		outputs: {
			image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"destination": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "destination"),
				"source": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "source"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"bbox": new ComfyNodeTypedInputRef<ComfyValueType_BBOX>(this, "bbox"),
			},
			outputs: Object.create(Object.prototype, {
				"image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageUncropByMaskInputs>) {
		if (typeof sources["destination"] === "object") {
			this.sockets.inputs["destination"].connectTo(sources["destination"])
		} else {
			this.sockets.inputs["destination"].value = sources["destination"]
		}

		if (typeof sources["source"] === "object") {
			this.sockets.inputs["source"].connectTo(sources["source"])
		} else {
			this.sockets.inputs["source"].value = sources["source"]
		}

		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["bbox"] === "object") {
			this.sockets.inputs["bbox"].connectTo(sources["bbox"])
		} else {
			this.sockets.inputs["bbox"].value = sources["bbox"]
		}

	}
}

type ImageUncropByMaskInputs = {
			"destination": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"source": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"bbox": ComfyNodeTypedInputRef<ComfyValueType_BBOX>
}


export class ImageBatchExtendWithOverlap extends ComfyNode {
	classType: string = "ImageBatchExtendWithOverlap"

	sockets: {
		inputs: Required<ImageBatchExtendWithOverlapInputs>
		outputs: {
			/** The original source images (passthrough)*/
			source_images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			/** The input images used as the starting point for extension*/
			start_images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			/** The extended images with overlap, if no new images are provided this will be empty*/
			extended_images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"source_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "source_images"),
				"overlap": new ComfyNodeTypedInputRef<number>(this, "overlap"),
				"overlap_side": new ComfyNodeTypedInputRef<string>(this, "overlap_side"),
				"overlap_mode": new ComfyNodeTypedInputRef<string>(this, "overlap_mode"),
				"new_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "new_images"),
			},
			outputs: Object.create(Object.prototype, {
				"source_images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"start_images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"extended_images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageBatchExtendWithOverlapInputs>) {
		if (typeof sources["source_images"] === "object") {
			this.sockets.inputs["source_images"].connectTo(sources["source_images"])
		} else {
			this.sockets.inputs["source_images"].value = sources["source_images"]
		}

		if (typeof sources["overlap"] === "object") {
			this.sockets.inputs["overlap"].connectTo(sources["overlap"])
		} else {
			this.sockets.inputs["overlap"].value = sources["overlap"]
		}

		if (typeof sources["overlap_side"] === "object") {
			this.sockets.inputs["overlap_side"].connectTo(sources["overlap_side"])
		} else {
			this.sockets.inputs["overlap_side"].value = sources["overlap_side"]
		}

		if (typeof sources["overlap_mode"] === "object") {
			this.sockets.inputs["overlap_mode"].connectTo(sources["overlap_mode"])
		} else {
			this.sockets.inputs["overlap_mode"].value = sources["overlap_mode"]
		}

		if (sources["new_images"] !== undefined) {
		if (typeof sources["new_images"] === "object") {
			this.sockets.inputs["new_images"].connectTo(sources["new_images"])
		} else {
			this.sockets.inputs["new_images"].value = sources["new_images"]
		}
		}

	}
}

type ImageBatchExtendWithOverlapInputs = {
			/** The source images to extend*/
			"source_images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Number of overlapping frames between source and new images*/
			"overlap": ComfyNodeTypedInputRef<number>
			/** Which side to overlap on*/
			"overlap_side": ComfyNodeTypedInputRef<string>
			/** Method to use for overlapping frames*/
			"overlap_mode": ComfyNodeTypedInputRef<string>
			/** The new images to extend with*/
			"new_images"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class ImageGrabPIL extends ComfyNode {
	classType: string = "ImageGrabPIL"

	sockets: {
		inputs: Required<ImageGrabPILInputs>
		outputs: {
			image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"x": new ComfyNodeTypedInputRef<number>(this, "x"),
				"y": new ComfyNodeTypedInputRef<number>(this, "y"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"num_frames": new ComfyNodeTypedInputRef<number>(this, "num_frames"),
				"delay": new ComfyNodeTypedInputRef<number>(this, "delay"),
			},
			outputs: Object.create(Object.prototype, {
				"image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageGrabPILInputs>) {
		if (typeof sources["x"] === "object") {
			this.sockets.inputs["x"].connectTo(sources["x"])
		} else {
			this.sockets.inputs["x"].value = sources["x"]
		}

		if (typeof sources["y"] === "object") {
			this.sockets.inputs["y"].connectTo(sources["y"])
		} else {
			this.sockets.inputs["y"].value = sources["y"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["num_frames"] === "object") {
			this.sockets.inputs["num_frames"].connectTo(sources["num_frames"])
		} else {
			this.sockets.inputs["num_frames"].value = sources["num_frames"]
		}

		if (typeof sources["delay"] === "object") {
			this.sockets.inputs["delay"].connectTo(sources["delay"])
		} else {
			this.sockets.inputs["delay"].value = sources["delay"]
		}

	}
}

type ImageGrabPILInputs = {
			"x": ComfyNodeTypedInputRef<number>
			"y": ComfyNodeTypedInputRef<number>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"num_frames": ComfyNodeTypedInputRef<number>
			"delay": ComfyNodeTypedInputRef<number>
}


export class ImageGridComposite2x2 extends ComfyNode {
	classType: string = "ImageGridComposite2x2"

	sockets: {
		inputs: Required<ImageGridComposite2x2Inputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image1": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image1"),
				"image2": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image2"),
				"image3": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image3"),
				"image4": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image4"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageGridComposite2x2Inputs>) {
		if (typeof sources["image1"] === "object") {
			this.sockets.inputs["image1"].connectTo(sources["image1"])
		} else {
			this.sockets.inputs["image1"].value = sources["image1"]
		}

		if (typeof sources["image2"] === "object") {
			this.sockets.inputs["image2"].connectTo(sources["image2"])
		} else {
			this.sockets.inputs["image2"].value = sources["image2"]
		}

		if (typeof sources["image3"] === "object") {
			this.sockets.inputs["image3"].connectTo(sources["image3"])
		} else {
			this.sockets.inputs["image3"].value = sources["image3"]
		}

		if (typeof sources["image4"] === "object") {
			this.sockets.inputs["image4"].connectTo(sources["image4"])
		} else {
			this.sockets.inputs["image4"].value = sources["image4"]
		}

	}
}

type ImageGridComposite2x2Inputs = {
			"image1": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"image2": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"image3": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"image4": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class ImageGridComposite3x3 extends ComfyNode {
	classType: string = "ImageGridComposite3x3"

	sockets: {
		inputs: Required<ImageGridComposite3x3Inputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image1": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image1"),
				"image2": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image2"),
				"image3": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image3"),
				"image4": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image4"),
				"image5": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image5"),
				"image6": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image6"),
				"image7": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image7"),
				"image8": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image8"),
				"image9": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image9"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageGridComposite3x3Inputs>) {
		if (typeof sources["image1"] === "object") {
			this.sockets.inputs["image1"].connectTo(sources["image1"])
		} else {
			this.sockets.inputs["image1"].value = sources["image1"]
		}

		if (typeof sources["image2"] === "object") {
			this.sockets.inputs["image2"].connectTo(sources["image2"])
		} else {
			this.sockets.inputs["image2"].value = sources["image2"]
		}

		if (typeof sources["image3"] === "object") {
			this.sockets.inputs["image3"].connectTo(sources["image3"])
		} else {
			this.sockets.inputs["image3"].value = sources["image3"]
		}

		if (typeof sources["image4"] === "object") {
			this.sockets.inputs["image4"].connectTo(sources["image4"])
		} else {
			this.sockets.inputs["image4"].value = sources["image4"]
		}

		if (typeof sources["image5"] === "object") {
			this.sockets.inputs["image5"].connectTo(sources["image5"])
		} else {
			this.sockets.inputs["image5"].value = sources["image5"]
		}

		if (typeof sources["image6"] === "object") {
			this.sockets.inputs["image6"].connectTo(sources["image6"])
		} else {
			this.sockets.inputs["image6"].value = sources["image6"]
		}

		if (typeof sources["image7"] === "object") {
			this.sockets.inputs["image7"].connectTo(sources["image7"])
		} else {
			this.sockets.inputs["image7"].value = sources["image7"]
		}

		if (typeof sources["image8"] === "object") {
			this.sockets.inputs["image8"].connectTo(sources["image8"])
		} else {
			this.sockets.inputs["image8"].value = sources["image8"]
		}

		if (typeof sources["image9"] === "object") {
			this.sockets.inputs["image9"].connectTo(sources["image9"])
		} else {
			this.sockets.inputs["image9"].value = sources["image9"]
		}

	}
}

type ImageGridComposite3x3Inputs = {
			"image1": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"image2": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"image3": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"image4": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"image5": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"image6": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"image7": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"image8": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"image9": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class ImageGridtoBatch extends ComfyNode {
	classType: string = "ImageGridtoBatch"

	sockets: {
		inputs: Required<ImageGridtoBatchInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"columns": new ComfyNodeTypedInputRef<number>(this, "columns"),
				"rows": new ComfyNodeTypedInputRef<number>(this, "rows"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageGridtoBatchInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["columns"] === "object") {
			this.sockets.inputs["columns"].connectTo(sources["columns"])
		} else {
			this.sockets.inputs["columns"].value = sources["columns"]
		}

		if (typeof sources["rows"] === "object") {
			this.sockets.inputs["rows"].connectTo(sources["rows"])
		} else {
			this.sockets.inputs["rows"].value = sources["rows"]
		}

	}
}

type ImageGridtoBatchInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** The number of columns in the grid.*/
			"columns": ComfyNodeTypedInputRef<number>
			/** The number of rows in the grid. Set to 0 for automatic calculation.*/
			"rows": ComfyNodeTypedInputRef<number>
}


export class ImageNoiseAugmentation extends ComfyNode {
	classType: string = "ImageNoiseAugmentation"

	sockets: {
		inputs: Required<ImageNoiseAugmentationInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"noise_aug_strength": new ComfyNodeTypedInputRef<number>(this, "noise_aug_strength"),
				"seed": new ComfyNodeTypedInputRef<number>(this, "seed"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageNoiseAugmentationInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["noise_aug_strength"] === "object") {
			this.sockets.inputs["noise_aug_strength"].connectTo(sources["noise_aug_strength"])
		} else {
			this.sockets.inputs["noise_aug_strength"].value = sources["noise_aug_strength"]
		}

		if (typeof sources["seed"] === "object") {
			this.sockets.inputs["seed"].connectTo(sources["seed"])
		} else {
			this.sockets.inputs["seed"].value = sources["seed"]
		}

	}
}

type ImageNoiseAugmentationInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"noise_aug_strength": ComfyNodeTypedInputRef<number>
			"seed": ComfyNodeTypedInputRef<number>
}


export class ImageNormalize_Neg1_To_1 extends ComfyNode {
	classType: string = "ImageNormalize_Neg1_To_1"

	sockets: {
		inputs: Required<ImageNormalize_Neg1_To_1Inputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageNormalize_Neg1_To_1Inputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

	}
}

type ImageNormalize_Neg1_To_1Inputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class ImagePass extends ComfyNode {
	classType: string = "ImagePass"

	sockets: {
		inputs: Required<ImagePassInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImagePassInputs>) {
		if (sources["image"] !== undefined) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}
		}

	}
}

type ImagePassInputs = {
			"image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class ImagePadKJ extends ComfyNode {
	classType: string = "ImagePadKJ"

	sockets: {
		inputs: Required<ImagePadKJInputs>
		outputs: {
			images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			masks: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"left": new ComfyNodeTypedInputRef<number>(this, "left"),
				"right": new ComfyNodeTypedInputRef<number>(this, "right"),
				"top": new ComfyNodeTypedInputRef<number>(this, "top"),
				"bottom": new ComfyNodeTypedInputRef<number>(this, "bottom"),
				"extra_padding": new ComfyNodeTypedInputRef<number>(this, "extra_padding"),
				"pad_mode": new ComfyNodeTypedInputRef<string>(this, "pad_mode"),
				"color": new ComfyNodeTypedInputRef<string>(this, "color"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"target_width": new ComfyNodeTypedInputRef<number>(this, "target_width"),
				"target_height": new ComfyNodeTypedInputRef<number>(this, "target_height"),
			},
			outputs: Object.create(Object.prototype, {
				"images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"masks": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImagePadKJInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["left"] === "object") {
			this.sockets.inputs["left"].connectTo(sources["left"])
		} else {
			this.sockets.inputs["left"].value = sources["left"]
		}

		if (typeof sources["right"] === "object") {
			this.sockets.inputs["right"].connectTo(sources["right"])
		} else {
			this.sockets.inputs["right"].value = sources["right"]
		}

		if (typeof sources["top"] === "object") {
			this.sockets.inputs["top"].connectTo(sources["top"])
		} else {
			this.sockets.inputs["top"].value = sources["top"]
		}

		if (typeof sources["bottom"] === "object") {
			this.sockets.inputs["bottom"].connectTo(sources["bottom"])
		} else {
			this.sockets.inputs["bottom"].value = sources["bottom"]
		}

		if (typeof sources["extra_padding"] === "object") {
			this.sockets.inputs["extra_padding"].connectTo(sources["extra_padding"])
		} else {
			this.sockets.inputs["extra_padding"].value = sources["extra_padding"]
		}

		if (typeof sources["pad_mode"] === "object") {
			this.sockets.inputs["pad_mode"].connectTo(sources["pad_mode"])
		} else {
			this.sockets.inputs["pad_mode"].value = sources["pad_mode"]
		}

		if (typeof sources["color"] === "object") {
			this.sockets.inputs["color"].connectTo(sources["color"])
		} else {
			this.sockets.inputs["color"].value = sources["color"]
		}

		if (sources["mask"] !== undefined) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}
		}

		if (sources["target_width"] !== undefined) {
		if (typeof sources["target_width"] === "object") {
			this.sockets.inputs["target_width"].connectTo(sources["target_width"])
		} else {
			this.sockets.inputs["target_width"].value = sources["target_width"]
		}
		}

		if (sources["target_height"] !== undefined) {
		if (typeof sources["target_height"] === "object") {
			this.sockets.inputs["target_height"].connectTo(sources["target_height"])
		} else {
			this.sockets.inputs["target_height"].value = sources["target_height"]
		}
		}

	}
}

type ImagePadKJInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"left": ComfyNodeTypedInputRef<number>
			"right": ComfyNodeTypedInputRef<number>
			"top": ComfyNodeTypedInputRef<number>
			"bottom": ComfyNodeTypedInputRef<number>
			"extra_padding": ComfyNodeTypedInputRef<number>
			"pad_mode": ComfyNodeTypedInputRef<string>
			/** Color as RGB values in range 0-255, separated by commas.*/
			"color": ComfyNodeTypedInputRef<string>
			"mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"target_width"?: ComfyNodeTypedInputRef<number>
			"target_height"?: ComfyNodeTypedInputRef<number>
}


export class ImagePadForOutpaintMasked extends ComfyNode {
	classType: string = "ImagePadForOutpaintMasked"

	sockets: {
		inputs: Required<ImagePadForOutpaintMaskedInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"left": new ComfyNodeTypedInputRef<number>(this, "left"),
				"top": new ComfyNodeTypedInputRef<number>(this, "top"),
				"right": new ComfyNodeTypedInputRef<number>(this, "right"),
				"bottom": new ComfyNodeTypedInputRef<number>(this, "bottom"),
				"feathering": new ComfyNodeTypedInputRef<number>(this, "feathering"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImagePadForOutpaintMaskedInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["left"] === "object") {
			this.sockets.inputs["left"].connectTo(sources["left"])
		} else {
			this.sockets.inputs["left"].value = sources["left"]
		}

		if (typeof sources["top"] === "object") {
			this.sockets.inputs["top"].connectTo(sources["top"])
		} else {
			this.sockets.inputs["top"].value = sources["top"]
		}

		if (typeof sources["right"] === "object") {
			this.sockets.inputs["right"].connectTo(sources["right"])
		} else {
			this.sockets.inputs["right"].value = sources["right"]
		}

		if (typeof sources["bottom"] === "object") {
			this.sockets.inputs["bottom"].connectTo(sources["bottom"])
		} else {
			this.sockets.inputs["bottom"].value = sources["bottom"]
		}

		if (typeof sources["feathering"] === "object") {
			this.sockets.inputs["feathering"].connectTo(sources["feathering"])
		} else {
			this.sockets.inputs["feathering"].value = sources["feathering"]
		}

		if (sources["mask"] !== undefined) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}
		}

	}
}

type ImagePadForOutpaintMaskedInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"left": ComfyNodeTypedInputRef<number>
			"top": ComfyNodeTypedInputRef<number>
			"right": ComfyNodeTypedInputRef<number>
			"bottom": ComfyNodeTypedInputRef<number>
			"feathering": ComfyNodeTypedInputRef<number>
			"mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class ImagePadForOutpaintTargetSize extends ComfyNode {
	classType: string = "ImagePadForOutpaintTargetSize"

	sockets: {
		inputs: Required<ImagePadForOutpaintTargetSizeInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"target_width": new ComfyNodeTypedInputRef<number>(this, "target_width"),
				"target_height": new ComfyNodeTypedInputRef<number>(this, "target_height"),
				"feathering": new ComfyNodeTypedInputRef<number>(this, "feathering"),
				"upscale_method": new ComfyNodeTypedInputRef<string>(this, "upscale_method"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImagePadForOutpaintTargetSizeInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["target_width"] === "object") {
			this.sockets.inputs["target_width"].connectTo(sources["target_width"])
		} else {
			this.sockets.inputs["target_width"].value = sources["target_width"]
		}

		if (typeof sources["target_height"] === "object") {
			this.sockets.inputs["target_height"].connectTo(sources["target_height"])
		} else {
			this.sockets.inputs["target_height"].value = sources["target_height"]
		}

		if (typeof sources["feathering"] === "object") {
			this.sockets.inputs["feathering"].connectTo(sources["feathering"])
		} else {
			this.sockets.inputs["feathering"].value = sources["feathering"]
		}

		if (typeof sources["upscale_method"] === "object") {
			this.sockets.inputs["upscale_method"].connectTo(sources["upscale_method"])
		} else {
			this.sockets.inputs["upscale_method"].value = sources["upscale_method"]
		}

		if (sources["mask"] !== undefined) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}
		}

	}
}

type ImagePadForOutpaintTargetSizeInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"target_width": ComfyNodeTypedInputRef<number>
			"target_height": ComfyNodeTypedInputRef<number>
			"feathering": ComfyNodeTypedInputRef<number>
			"upscale_method": ComfyNodeTypedInputRef<string>
			"mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class ImagePrepForICLora extends ComfyNode {
	classType: string = "ImagePrepForICLora"

	sockets: {
		inputs: Required<ImagePrepForICLoraInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"reference_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "reference_image"),
				"output_width": new ComfyNodeTypedInputRef<number>(this, "output_width"),
				"output_height": new ComfyNodeTypedInputRef<number>(this, "output_height"),
				"border_width": new ComfyNodeTypedInputRef<number>(this, "border_width"),
				"latent_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "latent_image"),
				"latent_mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "latent_mask"),
				"reference_mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "reference_mask"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImagePrepForICLoraInputs>) {
		if (typeof sources["reference_image"] === "object") {
			this.sockets.inputs["reference_image"].connectTo(sources["reference_image"])
		} else {
			this.sockets.inputs["reference_image"].value = sources["reference_image"]
		}

		if (typeof sources["output_width"] === "object") {
			this.sockets.inputs["output_width"].connectTo(sources["output_width"])
		} else {
			this.sockets.inputs["output_width"].value = sources["output_width"]
		}

		if (typeof sources["output_height"] === "object") {
			this.sockets.inputs["output_height"].connectTo(sources["output_height"])
		} else {
			this.sockets.inputs["output_height"].value = sources["output_height"]
		}

		if (typeof sources["border_width"] === "object") {
			this.sockets.inputs["border_width"].connectTo(sources["border_width"])
		} else {
			this.sockets.inputs["border_width"].value = sources["border_width"]
		}

		if (sources["latent_image"] !== undefined) {
		if (typeof sources["latent_image"] === "object") {
			this.sockets.inputs["latent_image"].connectTo(sources["latent_image"])
		} else {
			this.sockets.inputs["latent_image"].value = sources["latent_image"]
		}
		}

		if (sources["latent_mask"] !== undefined) {
		if (typeof sources["latent_mask"] === "object") {
			this.sockets.inputs["latent_mask"].connectTo(sources["latent_mask"])
		} else {
			this.sockets.inputs["latent_mask"].value = sources["latent_mask"]
		}
		}

		if (sources["reference_mask"] !== undefined) {
		if (typeof sources["reference_mask"] === "object") {
			this.sockets.inputs["reference_mask"].connectTo(sources["reference_mask"])
		} else {
			this.sockets.inputs["reference_mask"].value = sources["reference_mask"]
		}
		}

	}
}

type ImagePrepForICLoraInputs = {
			"reference_image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"output_width": ComfyNodeTypedInputRef<number>
			"output_height": ComfyNodeTypedInputRef<number>
			"border_width": ComfyNodeTypedInputRef<number>
			"latent_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"latent_mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"reference_mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class ImageResizeKJ extends ComfyNode {
	classType: string = "ImageResizeKJ"

	sockets: {
		inputs: Required<ImageResizeKJInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			width: ComfyNodeTypedSourceRef<number>
			height: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"upscale_method": new ComfyNodeTypedInputRef<string>(this, "upscale_method"),
				"keep_proportion": new ComfyNodeTypedInputRef<boolean>(this, "keep_proportion"),
				"divisible_by": new ComfyNodeTypedInputRef<number>(this, "divisible_by"),
				"get_image_size": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "get_image_size"),
				"crop": new ComfyNodeTypedInputRef<string>(this, "crop"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageResizeKJInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["upscale_method"] === "object") {
			this.sockets.inputs["upscale_method"].connectTo(sources["upscale_method"])
		} else {
			this.sockets.inputs["upscale_method"].value = sources["upscale_method"]
		}

		if (typeof sources["keep_proportion"] === "object") {
			this.sockets.inputs["keep_proportion"].connectTo(sources["keep_proportion"])
		} else {
			this.sockets.inputs["keep_proportion"].value = sources["keep_proportion"]
		}

		if (typeof sources["divisible_by"] === "object") {
			this.sockets.inputs["divisible_by"].connectTo(sources["divisible_by"])
		} else {
			this.sockets.inputs["divisible_by"].value = sources["divisible_by"]
		}

		if (sources["get_image_size"] !== undefined) {
		if (typeof sources["get_image_size"] === "object") {
			this.sockets.inputs["get_image_size"].connectTo(sources["get_image_size"])
		} else {
			this.sockets.inputs["get_image_size"].value = sources["get_image_size"]
		}
		}

		if (sources["crop"] !== undefined) {
		if (typeof sources["crop"] === "object") {
			this.sockets.inputs["crop"].connectTo(sources["crop"])
		} else {
			this.sockets.inputs["crop"].value = sources["crop"]
		}
		}

	}
}

type ImageResizeKJInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"upscale_method": ComfyNodeTypedInputRef<string>
			"keep_proportion": ComfyNodeTypedInputRef<boolean>
			"divisible_by": ComfyNodeTypedInputRef<number>
			"get_image_size"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** 0 will do the default center crop, this is a workaround for the widget order changing with the new frontend, as in old workflows the value of this widget becomes 0 automatically*/
			"crop"?: ComfyNodeTypedInputRef<string>
}


export class ImageResizeKJv2 extends ComfyNode {
	classType: string = "ImageResizeKJv2"

	sockets: {
		inputs: Required<ImageResizeKJv2Inputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			width: ComfyNodeTypedSourceRef<number>
			height: ComfyNodeTypedSourceRef<number>
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"upscale_method": new ComfyNodeTypedInputRef<string>(this, "upscale_method"),
				"keep_proportion": new ComfyNodeTypedInputRef<string>(this, "keep_proportion"),
				"pad_color": new ComfyNodeTypedInputRef<string>(this, "pad_color"),
				"crop_position": new ComfyNodeTypedInputRef<string>(this, "crop_position"),
				"divisible_by": new ComfyNodeTypedInputRef<number>(this, "divisible_by"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
				"unique_id": new ComfyNodeTypedInputRef<ComfyValueType_U>(this, "unique_id"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageResizeKJv2Inputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["upscale_method"] === "object") {
			this.sockets.inputs["upscale_method"].connectTo(sources["upscale_method"])
		} else {
			this.sockets.inputs["upscale_method"].value = sources["upscale_method"]
		}

		if (typeof sources["keep_proportion"] === "object") {
			this.sockets.inputs["keep_proportion"].connectTo(sources["keep_proportion"])
		} else {
			this.sockets.inputs["keep_proportion"].value = sources["keep_proportion"]
		}

		if (typeof sources["pad_color"] === "object") {
			this.sockets.inputs["pad_color"].connectTo(sources["pad_color"])
		} else {
			this.sockets.inputs["pad_color"].value = sources["pad_color"]
		}

		if (typeof sources["crop_position"] === "object") {
			this.sockets.inputs["crop_position"].connectTo(sources["crop_position"])
		} else {
			this.sockets.inputs["crop_position"].value = sources["crop_position"]
		}

		if (typeof sources["divisible_by"] === "object") {
			this.sockets.inputs["divisible_by"].connectTo(sources["divisible_by"])
		} else {
			this.sockets.inputs["divisible_by"].value = sources["divisible_by"]
		}

		if (sources["mask"] !== undefined) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

		if (sources["unique_id"] !== undefined) {
		if (typeof sources["unique_id"] === "object") {
			this.sockets.inputs["unique_id"].connectTo(sources["unique_id"])
		} else {
			this.sockets.inputs["unique_id"].value = sources["unique_id"]
		}
		}

	}
}

type ImageResizeKJv2Inputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"upscale_method": ComfyNodeTypedInputRef<string>
			"keep_proportion": ComfyNodeTypedInputRef<string>
			/** Color to use for padding.*/
			"pad_color": ComfyNodeTypedInputRef<string>
			"crop_position": ComfyNodeTypedInputRef<string>
			"divisible_by": ComfyNodeTypedInputRef<number>
			"mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"device"?: ComfyNodeTypedInputRef<string>
			"unique_id"?: ComfyNodeTypedInputRef<ComfyValueType_U>
}


export class ImageUpscaleWithModelBatched extends ComfyNode {
	classType: string = "ImageUpscaleWithModelBatched"

	sockets: {
		inputs: Required<ImageUpscaleWithModelBatchedInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"upscale_model": new ComfyNodeTypedInputRef<ComfyValueType_UPSCALE_MODEL>(this, "upscale_model"),
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"per_batch": new ComfyNodeTypedInputRef<number>(this, "per_batch"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageUpscaleWithModelBatchedInputs>) {
		if (typeof sources["upscale_model"] === "object") {
			this.sockets.inputs["upscale_model"].connectTo(sources["upscale_model"])
		} else {
			this.sockets.inputs["upscale_model"].value = sources["upscale_model"]
		}

		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["per_batch"] === "object") {
			this.sockets.inputs["per_batch"].connectTo(sources["per_batch"])
		} else {
			this.sockets.inputs["per_batch"].value = sources["per_batch"]
		}

	}
}

type ImageUpscaleWithModelBatchedInputs = {
			"upscale_model": ComfyNodeTypedInputRef<ComfyValueType_UPSCALE_MODEL>
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"per_batch": ComfyNodeTypedInputRef<number>
}


export class InsertImagesToBatchIndexed extends ComfyNode {
	classType: string = "InsertImagesToBatchIndexed"

	sockets: {
		inputs: Required<InsertImagesToBatchIndexedInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"original_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "original_images"),
				"images_to_insert": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images_to_insert"),
				"indexes": new ComfyNodeTypedInputRef<string>(this, "indexes"),
				"mode": new ComfyNodeTypedInputRef<string>(this, "mode"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<InsertImagesToBatchIndexedInputs>) {
		if (typeof sources["original_images"] === "object") {
			this.sockets.inputs["original_images"].connectTo(sources["original_images"])
		} else {
			this.sockets.inputs["original_images"].value = sources["original_images"]
		}

		if (typeof sources["images_to_insert"] === "object") {
			this.sockets.inputs["images_to_insert"].connectTo(sources["images_to_insert"])
		} else {
			this.sockets.inputs["images_to_insert"].value = sources["images_to_insert"]
		}

		if (typeof sources["indexes"] === "object") {
			this.sockets.inputs["indexes"].connectTo(sources["indexes"])
		} else {
			this.sockets.inputs["indexes"].value = sources["indexes"]
		}

		if (sources["mode"] !== undefined) {
		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}
		}

	}
}

type InsertImagesToBatchIndexedInputs = {
			"original_images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"images_to_insert": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"indexes": ComfyNodeTypedInputRef<string>
			"mode"?: ComfyNodeTypedInputRef<string>
}


export class InsertLatentToIndexed extends ComfyNode {
	classType: string = "InsertLatentToIndexed"

	sockets: {
		inputs: Required<InsertLatentToIndexedInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"source": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "source"),
				"destination": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "destination"),
				"index": new ComfyNodeTypedInputRef<number>(this, "index"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<InsertLatentToIndexedInputs>) {
		if (typeof sources["source"] === "object") {
			this.sockets.inputs["source"].connectTo(sources["source"])
		} else {
			this.sockets.inputs["source"].value = sources["source"]
		}

		if (typeof sources["destination"] === "object") {
			this.sockets.inputs["destination"].connectTo(sources["destination"])
		} else {
			this.sockets.inputs["destination"].value = sources["destination"]
		}

		if (typeof sources["index"] === "object") {
			this.sockets.inputs["index"].connectTo(sources["index"])
		} else {
			this.sockets.inputs["index"].value = sources["index"]
		}

	}
}

type InsertLatentToIndexedInputs = {
			"source": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"destination": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"index": ComfyNodeTypedInputRef<number>
}


export class LoadAndResizeImage extends ComfyNode {
	classType: string = "LoadAndResizeImage"

	sockets: {
		inputs: Required<LoadAndResizeImageInputs>
		outputs: {
			image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			width: ComfyNodeTypedSourceRef<number>
			height: ComfyNodeTypedSourceRef<number>
			image_path: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<string>(this, "image"),
				"resize": new ComfyNodeTypedInputRef<boolean>(this, "resize"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"repeat": new ComfyNodeTypedInputRef<number>(this, "repeat"),
				"keep_proportion": new ComfyNodeTypedInputRef<boolean>(this, "keep_proportion"),
				"divisible_by": new ComfyNodeTypedInputRef<number>(this, "divisible_by"),
				"mask_channel": new ComfyNodeTypedInputRef<string>(this, "mask_channel"),
				"background_color": new ComfyNodeTypedInputRef<string>(this, "background_color"),
			},
			outputs: Object.create(Object.prototype, {
				"image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
				"image_path": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 4 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoadAndResizeImageInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["resize"] === "object") {
			this.sockets.inputs["resize"].connectTo(sources["resize"])
		} else {
			this.sockets.inputs["resize"].value = sources["resize"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["repeat"] === "object") {
			this.sockets.inputs["repeat"].connectTo(sources["repeat"])
		} else {
			this.sockets.inputs["repeat"].value = sources["repeat"]
		}

		if (typeof sources["keep_proportion"] === "object") {
			this.sockets.inputs["keep_proportion"].connectTo(sources["keep_proportion"])
		} else {
			this.sockets.inputs["keep_proportion"].value = sources["keep_proportion"]
		}

		if (typeof sources["divisible_by"] === "object") {
			this.sockets.inputs["divisible_by"].connectTo(sources["divisible_by"])
		} else {
			this.sockets.inputs["divisible_by"].value = sources["divisible_by"]
		}

		if (typeof sources["mask_channel"] === "object") {
			this.sockets.inputs["mask_channel"].connectTo(sources["mask_channel"])
		} else {
			this.sockets.inputs["mask_channel"].value = sources["mask_channel"]
		}

		if (typeof sources["background_color"] === "object") {
			this.sockets.inputs["background_color"].connectTo(sources["background_color"])
		} else {
			this.sockets.inputs["background_color"].value = sources["background_color"]
		}

	}
}

type LoadAndResizeImageInputs = {
			"image": ComfyNodeTypedInputRef<string>
			"resize": ComfyNodeTypedInputRef<boolean>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"repeat": ComfyNodeTypedInputRef<number>
			"keep_proportion": ComfyNodeTypedInputRef<boolean>
			"divisible_by": ComfyNodeTypedInputRef<number>
			/** Channel to use for the mask output*/
			"mask_channel": ComfyNodeTypedInputRef<string>
			/** Fills the alpha channel with the specified color.*/
			"background_color": ComfyNodeTypedInputRef<string>
}


export class LoadImagesFromFolderKJ extends ComfyNode {
	classType: string = "LoadImagesFromFolderKJ"

	sockets: {
		inputs: Required<LoadImagesFromFolderKJInputs>
		outputs: {
			image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			count: ComfyNodeTypedSourceRef<number>
			image_path: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"folder": new ComfyNodeTypedInputRef<string>(this, "folder"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"keep_aspect_ratio": new ComfyNodeTypedInputRef<string>(this, "keep_aspect_ratio"),
				"image_load_cap": new ComfyNodeTypedInputRef<number>(this, "image_load_cap"),
				"start_index": new ComfyNodeTypedInputRef<number>(this, "start_index"),
				"include_subfolders": new ComfyNodeTypedInputRef<boolean>(this, "include_subfolders"),
			},
			outputs: Object.create(Object.prototype, {
				"image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"image_path": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoadImagesFromFolderKJInputs>) {
		if (typeof sources["folder"] === "object") {
			this.sockets.inputs["folder"].connectTo(sources["folder"])
		} else {
			this.sockets.inputs["folder"].value = sources["folder"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["keep_aspect_ratio"] === "object") {
			this.sockets.inputs["keep_aspect_ratio"].connectTo(sources["keep_aspect_ratio"])
		} else {
			this.sockets.inputs["keep_aspect_ratio"].value = sources["keep_aspect_ratio"]
		}

		if (sources["image_load_cap"] !== undefined) {
		if (typeof sources["image_load_cap"] === "object") {
			this.sockets.inputs["image_load_cap"].connectTo(sources["image_load_cap"])
		} else {
			this.sockets.inputs["image_load_cap"].value = sources["image_load_cap"]
		}
		}

		if (sources["start_index"] !== undefined) {
		if (typeof sources["start_index"] === "object") {
			this.sockets.inputs["start_index"].connectTo(sources["start_index"])
		} else {
			this.sockets.inputs["start_index"].value = sources["start_index"]
		}
		}

		if (sources["include_subfolders"] !== undefined) {
		if (typeof sources["include_subfolders"] === "object") {
			this.sockets.inputs["include_subfolders"].connectTo(sources["include_subfolders"])
		} else {
			this.sockets.inputs["include_subfolders"].value = sources["include_subfolders"]
		}
		}

	}
}

type LoadImagesFromFolderKJInputs = {
			"folder": ComfyNodeTypedInputRef<string>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"keep_aspect_ratio": ComfyNodeTypedInputRef<string>
			"image_load_cap"?: ComfyNodeTypedInputRef<number>
			"start_index"?: ComfyNodeTypedInputRef<number>
			"include_subfolders"?: ComfyNodeTypedInputRef<boolean>
}


export class LoadVideosFromFolder extends ComfyNode {
	classType: string = "LoadVideosFromFolder"

	sockets: {
		inputs: Required<LoadVideosFromFolderInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"video": new ComfyNodeTypedInputRef<string>(this, "video"),
				"force_rate": new ComfyNodeTypedInputRef<number>(this, "force_rate"),
				"custom_width": new ComfyNodeTypedInputRef<number>(this, "custom_width"),
				"custom_height": new ComfyNodeTypedInputRef<number>(this, "custom_height"),
				"frame_load_cap": new ComfyNodeTypedInputRef<number>(this, "frame_load_cap"),
				"skip_first_frames": new ComfyNodeTypedInputRef<number>(this, "skip_first_frames"),
				"select_every_nth": new ComfyNodeTypedInputRef<number>(this, "select_every_nth"),
				"output_type": new ComfyNodeTypedInputRef<string>(this, "output_type"),
				"grid_max_columns": new ComfyNodeTypedInputRef<number>(this, "grid_max_columns"),
				"add_label": new ComfyNodeTypedInputRef<boolean>(this, "add_label"),
				"force_size": new ComfyNodeTypedInputRef<ComfyValueType_S>(this, "force_size"),
				"unique_id": new ComfyNodeTypedInputRef<ComfyValueType_U>(this, "unique_id"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoadVideosFromFolderInputs>) {
		if (typeof sources["video"] === "object") {
			this.sockets.inputs["video"].connectTo(sources["video"])
		} else {
			this.sockets.inputs["video"].value = sources["video"]
		}

		if (typeof sources["force_rate"] === "object") {
			this.sockets.inputs["force_rate"].connectTo(sources["force_rate"])
		} else {
			this.sockets.inputs["force_rate"].value = sources["force_rate"]
		}

		if (typeof sources["custom_width"] === "object") {
			this.sockets.inputs["custom_width"].connectTo(sources["custom_width"])
		} else {
			this.sockets.inputs["custom_width"].value = sources["custom_width"]
		}

		if (typeof sources["custom_height"] === "object") {
			this.sockets.inputs["custom_height"].connectTo(sources["custom_height"])
		} else {
			this.sockets.inputs["custom_height"].value = sources["custom_height"]
		}

		if (typeof sources["frame_load_cap"] === "object") {
			this.sockets.inputs["frame_load_cap"].connectTo(sources["frame_load_cap"])
		} else {
			this.sockets.inputs["frame_load_cap"].value = sources["frame_load_cap"]
		}

		if (typeof sources["skip_first_frames"] === "object") {
			this.sockets.inputs["skip_first_frames"].connectTo(sources["skip_first_frames"])
		} else {
			this.sockets.inputs["skip_first_frames"].value = sources["skip_first_frames"]
		}

		if (typeof sources["select_every_nth"] === "object") {
			this.sockets.inputs["select_every_nth"].connectTo(sources["select_every_nth"])
		} else {
			this.sockets.inputs["select_every_nth"].value = sources["select_every_nth"]
		}

		if (typeof sources["output_type"] === "object") {
			this.sockets.inputs["output_type"].connectTo(sources["output_type"])
		} else {
			this.sockets.inputs["output_type"].value = sources["output_type"]
		}

		if (typeof sources["grid_max_columns"] === "object") {
			this.sockets.inputs["grid_max_columns"].connectTo(sources["grid_max_columns"])
		} else {
			this.sockets.inputs["grid_max_columns"].value = sources["grid_max_columns"]
		}

		if (typeof sources["add_label"] === "object") {
			this.sockets.inputs["add_label"].connectTo(sources["add_label"])
		} else {
			this.sockets.inputs["add_label"].value = sources["add_label"]
		}

		if (sources["force_size"] !== undefined) {
		if (typeof sources["force_size"] === "object") {
			this.sockets.inputs["force_size"].connectTo(sources["force_size"])
		} else {
			this.sockets.inputs["force_size"].value = sources["force_size"]
		}
		}

		if (sources["unique_id"] !== undefined) {
		if (typeof sources["unique_id"] === "object") {
			this.sockets.inputs["unique_id"].connectTo(sources["unique_id"])
		} else {
			this.sockets.inputs["unique_id"].value = sources["unique_id"]
		}
		}

	}
}

type LoadVideosFromFolderInputs = {
			"video": ComfyNodeTypedInputRef<string>
			"force_rate": ComfyNodeTypedInputRef<number>
			"custom_width": ComfyNodeTypedInputRef<number>
			"custom_height": ComfyNodeTypedInputRef<number>
			"frame_load_cap": ComfyNodeTypedInputRef<number>
			"skip_first_frames": ComfyNodeTypedInputRef<number>
			"select_every_nth": ComfyNodeTypedInputRef<number>
			"output_type": ComfyNodeTypedInputRef<string>
			"grid_max_columns": ComfyNodeTypedInputRef<number>
			"add_label": ComfyNodeTypedInputRef<boolean>
			"force_size"?: ComfyNodeTypedInputRef<ComfyValueType_S>
			"unique_id"?: ComfyNodeTypedInputRef<ComfyValueType_U>
}


export class MergeImageChannels extends ComfyNode {
	classType: string = "MergeImageChannels"

	sockets: {
		inputs: Required<MergeImageChannelsInputs>
		outputs: {
			image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"red": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "red"),
				"green": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "green"),
				"blue": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "blue"),
				"alpha": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "alpha"),
			},
			outputs: Object.create(Object.prototype, {
				"image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<MergeImageChannelsInputs>) {
		if (typeof sources["red"] === "object") {
			this.sockets.inputs["red"].connectTo(sources["red"])
		} else {
			this.sockets.inputs["red"].value = sources["red"]
		}

		if (typeof sources["green"] === "object") {
			this.sockets.inputs["green"].connectTo(sources["green"])
		} else {
			this.sockets.inputs["green"].value = sources["green"]
		}

		if (typeof sources["blue"] === "object") {
			this.sockets.inputs["blue"].connectTo(sources["blue"])
		} else {
			this.sockets.inputs["blue"].value = sources["blue"]
		}

		if (sources["alpha"] !== undefined) {
		if (typeof sources["alpha"] === "object") {
			this.sockets.inputs["alpha"].connectTo(sources["alpha"])
		} else {
			this.sockets.inputs["alpha"].value = sources["alpha"]
		}
		}

	}
}

type MergeImageChannelsInputs = {
			"red": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"green": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"blue": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"alpha"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class PadImageBatchInterleaved extends ComfyNode {
	classType: string = "PadImageBatchInterleaved"

	sockets: {
		inputs: Required<PadImageBatchInterleavedInputs>
		outputs: {
			images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			masks: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"empty_frames_per_image": new ComfyNodeTypedInputRef<number>(this, "empty_frames_per_image"),
				"pad_frame_value": new ComfyNodeTypedInputRef<number>(this, "pad_frame_value"),
				"add_after_last": new ComfyNodeTypedInputRef<boolean>(this, "add_after_last"),
			},
			outputs: Object.create(Object.prototype, {
				"images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"masks": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PadImageBatchInterleavedInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["empty_frames_per_image"] === "object") {
			this.sockets.inputs["empty_frames_per_image"].connectTo(sources["empty_frames_per_image"])
		} else {
			this.sockets.inputs["empty_frames_per_image"].value = sources["empty_frames_per_image"]
		}

		if (typeof sources["pad_frame_value"] === "object") {
			this.sockets.inputs["pad_frame_value"].connectTo(sources["pad_frame_value"])
		} else {
			this.sockets.inputs["pad_frame_value"].value = sources["pad_frame_value"]
		}

		if (typeof sources["add_after_last"] === "object") {
			this.sockets.inputs["add_after_last"].connectTo(sources["add_after_last"])
		} else {
			this.sockets.inputs["add_after_last"].value = sources["add_after_last"]
		}

	}
}

type PadImageBatchInterleavedInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"empty_frames_per_image": ComfyNodeTypedInputRef<number>
			"pad_frame_value": ComfyNodeTypedInputRef<number>
			"add_after_last": ComfyNodeTypedInputRef<boolean>
}


export class PreviewAnimation extends ComfyNode {
	classType: string = "PreviewAnimation"

	sockets: {
		inputs: Required<PreviewAnimationInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"fps": new ComfyNodeTypedInputRef<number>(this, "fps"),
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"masks": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "masks"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<PreviewAnimationInputs>) {
		if (typeof sources["fps"] === "object") {
			this.sockets.inputs["fps"].connectTo(sources["fps"])
		} else {
			this.sockets.inputs["fps"].value = sources["fps"]
		}

		if (sources["images"] !== undefined) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}
		}

		if (sources["masks"] !== undefined) {
		if (typeof sources["masks"] === "object") {
			this.sockets.inputs["masks"].connectTo(sources["masks"])
		} else {
			this.sockets.inputs["masks"].value = sources["masks"]
		}
		}

	}
}

type PreviewAnimationInputs = {
			"fps": ComfyNodeTypedInputRef<number>
			"images"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"masks"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class RemapImageRange extends ComfyNode {
	classType: string = "RemapImageRange"

	sockets: {
		inputs: Required<RemapImageRangeInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"min": new ComfyNodeTypedInputRef<number>(this, "min"),
				"max": new ComfyNodeTypedInputRef<number>(this, "max"),
				"clamp": new ComfyNodeTypedInputRef<boolean>(this, "clamp"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<RemapImageRangeInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["min"] === "object") {
			this.sockets.inputs["min"].connectTo(sources["min"])
		} else {
			this.sockets.inputs["min"].value = sources["min"]
		}

		if (typeof sources["max"] === "object") {
			this.sockets.inputs["max"].connectTo(sources["max"])
		} else {
			this.sockets.inputs["max"].value = sources["max"]
		}

		if (typeof sources["clamp"] === "object") {
			this.sockets.inputs["clamp"].connectTo(sources["clamp"])
		} else {
			this.sockets.inputs["clamp"].value = sources["clamp"]
		}

	}
}

type RemapImageRangeInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"min": ComfyNodeTypedInputRef<number>
			"max": ComfyNodeTypedInputRef<number>
			"clamp": ComfyNodeTypedInputRef<boolean>
}


export class ReverseImageBatch extends ComfyNode {
	classType: string = "ReverseImageBatch"

	sockets: {
		inputs: Required<ReverseImageBatchInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ReverseImageBatchInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

	}
}

type ReverseImageBatchInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class ReplaceImagesInBatch extends ComfyNode {
	classType: string = "ReplaceImagesInBatch"

	sockets: {
		inputs: Required<ReplaceImagesInBatchInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"start_index": new ComfyNodeTypedInputRef<number>(this, "start_index"),
				"original_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "original_images"),
				"replacement_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "replacement_images"),
				"original_masks": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "original_masks"),
				"replacement_masks": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "replacement_masks"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ReplaceImagesInBatchInputs>) {
		if (typeof sources["start_index"] === "object") {
			this.sockets.inputs["start_index"].connectTo(sources["start_index"])
		} else {
			this.sockets.inputs["start_index"].value = sources["start_index"]
		}

		if (sources["original_images"] !== undefined) {
		if (typeof sources["original_images"] === "object") {
			this.sockets.inputs["original_images"].connectTo(sources["original_images"])
		} else {
			this.sockets.inputs["original_images"].value = sources["original_images"]
		}
		}

		if (sources["replacement_images"] !== undefined) {
		if (typeof sources["replacement_images"] === "object") {
			this.sockets.inputs["replacement_images"].connectTo(sources["replacement_images"])
		} else {
			this.sockets.inputs["replacement_images"].value = sources["replacement_images"]
		}
		}

		if (sources["original_masks"] !== undefined) {
		if (typeof sources["original_masks"] === "object") {
			this.sockets.inputs["original_masks"].connectTo(sources["original_masks"])
		} else {
			this.sockets.inputs["original_masks"].value = sources["original_masks"]
		}
		}

		if (sources["replacement_masks"] !== undefined) {
		if (typeof sources["replacement_masks"] === "object") {
			this.sockets.inputs["replacement_masks"].connectTo(sources["replacement_masks"])
		} else {
			this.sockets.inputs["replacement_masks"].value = sources["replacement_masks"]
		}
		}

	}
}

type ReplaceImagesInBatchInputs = {
			"start_index": ComfyNodeTypedInputRef<number>
			"original_images"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"replacement_images"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"original_masks"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"replacement_masks"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class SaveImageWithAlpha extends ComfyNode {
	classType: string = "SaveImageWithAlpha"

	sockets: {
		inputs: Required<SaveImageWithAlphaInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_E>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<SaveImageWithAlphaInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type SaveImageWithAlphaInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"filename_prefix": ComfyNodeTypedInputRef<string>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_E>
}


export class SaveImageKJ extends ComfyNode {
	classType: string = "SaveImageKJ"

	sockets: {
		inputs: Required<SaveImageKJInputs>
		outputs: {
			filename: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"output_folder": new ComfyNodeTypedInputRef<string>(this, "output_folder"),
				"caption_file_extension": new ComfyNodeTypedInputRef<string>(this, "caption_file_extension"),
				"caption": new ComfyNodeTypedInputRef<string>(this, "caption"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_E>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
				"filename": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SaveImageKJInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (typeof sources["output_folder"] === "object") {
			this.sockets.inputs["output_folder"].connectTo(sources["output_folder"])
		} else {
			this.sockets.inputs["output_folder"].value = sources["output_folder"]
		}

		if (sources["caption_file_extension"] !== undefined) {
		if (typeof sources["caption_file_extension"] === "object") {
			this.sockets.inputs["caption_file_extension"].connectTo(sources["caption_file_extension"])
		} else {
			this.sockets.inputs["caption_file_extension"].value = sources["caption_file_extension"]
		}
		}

		if (sources["caption"] !== undefined) {
		if (typeof sources["caption"] === "object") {
			this.sockets.inputs["caption"].connectTo(sources["caption"])
		} else {
			this.sockets.inputs["caption"].value = sources["caption"]
		}
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type SaveImageKJInputs = {
			/** The images to save.*/
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** The prefix for the file to save. This may include formatting information such as %date:yyyy-MM-dd% or %Empty Latent Image.width% to include values from nodes.*/
			"filename_prefix": ComfyNodeTypedInputRef<string>
			/** The folder to save the images to.*/
			"output_folder": ComfyNodeTypedInputRef<string>
			/** The extension for the caption file.*/
			"caption_file_extension"?: ComfyNodeTypedInputRef<string>
			/** string to save as .txt file*/
			"caption"?: ComfyNodeTypedInputRef<string>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_E>
}


export class ShuffleImageBatch extends ComfyNode {
	classType: string = "ShuffleImageBatch"

	sockets: {
		inputs: Required<ShuffleImageBatchInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"seed": new ComfyNodeTypedInputRef<number>(this, "seed"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ShuffleImageBatchInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["seed"] === "object") {
			this.sockets.inputs["seed"].connectTo(sources["seed"])
		} else {
			this.sockets.inputs["seed"].value = sources["seed"]
		}

	}
}

type ShuffleImageBatchInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"seed": ComfyNodeTypedInputRef<number>
}


export class SplitImageChannels extends ComfyNode {
	classType: string = "SplitImageChannels"

	sockets: {
		inputs: Required<SplitImageChannelsInputs>
		outputs: {
			red: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			green: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			blue: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
			},
			outputs: Object.create(Object.prototype, {
				"red": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"green": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"blue": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SplitImageChannelsInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

	}
}

type SplitImageChannelsInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class TransitionImagesMulti extends ComfyNode {
	classType: string = "TransitionImagesMulti"

	sockets: {
		inputs: Required<TransitionImagesMultiInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"inputcount": new ComfyNodeTypedInputRef<number>(this, "inputcount"),
				"image_1": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image_1"),
				"interpolation": new ComfyNodeTypedInputRef<string>(this, "interpolation"),
				"transition_type": new ComfyNodeTypedInputRef<string>(this, "transition_type"),
				"transitioning_frames": new ComfyNodeTypedInputRef<number>(this, "transitioning_frames"),
				"blur_radius": new ComfyNodeTypedInputRef<number>(this, "blur_radius"),
				"reverse": new ComfyNodeTypedInputRef<boolean>(this, "reverse"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
				"image_2": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image_2"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TransitionImagesMultiInputs>) {
		if (typeof sources["inputcount"] === "object") {
			this.sockets.inputs["inputcount"].connectTo(sources["inputcount"])
		} else {
			this.sockets.inputs["inputcount"].value = sources["inputcount"]
		}

		if (typeof sources["image_1"] === "object") {
			this.sockets.inputs["image_1"].connectTo(sources["image_1"])
		} else {
			this.sockets.inputs["image_1"].value = sources["image_1"]
		}

		if (typeof sources["interpolation"] === "object") {
			this.sockets.inputs["interpolation"].connectTo(sources["interpolation"])
		} else {
			this.sockets.inputs["interpolation"].value = sources["interpolation"]
		}

		if (typeof sources["transition_type"] === "object") {
			this.sockets.inputs["transition_type"].connectTo(sources["transition_type"])
		} else {
			this.sockets.inputs["transition_type"].value = sources["transition_type"]
		}

		if (typeof sources["transitioning_frames"] === "object") {
			this.sockets.inputs["transitioning_frames"].connectTo(sources["transitioning_frames"])
		} else {
			this.sockets.inputs["transitioning_frames"].value = sources["transitioning_frames"]
		}

		if (typeof sources["blur_radius"] === "object") {
			this.sockets.inputs["blur_radius"].connectTo(sources["blur_radius"])
		} else {
			this.sockets.inputs["blur_radius"].value = sources["blur_radius"]
		}

		if (typeof sources["reverse"] === "object") {
			this.sockets.inputs["reverse"].connectTo(sources["reverse"])
		} else {
			this.sockets.inputs["reverse"].value = sources["reverse"]
		}

		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}

		if (sources["image_2"] !== undefined) {
		if (typeof sources["image_2"] === "object") {
			this.sockets.inputs["image_2"].connectTo(sources["image_2"])
		} else {
			this.sockets.inputs["image_2"].value = sources["image_2"]
		}
		}

	}
}

type TransitionImagesMultiInputs = {
			"inputcount": ComfyNodeTypedInputRef<number>
			"image_1": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"interpolation": ComfyNodeTypedInputRef<string>
			"transition_type": ComfyNodeTypedInputRef<string>
			"transitioning_frames": ComfyNodeTypedInputRef<number>
			"blur_radius": ComfyNodeTypedInputRef<number>
			"reverse": ComfyNodeTypedInputRef<boolean>
			"device": ComfyNodeTypedInputRef<string>
			"image_2"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class TransitionImagesInBatch extends ComfyNode {
	classType: string = "TransitionImagesInBatch"

	sockets: {
		inputs: Required<TransitionImagesInBatchInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"interpolation": new ComfyNodeTypedInputRef<string>(this, "interpolation"),
				"transition_type": new ComfyNodeTypedInputRef<string>(this, "transition_type"),
				"transitioning_frames": new ComfyNodeTypedInputRef<number>(this, "transitioning_frames"),
				"blur_radius": new ComfyNodeTypedInputRef<number>(this, "blur_radius"),
				"reverse": new ComfyNodeTypedInputRef<boolean>(this, "reverse"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TransitionImagesInBatchInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["interpolation"] === "object") {
			this.sockets.inputs["interpolation"].connectTo(sources["interpolation"])
		} else {
			this.sockets.inputs["interpolation"].value = sources["interpolation"]
		}

		if (typeof sources["transition_type"] === "object") {
			this.sockets.inputs["transition_type"].connectTo(sources["transition_type"])
		} else {
			this.sockets.inputs["transition_type"].value = sources["transition_type"]
		}

		if (typeof sources["transitioning_frames"] === "object") {
			this.sockets.inputs["transitioning_frames"].connectTo(sources["transitioning_frames"])
		} else {
			this.sockets.inputs["transitioning_frames"].value = sources["transitioning_frames"]
		}

		if (typeof sources["blur_radius"] === "object") {
			this.sockets.inputs["blur_radius"].connectTo(sources["blur_radius"])
		} else {
			this.sockets.inputs["blur_radius"].value = sources["blur_radius"]
		}

		if (typeof sources["reverse"] === "object") {
			this.sockets.inputs["reverse"].connectTo(sources["reverse"])
		} else {
			this.sockets.inputs["reverse"].value = sources["reverse"]
		}

		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}

	}
}

type TransitionImagesInBatchInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"interpolation": ComfyNodeTypedInputRef<string>
			"transition_type": ComfyNodeTypedInputRef<string>
			"transitioning_frames": ComfyNodeTypedInputRef<number>
			"blur_radius": ComfyNodeTypedInputRef<number>
			"reverse": ComfyNodeTypedInputRef<boolean>
			"device": ComfyNodeTypedInputRef<string>
}


export class BatchCropFromMask extends ComfyNode {
	classType: string = "BatchCropFromMask"

	sockets: {
		inputs: Required<BatchCropFromMaskInputs>
		outputs: {
			original_images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			cropped_images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			bboxes: ComfyNodeTypedSourceRef<ComfyValueType_BBOX>
			width: ComfyNodeTypedSourceRef<number>
			height: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"original_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "original_images"),
				"masks": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "masks"),
				"crop_size_mult": new ComfyNodeTypedInputRef<number>(this, "crop_size_mult"),
				"bbox_smooth_alpha": new ComfyNodeTypedInputRef<number>(this, "bbox_smooth_alpha"),
			},
			outputs: Object.create(Object.prototype, {
				"original_images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"cropped_images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"bboxes": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
				"height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 4 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<BatchCropFromMaskInputs>) {
		if (typeof sources["original_images"] === "object") {
			this.sockets.inputs["original_images"].connectTo(sources["original_images"])
		} else {
			this.sockets.inputs["original_images"].value = sources["original_images"]
		}

		if (typeof sources["masks"] === "object") {
			this.sockets.inputs["masks"].connectTo(sources["masks"])
		} else {
			this.sockets.inputs["masks"].value = sources["masks"]
		}

		if (typeof sources["crop_size_mult"] === "object") {
			this.sockets.inputs["crop_size_mult"].connectTo(sources["crop_size_mult"])
		} else {
			this.sockets.inputs["crop_size_mult"].value = sources["crop_size_mult"]
		}

		if (typeof sources["bbox_smooth_alpha"] === "object") {
			this.sockets.inputs["bbox_smooth_alpha"].connectTo(sources["bbox_smooth_alpha"])
		} else {
			this.sockets.inputs["bbox_smooth_alpha"].value = sources["bbox_smooth_alpha"]
		}

	}
}

type BatchCropFromMaskInputs = {
			"original_images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"masks": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"crop_size_mult": ComfyNodeTypedInputRef<number>
			"bbox_smooth_alpha": ComfyNodeTypedInputRef<number>
}


export class BatchCropFromMaskAdvanced extends ComfyNode {
	classType: string = "BatchCropFromMaskAdvanced"

	sockets: {
		inputs: Required<BatchCropFromMaskAdvancedInputs>
		outputs: {
			original_images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			cropped_images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			cropped_masks: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			combined_crop_image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			combined_crop_masks: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			bboxes: ComfyNodeTypedSourceRef<ComfyValueType_BBOX>
			combined_bounding_box: ComfyNodeTypedSourceRef<ComfyValueType_BBOX>
			bbox_width: ComfyNodeTypedSourceRef<number>
			bbox_height: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"original_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "original_images"),
				"masks": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "masks"),
				"crop_size_mult": new ComfyNodeTypedInputRef<number>(this, "crop_size_mult"),
				"bbox_smooth_alpha": new ComfyNodeTypedInputRef<number>(this, "bbox_smooth_alpha"),
			},
			outputs: Object.create(Object.prototype, {
				"original_images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"cropped_images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"cropped_masks": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"combined_crop_image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
				"combined_crop_masks": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 4 }
					}
				},
				"bboxes": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 5 }
					}
				},
				"combined_bounding_box": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 6 }
					}
				},
				"bbox_width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 7 }
					}
				},
				"bbox_height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 8 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<BatchCropFromMaskAdvancedInputs>) {
		if (typeof sources["original_images"] === "object") {
			this.sockets.inputs["original_images"].connectTo(sources["original_images"])
		} else {
			this.sockets.inputs["original_images"].value = sources["original_images"]
		}

		if (typeof sources["masks"] === "object") {
			this.sockets.inputs["masks"].connectTo(sources["masks"])
		} else {
			this.sockets.inputs["masks"].value = sources["masks"]
		}

		if (typeof sources["crop_size_mult"] === "object") {
			this.sockets.inputs["crop_size_mult"].connectTo(sources["crop_size_mult"])
		} else {
			this.sockets.inputs["crop_size_mult"].value = sources["crop_size_mult"]
		}

		if (typeof sources["bbox_smooth_alpha"] === "object") {
			this.sockets.inputs["bbox_smooth_alpha"].connectTo(sources["bbox_smooth_alpha"])
		} else {
			this.sockets.inputs["bbox_smooth_alpha"].value = sources["bbox_smooth_alpha"]
		}

	}
}

type BatchCropFromMaskAdvancedInputs = {
			"original_images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"masks": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"crop_size_mult": ComfyNodeTypedInputRef<number>
			"bbox_smooth_alpha": ComfyNodeTypedInputRef<number>
}


export class FilterZeroMasksAndCorrespondingImages extends ComfyNode {
	classType: string = "FilterZeroMasksAndCorrespondingImages"

	sockets: {
		inputs: Required<FilterZeroMasksAndCorrespondingImagesInputs>
		outputs: {
			non_zero_masks_out: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			non_zero_mask_images_out: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			zero_mask_images_out: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			zero_mask_images_out_indexes: ComfyNodeTypedSourceRef<ComfyValueType_INDEXES>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"masks": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "masks"),
				"original_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "original_images"),
			},
			outputs: Object.create(Object.prototype, {
				"non_zero_masks_out": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"non_zero_mask_images_out": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"zero_mask_images_out": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"zero_mask_images_out_indexes": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<FilterZeroMasksAndCorrespondingImagesInputs>) {
		if (typeof sources["masks"] === "object") {
			this.sockets.inputs["masks"].connectTo(sources["masks"])
		} else {
			this.sockets.inputs["masks"].value = sources["masks"]
		}

		if (sources["original_images"] !== undefined) {
		if (typeof sources["original_images"] === "object") {
			this.sockets.inputs["original_images"].connectTo(sources["original_images"])
		} else {
			this.sockets.inputs["original_images"].value = sources["original_images"]
		}
		}

	}
}

type FilterZeroMasksAndCorrespondingImagesInputs = {
			"masks": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"original_images"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class InsertImageBatchByIndexes extends ComfyNode {
	classType: string = "InsertImageBatchByIndexes"

	sockets: {
		inputs: Required<InsertImageBatchByIndexesInputs>
		outputs: {
			images_after_insert: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"images_to_insert": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images_to_insert"),
				"insert_indexes": new ComfyNodeTypedInputRef<ComfyValueType_INDEXES>(this, "insert_indexes"),
			},
			outputs: Object.create(Object.prototype, {
				"images_after_insert": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<InsertImageBatchByIndexesInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["images_to_insert"] === "object") {
			this.sockets.inputs["images_to_insert"].connectTo(sources["images_to_insert"])
		} else {
			this.sockets.inputs["images_to_insert"].value = sources["images_to_insert"]
		}

		if (typeof sources["insert_indexes"] === "object") {
			this.sockets.inputs["insert_indexes"].connectTo(sources["insert_indexes"])
		} else {
			this.sockets.inputs["insert_indexes"].value = sources["insert_indexes"]
		}

	}
}

type InsertImageBatchByIndexesInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"images_to_insert": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"insert_indexes": ComfyNodeTypedInputRef<ComfyValueType_INDEXES>
}


export class BatchUncrop extends ComfyNode {
	classType: string = "BatchUncrop"

	sockets: {
		inputs: Required<BatchUncropInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"original_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "original_images"),
				"cropped_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "cropped_images"),
				"bboxes": new ComfyNodeTypedInputRef<ComfyValueType_BBOX>(this, "bboxes"),
				"border_blending": new ComfyNodeTypedInputRef<number>(this, "border_blending"),
				"crop_rescale": new ComfyNodeTypedInputRef<number>(this, "crop_rescale"),
				"border_top": new ComfyNodeTypedInputRef<boolean>(this, "border_top"),
				"border_bottom": new ComfyNodeTypedInputRef<boolean>(this, "border_bottom"),
				"border_left": new ComfyNodeTypedInputRef<boolean>(this, "border_left"),
				"border_right": new ComfyNodeTypedInputRef<boolean>(this, "border_right"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<BatchUncropInputs>) {
		if (typeof sources["original_images"] === "object") {
			this.sockets.inputs["original_images"].connectTo(sources["original_images"])
		} else {
			this.sockets.inputs["original_images"].value = sources["original_images"]
		}

		if (typeof sources["cropped_images"] === "object") {
			this.sockets.inputs["cropped_images"].connectTo(sources["cropped_images"])
		} else {
			this.sockets.inputs["cropped_images"].value = sources["cropped_images"]
		}

		if (typeof sources["bboxes"] === "object") {
			this.sockets.inputs["bboxes"].connectTo(sources["bboxes"])
		} else {
			this.sockets.inputs["bboxes"].value = sources["bboxes"]
		}

		if (typeof sources["border_blending"] === "object") {
			this.sockets.inputs["border_blending"].connectTo(sources["border_blending"])
		} else {
			this.sockets.inputs["border_blending"].value = sources["border_blending"]
		}

		if (typeof sources["crop_rescale"] === "object") {
			this.sockets.inputs["crop_rescale"].connectTo(sources["crop_rescale"])
		} else {
			this.sockets.inputs["crop_rescale"].value = sources["crop_rescale"]
		}

		if (typeof sources["border_top"] === "object") {
			this.sockets.inputs["border_top"].connectTo(sources["border_top"])
		} else {
			this.sockets.inputs["border_top"].value = sources["border_top"]
		}

		if (typeof sources["border_bottom"] === "object") {
			this.sockets.inputs["border_bottom"].connectTo(sources["border_bottom"])
		} else {
			this.sockets.inputs["border_bottom"].value = sources["border_bottom"]
		}

		if (typeof sources["border_left"] === "object") {
			this.sockets.inputs["border_left"].connectTo(sources["border_left"])
		} else {
			this.sockets.inputs["border_left"].value = sources["border_left"]
		}

		if (typeof sources["border_right"] === "object") {
			this.sockets.inputs["border_right"].connectTo(sources["border_right"])
		} else {
			this.sockets.inputs["border_right"].value = sources["border_right"]
		}

	}
}

type BatchUncropInputs = {
			"original_images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"cropped_images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"bboxes": ComfyNodeTypedInputRef<ComfyValueType_BBOX>
			"border_blending": ComfyNodeTypedInputRef<number>
			"crop_rescale": ComfyNodeTypedInputRef<number>
			"border_top": ComfyNodeTypedInputRef<boolean>
			"border_bottom": ComfyNodeTypedInputRef<boolean>
			"border_left": ComfyNodeTypedInputRef<boolean>
			"border_right": ComfyNodeTypedInputRef<boolean>
}


export class BatchUncropAdvanced extends ComfyNode {
	classType: string = "BatchUncropAdvanced"

	sockets: {
		inputs: Required<BatchUncropAdvancedInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"original_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "original_images"),
				"cropped_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "cropped_images"),
				"cropped_masks": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "cropped_masks"),
				"combined_crop_mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "combined_crop_mask"),
				"bboxes": new ComfyNodeTypedInputRef<ComfyValueType_BBOX>(this, "bboxes"),
				"border_blending": new ComfyNodeTypedInputRef<number>(this, "border_blending"),
				"crop_rescale": new ComfyNodeTypedInputRef<number>(this, "crop_rescale"),
				"use_combined_mask": new ComfyNodeTypedInputRef<boolean>(this, "use_combined_mask"),
				"use_square_mask": new ComfyNodeTypedInputRef<boolean>(this, "use_square_mask"),
				"combined_bounding_box": new ComfyNodeTypedInputRef<ComfyValueType_BBOX>(this, "combined_bounding_box"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<BatchUncropAdvancedInputs>) {
		if (typeof sources["original_images"] === "object") {
			this.sockets.inputs["original_images"].connectTo(sources["original_images"])
		} else {
			this.sockets.inputs["original_images"].value = sources["original_images"]
		}

		if (typeof sources["cropped_images"] === "object") {
			this.sockets.inputs["cropped_images"].connectTo(sources["cropped_images"])
		} else {
			this.sockets.inputs["cropped_images"].value = sources["cropped_images"]
		}

		if (typeof sources["cropped_masks"] === "object") {
			this.sockets.inputs["cropped_masks"].connectTo(sources["cropped_masks"])
		} else {
			this.sockets.inputs["cropped_masks"].value = sources["cropped_masks"]
		}

		if (typeof sources["combined_crop_mask"] === "object") {
			this.sockets.inputs["combined_crop_mask"].connectTo(sources["combined_crop_mask"])
		} else {
			this.sockets.inputs["combined_crop_mask"].value = sources["combined_crop_mask"]
		}

		if (typeof sources["bboxes"] === "object") {
			this.sockets.inputs["bboxes"].connectTo(sources["bboxes"])
		} else {
			this.sockets.inputs["bboxes"].value = sources["bboxes"]
		}

		if (typeof sources["border_blending"] === "object") {
			this.sockets.inputs["border_blending"].connectTo(sources["border_blending"])
		} else {
			this.sockets.inputs["border_blending"].value = sources["border_blending"]
		}

		if (typeof sources["crop_rescale"] === "object") {
			this.sockets.inputs["crop_rescale"].connectTo(sources["crop_rescale"])
		} else {
			this.sockets.inputs["crop_rescale"].value = sources["crop_rescale"]
		}

		if (typeof sources["use_combined_mask"] === "object") {
			this.sockets.inputs["use_combined_mask"].connectTo(sources["use_combined_mask"])
		} else {
			this.sockets.inputs["use_combined_mask"].value = sources["use_combined_mask"]
		}

		if (typeof sources["use_square_mask"] === "object") {
			this.sockets.inputs["use_square_mask"].connectTo(sources["use_square_mask"])
		} else {
			this.sockets.inputs["use_square_mask"].value = sources["use_square_mask"]
		}

		if (sources["combined_bounding_box"] !== undefined) {
		if (typeof sources["combined_bounding_box"] === "object") {
			this.sockets.inputs["combined_bounding_box"].connectTo(sources["combined_bounding_box"])
		} else {
			this.sockets.inputs["combined_bounding_box"].value = sources["combined_bounding_box"]
		}
		}

	}
}

type BatchUncropAdvancedInputs = {
			"original_images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"cropped_images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"cropped_masks": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"combined_crop_mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"bboxes": ComfyNodeTypedInputRef<ComfyValueType_BBOX>
			"border_blending": ComfyNodeTypedInputRef<number>
			"crop_rescale": ComfyNodeTypedInputRef<number>
			"use_combined_mask": ComfyNodeTypedInputRef<boolean>
			"use_square_mask": ComfyNodeTypedInputRef<boolean>
			"combined_bounding_box"?: ComfyNodeTypedInputRef<ComfyValueType_BBOX>
}


export class SplitBboxes extends ComfyNode {
	classType: string = "SplitBboxes"

	sockets: {
		inputs: Required<SplitBboxesInputs>
		outputs: {
			bboxes_a: ComfyNodeTypedSourceRef<ComfyValueType_BBOX>
			bboxes_b: ComfyNodeTypedSourceRef<ComfyValueType_BBOX>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"bboxes": new ComfyNodeTypedInputRef<ComfyValueType_BBOX>(this, "bboxes"),
				"index": new ComfyNodeTypedInputRef<number>(this, "index"),
			},
			outputs: Object.create(Object.prototype, {
				"bboxes_a": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"bboxes_b": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SplitBboxesInputs>) {
		if (typeof sources["bboxes"] === "object") {
			this.sockets.inputs["bboxes"].connectTo(sources["bboxes"])
		} else {
			this.sockets.inputs["bboxes"].value = sources["bboxes"]
		}

		if (typeof sources["index"] === "object") {
			this.sockets.inputs["index"].connectTo(sources["index"])
		} else {
			this.sockets.inputs["index"].value = sources["index"]
		}

	}
}

type SplitBboxesInputs = {
			"bboxes": ComfyNodeTypedInputRef<ComfyValueType_BBOX>
			"index": ComfyNodeTypedInputRef<number>
}


export class BboxToInt extends ComfyNode {
	classType: string = "BboxToInt"

	sockets: {
		inputs: Required<BboxToIntInputs>
		outputs: {
			x_min: ComfyNodeTypedSourceRef<number>
			y_min: ComfyNodeTypedSourceRef<number>
			width: ComfyNodeTypedSourceRef<number>
			height: ComfyNodeTypedSourceRef<number>
			center_x: ComfyNodeTypedSourceRef<number>
			center_y: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"bboxes": new ComfyNodeTypedInputRef<ComfyValueType_BBOX>(this, "bboxes"),
				"index": new ComfyNodeTypedInputRef<number>(this, "index"),
			},
			outputs: Object.create(Object.prototype, {
				"x_min": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"y_min": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
				"center_x": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 4 }
					}
				},
				"center_y": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 5 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<BboxToIntInputs>) {
		if (typeof sources["bboxes"] === "object") {
			this.sockets.inputs["bboxes"].connectTo(sources["bboxes"])
		} else {
			this.sockets.inputs["bboxes"].value = sources["bboxes"]
		}

		if (typeof sources["index"] === "object") {
			this.sockets.inputs["index"].connectTo(sources["index"])
		} else {
			this.sockets.inputs["index"].value = sources["index"]
		}

	}
}

type BboxToIntInputs = {
			"bboxes": ComfyNodeTypedInputRef<ComfyValueType_BBOX>
			"index": ComfyNodeTypedInputRef<number>
}


export class BboxVisualize extends ComfyNode {
	classType: string = "BboxVisualize"

	sockets: {
		inputs: Required<BboxVisualizeInputs>
		outputs: {
			images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"bboxes": new ComfyNodeTypedInputRef<ComfyValueType_BBOX>(this, "bboxes"),
				"line_width": new ComfyNodeTypedInputRef<number>(this, "line_width"),
				"bbox_format": new ComfyNodeTypedInputRef<string>(this, "bbox_format"),
			},
			outputs: Object.create(Object.prototype, {
				"images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<BboxVisualizeInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["bboxes"] === "object") {
			this.sockets.inputs["bboxes"].connectTo(sources["bboxes"])
		} else {
			this.sockets.inputs["bboxes"].value = sources["bboxes"]
		}

		if (typeof sources["line_width"] === "object") {
			this.sockets.inputs["line_width"].connectTo(sources["line_width"])
		} else {
			this.sockets.inputs["line_width"].value = sources["line_width"]
		}

		if (typeof sources["bbox_format"] === "object") {
			this.sockets.inputs["bbox_format"].connectTo(sources["bbox_format"])
		} else {
			this.sockets.inputs["bbox_format"].value = sources["bbox_format"]
		}

	}
}

type BboxVisualizeInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"bboxes": ComfyNodeTypedInputRef<ComfyValueType_BBOX>
			"line_width": ComfyNodeTypedInputRef<number>
			"bbox_format": ComfyNodeTypedInputRef<string>
}


export class GenerateNoise extends ComfyNode {
	classType: string = "GenerateNoise"

	sockets: {
		inputs: Required<GenerateNoiseInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"seed": new ComfyNodeTypedInputRef<number>(this, "seed"),
				"multiplier": new ComfyNodeTypedInputRef<number>(this, "multiplier"),
				"constant_batch_noise": new ComfyNodeTypedInputRef<boolean>(this, "constant_batch_noise"),
				"normalize": new ComfyNodeTypedInputRef<boolean>(this, "normalize"),
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"sigmas": new ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>(this, "sigmas"),
				"latent_channels": new ComfyNodeTypedInputRef<string>(this, "latent_channels"),
				"shape": new ComfyNodeTypedInputRef<string>(this, "shape"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<GenerateNoiseInputs>) {
		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (typeof sources["seed"] === "object") {
			this.sockets.inputs["seed"].connectTo(sources["seed"])
		} else {
			this.sockets.inputs["seed"].value = sources["seed"]
		}

		if (typeof sources["multiplier"] === "object") {
			this.sockets.inputs["multiplier"].connectTo(sources["multiplier"])
		} else {
			this.sockets.inputs["multiplier"].value = sources["multiplier"]
		}

		if (typeof sources["constant_batch_noise"] === "object") {
			this.sockets.inputs["constant_batch_noise"].connectTo(sources["constant_batch_noise"])
		} else {
			this.sockets.inputs["constant_batch_noise"].value = sources["constant_batch_noise"]
		}

		if (typeof sources["normalize"] === "object") {
			this.sockets.inputs["normalize"].connectTo(sources["normalize"])
		} else {
			this.sockets.inputs["normalize"].value = sources["normalize"]
		}

		if (sources["model"] !== undefined) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}
		}

		if (sources["sigmas"] !== undefined) {
		if (typeof sources["sigmas"] === "object") {
			this.sockets.inputs["sigmas"].connectTo(sources["sigmas"])
		} else {
			this.sockets.inputs["sigmas"].value = sources["sigmas"]
		}
		}

		if (sources["latent_channels"] !== undefined) {
		if (typeof sources["latent_channels"] === "object") {
			this.sockets.inputs["latent_channels"].connectTo(sources["latent_channels"])
		} else {
			this.sockets.inputs["latent_channels"].value = sources["latent_channels"]
		}
		}

		if (sources["shape"] !== undefined) {
		if (typeof sources["shape"] === "object") {
			this.sockets.inputs["shape"].connectTo(sources["shape"])
		} else {
			this.sockets.inputs["shape"].value = sources["shape"]
		}
		}

	}
}

type GenerateNoiseInputs = {
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"seed": ComfyNodeTypedInputRef<number>
			"multiplier": ComfyNodeTypedInputRef<number>
			"constant_batch_noise": ComfyNodeTypedInputRef<boolean>
			"normalize": ComfyNodeTypedInputRef<boolean>
			"model"?: ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"sigmas"?: ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>
			"latent_channels"?: ComfyNodeTypedInputRef<string>
			"shape"?: ComfyNodeTypedInputRef<string>
}


export class FlipSigmasAdjusted extends ComfyNode {
	classType: string = "FlipSigmasAdjusted"

	sockets: {
		inputs: Required<FlipSigmasAdjustedInputs>
		outputs: {
			SIGMAS: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
			sigmas_string: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"sigmas": new ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>(this, "sigmas"),
				"divide_by_last_sigma": new ComfyNodeTypedInputRef<boolean>(this, "divide_by_last_sigma"),
				"divide_by": new ComfyNodeTypedInputRef<number>(this, "divide_by"),
				"offset_by": new ComfyNodeTypedInputRef<number>(this, "offset_by"),
			},
			outputs: Object.create(Object.prototype, {
				"SIGMAS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"sigmas_string": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<FlipSigmasAdjustedInputs>) {
		if (typeof sources["sigmas"] === "object") {
			this.sockets.inputs["sigmas"].connectTo(sources["sigmas"])
		} else {
			this.sockets.inputs["sigmas"].value = sources["sigmas"]
		}

		if (typeof sources["divide_by_last_sigma"] === "object") {
			this.sockets.inputs["divide_by_last_sigma"].connectTo(sources["divide_by_last_sigma"])
		} else {
			this.sockets.inputs["divide_by_last_sigma"].value = sources["divide_by_last_sigma"]
		}

		if (typeof sources["divide_by"] === "object") {
			this.sockets.inputs["divide_by"].connectTo(sources["divide_by"])
		} else {
			this.sockets.inputs["divide_by"].value = sources["divide_by"]
		}

		if (typeof sources["offset_by"] === "object") {
			this.sockets.inputs["offset_by"].connectTo(sources["offset_by"])
		} else {
			this.sockets.inputs["offset_by"].value = sources["offset_by"]
		}

	}
}

type FlipSigmasAdjustedInputs = {
			"sigmas": ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>
			"divide_by_last_sigma": ComfyNodeTypedInputRef<boolean>
			"divide_by": ComfyNodeTypedInputRef<number>
			"offset_by": ComfyNodeTypedInputRef<number>
}


export class InjectNoiseToLatent extends ComfyNode {
	classType: string = "InjectNoiseToLatent"

	sockets: {
		inputs: Required<InjectNoiseToLatentInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latents"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"noise": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "noise"),
				"normalize": new ComfyNodeTypedInputRef<boolean>(this, "normalize"),
				"average": new ComfyNodeTypedInputRef<boolean>(this, "average"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"mix_randn_amount": new ComfyNodeTypedInputRef<number>(this, "mix_randn_amount"),
				"seed": new ComfyNodeTypedInputRef<number>(this, "seed"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<InjectNoiseToLatentInputs>) {
		if (typeof sources["latents"] === "object") {
			this.sockets.inputs["latents"].connectTo(sources["latents"])
		} else {
			this.sockets.inputs["latents"].value = sources["latents"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (typeof sources["noise"] === "object") {
			this.sockets.inputs["noise"].connectTo(sources["noise"])
		} else {
			this.sockets.inputs["noise"].value = sources["noise"]
		}

		if (typeof sources["normalize"] === "object") {
			this.sockets.inputs["normalize"].connectTo(sources["normalize"])
		} else {
			this.sockets.inputs["normalize"].value = sources["normalize"]
		}

		if (typeof sources["average"] === "object") {
			this.sockets.inputs["average"].connectTo(sources["average"])
		} else {
			this.sockets.inputs["average"].value = sources["average"]
		}

		if (sources["mask"] !== undefined) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}
		}

		if (sources["mix_randn_amount"] !== undefined) {
		if (typeof sources["mix_randn_amount"] === "object") {
			this.sockets.inputs["mix_randn_amount"].connectTo(sources["mix_randn_amount"])
		} else {
			this.sockets.inputs["mix_randn_amount"].value = sources["mix_randn_amount"]
		}
		}

		if (sources["seed"] !== undefined) {
		if (typeof sources["seed"] === "object") {
			this.sockets.inputs["seed"].connectTo(sources["seed"])
		} else {
			this.sockets.inputs["seed"].value = sources["seed"]
		}
		}

	}
}

type InjectNoiseToLatentInputs = {
			"latents": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"strength": ComfyNodeTypedInputRef<number>
			"noise": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"normalize": ComfyNodeTypedInputRef<boolean>
			"average": ComfyNodeTypedInputRef<boolean>
			"mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"mix_randn_amount"?: ComfyNodeTypedInputRef<number>
			"seed"?: ComfyNodeTypedInputRef<number>
}


export class CustomSigmas extends ComfyNode {
	classType: string = "CustomSigmas"

	sockets: {
		inputs: Required<CustomSigmasInputs>
		outputs: {
			SIGMAS: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"sigmas_string": new ComfyNodeTypedInputRef<string>(this, "sigmas_string"),
				"interpolate_to_steps": new ComfyNodeTypedInputRef<number>(this, "interpolate_to_steps"),
			},
			outputs: Object.create(Object.prototype, {
				"SIGMAS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CustomSigmasInputs>) {
		if (typeof sources["sigmas_string"] === "object") {
			this.sockets.inputs["sigmas_string"].connectTo(sources["sigmas_string"])
		} else {
			this.sockets.inputs["sigmas_string"].value = sources["sigmas_string"]
		}

		if (typeof sources["interpolate_to_steps"] === "object") {
			this.sockets.inputs["interpolate_to_steps"].connectTo(sources["interpolate_to_steps"])
		} else {
			this.sockets.inputs["interpolate_to_steps"].value = sources["interpolate_to_steps"]
		}

	}
}

type CustomSigmasInputs = {
			"sigmas_string": ComfyNodeTypedInputRef<string>
			"interpolate_to_steps": ComfyNodeTypedInputRef<number>
}


export class StringToFloatList extends ComfyNode {
	classType: string = "StringToFloatList"

	sockets: {
		inputs: Required<StringToFloatListInputs>
		outputs: {
			FLOAT: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"string": new ComfyNodeTypedInputRef<string>(this, "string"),
			},
			outputs: Object.create(Object.prototype, {
				"FLOAT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<StringToFloatListInputs>) {
		if (typeof sources["string"] === "object") {
			this.sockets.inputs["string"].connectTo(sources["string"])
		} else {
			this.sockets.inputs["string"].value = sources["string"]
		}

	}
}

type StringToFloatListInputs = {
			"string": ComfyNodeTypedInputRef<string>
}


export class WidgetToString extends ComfyNode {
	classType: string = "WidgetToString"

	sockets: {
		inputs: Required<WidgetToStringInputs>
		outputs: {
			STRING: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"id": new ComfyNodeTypedInputRef<number>(this, "id"),
				"widget_name": new ComfyNodeTypedInputRef<string>(this, "widget_name"),
				"return_all": new ComfyNodeTypedInputRef<boolean>(this, "return_all"),
				"any_input": new ComfyNodeTypedInputRef<ComfyValueType_$STAR>(this, "any_input"),
				"node_title": new ComfyNodeTypedInputRef<string>(this, "node_title"),
				"allowed_float_decimals": new ComfyNodeTypedInputRef<number>(this, "allowed_float_decimals"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_E>(this, "extra_pnginfo"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"unique_id": new ComfyNodeTypedInputRef<ComfyValueType_U>(this, "unique_id"),
			},
			outputs: Object.create(Object.prototype, {
				"STRING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WidgetToStringInputs>) {
		if (typeof sources["id"] === "object") {
			this.sockets.inputs["id"].connectTo(sources["id"])
		} else {
			this.sockets.inputs["id"].value = sources["id"]
		}

		if (typeof sources["widget_name"] === "object") {
			this.sockets.inputs["widget_name"].connectTo(sources["widget_name"])
		} else {
			this.sockets.inputs["widget_name"].value = sources["widget_name"]
		}

		if (typeof sources["return_all"] === "object") {
			this.sockets.inputs["return_all"].connectTo(sources["return_all"])
		} else {
			this.sockets.inputs["return_all"].value = sources["return_all"]
		}

		if (sources["any_input"] !== undefined) {
		if (typeof sources["any_input"] === "object") {
			this.sockets.inputs["any_input"].connectTo(sources["any_input"])
		} else {
			this.sockets.inputs["any_input"].value = sources["any_input"]
		}
		}

		if (sources["node_title"] !== undefined) {
		if (typeof sources["node_title"] === "object") {
			this.sockets.inputs["node_title"].connectTo(sources["node_title"])
		} else {
			this.sockets.inputs["node_title"].value = sources["node_title"]
		}
		}

		if (sources["allowed_float_decimals"] !== undefined) {
		if (typeof sources["allowed_float_decimals"] === "object") {
			this.sockets.inputs["allowed_float_decimals"].connectTo(sources["allowed_float_decimals"])
		} else {
			this.sockets.inputs["allowed_float_decimals"].value = sources["allowed_float_decimals"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["unique_id"] !== undefined) {
		if (typeof sources["unique_id"] === "object") {
			this.sockets.inputs["unique_id"].connectTo(sources["unique_id"])
		} else {
			this.sockets.inputs["unique_id"].value = sources["unique_id"]
		}
		}

	}
}

type WidgetToStringInputs = {
			"id": ComfyNodeTypedInputRef<number>
			"widget_name": ComfyNodeTypedInputRef<string>
			"return_all": ComfyNodeTypedInputRef<boolean>
			"any_input"?: ComfyNodeTypedInputRef<ComfyValueType_$STAR>
			"node_title"?: ComfyNodeTypedInputRef<string>
			/** Number of decimal places to display for float values*/
			"allowed_float_decimals"?: ComfyNodeTypedInputRef<number>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_E>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"unique_id"?: ComfyNodeTypedInputRef<ComfyValueType_U>
}


export class SaveStringKJ extends ComfyNode {
	classType: string = "SaveStringKJ"

	sockets: {
		inputs: Required<SaveStringKJInputs>
		outputs: {
			filename: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"string": new ComfyNodeTypedInputRef<string>(this, "string"),
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"output_folder": new ComfyNodeTypedInputRef<string>(this, "output_folder"),
				"file_extension": new ComfyNodeTypedInputRef<string>(this, "file_extension"),
			},
			outputs: Object.create(Object.prototype, {
				"filename": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SaveStringKJInputs>) {
		if (typeof sources["string"] === "object") {
			this.sockets.inputs["string"].connectTo(sources["string"])
		} else {
			this.sockets.inputs["string"].value = sources["string"]
		}

		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (typeof sources["output_folder"] === "object") {
			this.sockets.inputs["output_folder"].connectTo(sources["output_folder"])
		} else {
			this.sockets.inputs["output_folder"].value = sources["output_folder"]
		}

		if (sources["file_extension"] !== undefined) {
		if (typeof sources["file_extension"] === "object") {
			this.sockets.inputs["file_extension"].connectTo(sources["file_extension"])
		} else {
			this.sockets.inputs["file_extension"].value = sources["file_extension"]
		}
		}

	}
}

type SaveStringKJInputs = {
			/** string to save as .txt file*/
			"string": ComfyNodeTypedInputRef<string>
			/** The prefix for the file to save. This may include formatting information such as %date:yyyy-MM-dd% or %Empty Latent Image.width% to include values from nodes.*/
			"filename_prefix": ComfyNodeTypedInputRef<string>
			/** The folder to save the images to.*/
			"output_folder": ComfyNodeTypedInputRef<string>
			/** The extension for the caption file.*/
			"file_extension"?: ComfyNodeTypedInputRef<string>
}


export class DummyOut extends ComfyNode {
	classType: string = "DummyOut"

	sockets: {
		inputs: Required<DummyOutInputs>
		outputs: {
			_: ComfyNodeTypedSourceRef<ComfyValueType_$STAR>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"any_input": new ComfyNodeTypedInputRef<ComfyValueType_$STAR>(this, "any_input"),
			},
			outputs: Object.create(Object.prototype, {
				"*": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DummyOutInputs>) {
		if (typeof sources["any_input"] === "object") {
			this.sockets.inputs["any_input"].connectTo(sources["any_input"])
		} else {
			this.sockets.inputs["any_input"].value = sources["any_input"]
		}

	}
}

type DummyOutInputs = {
			"any_input": ComfyNodeTypedInputRef<ComfyValueType_$STAR>
}


export class GetLatentsFromBatchIndexed extends ComfyNode {
	classType: string = "GetLatentsFromBatchIndexed"

	sockets: {
		inputs: Required<GetLatentsFromBatchIndexedInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latents"),
				"indexes": new ComfyNodeTypedInputRef<string>(this, "indexes"),
				"latent_format": new ComfyNodeTypedInputRef<string>(this, "latent_format"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<GetLatentsFromBatchIndexedInputs>) {
		if (typeof sources["latents"] === "object") {
			this.sockets.inputs["latents"].connectTo(sources["latents"])
		} else {
			this.sockets.inputs["latents"].value = sources["latents"]
		}

		if (typeof sources["indexes"] === "object") {
			this.sockets.inputs["indexes"].connectTo(sources["indexes"])
		} else {
			this.sockets.inputs["indexes"].value = sources["indexes"]
		}

		if (typeof sources["latent_format"] === "object") {
			this.sockets.inputs["latent_format"].connectTo(sources["latent_format"])
		} else {
			this.sockets.inputs["latent_format"].value = sources["latent_format"]
		}

	}
}

type GetLatentsFromBatchIndexedInputs = {
			"latents": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"indexes": ComfyNodeTypedInputRef<string>
			"latent_format": ComfyNodeTypedInputRef<string>
}


export class ScaleBatchPromptSchedule extends ComfyNode {
	classType: string = "ScaleBatchPromptSchedule"

	sockets: {
		inputs: Required<ScaleBatchPromptScheduleInputs>
		outputs: {
			STRING: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"input_str": new ComfyNodeTypedInputRef<string>(this, "input_str"),
				"old_frame_count": new ComfyNodeTypedInputRef<number>(this, "old_frame_count"),
				"new_frame_count": new ComfyNodeTypedInputRef<number>(this, "new_frame_count"),
			},
			outputs: Object.create(Object.prototype, {
				"STRING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ScaleBatchPromptScheduleInputs>) {
		if (typeof sources["input_str"] === "object") {
			this.sockets.inputs["input_str"].connectTo(sources["input_str"])
		} else {
			this.sockets.inputs["input_str"].value = sources["input_str"]
		}

		if (typeof sources["old_frame_count"] === "object") {
			this.sockets.inputs["old_frame_count"].connectTo(sources["old_frame_count"])
		} else {
			this.sockets.inputs["old_frame_count"].value = sources["old_frame_count"]
		}

		if (typeof sources["new_frame_count"] === "object") {
			this.sockets.inputs["new_frame_count"].connectTo(sources["new_frame_count"])
		} else {
			this.sockets.inputs["new_frame_count"].value = sources["new_frame_count"]
		}

	}
}

type ScaleBatchPromptScheduleInputs = {
			"input_str": ComfyNodeTypedInputRef<string>
			"old_frame_count": ComfyNodeTypedInputRef<number>
			"new_frame_count": ComfyNodeTypedInputRef<number>
}


export class CameraPoseVisualizer extends ComfyNode {
	classType: string = "CameraPoseVisualizer"

	sockets: {
		inputs: Required<CameraPoseVisualizerInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"pose_file_path": new ComfyNodeTypedInputRef<string>(this, "pose_file_path"),
				"base_xval": new ComfyNodeTypedInputRef<number>(this, "base_xval"),
				"zval": new ComfyNodeTypedInputRef<number>(this, "zval"),
				"scale": new ComfyNodeTypedInputRef<number>(this, "scale"),
				"use_exact_fx": new ComfyNodeTypedInputRef<boolean>(this, "use_exact_fx"),
				"relative_c2w": new ComfyNodeTypedInputRef<boolean>(this, "relative_c2w"),
				"use_viewer": new ComfyNodeTypedInputRef<boolean>(this, "use_viewer"),
				"cameractrl_poses": new ComfyNodeTypedInputRef<ComfyValueType_CAMERACTRL_POSES>(this, "cameractrl_poses"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CameraPoseVisualizerInputs>) {
		if (typeof sources["pose_file_path"] === "object") {
			this.sockets.inputs["pose_file_path"].connectTo(sources["pose_file_path"])
		} else {
			this.sockets.inputs["pose_file_path"].value = sources["pose_file_path"]
		}

		if (typeof sources["base_xval"] === "object") {
			this.sockets.inputs["base_xval"].connectTo(sources["base_xval"])
		} else {
			this.sockets.inputs["base_xval"].value = sources["base_xval"]
		}

		if (typeof sources["zval"] === "object") {
			this.sockets.inputs["zval"].connectTo(sources["zval"])
		} else {
			this.sockets.inputs["zval"].value = sources["zval"]
		}

		if (typeof sources["scale"] === "object") {
			this.sockets.inputs["scale"].connectTo(sources["scale"])
		} else {
			this.sockets.inputs["scale"].value = sources["scale"]
		}

		if (typeof sources["use_exact_fx"] === "object") {
			this.sockets.inputs["use_exact_fx"].connectTo(sources["use_exact_fx"])
		} else {
			this.sockets.inputs["use_exact_fx"].value = sources["use_exact_fx"]
		}

		if (typeof sources["relative_c2w"] === "object") {
			this.sockets.inputs["relative_c2w"].connectTo(sources["relative_c2w"])
		} else {
			this.sockets.inputs["relative_c2w"].value = sources["relative_c2w"]
		}

		if (typeof sources["use_viewer"] === "object") {
			this.sockets.inputs["use_viewer"].connectTo(sources["use_viewer"])
		} else {
			this.sockets.inputs["use_viewer"].value = sources["use_viewer"]
		}

		if (sources["cameractrl_poses"] !== undefined) {
		if (typeof sources["cameractrl_poses"] === "object") {
			this.sockets.inputs["cameractrl_poses"].connectTo(sources["cameractrl_poses"])
		} else {
			this.sockets.inputs["cameractrl_poses"].value = sources["cameractrl_poses"]
		}
		}

	}
}

type CameraPoseVisualizerInputs = {
			"pose_file_path": ComfyNodeTypedInputRef<string>
			"base_xval": ComfyNodeTypedInputRef<number>
			"zval": ComfyNodeTypedInputRef<number>
			"scale": ComfyNodeTypedInputRef<number>
			"use_exact_fx": ComfyNodeTypedInputRef<boolean>
			"relative_c2w": ComfyNodeTypedInputRef<boolean>
			"use_viewer": ComfyNodeTypedInputRef<boolean>
			"cameractrl_poses"?: ComfyNodeTypedInputRef<ComfyValueType_CAMERACTRL_POSES>
}


export class AppendStringsToList extends ComfyNode {
	classType: string = "AppendStringsToList"

	sockets: {
		inputs: Required<AppendStringsToListInputs>
		outputs: {
			STRING: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"string1": new ComfyNodeTypedInputRef<string>(this, "string1"),
				"string2": new ComfyNodeTypedInputRef<string>(this, "string2"),
			},
			outputs: Object.create(Object.prototype, {
				"STRING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<AppendStringsToListInputs>) {
		if (typeof sources["string1"] === "object") {
			this.sockets.inputs["string1"].connectTo(sources["string1"])
		} else {
			this.sockets.inputs["string1"].value = sources["string1"]
		}

		if (typeof sources["string2"] === "object") {
			this.sockets.inputs["string2"].connectTo(sources["string2"])
		} else {
			this.sockets.inputs["string2"].value = sources["string2"]
		}

	}
}

type AppendStringsToListInputs = {
			"string1": ComfyNodeTypedInputRef<string>
			"string2": ComfyNodeTypedInputRef<string>
}


export class JoinStrings extends ComfyNode {
	classType: string = "JoinStrings"

	sockets: {
		inputs: Required<JoinStringsInputs>
		outputs: {
			STRING: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"delimiter": new ComfyNodeTypedInputRef<string>(this, "delimiter"),
				"string1": new ComfyNodeTypedInputRef<string>(this, "string1"),
				"string2": new ComfyNodeTypedInputRef<string>(this, "string2"),
			},
			outputs: Object.create(Object.prototype, {
				"STRING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<JoinStringsInputs>) {
		if (typeof sources["delimiter"] === "object") {
			this.sockets.inputs["delimiter"].connectTo(sources["delimiter"])
		} else {
			this.sockets.inputs["delimiter"].value = sources["delimiter"]
		}

		if (sources["string1"] !== undefined) {
		if (typeof sources["string1"] === "object") {
			this.sockets.inputs["string1"].connectTo(sources["string1"])
		} else {
			this.sockets.inputs["string1"].value = sources["string1"]
		}
		}

		if (sources["string2"] !== undefined) {
		if (typeof sources["string2"] === "object") {
			this.sockets.inputs["string2"].connectTo(sources["string2"])
		} else {
			this.sockets.inputs["string2"].value = sources["string2"]
		}
		}

	}
}

type JoinStringsInputs = {
			"delimiter": ComfyNodeTypedInputRef<string>
			"string1"?: ComfyNodeTypedInputRef<string>
			"string2"?: ComfyNodeTypedInputRef<string>
}


export class JoinStringMulti extends ComfyNode {
	classType: string = "JoinStringMulti"

	sockets: {
		inputs: Required<JoinStringMultiInputs>
		outputs: {
			string: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"inputcount": new ComfyNodeTypedInputRef<number>(this, "inputcount"),
				"string_1": new ComfyNodeTypedInputRef<string>(this, "string_1"),
				"delimiter": new ComfyNodeTypedInputRef<string>(this, "delimiter"),
				"return_list": new ComfyNodeTypedInputRef<boolean>(this, "return_list"),
				"string_2": new ComfyNodeTypedInputRef<string>(this, "string_2"),
			},
			outputs: Object.create(Object.prototype, {
				"string": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<JoinStringMultiInputs>) {
		if (typeof sources["inputcount"] === "object") {
			this.sockets.inputs["inputcount"].connectTo(sources["inputcount"])
		} else {
			this.sockets.inputs["inputcount"].value = sources["inputcount"]
		}

		if (typeof sources["string_1"] === "object") {
			this.sockets.inputs["string_1"].connectTo(sources["string_1"])
		} else {
			this.sockets.inputs["string_1"].value = sources["string_1"]
		}

		if (typeof sources["delimiter"] === "object") {
			this.sockets.inputs["delimiter"].connectTo(sources["delimiter"])
		} else {
			this.sockets.inputs["delimiter"].value = sources["delimiter"]
		}

		if (typeof sources["return_list"] === "object") {
			this.sockets.inputs["return_list"].connectTo(sources["return_list"])
		} else {
			this.sockets.inputs["return_list"].value = sources["return_list"]
		}

		if (sources["string_2"] !== undefined) {
		if (typeof sources["string_2"] === "object") {
			this.sockets.inputs["string_2"].connectTo(sources["string_2"])
		} else {
			this.sockets.inputs["string_2"].value = sources["string_2"]
		}
		}

	}
}

type JoinStringMultiInputs = {
			"inputcount": ComfyNodeTypedInputRef<number>
			"string_1": ComfyNodeTypedInputRef<string>
			"delimiter": ComfyNodeTypedInputRef<string>
			"return_list": ComfyNodeTypedInputRef<boolean>
			"string_2"?: ComfyNodeTypedInputRef<string>
}


export class SomethingToString extends ComfyNode {
	classType: string = "SomethingToString"

	sockets: {
		inputs: Required<SomethingToStringInputs>
		outputs: {
			STRING: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"input": new ComfyNodeTypedInputRef<ComfyValueType_$STAR>(this, "input"),
				"prefix": new ComfyNodeTypedInputRef<string>(this, "prefix"),
				"suffix": new ComfyNodeTypedInputRef<string>(this, "suffix"),
			},
			outputs: Object.create(Object.prototype, {
				"STRING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SomethingToStringInputs>) {
		if (typeof sources["input"] === "object") {
			this.sockets.inputs["input"].connectTo(sources["input"])
		} else {
			this.sockets.inputs["input"].value = sources["input"]
		}

		if (sources["prefix"] !== undefined) {
		if (typeof sources["prefix"] === "object") {
			this.sockets.inputs["prefix"].connectTo(sources["prefix"])
		} else {
			this.sockets.inputs["prefix"].value = sources["prefix"]
		}
		}

		if (sources["suffix"] !== undefined) {
		if (typeof sources["suffix"] === "object") {
			this.sockets.inputs["suffix"].connectTo(sources["suffix"])
		} else {
			this.sockets.inputs["suffix"].value = sources["suffix"]
		}
		}

	}
}

type SomethingToStringInputs = {
			"input": ComfyNodeTypedInputRef<ComfyValueType_$STAR>
			"prefix"?: ComfyNodeTypedInputRef<string>
			"suffix"?: ComfyNodeTypedInputRef<string>
}


export class Sleep extends ComfyNode {
	classType: string = "Sleep"

	sockets: {
		inputs: Required<SleepInputs>
		outputs: {
			_: ComfyNodeTypedSourceRef<ComfyValueType_$STAR>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"input": new ComfyNodeTypedInputRef<ComfyValueType_$STAR>(this, "input"),
				"minutes": new ComfyNodeTypedInputRef<number>(this, "minutes"),
				"seconds": new ComfyNodeTypedInputRef<number>(this, "seconds"),
			},
			outputs: Object.create(Object.prototype, {
				"*": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SleepInputs>) {
		if (typeof sources["input"] === "object") {
			this.sockets.inputs["input"].connectTo(sources["input"])
		} else {
			this.sockets.inputs["input"].value = sources["input"]
		}

		if (typeof sources["minutes"] === "object") {
			this.sockets.inputs["minutes"].connectTo(sources["minutes"])
		} else {
			this.sockets.inputs["minutes"].value = sources["minutes"]
		}

		if (typeof sources["seconds"] === "object") {
			this.sockets.inputs["seconds"].connectTo(sources["seconds"])
		} else {
			this.sockets.inputs["seconds"].value = sources["seconds"]
		}

	}
}

type SleepInputs = {
			"input": ComfyNodeTypedInputRef<ComfyValueType_$STAR>
			"minutes": ComfyNodeTypedInputRef<number>
			"seconds": ComfyNodeTypedInputRef<number>
}


export class VRAM_Debug extends ComfyNode {
	classType: string = "VRAM_Debug"

	sockets: {
		inputs: Required<VRAM_DebugInputs>
		outputs: {
			any_output: ComfyNodeTypedSourceRef<ComfyValueType_$STAR>
			image_pass: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			model_pass: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
			freemem_before: ComfyNodeTypedSourceRef<number>
			freemem_after: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"empty_cache": new ComfyNodeTypedInputRef<boolean>(this, "empty_cache"),
				"gc_collect": new ComfyNodeTypedInputRef<boolean>(this, "gc_collect"),
				"unload_all_models": new ComfyNodeTypedInputRef<boolean>(this, "unload_all_models"),
				"any_input": new ComfyNodeTypedInputRef<ComfyValueType_$STAR>(this, "any_input"),
				"image_pass": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image_pass"),
				"model_pass": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model_pass"),
			},
			outputs: Object.create(Object.prototype, {
				"any_output": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"image_pass": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"model_pass": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"freemem_before": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
				"freemem_after": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 4 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VRAM_DebugInputs>) {
		if (typeof sources["empty_cache"] === "object") {
			this.sockets.inputs["empty_cache"].connectTo(sources["empty_cache"])
		} else {
			this.sockets.inputs["empty_cache"].value = sources["empty_cache"]
		}

		if (typeof sources["gc_collect"] === "object") {
			this.sockets.inputs["gc_collect"].connectTo(sources["gc_collect"])
		} else {
			this.sockets.inputs["gc_collect"].value = sources["gc_collect"]
		}

		if (typeof sources["unload_all_models"] === "object") {
			this.sockets.inputs["unload_all_models"].connectTo(sources["unload_all_models"])
		} else {
			this.sockets.inputs["unload_all_models"].value = sources["unload_all_models"]
		}

		if (sources["any_input"] !== undefined) {
		if (typeof sources["any_input"] === "object") {
			this.sockets.inputs["any_input"].connectTo(sources["any_input"])
		} else {
			this.sockets.inputs["any_input"].value = sources["any_input"]
		}
		}

		if (sources["image_pass"] !== undefined) {
		if (typeof sources["image_pass"] === "object") {
			this.sockets.inputs["image_pass"].connectTo(sources["image_pass"])
		} else {
			this.sockets.inputs["image_pass"].value = sources["image_pass"]
		}
		}

		if (sources["model_pass"] !== undefined) {
		if (typeof sources["model_pass"] === "object") {
			this.sockets.inputs["model_pass"].connectTo(sources["model_pass"])
		} else {
			this.sockets.inputs["model_pass"].value = sources["model_pass"]
		}
		}

	}
}

type VRAM_DebugInputs = {
			"empty_cache": ComfyNodeTypedInputRef<boolean>
			"gc_collect": ComfyNodeTypedInputRef<boolean>
			"unload_all_models": ComfyNodeTypedInputRef<boolean>
			"any_input"?: ComfyNodeTypedInputRef<ComfyValueType_$STAR>
			"image_pass"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"model_pass"?: ComfyNodeTypedInputRef<ComfyValueType_MODEL>
}


export class EmptyLatentImagePresets extends ComfyNode {
	classType: string = "EmptyLatentImagePresets"

	sockets: {
		inputs: Required<EmptyLatentImagePresetsInputs>
		outputs: {
			Latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
			Width: ComfyNodeTypedSourceRef<number>
			Height: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"dimensions": new ComfyNodeTypedInputRef<string>(this, "dimensions"),
				"invert": new ComfyNodeTypedInputRef<boolean>(this, "invert"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
			},
			outputs: Object.create(Object.prototype, {
				"Latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"Width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"Height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<EmptyLatentImagePresetsInputs>) {
		if (typeof sources["dimensions"] === "object") {
			this.sockets.inputs["dimensions"].connectTo(sources["dimensions"])
		} else {
			this.sockets.inputs["dimensions"].value = sources["dimensions"]
		}

		if (typeof sources["invert"] === "object") {
			this.sockets.inputs["invert"].connectTo(sources["invert"])
		} else {
			this.sockets.inputs["invert"].value = sources["invert"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

	}
}

type EmptyLatentImagePresetsInputs = {
			"dimensions": ComfyNodeTypedInputRef<string>
			"invert": ComfyNodeTypedInputRef<boolean>
			"batch_size": ComfyNodeTypedInputRef<number>
}


export class EmptyLatentImageCustomPresets extends ComfyNode {
	classType: string = "EmptyLatentImageCustomPresets"

	sockets: {
		inputs: Required<EmptyLatentImageCustomPresetsInputs>
		outputs: {
			Latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
			Width: ComfyNodeTypedSourceRef<number>
			Height: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"dimensions": new ComfyNodeTypedInputRef<void>(this, "dimensions"),
				"invert": new ComfyNodeTypedInputRef<boolean>(this, "invert"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
			},
			outputs: Object.create(Object.prototype, {
				"Latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"Width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"Height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<EmptyLatentImageCustomPresetsInputs>) {
		if (typeof sources["dimensions"] === "object") {
			this.sockets.inputs["dimensions"].connectTo(sources["dimensions"])
		} else {
			this.sockets.inputs["dimensions"].value = sources["dimensions"]
		}

		if (typeof sources["invert"] === "object") {
			this.sockets.inputs["invert"].connectTo(sources["invert"])
		} else {
			this.sockets.inputs["invert"].value = sources["invert"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

	}
}

type EmptyLatentImageCustomPresetsInputs = {
			"dimensions": ComfyNodeTypedInputRef<void>
			"invert": ComfyNodeTypedInputRef<boolean>
			"batch_size": ComfyNodeTypedInputRef<number>
}


export class ModelPassThrough extends ComfyNode {
	classType: string = "ModelPassThrough"

	sockets: {
		inputs: Required<ModelPassThroughInputs>
		outputs: {
			model: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
			},
			outputs: Object.create(Object.prototype, {
				"model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelPassThroughInputs>) {
		if (sources["model"] !== undefined) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}
		}

	}
}

type ModelPassThroughInputs = {
			"model"?: ComfyNodeTypedInputRef<ComfyValueType_MODEL>
}


export class ModelSaveKJ extends ComfyNode {
	classType: string = "ModelSaveKJ"

	sockets: {
		inputs: Required<ModelSaveKJInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"model_key_prefix": new ComfyNodeTypedInputRef<string>(this, "model_key_prefix"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_E>(this, "extra_pnginfo"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<ModelSaveKJInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (typeof sources["model_key_prefix"] === "object") {
			this.sockets.inputs["model_key_prefix"].connectTo(sources["model_key_prefix"])
		} else {
			this.sockets.inputs["model_key_prefix"].value = sources["model_key_prefix"]
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

	}
}

type ModelSaveKJInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"filename_prefix": ComfyNodeTypedInputRef<string>
			"model_key_prefix": ComfyNodeTypedInputRef<string>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_E>
}


export class SetShakkerLabsUnionControlNetType extends ComfyNode {
	classType: string = "SetShakkerLabsUnionControlNetType"

	sockets: {
		inputs: Required<SetShakkerLabsUnionControlNetTypeInputs>
		outputs: {
			CONTROL_NET: ComfyNodeTypedSourceRef<ComfyValueType_CONTROL_NET>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"control_net": new ComfyNodeTypedInputRef<ComfyValueType_CONTROL_NET>(this, "control_net"),
				"type": new ComfyNodeTypedInputRef<string>(this, "type"),
			},
			outputs: Object.create(Object.prototype, {
				"CONTROL_NET": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SetShakkerLabsUnionControlNetTypeInputs>) {
		if (typeof sources["control_net"] === "object") {
			this.sockets.inputs["control_net"].connectTo(sources["control_net"])
		} else {
			this.sockets.inputs["control_net"].value = sources["control_net"]
		}

		if (typeof sources["type"] === "object") {
			this.sockets.inputs["type"].connectTo(sources["type"])
		} else {
			this.sockets.inputs["type"].value = sources["type"]
		}

	}
}

type SetShakkerLabsUnionControlNetTypeInputs = {
			"control_net": ComfyNodeTypedInputRef<ComfyValueType_CONTROL_NET>
			"type": ComfyNodeTypedInputRef<string>
}


export class StyleModelApplyAdvanced extends ComfyNode {
	classType: string = "StyleModelApplyAdvanced"

	sockets: {
		inputs: Required<StyleModelApplyAdvancedInputs>
		outputs: {
			CONDITIONING: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning"),
				"style_model": new ComfyNodeTypedInputRef<ComfyValueType_STYLE_MODEL>(this, "style_model"),
				"clip_vision_output": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>(this, "clip_vision_output"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
			},
			outputs: Object.create(Object.prototype, {
				"CONDITIONING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<StyleModelApplyAdvancedInputs>) {
		if (typeof sources["conditioning"] === "object") {
			this.sockets.inputs["conditioning"].connectTo(sources["conditioning"])
		} else {
			this.sockets.inputs["conditioning"].value = sources["conditioning"]
		}

		if (typeof sources["style_model"] === "object") {
			this.sockets.inputs["style_model"].connectTo(sources["style_model"])
		} else {
			this.sockets.inputs["style_model"].value = sources["style_model"]
		}

		if (typeof sources["clip_vision_output"] === "object") {
			this.sockets.inputs["clip_vision_output"].connectTo(sources["clip_vision_output"])
		} else {
			this.sockets.inputs["clip_vision_output"].value = sources["clip_vision_output"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

	}
}

type StyleModelApplyAdvancedInputs = {
			"conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"style_model": ComfyNodeTypedInputRef<ComfyValueType_STYLE_MODEL>
			"clip_vision_output": ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION_OUTPUT>
			"strength": ComfyNodeTypedInputRef<number>
}


export class DiffusionModelSelector extends ComfyNode {
	classType: string = "DiffusionModelSelector"

	sockets: {
		inputs: Required<DiffusionModelSelectorInputs>
		outputs: {
			model_path: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_name": new ComfyNodeTypedInputRef<string>(this, "model_name"),
			},
			outputs: Object.create(Object.prototype, {
				"model_path": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DiffusionModelSelectorInputs>) {
		if (typeof sources["model_name"] === "object") {
			this.sockets.inputs["model_name"].connectTo(sources["model_name"])
		} else {
			this.sockets.inputs["model_name"].value = sources["model_name"]
		}

	}
}

type DiffusionModelSelectorInputs = {
			/** The name of the checkpoint (model) to load.*/
			"model_name": ComfyNodeTypedInputRef<string>
}


export class LazySwitchKJ extends ComfyNode {
	classType: string = "LazySwitchKJ"

	sockets: {
		inputs: Required<LazySwitchKJInputs>
		outputs: {
			_: ComfyNodeTypedSourceRef<ComfyValueType_$STAR>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"switch": new ComfyNodeTypedInputRef<boolean>(this, "switch"),
				"on_false": new ComfyNodeTypedInputRef<ComfyValueType_$STAR>(this, "on_false"),
				"on_true": new ComfyNodeTypedInputRef<ComfyValueType_$STAR>(this, "on_true"),
			},
			outputs: Object.create(Object.prototype, {
				"*": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LazySwitchKJInputs>) {
		if (typeof sources["switch"] === "object") {
			this.sockets.inputs["switch"].connectTo(sources["switch"])
		} else {
			this.sockets.inputs["switch"].value = sources["switch"]
		}

		if (typeof sources["on_false"] === "object") {
			this.sockets.inputs["on_false"].connectTo(sources["on_false"])
		} else {
			this.sockets.inputs["on_false"].value = sources["on_false"]
		}

		if (typeof sources["on_true"] === "object") {
			this.sockets.inputs["on_true"].connectTo(sources["on_true"])
		} else {
			this.sockets.inputs["on_true"].value = sources["on_true"]
		}

	}
}

type LazySwitchKJInputs = {
			"switch": ComfyNodeTypedInputRef<boolean>
			"on_false": ComfyNodeTypedInputRef<ComfyValueType_$STAR>
			"on_true": ComfyNodeTypedInputRef<ComfyValueType_$STAR>
}


export class NormalizedAmplitudeToMask extends ComfyNode {
	classType: string = "NormalizedAmplitudeToMask"

	sockets: {
		inputs: Required<NormalizedAmplitudeToMaskInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"normalized_amp": new ComfyNodeTypedInputRef<ComfyValueType_NORMALIZED_AMPLITUDE>(this, "normalized_amp"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"frame_offset": new ComfyNodeTypedInputRef<number>(this, "frame_offset"),
				"location_x": new ComfyNodeTypedInputRef<number>(this, "location_x"),
				"location_y": new ComfyNodeTypedInputRef<number>(this, "location_y"),
				"size": new ComfyNodeTypedInputRef<number>(this, "size"),
				"shape": new ComfyNodeTypedInputRef<string>(this, "shape"),
				"color": new ComfyNodeTypedInputRef<string>(this, "color"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<NormalizedAmplitudeToMaskInputs>) {
		if (typeof sources["normalized_amp"] === "object") {
			this.sockets.inputs["normalized_amp"].connectTo(sources["normalized_amp"])
		} else {
			this.sockets.inputs["normalized_amp"].value = sources["normalized_amp"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["frame_offset"] === "object") {
			this.sockets.inputs["frame_offset"].connectTo(sources["frame_offset"])
		} else {
			this.sockets.inputs["frame_offset"].value = sources["frame_offset"]
		}

		if (typeof sources["location_x"] === "object") {
			this.sockets.inputs["location_x"].connectTo(sources["location_x"])
		} else {
			this.sockets.inputs["location_x"].value = sources["location_x"]
		}

		if (typeof sources["location_y"] === "object") {
			this.sockets.inputs["location_y"].connectTo(sources["location_y"])
		} else {
			this.sockets.inputs["location_y"].value = sources["location_y"]
		}

		if (typeof sources["size"] === "object") {
			this.sockets.inputs["size"].connectTo(sources["size"])
		} else {
			this.sockets.inputs["size"].value = sources["size"]
		}

		if (typeof sources["shape"] === "object") {
			this.sockets.inputs["shape"].connectTo(sources["shape"])
		} else {
			this.sockets.inputs["shape"].value = sources["shape"]
		}

		if (typeof sources["color"] === "object") {
			this.sockets.inputs["color"].connectTo(sources["color"])
		} else {
			this.sockets.inputs["color"].value = sources["color"]
		}

	}
}

type NormalizedAmplitudeToMaskInputs = {
			"normalized_amp": ComfyNodeTypedInputRef<ComfyValueType_NORMALIZED_AMPLITUDE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"frame_offset": ComfyNodeTypedInputRef<number>
			"location_x": ComfyNodeTypedInputRef<number>
			"location_y": ComfyNodeTypedInputRef<number>
			"size": ComfyNodeTypedInputRef<number>
			"shape": ComfyNodeTypedInputRef<string>
			"color": ComfyNodeTypedInputRef<string>
}


export class NormalizedAmplitudeToFloatList extends ComfyNode {
	classType: string = "NormalizedAmplitudeToFloatList"

	sockets: {
		inputs: Required<NormalizedAmplitudeToFloatListInputs>
		outputs: {
			FLOAT: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"normalized_amp": new ComfyNodeTypedInputRef<ComfyValueType_NORMALIZED_AMPLITUDE>(this, "normalized_amp"),
			},
			outputs: Object.create(Object.prototype, {
				"FLOAT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<NormalizedAmplitudeToFloatListInputs>) {
		if (typeof sources["normalized_amp"] === "object") {
			this.sockets.inputs["normalized_amp"].connectTo(sources["normalized_amp"])
		} else {
			this.sockets.inputs["normalized_amp"].value = sources["normalized_amp"]
		}

	}
}

type NormalizedAmplitudeToFloatListInputs = {
			"normalized_amp": ComfyNodeTypedInputRef<ComfyValueType_NORMALIZED_AMPLITUDE>
}


export class OffsetMaskByNormalizedAmplitude extends ComfyNode {
	classType: string = "OffsetMaskByNormalizedAmplitude"

	sockets: {
		inputs: Required<OffsetMaskByNormalizedAmplitudeInputs>
		outputs: {
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"normalized_amp": new ComfyNodeTypedInputRef<ComfyValueType_NORMALIZED_AMPLITUDE>(this, "normalized_amp"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"x": new ComfyNodeTypedInputRef<number>(this, "x"),
				"y": new ComfyNodeTypedInputRef<number>(this, "y"),
				"rotate": new ComfyNodeTypedInputRef<boolean>(this, "rotate"),
				"angle_multiplier": new ComfyNodeTypedInputRef<number>(this, "angle_multiplier"),
			},
			outputs: Object.create(Object.prototype, {
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<OffsetMaskByNormalizedAmplitudeInputs>) {
		if (typeof sources["normalized_amp"] === "object") {
			this.sockets.inputs["normalized_amp"].connectTo(sources["normalized_amp"])
		} else {
			this.sockets.inputs["normalized_amp"].value = sources["normalized_amp"]
		}

		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["x"] === "object") {
			this.sockets.inputs["x"].connectTo(sources["x"])
		} else {
			this.sockets.inputs["x"].value = sources["x"]
		}

		if (typeof sources["y"] === "object") {
			this.sockets.inputs["y"].connectTo(sources["y"])
		} else {
			this.sockets.inputs["y"].value = sources["y"]
		}

		if (typeof sources["rotate"] === "object") {
			this.sockets.inputs["rotate"].connectTo(sources["rotate"])
		} else {
			this.sockets.inputs["rotate"].value = sources["rotate"]
		}

		if (typeof sources["angle_multiplier"] === "object") {
			this.sockets.inputs["angle_multiplier"].connectTo(sources["angle_multiplier"])
		} else {
			this.sockets.inputs["angle_multiplier"].value = sources["angle_multiplier"]
		}

	}
}

type OffsetMaskByNormalizedAmplitudeInputs = {
			"normalized_amp": ComfyNodeTypedInputRef<ComfyValueType_NORMALIZED_AMPLITUDE>
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"x": ComfyNodeTypedInputRef<number>
			"y": ComfyNodeTypedInputRef<number>
			"rotate": ComfyNodeTypedInputRef<boolean>
			"angle_multiplier": ComfyNodeTypedInputRef<number>
}


export class ImageTransformByNormalizedAmplitude extends ComfyNode {
	classType: string = "ImageTransformByNormalizedAmplitude"

	sockets: {
		inputs: Required<ImageTransformByNormalizedAmplitudeInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"normalized_amp": new ComfyNodeTypedInputRef<ComfyValueType_NORMALIZED_AMPLITUDE>(this, "normalized_amp"),
				"zoom_scale": new ComfyNodeTypedInputRef<number>(this, "zoom_scale"),
				"x_offset": new ComfyNodeTypedInputRef<number>(this, "x_offset"),
				"y_offset": new ComfyNodeTypedInputRef<number>(this, "y_offset"),
				"cumulative": new ComfyNodeTypedInputRef<boolean>(this, "cumulative"),
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ImageTransformByNormalizedAmplitudeInputs>) {
		if (typeof sources["normalized_amp"] === "object") {
			this.sockets.inputs["normalized_amp"].connectTo(sources["normalized_amp"])
		} else {
			this.sockets.inputs["normalized_amp"].value = sources["normalized_amp"]
		}

		if (typeof sources["zoom_scale"] === "object") {
			this.sockets.inputs["zoom_scale"].connectTo(sources["zoom_scale"])
		} else {
			this.sockets.inputs["zoom_scale"].value = sources["zoom_scale"]
		}

		if (typeof sources["x_offset"] === "object") {
			this.sockets.inputs["x_offset"].connectTo(sources["x_offset"])
		} else {
			this.sockets.inputs["x_offset"].value = sources["x_offset"]
		}

		if (typeof sources["y_offset"] === "object") {
			this.sockets.inputs["y_offset"].connectTo(sources["y_offset"])
		} else {
			this.sockets.inputs["y_offset"].value = sources["y_offset"]
		}

		if (typeof sources["cumulative"] === "object") {
			this.sockets.inputs["cumulative"].connectTo(sources["cumulative"])
		} else {
			this.sockets.inputs["cumulative"].value = sources["cumulative"]
		}

		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

	}
}

type ImageTransformByNormalizedAmplitudeInputs = {
			"normalized_amp": ComfyNodeTypedInputRef<ComfyValueType_NORMALIZED_AMPLITUDE>
			"zoom_scale": ComfyNodeTypedInputRef<number>
			"x_offset": ComfyNodeTypedInputRef<number>
			"y_offset": ComfyNodeTypedInputRef<number>
			"cumulative": ComfyNodeTypedInputRef<boolean>
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class AudioConcatenate extends ComfyNode {
	classType: string = "AudioConcatenate"

	sockets: {
		inputs: Required<AudioConcatenateInputs>
		outputs: {
			AUDIO: ComfyNodeTypedSourceRef<ComfyValueType_AUDIO>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"audio1": new ComfyNodeTypedInputRef<ComfyValueType_AUDIO>(this, "audio1"),
				"audio2": new ComfyNodeTypedInputRef<ComfyValueType_AUDIO>(this, "audio2"),
				"direction": new ComfyNodeTypedInputRef<string>(this, "direction"),
			},
			outputs: Object.create(Object.prototype, {
				"AUDIO": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<AudioConcatenateInputs>) {
		if (typeof sources["audio1"] === "object") {
			this.sockets.inputs["audio1"].connectTo(sources["audio1"])
		} else {
			this.sockets.inputs["audio1"].value = sources["audio1"]
		}

		if (typeof sources["audio2"] === "object") {
			this.sockets.inputs["audio2"].connectTo(sources["audio2"])
		} else {
			this.sockets.inputs["audio2"].value = sources["audio2"]
		}

		if (typeof sources["direction"] === "object") {
			this.sockets.inputs["direction"].connectTo(sources["direction"])
		} else {
			this.sockets.inputs["direction"].value = sources["direction"]
		}

	}
}

type AudioConcatenateInputs = {
			"audio1": ComfyNodeTypedInputRef<ComfyValueType_AUDIO>
			"audio2": ComfyNodeTypedInputRef<ComfyValueType_AUDIO>
			"direction": ComfyNodeTypedInputRef<string>
}


export class SplineEditor extends ComfyNode {
	classType: string = "SplineEditor"

	sockets: {
		inputs: Required<SplineEditorInputs>
		outputs: {
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			coord_str: ComfyNodeTypedSourceRef<string>
			float: ComfyNodeTypedSourceRef<number>
			count: ComfyNodeTypedSourceRef<number>
			normalized_str: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"points_store": new ComfyNodeTypedInputRef<string>(this, "points_store"),
				"coordinates": new ComfyNodeTypedInputRef<string>(this, "coordinates"),
				"mask_width": new ComfyNodeTypedInputRef<number>(this, "mask_width"),
				"mask_height": new ComfyNodeTypedInputRef<number>(this, "mask_height"),
				"points_to_sample": new ComfyNodeTypedInputRef<number>(this, "points_to_sample"),
				"sampling_method": new ComfyNodeTypedInputRef<string>(this, "sampling_method"),
				"interpolation": new ComfyNodeTypedInputRef<string>(this, "interpolation"),
				"tension": new ComfyNodeTypedInputRef<number>(this, "tension"),
				"repeat_output": new ComfyNodeTypedInputRef<number>(this, "repeat_output"),
				"float_output_type": new ComfyNodeTypedInputRef<string>(this, "float_output_type"),
				"min_value": new ComfyNodeTypedInputRef<number>(this, "min_value"),
				"max_value": new ComfyNodeTypedInputRef<number>(this, "max_value"),
				"bg_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "bg_image"),
			},
			outputs: Object.create(Object.prototype, {
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"coord_str": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"float": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
				"normalized_str": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 4 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SplineEditorInputs>) {
		if (typeof sources["points_store"] === "object") {
			this.sockets.inputs["points_store"].connectTo(sources["points_store"])
		} else {
			this.sockets.inputs["points_store"].value = sources["points_store"]
		}

		if (typeof sources["coordinates"] === "object") {
			this.sockets.inputs["coordinates"].connectTo(sources["coordinates"])
		} else {
			this.sockets.inputs["coordinates"].value = sources["coordinates"]
		}

		if (typeof sources["mask_width"] === "object") {
			this.sockets.inputs["mask_width"].connectTo(sources["mask_width"])
		} else {
			this.sockets.inputs["mask_width"].value = sources["mask_width"]
		}

		if (typeof sources["mask_height"] === "object") {
			this.sockets.inputs["mask_height"].connectTo(sources["mask_height"])
		} else {
			this.sockets.inputs["mask_height"].value = sources["mask_height"]
		}

		if (typeof sources["points_to_sample"] === "object") {
			this.sockets.inputs["points_to_sample"].connectTo(sources["points_to_sample"])
		} else {
			this.sockets.inputs["points_to_sample"].value = sources["points_to_sample"]
		}

		if (typeof sources["sampling_method"] === "object") {
			this.sockets.inputs["sampling_method"].connectTo(sources["sampling_method"])
		} else {
			this.sockets.inputs["sampling_method"].value = sources["sampling_method"]
		}

		if (typeof sources["interpolation"] === "object") {
			this.sockets.inputs["interpolation"].connectTo(sources["interpolation"])
		} else {
			this.sockets.inputs["interpolation"].value = sources["interpolation"]
		}

		if (typeof sources["tension"] === "object") {
			this.sockets.inputs["tension"].connectTo(sources["tension"])
		} else {
			this.sockets.inputs["tension"].value = sources["tension"]
		}

		if (typeof sources["repeat_output"] === "object") {
			this.sockets.inputs["repeat_output"].connectTo(sources["repeat_output"])
		} else {
			this.sockets.inputs["repeat_output"].value = sources["repeat_output"]
		}

		if (typeof sources["float_output_type"] === "object") {
			this.sockets.inputs["float_output_type"].connectTo(sources["float_output_type"])
		} else {
			this.sockets.inputs["float_output_type"].value = sources["float_output_type"]
		}

		if (sources["min_value"] !== undefined) {
		if (typeof sources["min_value"] === "object") {
			this.sockets.inputs["min_value"].connectTo(sources["min_value"])
		} else {
			this.sockets.inputs["min_value"].value = sources["min_value"]
		}
		}

		if (sources["max_value"] !== undefined) {
		if (typeof sources["max_value"] === "object") {
			this.sockets.inputs["max_value"].connectTo(sources["max_value"])
		} else {
			this.sockets.inputs["max_value"].value = sources["max_value"]
		}
		}

		if (sources["bg_image"] !== undefined) {
		if (typeof sources["bg_image"] === "object") {
			this.sockets.inputs["bg_image"].connectTo(sources["bg_image"])
		} else {
			this.sockets.inputs["bg_image"].value = sources["bg_image"]
		}
		}

	}
}

type SplineEditorInputs = {
			"points_store": ComfyNodeTypedInputRef<string>
			"coordinates": ComfyNodeTypedInputRef<string>
			"mask_width": ComfyNodeTypedInputRef<number>
			"mask_height": ComfyNodeTypedInputRef<number>
			"points_to_sample": ComfyNodeTypedInputRef<number>
			"sampling_method": ComfyNodeTypedInputRef<string>
			"interpolation": ComfyNodeTypedInputRef<string>
			"tension": ComfyNodeTypedInputRef<number>
			"repeat_output": ComfyNodeTypedInputRef<number>
			"float_output_type": ComfyNodeTypedInputRef<string>
			"min_value"?: ComfyNodeTypedInputRef<number>
			"max_value"?: ComfyNodeTypedInputRef<number>
			"bg_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class CreateShapeImageOnPath extends ComfyNode {
	classType: string = "CreateShapeImageOnPath"

	sockets: {
		inputs: Required<CreateShapeImageOnPathInputs>
		outputs: {
			image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"shape": new ComfyNodeTypedInputRef<string>(this, "shape"),
				"coordinates": new ComfyNodeTypedInputRef<string>(this, "coordinates"),
				"frame_width": new ComfyNodeTypedInputRef<number>(this, "frame_width"),
				"frame_height": new ComfyNodeTypedInputRef<number>(this, "frame_height"),
				"shape_width": new ComfyNodeTypedInputRef<number>(this, "shape_width"),
				"shape_height": new ComfyNodeTypedInputRef<number>(this, "shape_height"),
				"shape_color": new ComfyNodeTypedInputRef<string>(this, "shape_color"),
				"bg_color": new ComfyNodeTypedInputRef<string>(this, "bg_color"),
				"blur_radius": new ComfyNodeTypedInputRef<number>(this, "blur_radius"),
				"intensity": new ComfyNodeTypedInputRef<number>(this, "intensity"),
				"size_multiplier": new ComfyNodeTypedInputRef<number>(this, "size_multiplier"),
				"trailing": new ComfyNodeTypedInputRef<number>(this, "trailing"),
				"border_width": new ComfyNodeTypedInputRef<number>(this, "border_width"),
				"border_color": new ComfyNodeTypedInputRef<string>(this, "border_color"),
			},
			outputs: Object.create(Object.prototype, {
				"image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateShapeImageOnPathInputs>) {
		if (typeof sources["shape"] === "object") {
			this.sockets.inputs["shape"].connectTo(sources["shape"])
		} else {
			this.sockets.inputs["shape"].value = sources["shape"]
		}

		if (typeof sources["coordinates"] === "object") {
			this.sockets.inputs["coordinates"].connectTo(sources["coordinates"])
		} else {
			this.sockets.inputs["coordinates"].value = sources["coordinates"]
		}

		if (typeof sources["frame_width"] === "object") {
			this.sockets.inputs["frame_width"].connectTo(sources["frame_width"])
		} else {
			this.sockets.inputs["frame_width"].value = sources["frame_width"]
		}

		if (typeof sources["frame_height"] === "object") {
			this.sockets.inputs["frame_height"].connectTo(sources["frame_height"])
		} else {
			this.sockets.inputs["frame_height"].value = sources["frame_height"]
		}

		if (typeof sources["shape_width"] === "object") {
			this.sockets.inputs["shape_width"].connectTo(sources["shape_width"])
		} else {
			this.sockets.inputs["shape_width"].value = sources["shape_width"]
		}

		if (typeof sources["shape_height"] === "object") {
			this.sockets.inputs["shape_height"].connectTo(sources["shape_height"])
		} else {
			this.sockets.inputs["shape_height"].value = sources["shape_height"]
		}

		if (typeof sources["shape_color"] === "object") {
			this.sockets.inputs["shape_color"].connectTo(sources["shape_color"])
		} else {
			this.sockets.inputs["shape_color"].value = sources["shape_color"]
		}

		if (typeof sources["bg_color"] === "object") {
			this.sockets.inputs["bg_color"].connectTo(sources["bg_color"])
		} else {
			this.sockets.inputs["bg_color"].value = sources["bg_color"]
		}

		if (typeof sources["blur_radius"] === "object") {
			this.sockets.inputs["blur_radius"].connectTo(sources["blur_radius"])
		} else {
			this.sockets.inputs["blur_radius"].value = sources["blur_radius"]
		}

		if (typeof sources["intensity"] === "object") {
			this.sockets.inputs["intensity"].connectTo(sources["intensity"])
		} else {
			this.sockets.inputs["intensity"].value = sources["intensity"]
		}

		if (sources["size_multiplier"] !== undefined) {
		if (typeof sources["size_multiplier"] === "object") {
			this.sockets.inputs["size_multiplier"].connectTo(sources["size_multiplier"])
		} else {
			this.sockets.inputs["size_multiplier"].value = sources["size_multiplier"]
		}
		}

		if (sources["trailing"] !== undefined) {
		if (typeof sources["trailing"] === "object") {
			this.sockets.inputs["trailing"].connectTo(sources["trailing"])
		} else {
			this.sockets.inputs["trailing"].value = sources["trailing"]
		}
		}

		if (sources["border_width"] !== undefined) {
		if (typeof sources["border_width"] === "object") {
			this.sockets.inputs["border_width"].connectTo(sources["border_width"])
		} else {
			this.sockets.inputs["border_width"].value = sources["border_width"]
		}
		}

		if (sources["border_color"] !== undefined) {
		if (typeof sources["border_color"] === "object") {
			this.sockets.inputs["border_color"].connectTo(sources["border_color"])
		} else {
			this.sockets.inputs["border_color"].value = sources["border_color"]
		}
		}

	}
}

type CreateShapeImageOnPathInputs = {
			"shape": ComfyNodeTypedInputRef<string>
			"coordinates": ComfyNodeTypedInputRef<string>
			"frame_width": ComfyNodeTypedInputRef<number>
			"frame_height": ComfyNodeTypedInputRef<number>
			"shape_width": ComfyNodeTypedInputRef<number>
			"shape_height": ComfyNodeTypedInputRef<number>
			"shape_color": ComfyNodeTypedInputRef<string>
			"bg_color": ComfyNodeTypedInputRef<string>
			"blur_radius": ComfyNodeTypedInputRef<number>
			"intensity": ComfyNodeTypedInputRef<number>
			"size_multiplier"?: ComfyNodeTypedInputRef<number>
			"trailing"?: ComfyNodeTypedInputRef<number>
			"border_width"?: ComfyNodeTypedInputRef<number>
			"border_color"?: ComfyNodeTypedInputRef<string>
}


export class CreateShapeMaskOnPath extends ComfyNode {
	classType: string = "CreateShapeMaskOnPath"

	sockets: {
		inputs: Required<CreateShapeMaskOnPathInputs>
		outputs: {
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			mask_inverted: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"shape": new ComfyNodeTypedInputRef<string>(this, "shape"),
				"coordinates": new ComfyNodeTypedInputRef<string>(this, "coordinates"),
				"frame_width": new ComfyNodeTypedInputRef<number>(this, "frame_width"),
				"frame_height": new ComfyNodeTypedInputRef<number>(this, "frame_height"),
				"shape_width": new ComfyNodeTypedInputRef<number>(this, "shape_width"),
				"shape_height": new ComfyNodeTypedInputRef<number>(this, "shape_height"),
				"size_multiplier": new ComfyNodeTypedInputRef<number>(this, "size_multiplier"),
			},
			outputs: Object.create(Object.prototype, {
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"mask_inverted": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateShapeMaskOnPathInputs>) {
		if (typeof sources["shape"] === "object") {
			this.sockets.inputs["shape"].connectTo(sources["shape"])
		} else {
			this.sockets.inputs["shape"].value = sources["shape"]
		}

		if (typeof sources["coordinates"] === "object") {
			this.sockets.inputs["coordinates"].connectTo(sources["coordinates"])
		} else {
			this.sockets.inputs["coordinates"].value = sources["coordinates"]
		}

		if (typeof sources["frame_width"] === "object") {
			this.sockets.inputs["frame_width"].connectTo(sources["frame_width"])
		} else {
			this.sockets.inputs["frame_width"].value = sources["frame_width"]
		}

		if (typeof sources["frame_height"] === "object") {
			this.sockets.inputs["frame_height"].connectTo(sources["frame_height"])
		} else {
			this.sockets.inputs["frame_height"].value = sources["frame_height"]
		}

		if (typeof sources["shape_width"] === "object") {
			this.sockets.inputs["shape_width"].connectTo(sources["shape_width"])
		} else {
			this.sockets.inputs["shape_width"].value = sources["shape_width"]
		}

		if (typeof sources["shape_height"] === "object") {
			this.sockets.inputs["shape_height"].connectTo(sources["shape_height"])
		} else {
			this.sockets.inputs["shape_height"].value = sources["shape_height"]
		}

		if (sources["size_multiplier"] !== undefined) {
		if (typeof sources["size_multiplier"] === "object") {
			this.sockets.inputs["size_multiplier"].connectTo(sources["size_multiplier"])
		} else {
			this.sockets.inputs["size_multiplier"].value = sources["size_multiplier"]
		}
		}

	}
}

type CreateShapeMaskOnPathInputs = {
			"shape": ComfyNodeTypedInputRef<string>
			"coordinates": ComfyNodeTypedInputRef<string>
			"frame_width": ComfyNodeTypedInputRef<number>
			"frame_height": ComfyNodeTypedInputRef<number>
			"shape_width": ComfyNodeTypedInputRef<number>
			"shape_height": ComfyNodeTypedInputRef<number>
			"size_multiplier"?: ComfyNodeTypedInputRef<number>
}


export class CreateTextOnPath extends ComfyNode {
	classType: string = "CreateTextOnPath"

	sockets: {
		inputs: Required<CreateTextOnPathInputs>
		outputs: {
			image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			mask_inverted: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"coordinates": new ComfyNodeTypedInputRef<string>(this, "coordinates"),
				"text": new ComfyNodeTypedInputRef<string>(this, "text"),
				"frame_width": new ComfyNodeTypedInputRef<number>(this, "frame_width"),
				"frame_height": new ComfyNodeTypedInputRef<number>(this, "frame_height"),
				"font": new ComfyNodeTypedInputRef<string>(this, "font"),
				"font_size": new ComfyNodeTypedInputRef<number>(this, "font_size"),
				"alignment": new ComfyNodeTypedInputRef<string>(this, "alignment"),
				"text_color": new ComfyNodeTypedInputRef<string>(this, "text_color"),
				"size_multiplier": new ComfyNodeTypedInputRef<number>(this, "size_multiplier"),
			},
			outputs: Object.create(Object.prototype, {
				"image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"mask_inverted": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateTextOnPathInputs>) {
		if (typeof sources["coordinates"] === "object") {
			this.sockets.inputs["coordinates"].connectTo(sources["coordinates"])
		} else {
			this.sockets.inputs["coordinates"].value = sources["coordinates"]
		}

		if (typeof sources["text"] === "object") {
			this.sockets.inputs["text"].connectTo(sources["text"])
		} else {
			this.sockets.inputs["text"].value = sources["text"]
		}

		if (typeof sources["frame_width"] === "object") {
			this.sockets.inputs["frame_width"].connectTo(sources["frame_width"])
		} else {
			this.sockets.inputs["frame_width"].value = sources["frame_width"]
		}

		if (typeof sources["frame_height"] === "object") {
			this.sockets.inputs["frame_height"].connectTo(sources["frame_height"])
		} else {
			this.sockets.inputs["frame_height"].value = sources["frame_height"]
		}

		if (typeof sources["font"] === "object") {
			this.sockets.inputs["font"].connectTo(sources["font"])
		} else {
			this.sockets.inputs["font"].value = sources["font"]
		}

		if (typeof sources["font_size"] === "object") {
			this.sockets.inputs["font_size"].connectTo(sources["font_size"])
		} else {
			this.sockets.inputs["font_size"].value = sources["font_size"]
		}

		if (typeof sources["alignment"] === "object") {
			this.sockets.inputs["alignment"].connectTo(sources["alignment"])
		} else {
			this.sockets.inputs["alignment"].value = sources["alignment"]
		}

		if (typeof sources["text_color"] === "object") {
			this.sockets.inputs["text_color"].connectTo(sources["text_color"])
		} else {
			this.sockets.inputs["text_color"].value = sources["text_color"]
		}

		if (sources["size_multiplier"] !== undefined) {
		if (typeof sources["size_multiplier"] === "object") {
			this.sockets.inputs["size_multiplier"].connectTo(sources["size_multiplier"])
		} else {
			this.sockets.inputs["size_multiplier"].value = sources["size_multiplier"]
		}
		}

	}
}

type CreateTextOnPathInputs = {
			"coordinates": ComfyNodeTypedInputRef<string>
			"text": ComfyNodeTypedInputRef<string>
			"frame_width": ComfyNodeTypedInputRef<number>
			"frame_height": ComfyNodeTypedInputRef<number>
			"font": ComfyNodeTypedInputRef<string>
			"font_size": ComfyNodeTypedInputRef<number>
			"alignment": ComfyNodeTypedInputRef<string>
			"text_color": ComfyNodeTypedInputRef<string>
			"size_multiplier"?: ComfyNodeTypedInputRef<number>
}


export class CreateGradientFromCoords extends ComfyNode {
	classType: string = "CreateGradientFromCoords"

	sockets: {
		inputs: Required<CreateGradientFromCoordsInputs>
		outputs: {
			image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"coordinates": new ComfyNodeTypedInputRef<string>(this, "coordinates"),
				"frame_width": new ComfyNodeTypedInputRef<number>(this, "frame_width"),
				"frame_height": new ComfyNodeTypedInputRef<number>(this, "frame_height"),
				"start_color": new ComfyNodeTypedInputRef<string>(this, "start_color"),
				"end_color": new ComfyNodeTypedInputRef<string>(this, "end_color"),
				"multiplier": new ComfyNodeTypedInputRef<number>(this, "multiplier"),
			},
			outputs: Object.create(Object.prototype, {
				"image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateGradientFromCoordsInputs>) {
		if (typeof sources["coordinates"] === "object") {
			this.sockets.inputs["coordinates"].connectTo(sources["coordinates"])
		} else {
			this.sockets.inputs["coordinates"].value = sources["coordinates"]
		}

		if (typeof sources["frame_width"] === "object") {
			this.sockets.inputs["frame_width"].connectTo(sources["frame_width"])
		} else {
			this.sockets.inputs["frame_width"].value = sources["frame_width"]
		}

		if (typeof sources["frame_height"] === "object") {
			this.sockets.inputs["frame_height"].connectTo(sources["frame_height"])
		} else {
			this.sockets.inputs["frame_height"].value = sources["frame_height"]
		}

		if (typeof sources["start_color"] === "object") {
			this.sockets.inputs["start_color"].connectTo(sources["start_color"])
		} else {
			this.sockets.inputs["start_color"].value = sources["start_color"]
		}

		if (typeof sources["end_color"] === "object") {
			this.sockets.inputs["end_color"].connectTo(sources["end_color"])
		} else {
			this.sockets.inputs["end_color"].value = sources["end_color"]
		}

		if (typeof sources["multiplier"] === "object") {
			this.sockets.inputs["multiplier"].connectTo(sources["multiplier"])
		} else {
			this.sockets.inputs["multiplier"].value = sources["multiplier"]
		}

	}
}

type CreateGradientFromCoordsInputs = {
			"coordinates": ComfyNodeTypedInputRef<string>
			"frame_width": ComfyNodeTypedInputRef<number>
			"frame_height": ComfyNodeTypedInputRef<number>
			"start_color": ComfyNodeTypedInputRef<string>
			"end_color": ComfyNodeTypedInputRef<string>
			"multiplier": ComfyNodeTypedInputRef<number>
}


export class CutAndDragOnPath extends ComfyNode {
	classType: string = "CutAndDragOnPath"

	sockets: {
		inputs: Required<CutAndDragOnPathInputs>
		outputs: {
			image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"coordinates": new ComfyNodeTypedInputRef<string>(this, "coordinates"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"frame_width": new ComfyNodeTypedInputRef<number>(this, "frame_width"),
				"frame_height": new ComfyNodeTypedInputRef<number>(this, "frame_height"),
				"inpaint": new ComfyNodeTypedInputRef<boolean>(this, "inpaint"),
				"bg_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "bg_image"),
			},
			outputs: Object.create(Object.prototype, {
				"image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CutAndDragOnPathInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["coordinates"] === "object") {
			this.sockets.inputs["coordinates"].connectTo(sources["coordinates"])
		} else {
			this.sockets.inputs["coordinates"].value = sources["coordinates"]
		}

		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["frame_width"] === "object") {
			this.sockets.inputs["frame_width"].connectTo(sources["frame_width"])
		} else {
			this.sockets.inputs["frame_width"].value = sources["frame_width"]
		}

		if (typeof sources["frame_height"] === "object") {
			this.sockets.inputs["frame_height"].connectTo(sources["frame_height"])
		} else {
			this.sockets.inputs["frame_height"].value = sources["frame_height"]
		}

		if (typeof sources["inpaint"] === "object") {
			this.sockets.inputs["inpaint"].connectTo(sources["inpaint"])
		} else {
			this.sockets.inputs["inpaint"].value = sources["inpaint"]
		}

		if (sources["bg_image"] !== undefined) {
		if (typeof sources["bg_image"] === "object") {
			this.sockets.inputs["bg_image"].connectTo(sources["bg_image"])
		} else {
			this.sockets.inputs["bg_image"].value = sources["bg_image"]
		}
		}

	}
}

type CutAndDragOnPathInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"coordinates": ComfyNodeTypedInputRef<string>
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"frame_width": ComfyNodeTypedInputRef<number>
			"frame_height": ComfyNodeTypedInputRef<number>
			"inpaint": ComfyNodeTypedInputRef<boolean>
			"bg_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class GradientToFloat extends ComfyNode {
	classType: string = "GradientToFloat"

	sockets: {
		inputs: Required<GradientToFloatInputs>
		outputs: {
			float_x: ComfyNodeTypedSourceRef<number>
			float_y: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
			},
			outputs: Object.create(Object.prototype, {
				"float_x": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"float_y": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<GradientToFloatInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

	}
}

type GradientToFloatInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"steps": ComfyNodeTypedInputRef<number>
}


export class WeightScheduleExtend extends ComfyNode {
	classType: string = "WeightScheduleExtend"

	sockets: {
		inputs: Required<WeightScheduleExtendInputs>
		outputs: {
			FLOAT: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"input_values_1": new ComfyNodeTypedInputRef<number>(this, "input_values_1"),
				"input_values_2": new ComfyNodeTypedInputRef<number>(this, "input_values_2"),
				"output_type": new ComfyNodeTypedInputRef<string>(this, "output_type"),
			},
			outputs: Object.create(Object.prototype, {
				"FLOAT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WeightScheduleExtendInputs>) {
		if (typeof sources["input_values_1"] === "object") {
			this.sockets.inputs["input_values_1"].connectTo(sources["input_values_1"])
		} else {
			this.sockets.inputs["input_values_1"].value = sources["input_values_1"]
		}

		if (typeof sources["input_values_2"] === "object") {
			this.sockets.inputs["input_values_2"].connectTo(sources["input_values_2"])
		} else {
			this.sockets.inputs["input_values_2"].value = sources["input_values_2"]
		}

		if (typeof sources["output_type"] === "object") {
			this.sockets.inputs["output_type"].connectTo(sources["output_type"])
		} else {
			this.sockets.inputs["output_type"].value = sources["output_type"]
		}

	}
}

type WeightScheduleExtendInputs = {
			"input_values_1": ComfyNodeTypedInputRef<number>
			"input_values_2": ComfyNodeTypedInputRef<number>
			"output_type": ComfyNodeTypedInputRef<string>
}


export class MaskOrImageToWeight extends ComfyNode {
	classType: string = "MaskOrImageToWeight"

	sockets: {
		inputs: Required<MaskOrImageToWeightInputs>
		outputs: {
			FLOAT: ComfyNodeTypedSourceRef<number>
			STRING: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"output_type": new ComfyNodeTypedInputRef<string>(this, "output_type"),
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"masks": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "masks"),
			},
			outputs: Object.create(Object.prototype, {
				"FLOAT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"STRING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<MaskOrImageToWeightInputs>) {
		if (typeof sources["output_type"] === "object") {
			this.sockets.inputs["output_type"].connectTo(sources["output_type"])
		} else {
			this.sockets.inputs["output_type"].value = sources["output_type"]
		}

		if (sources["images"] !== undefined) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}
		}

		if (sources["masks"] !== undefined) {
		if (typeof sources["masks"] === "object") {
			this.sockets.inputs["masks"].connectTo(sources["masks"])
		} else {
			this.sockets.inputs["masks"].value = sources["masks"]
		}
		}

	}
}

type MaskOrImageToWeightInputs = {
			"output_type": ComfyNodeTypedInputRef<string>
			"images"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"masks"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class WeightScheduleConvert extends ComfyNode {
	classType: string = "WeightScheduleConvert"

	sockets: {
		inputs: Required<WeightScheduleConvertInputs>
		outputs: {
			FLOAT: ComfyNodeTypedSourceRef<number>
			STRING: ComfyNodeTypedSourceRef<string>
			INT: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"input_values": new ComfyNodeTypedInputRef<number>(this, "input_values"),
				"output_type": new ComfyNodeTypedInputRef<string>(this, "output_type"),
				"invert": new ComfyNodeTypedInputRef<boolean>(this, "invert"),
				"repeat": new ComfyNodeTypedInputRef<number>(this, "repeat"),
				"remap_to_frames": new ComfyNodeTypedInputRef<number>(this, "remap_to_frames"),
				"interpolation_curve": new ComfyNodeTypedInputRef<number>(this, "interpolation_curve"),
				"remap_values": new ComfyNodeTypedInputRef<boolean>(this, "remap_values"),
				"remap_min": new ComfyNodeTypedInputRef<number>(this, "remap_min"),
				"remap_max": new ComfyNodeTypedInputRef<number>(this, "remap_max"),
			},
			outputs: Object.create(Object.prototype, {
				"FLOAT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"STRING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"INT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WeightScheduleConvertInputs>) {
		if (typeof sources["input_values"] === "object") {
			this.sockets.inputs["input_values"].connectTo(sources["input_values"])
		} else {
			this.sockets.inputs["input_values"].value = sources["input_values"]
		}

		if (typeof sources["output_type"] === "object") {
			this.sockets.inputs["output_type"].connectTo(sources["output_type"])
		} else {
			this.sockets.inputs["output_type"].value = sources["output_type"]
		}

		if (typeof sources["invert"] === "object") {
			this.sockets.inputs["invert"].connectTo(sources["invert"])
		} else {
			this.sockets.inputs["invert"].value = sources["invert"]
		}

		if (typeof sources["repeat"] === "object") {
			this.sockets.inputs["repeat"].connectTo(sources["repeat"])
		} else {
			this.sockets.inputs["repeat"].value = sources["repeat"]
		}

		if (sources["remap_to_frames"] !== undefined) {
		if (typeof sources["remap_to_frames"] === "object") {
			this.sockets.inputs["remap_to_frames"].connectTo(sources["remap_to_frames"])
		} else {
			this.sockets.inputs["remap_to_frames"].value = sources["remap_to_frames"]
		}
		}

		if (sources["interpolation_curve"] !== undefined) {
		if (typeof sources["interpolation_curve"] === "object") {
			this.sockets.inputs["interpolation_curve"].connectTo(sources["interpolation_curve"])
		} else {
			this.sockets.inputs["interpolation_curve"].value = sources["interpolation_curve"]
		}
		}

		if (sources["remap_values"] !== undefined) {
		if (typeof sources["remap_values"] === "object") {
			this.sockets.inputs["remap_values"].connectTo(sources["remap_values"])
		} else {
			this.sockets.inputs["remap_values"].value = sources["remap_values"]
		}
		}

		if (sources["remap_min"] !== undefined) {
		if (typeof sources["remap_min"] === "object") {
			this.sockets.inputs["remap_min"].connectTo(sources["remap_min"])
		} else {
			this.sockets.inputs["remap_min"].value = sources["remap_min"]
		}
		}

		if (sources["remap_max"] !== undefined) {
		if (typeof sources["remap_max"] === "object") {
			this.sockets.inputs["remap_max"].connectTo(sources["remap_max"])
		} else {
			this.sockets.inputs["remap_max"].value = sources["remap_max"]
		}
		}

	}
}

type WeightScheduleConvertInputs = {
			"input_values": ComfyNodeTypedInputRef<number>
			"output_type": ComfyNodeTypedInputRef<string>
			"invert": ComfyNodeTypedInputRef<boolean>
			"repeat": ComfyNodeTypedInputRef<number>
			"remap_to_frames"?: ComfyNodeTypedInputRef<number>
			"interpolation_curve"?: ComfyNodeTypedInputRef<number>
			"remap_values"?: ComfyNodeTypedInputRef<boolean>
			"remap_min"?: ComfyNodeTypedInputRef<number>
			"remap_max"?: ComfyNodeTypedInputRef<number>
}


export class FloatToMask extends ComfyNode {
	classType: string = "FloatToMask"

	sockets: {
		inputs: Required<FloatToMaskInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"input_values": new ComfyNodeTypedInputRef<number>(this, "input_values"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<FloatToMaskInputs>) {
		if (typeof sources["input_values"] === "object") {
			this.sockets.inputs["input_values"].connectTo(sources["input_values"])
		} else {
			this.sockets.inputs["input_values"].value = sources["input_values"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

	}
}

type FloatToMaskInputs = {
			"input_values": ComfyNodeTypedInputRef<number>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
}


export class FloatToSigmas extends ComfyNode {
	classType: string = "FloatToSigmas"

	sockets: {
		inputs: Required<FloatToSigmasInputs>
		outputs: {
			SIGMAS: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"float_list": new ComfyNodeTypedInputRef<number>(this, "float_list"),
			},
			outputs: Object.create(Object.prototype, {
				"SIGMAS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<FloatToSigmasInputs>) {
		if (typeof sources["float_list"] === "object") {
			this.sockets.inputs["float_list"].connectTo(sources["float_list"])
		} else {
			this.sockets.inputs["float_list"].value = sources["float_list"]
		}

	}
}

type FloatToSigmasInputs = {
			"float_list": ComfyNodeTypedInputRef<number>
}


export class SigmasToFloat extends ComfyNode {
	classType: string = "SigmasToFloat"

	sockets: {
		inputs: Required<SigmasToFloatInputs>
		outputs: {
			float: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"sigmas": new ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>(this, "sigmas"),
			},
			outputs: Object.create(Object.prototype, {
				"float": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SigmasToFloatInputs>) {
		if (typeof sources["sigmas"] === "object") {
			this.sockets.inputs["sigmas"].connectTo(sources["sigmas"])
		} else {
			this.sockets.inputs["sigmas"].value = sources["sigmas"]
		}

	}
}

type SigmasToFloatInputs = {
			"sigmas": ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>
}


export class PlotCoordinates extends ComfyNode {
	classType: string = "PlotCoordinates"

	sockets: {
		inputs: Required<PlotCoordinatesInputs>
		outputs: {
			images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			width: ComfyNodeTypedSourceRef<number>
			height: ComfyNodeTypedSourceRef<number>
			bbox_width: ComfyNodeTypedSourceRef<number>
			bbox_height: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"coordinates": new ComfyNodeTypedInputRef<string>(this, "coordinates"),
				"text": new ComfyNodeTypedInputRef<string>(this, "text"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"bbox_width": new ComfyNodeTypedInputRef<number>(this, "bbox_width"),
				"bbox_height": new ComfyNodeTypedInputRef<number>(this, "bbox_height"),
				"size_multiplier": new ComfyNodeTypedInputRef<number>(this, "size_multiplier"),
			},
			outputs: Object.create(Object.prototype, {
				"images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"bbox_width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
				"bbox_height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 4 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PlotCoordinatesInputs>) {
		if (typeof sources["coordinates"] === "object") {
			this.sockets.inputs["coordinates"].connectTo(sources["coordinates"])
		} else {
			this.sockets.inputs["coordinates"].value = sources["coordinates"]
		}

		if (typeof sources["text"] === "object") {
			this.sockets.inputs["text"].connectTo(sources["text"])
		} else {
			this.sockets.inputs["text"].value = sources["text"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["bbox_width"] === "object") {
			this.sockets.inputs["bbox_width"].connectTo(sources["bbox_width"])
		} else {
			this.sockets.inputs["bbox_width"].value = sources["bbox_width"]
		}

		if (typeof sources["bbox_height"] === "object") {
			this.sockets.inputs["bbox_height"].connectTo(sources["bbox_height"])
		} else {
			this.sockets.inputs["bbox_height"].value = sources["bbox_height"]
		}

		if (sources["size_multiplier"] !== undefined) {
		if (typeof sources["size_multiplier"] === "object") {
			this.sockets.inputs["size_multiplier"].connectTo(sources["size_multiplier"])
		} else {
			this.sockets.inputs["size_multiplier"].value = sources["size_multiplier"]
		}
		}

	}
}

type PlotCoordinatesInputs = {
			"coordinates": ComfyNodeTypedInputRef<string>
			"text": ComfyNodeTypedInputRef<string>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"bbox_width": ComfyNodeTypedInputRef<number>
			"bbox_height": ComfyNodeTypedInputRef<number>
			"size_multiplier"?: ComfyNodeTypedInputRef<number>
}


export class InterpolateCoords extends ComfyNode {
	classType: string = "InterpolateCoords"

	sockets: {
		inputs: Required<InterpolateCoordsInputs>
		outputs: {
			coordinates: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"coordinates": new ComfyNodeTypedInputRef<string>(this, "coordinates"),
				"interpolation_curve": new ComfyNodeTypedInputRef<number>(this, "interpolation_curve"),
			},
			outputs: Object.create(Object.prototype, {
				"coordinates": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<InterpolateCoordsInputs>) {
		if (typeof sources["coordinates"] === "object") {
			this.sockets.inputs["coordinates"].connectTo(sources["coordinates"])
		} else {
			this.sockets.inputs["coordinates"].value = sources["coordinates"]
		}

		if (typeof sources["interpolation_curve"] === "object") {
			this.sockets.inputs["interpolation_curve"].connectTo(sources["interpolation_curve"])
		} else {
			this.sockets.inputs["interpolation_curve"].value = sources["interpolation_curve"]
		}

	}
}

type InterpolateCoordsInputs = {
			"coordinates": ComfyNodeTypedInputRef<string>
			"interpolation_curve": ComfyNodeTypedInputRef<number>
}


export class PointsEditor extends ComfyNode {
	classType: string = "PointsEditor"

	sockets: {
		inputs: Required<PointsEditorInputs>
		outputs: {
			positive_coords: ComfyNodeTypedSourceRef<string>
			negative_coords: ComfyNodeTypedSourceRef<string>
			bbox: ComfyNodeTypedSourceRef<ComfyValueType_BBOX>
			bbox_mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			cropped_image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"points_store": new ComfyNodeTypedInputRef<string>(this, "points_store"),
				"coordinates": new ComfyNodeTypedInputRef<string>(this, "coordinates"),
				"neg_coordinates": new ComfyNodeTypedInputRef<string>(this, "neg_coordinates"),
				"bbox_store": new ComfyNodeTypedInputRef<string>(this, "bbox_store"),
				"bboxes": new ComfyNodeTypedInputRef<string>(this, "bboxes"),
				"bbox_format": new ComfyNodeTypedInputRef<string>(this, "bbox_format"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"normalize": new ComfyNodeTypedInputRef<boolean>(this, "normalize"),
				"bg_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "bg_image"),
			},
			outputs: Object.create(Object.prototype, {
				"positive_coords": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative_coords": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"bbox": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"bbox_mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
				"cropped_image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 4 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PointsEditorInputs>) {
		if (typeof sources["points_store"] === "object") {
			this.sockets.inputs["points_store"].connectTo(sources["points_store"])
		} else {
			this.sockets.inputs["points_store"].value = sources["points_store"]
		}

		if (typeof sources["coordinates"] === "object") {
			this.sockets.inputs["coordinates"].connectTo(sources["coordinates"])
		} else {
			this.sockets.inputs["coordinates"].value = sources["coordinates"]
		}

		if (typeof sources["neg_coordinates"] === "object") {
			this.sockets.inputs["neg_coordinates"].connectTo(sources["neg_coordinates"])
		} else {
			this.sockets.inputs["neg_coordinates"].value = sources["neg_coordinates"]
		}

		if (typeof sources["bbox_store"] === "object") {
			this.sockets.inputs["bbox_store"].connectTo(sources["bbox_store"])
		} else {
			this.sockets.inputs["bbox_store"].value = sources["bbox_store"]
		}

		if (typeof sources["bboxes"] === "object") {
			this.sockets.inputs["bboxes"].connectTo(sources["bboxes"])
		} else {
			this.sockets.inputs["bboxes"].value = sources["bboxes"]
		}

		if (typeof sources["bbox_format"] === "object") {
			this.sockets.inputs["bbox_format"].connectTo(sources["bbox_format"])
		} else {
			this.sockets.inputs["bbox_format"].value = sources["bbox_format"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["normalize"] === "object") {
			this.sockets.inputs["normalize"].connectTo(sources["normalize"])
		} else {
			this.sockets.inputs["normalize"].value = sources["normalize"]
		}

		if (sources["bg_image"] !== undefined) {
		if (typeof sources["bg_image"] === "object") {
			this.sockets.inputs["bg_image"].connectTo(sources["bg_image"])
		} else {
			this.sockets.inputs["bg_image"].value = sources["bg_image"]
		}
		}

	}
}

type PointsEditorInputs = {
			"points_store": ComfyNodeTypedInputRef<string>
			"coordinates": ComfyNodeTypedInputRef<string>
			"neg_coordinates": ComfyNodeTypedInputRef<string>
			"bbox_store": ComfyNodeTypedInputRef<string>
			"bboxes": ComfyNodeTypedInputRef<string>
			"bbox_format": ComfyNodeTypedInputRef<string>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"normalize": ComfyNodeTypedInputRef<boolean>
			"bg_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class SoundReactive extends ComfyNode {
	classType: string = "SoundReactive"

	sockets: {
		inputs: Required<SoundReactiveInputs>
		outputs: {
			sound_level: ComfyNodeTypedSourceRef<number>
			sound_level_int: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"sound_level": new ComfyNodeTypedInputRef<number>(this, "sound_level"),
				"start_range_hz": new ComfyNodeTypedInputRef<number>(this, "start_range_hz"),
				"end_range_hz": new ComfyNodeTypedInputRef<number>(this, "end_range_hz"),
				"multiplier": new ComfyNodeTypedInputRef<number>(this, "multiplier"),
				"smoothing_factor": new ComfyNodeTypedInputRef<number>(this, "smoothing_factor"),
				"normalize": new ComfyNodeTypedInputRef<boolean>(this, "normalize"),
			},
			outputs: Object.create(Object.prototype, {
				"sound_level": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"sound_level_int": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SoundReactiveInputs>) {
		if (typeof sources["sound_level"] === "object") {
			this.sockets.inputs["sound_level"].connectTo(sources["sound_level"])
		} else {
			this.sockets.inputs["sound_level"].value = sources["sound_level"]
		}

		if (typeof sources["start_range_hz"] === "object") {
			this.sockets.inputs["start_range_hz"].connectTo(sources["start_range_hz"])
		} else {
			this.sockets.inputs["start_range_hz"].value = sources["start_range_hz"]
		}

		if (typeof sources["end_range_hz"] === "object") {
			this.sockets.inputs["end_range_hz"].connectTo(sources["end_range_hz"])
		} else {
			this.sockets.inputs["end_range_hz"].value = sources["end_range_hz"]
		}

		if (typeof sources["multiplier"] === "object") {
			this.sockets.inputs["multiplier"].connectTo(sources["multiplier"])
		} else {
			this.sockets.inputs["multiplier"].value = sources["multiplier"]
		}

		if (typeof sources["smoothing_factor"] === "object") {
			this.sockets.inputs["smoothing_factor"].connectTo(sources["smoothing_factor"])
		} else {
			this.sockets.inputs["smoothing_factor"].value = sources["smoothing_factor"]
		}

		if (typeof sources["normalize"] === "object") {
			this.sockets.inputs["normalize"].connectTo(sources["normalize"])
		} else {
			this.sockets.inputs["normalize"].value = sources["normalize"]
		}

	}
}

type SoundReactiveInputs = {
			"sound_level": ComfyNodeTypedInputRef<number>
			"start_range_hz": ComfyNodeTypedInputRef<number>
			"end_range_hz": ComfyNodeTypedInputRef<number>
			"multiplier": ComfyNodeTypedInputRef<number>
			"smoothing_factor": ComfyNodeTypedInputRef<number>
			"normalize": ComfyNodeTypedInputRef<boolean>
}


export class StableZero123_BatchSchedule extends ComfyNode {
	classType: string = "StableZero123_BatchSchedule"

	sockets: {
		inputs: Required<StableZero123_BatchScheduleInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_vision": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>(this, "clip_vision"),
				"init_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "init_image"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"interpolation": new ComfyNodeTypedInputRef<string>(this, "interpolation"),
				"azimuth_points_string": new ComfyNodeTypedInputRef<string>(this, "azimuth_points_string"),
				"elevation_points_string": new ComfyNodeTypedInputRef<string>(this, "elevation_points_string"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<StableZero123_BatchScheduleInputs>) {
		if (typeof sources["clip_vision"] === "object") {
			this.sockets.inputs["clip_vision"].connectTo(sources["clip_vision"])
		} else {
			this.sockets.inputs["clip_vision"].value = sources["clip_vision"]
		}

		if (typeof sources["init_image"] === "object") {
			this.sockets.inputs["init_image"].connectTo(sources["init_image"])
		} else {
			this.sockets.inputs["init_image"].value = sources["init_image"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (typeof sources["interpolation"] === "object") {
			this.sockets.inputs["interpolation"].connectTo(sources["interpolation"])
		} else {
			this.sockets.inputs["interpolation"].value = sources["interpolation"]
		}

		if (typeof sources["azimuth_points_string"] === "object") {
			this.sockets.inputs["azimuth_points_string"].connectTo(sources["azimuth_points_string"])
		} else {
			this.sockets.inputs["azimuth_points_string"].value = sources["azimuth_points_string"]
		}

		if (typeof sources["elevation_points_string"] === "object") {
			this.sockets.inputs["elevation_points_string"].connectTo(sources["elevation_points_string"])
		} else {
			this.sockets.inputs["elevation_points_string"].value = sources["elevation_points_string"]
		}

	}
}

type StableZero123_BatchScheduleInputs = {
			"clip_vision": ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>
			"init_image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"interpolation": ComfyNodeTypedInputRef<string>
			"azimuth_points_string": ComfyNodeTypedInputRef<string>
			"elevation_points_string": ComfyNodeTypedInputRef<string>
}


export class SV3D_BatchSchedule extends ComfyNode {
	classType: string = "SV3D_BatchSchedule"

	sockets: {
		inputs: Required<SV3D_BatchScheduleInputs>
		outputs: {
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_vision": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>(this, "clip_vision"),
				"init_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "init_image"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"batch_size": new ComfyNodeTypedInputRef<number>(this, "batch_size"),
				"interpolation": new ComfyNodeTypedInputRef<string>(this, "interpolation"),
				"azimuth_points_string": new ComfyNodeTypedInputRef<string>(this, "azimuth_points_string"),
				"elevation_points_string": new ComfyNodeTypedInputRef<string>(this, "elevation_points_string"),
			},
			outputs: Object.create(Object.prototype, {
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SV3D_BatchScheduleInputs>) {
		if (typeof sources["clip_vision"] === "object") {
			this.sockets.inputs["clip_vision"].connectTo(sources["clip_vision"])
		} else {
			this.sockets.inputs["clip_vision"].value = sources["clip_vision"]
		}

		if (typeof sources["init_image"] === "object") {
			this.sockets.inputs["init_image"].connectTo(sources["init_image"])
		} else {
			this.sockets.inputs["init_image"].value = sources["init_image"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["batch_size"] === "object") {
			this.sockets.inputs["batch_size"].connectTo(sources["batch_size"])
		} else {
			this.sockets.inputs["batch_size"].value = sources["batch_size"]
		}

		if (typeof sources["interpolation"] === "object") {
			this.sockets.inputs["interpolation"].connectTo(sources["interpolation"])
		} else {
			this.sockets.inputs["interpolation"].value = sources["interpolation"]
		}

		if (typeof sources["azimuth_points_string"] === "object") {
			this.sockets.inputs["azimuth_points_string"].connectTo(sources["azimuth_points_string"])
		} else {
			this.sockets.inputs["azimuth_points_string"].value = sources["azimuth_points_string"]
		}

		if (typeof sources["elevation_points_string"] === "object") {
			this.sockets.inputs["elevation_points_string"].connectTo(sources["elevation_points_string"])
		} else {
			this.sockets.inputs["elevation_points_string"].value = sources["elevation_points_string"]
		}

	}
}

type SV3D_BatchScheduleInputs = {
			"clip_vision": ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>
			"init_image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"batch_size": ComfyNodeTypedInputRef<number>
			"interpolation": ComfyNodeTypedInputRef<string>
			"azimuth_points_string": ComfyNodeTypedInputRef<string>
			"elevation_points_string": ComfyNodeTypedInputRef<string>
}


export class LoadResAdapterNormalization extends ComfyNode {
	classType: string = "LoadResAdapterNormalization"

	sockets: {
		inputs: Required<LoadResAdapterNormalizationInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"resadapter_path": new ComfyNodeTypedInputRef<string>(this, "resadapter_path"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoadResAdapterNormalizationInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["resadapter_path"] === "object") {
			this.sockets.inputs["resadapter_path"].connectTo(sources["resadapter_path"])
		} else {
			this.sockets.inputs["resadapter_path"].value = sources["resadapter_path"]
		}

	}
}

type LoadResAdapterNormalizationInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"resadapter_path": ComfyNodeTypedInputRef<string>
}


export class Superprompt extends ComfyNode {
	classType: string = "Superprompt"

	sockets: {
		inputs: Required<SuperpromptInputs>
		outputs: {
			STRING: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"instruction_prompt": new ComfyNodeTypedInputRef<string>(this, "instruction_prompt"),
				"prompt": new ComfyNodeTypedInputRef<string>(this, "prompt"),
				"max_new_tokens": new ComfyNodeTypedInputRef<number>(this, "max_new_tokens"),
			},
			outputs: Object.create(Object.prototype, {
				"STRING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SuperpromptInputs>) {
		if (typeof sources["instruction_prompt"] === "object") {
			this.sockets.inputs["instruction_prompt"].connectTo(sources["instruction_prompt"])
		} else {
			this.sockets.inputs["instruction_prompt"].value = sources["instruction_prompt"]
		}

		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}

		if (typeof sources["max_new_tokens"] === "object") {
			this.sockets.inputs["max_new_tokens"].connectTo(sources["max_new_tokens"])
		} else {
			this.sockets.inputs["max_new_tokens"].value = sources["max_new_tokens"]
		}

	}
}

type SuperpromptInputs = {
			"instruction_prompt": ComfyNodeTypedInputRef<string>
			"prompt": ComfyNodeTypedInputRef<string>
			"max_new_tokens": ComfyNodeTypedInputRef<number>
}


export class GLIGENTextBoxApplyBatchCoords extends ComfyNode {
	classType: string = "GLIGENTextBoxApplyBatchCoords"

	sockets: {
		inputs: Required<GLIGENTextBoxApplyBatchCoordsInputs>
		outputs: {
			conditioning: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			coord_preview: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"conditioning_to": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning_to"),
				"latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latents"),
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"gligen_textbox_model": new ComfyNodeTypedInputRef<ComfyValueType_GLIGEN>(this, "gligen_textbox_model"),
				"coordinates": new ComfyNodeTypedInputRef<string>(this, "coordinates"),
				"text": new ComfyNodeTypedInputRef<string>(this, "text"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"size_multiplier": new ComfyNodeTypedInputRef<number>(this, "size_multiplier"),
			},
			outputs: Object.create(Object.prototype, {
				"conditioning": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"coord_preview": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<GLIGENTextBoxApplyBatchCoordsInputs>) {
		if (typeof sources["conditioning_to"] === "object") {
			this.sockets.inputs["conditioning_to"].connectTo(sources["conditioning_to"])
		} else {
			this.sockets.inputs["conditioning_to"].value = sources["conditioning_to"]
		}

		if (typeof sources["latents"] === "object") {
			this.sockets.inputs["latents"].connectTo(sources["latents"])
		} else {
			this.sockets.inputs["latents"].value = sources["latents"]
		}

		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["gligen_textbox_model"] === "object") {
			this.sockets.inputs["gligen_textbox_model"].connectTo(sources["gligen_textbox_model"])
		} else {
			this.sockets.inputs["gligen_textbox_model"].value = sources["gligen_textbox_model"]
		}

		if (typeof sources["coordinates"] === "object") {
			this.sockets.inputs["coordinates"].connectTo(sources["coordinates"])
		} else {
			this.sockets.inputs["coordinates"].value = sources["coordinates"]
		}

		if (typeof sources["text"] === "object") {
			this.sockets.inputs["text"].connectTo(sources["text"])
		} else {
			this.sockets.inputs["text"].value = sources["text"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (sources["size_multiplier"] !== undefined) {
		if (typeof sources["size_multiplier"] === "object") {
			this.sockets.inputs["size_multiplier"].connectTo(sources["size_multiplier"])
		} else {
			this.sockets.inputs["size_multiplier"].value = sources["size_multiplier"]
		}
		}

	}
}

type GLIGENTextBoxApplyBatchCoordsInputs = {
			"conditioning_to": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"latents": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"gligen_textbox_model": ComfyNodeTypedInputRef<ComfyValueType_GLIGEN>
			"coordinates": ComfyNodeTypedInputRef<string>
			"text": ComfyNodeTypedInputRef<string>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"size_multiplier"?: ComfyNodeTypedInputRef<number>
}


export class Intrinsic_lora_sampling extends ComfyNode {
	classType: string = "Intrinsic_lora_sampling"

	sockets: {
		inputs: Required<Intrinsic_lora_samplingInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"lora_name": new ComfyNodeTypedInputRef<string>(this, "lora_name"),
				"task": new ComfyNodeTypedInputRef<string>(this, "task"),
				"text": new ComfyNodeTypedInputRef<string>(this, "text"),
				"clip": new ComfyNodeTypedInputRef<ComfyValueType_CLIP>(this, "clip"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"per_batch": new ComfyNodeTypedInputRef<number>(this, "per_batch"),
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"optional_latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "optional_latent"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<Intrinsic_lora_samplingInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["lora_name"] === "object") {
			this.sockets.inputs["lora_name"].connectTo(sources["lora_name"])
		} else {
			this.sockets.inputs["lora_name"].value = sources["lora_name"]
		}

		if (typeof sources["task"] === "object") {
			this.sockets.inputs["task"].connectTo(sources["task"])
		} else {
			this.sockets.inputs["task"].value = sources["task"]
		}

		if (typeof sources["text"] === "object") {
			this.sockets.inputs["text"].connectTo(sources["text"])
		} else {
			this.sockets.inputs["text"].value = sources["text"]
		}

		if (typeof sources["clip"] === "object") {
			this.sockets.inputs["clip"].connectTo(sources["clip"])
		} else {
			this.sockets.inputs["clip"].value = sources["clip"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["per_batch"] === "object") {
			this.sockets.inputs["per_batch"].connectTo(sources["per_batch"])
		} else {
			this.sockets.inputs["per_batch"].value = sources["per_batch"]
		}

		if (sources["image"] !== undefined) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}
		}

		if (sources["optional_latent"] !== undefined) {
		if (typeof sources["optional_latent"] === "object") {
			this.sockets.inputs["optional_latent"].connectTo(sources["optional_latent"])
		} else {
			this.sockets.inputs["optional_latent"].value = sources["optional_latent"]
		}
		}

	}
}

type Intrinsic_lora_samplingInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"lora_name": ComfyNodeTypedInputRef<string>
			"task": ComfyNodeTypedInputRef<string>
			"text": ComfyNodeTypedInputRef<string>
			"clip": ComfyNodeTypedInputRef<ComfyValueType_CLIP>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"per_batch": ComfyNodeTypedInputRef<number>
			"image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"optional_latent"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class CheckpointPerturbWeights extends ComfyNode {
	classType: string = "CheckpointPerturbWeights"

	sockets: {
		inputs: Required<CheckpointPerturbWeightsInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"joint_blocks": new ComfyNodeTypedInputRef<number>(this, "joint_blocks"),
				"final_layer": new ComfyNodeTypedInputRef<number>(this, "final_layer"),
				"rest_of_the_blocks": new ComfyNodeTypedInputRef<number>(this, "rest_of_the_blocks"),
				"seed": new ComfyNodeTypedInputRef<number>(this, "seed"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CheckpointPerturbWeightsInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["joint_blocks"] === "object") {
			this.sockets.inputs["joint_blocks"].connectTo(sources["joint_blocks"])
		} else {
			this.sockets.inputs["joint_blocks"].value = sources["joint_blocks"]
		}

		if (typeof sources["final_layer"] === "object") {
			this.sockets.inputs["final_layer"].connectTo(sources["final_layer"])
		} else {
			this.sockets.inputs["final_layer"].value = sources["final_layer"]
		}

		if (typeof sources["rest_of_the_blocks"] === "object") {
			this.sockets.inputs["rest_of_the_blocks"].connectTo(sources["rest_of_the_blocks"])
		} else {
			this.sockets.inputs["rest_of_the_blocks"].value = sources["rest_of_the_blocks"]
		}

		if (typeof sources["seed"] === "object") {
			this.sockets.inputs["seed"].connectTo(sources["seed"])
		} else {
			this.sockets.inputs["seed"].value = sources["seed"]
		}

	}
}

type CheckpointPerturbWeightsInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"joint_blocks": ComfyNodeTypedInputRef<number>
			"final_layer": ComfyNodeTypedInputRef<number>
			"rest_of_the_blocks": ComfyNodeTypedInputRef<number>
			"seed": ComfyNodeTypedInputRef<number>
}


export class Screencap_mss extends ComfyNode {
	classType: string = "Screencap_mss"

	sockets: {
		inputs: Required<Screencap_mssInputs>
		outputs: {
			image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"x": new ComfyNodeTypedInputRef<number>(this, "x"),
				"y": new ComfyNodeTypedInputRef<number>(this, "y"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"num_frames": new ComfyNodeTypedInputRef<number>(this, "num_frames"),
				"delay": new ComfyNodeTypedInputRef<number>(this, "delay"),
			},
			outputs: Object.create(Object.prototype, {
				"image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<Screencap_mssInputs>) {
		if (typeof sources["x"] === "object") {
			this.sockets.inputs["x"].connectTo(sources["x"])
		} else {
			this.sockets.inputs["x"].value = sources["x"]
		}

		if (typeof sources["y"] === "object") {
			this.sockets.inputs["y"].connectTo(sources["y"])
		} else {
			this.sockets.inputs["y"].value = sources["y"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["num_frames"] === "object") {
			this.sockets.inputs["num_frames"].connectTo(sources["num_frames"])
		} else {
			this.sockets.inputs["num_frames"].value = sources["num_frames"]
		}

		if (typeof sources["delay"] === "object") {
			this.sockets.inputs["delay"].connectTo(sources["delay"])
		} else {
			this.sockets.inputs["delay"].value = sources["delay"]
		}

	}
}

type Screencap_mssInputs = {
			"x": ComfyNodeTypedInputRef<number>
			"y": ComfyNodeTypedInputRef<number>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"num_frames": ComfyNodeTypedInputRef<number>
			"delay": ComfyNodeTypedInputRef<number>
}


export class WebcamCaptureCV2 extends ComfyNode {
	classType: string = "WebcamCaptureCV2"

	sockets: {
		inputs: Required<WebcamCaptureCV2Inputs>
		outputs: {
			image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"x": new ComfyNodeTypedInputRef<number>(this, "x"),
				"y": new ComfyNodeTypedInputRef<number>(this, "y"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"cam_index": new ComfyNodeTypedInputRef<number>(this, "cam_index"),
				"release": new ComfyNodeTypedInputRef<boolean>(this, "release"),
			},
			outputs: Object.create(Object.prototype, {
				"image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WebcamCaptureCV2Inputs>) {
		if (typeof sources["x"] === "object") {
			this.sockets.inputs["x"].connectTo(sources["x"])
		} else {
			this.sockets.inputs["x"].value = sources["x"]
		}

		if (typeof sources["y"] === "object") {
			this.sockets.inputs["y"].connectTo(sources["y"])
		} else {
			this.sockets.inputs["y"].value = sources["y"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["cam_index"] === "object") {
			this.sockets.inputs["cam_index"].connectTo(sources["cam_index"])
		} else {
			this.sockets.inputs["cam_index"].value = sources["cam_index"]
		}

		if (typeof sources["release"] === "object") {
			this.sockets.inputs["release"].connectTo(sources["release"])
		} else {
			this.sockets.inputs["release"].value = sources["release"]
		}

	}
}

type WebcamCaptureCV2Inputs = {
			"x": ComfyNodeTypedInputRef<number>
			"y": ComfyNodeTypedInputRef<number>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"cam_index": ComfyNodeTypedInputRef<number>
			"release": ComfyNodeTypedInputRef<boolean>
}


export class DifferentialDiffusionAdvanced extends ComfyNode {
	classType: string = "DifferentialDiffusionAdvanced"

	sockets: {
		inputs: Required<DifferentialDiffusionAdvancedInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"multiplier": new ComfyNodeTypedInputRef<number>(this, "multiplier"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DifferentialDiffusionAdvancedInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["multiplier"] === "object") {
			this.sockets.inputs["multiplier"].connectTo(sources["multiplier"])
		} else {
			this.sockets.inputs["multiplier"].value = sources["multiplier"]
		}

	}
}

type DifferentialDiffusionAdvancedInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"multiplier": ComfyNodeTypedInputRef<number>
}


export class DiTBlockLoraLoader extends ComfyNode {
	classType: string = "DiTBlockLoraLoader"

	sockets: {
		inputs: Required<DiTBlockLoraLoaderInputs>
		outputs: {
			/** The modified diffusion model.*/
			model: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
			/** possible rank of the LoRA.*/
			rank: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"strength_model": new ComfyNodeTypedInputRef<number>(this, "strength_model"),
				"lora_name": new ComfyNodeTypedInputRef<string>(this, "lora_name"),
				"opt_lora_path": new ComfyNodeTypedInputRef<string>(this, "opt_lora_path"),
				"blocks": new ComfyNodeTypedInputRef<ComfyValueType_SELECTEDDITBLOCKS>(this, "blocks"),
			},
			outputs: Object.create(Object.prototype, {
				"model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"rank": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DiTBlockLoraLoaderInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["strength_model"] === "object") {
			this.sockets.inputs["strength_model"].connectTo(sources["strength_model"])
		} else {
			this.sockets.inputs["strength_model"].value = sources["strength_model"]
		}

		if (sources["lora_name"] !== undefined) {
		if (typeof sources["lora_name"] === "object") {
			this.sockets.inputs["lora_name"].connectTo(sources["lora_name"])
		} else {
			this.sockets.inputs["lora_name"].value = sources["lora_name"]
		}
		}

		if (sources["opt_lora_path"] !== undefined) {
		if (typeof sources["opt_lora_path"] === "object") {
			this.sockets.inputs["opt_lora_path"].connectTo(sources["opt_lora_path"])
		} else {
			this.sockets.inputs["opt_lora_path"].value = sources["opt_lora_path"]
		}
		}

		if (sources["blocks"] !== undefined) {
		if (typeof sources["blocks"] === "object") {
			this.sockets.inputs["blocks"].connectTo(sources["blocks"])
		} else {
			this.sockets.inputs["blocks"].value = sources["blocks"]
		}
		}

	}
}

type DiTBlockLoraLoaderInputs = {
			/** The diffusion model the LoRA will be applied to.*/
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** How strongly to modify the diffusion model. This value can be negative.*/
			"strength_model": ComfyNodeTypedInputRef<number>
			/** The name of the LoRA.*/
			"lora_name"?: ComfyNodeTypedInputRef<string>
			/** Absolute path of the LoRA.*/
			"opt_lora_path"?: ComfyNodeTypedInputRef<string>
			"blocks"?: ComfyNodeTypedInputRef<ComfyValueType_SELECTEDDITBLOCKS>
}


export class FluxBlockLoraSelect extends ComfyNode {
	classType: string = "FluxBlockLoraSelect"

	sockets: {
		inputs: Required<FluxBlockLoraSelectInputs>
		outputs: {
			/** The modified diffusion model.*/
			blocks: ComfyNodeTypedSourceRef<ComfyValueType_SELECTEDDITBLOCKS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"double_blocks.0.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.0."),
				"double_blocks.1.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.1."),
				"double_blocks.2.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.2."),
				"double_blocks.3.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.3."),
				"double_blocks.4.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.4."),
				"double_blocks.5.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.5."),
				"double_blocks.6.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.6."),
				"double_blocks.7.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.7."),
				"double_blocks.8.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.8."),
				"double_blocks.9.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.9."),
				"double_blocks.10.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.10."),
				"double_blocks.11.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.11."),
				"double_blocks.12.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.12."),
				"double_blocks.13.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.13."),
				"double_blocks.14.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.14."),
				"double_blocks.15.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.15."),
				"double_blocks.16.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.16."),
				"double_blocks.17.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.17."),
				"double_blocks.18.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.18."),
				"single_blocks.0.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.0."),
				"single_blocks.1.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.1."),
				"single_blocks.2.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.2."),
				"single_blocks.3.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.3."),
				"single_blocks.4.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.4."),
				"single_blocks.5.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.5."),
				"single_blocks.6.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.6."),
				"single_blocks.7.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.7."),
				"single_blocks.8.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.8."),
				"single_blocks.9.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.9."),
				"single_blocks.10.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.10."),
				"single_blocks.11.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.11."),
				"single_blocks.12.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.12."),
				"single_blocks.13.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.13."),
				"single_blocks.14.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.14."),
				"single_blocks.15.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.15."),
				"single_blocks.16.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.16."),
				"single_blocks.17.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.17."),
				"single_blocks.18.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.18."),
				"single_blocks.19.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.19."),
				"single_blocks.20.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.20."),
				"single_blocks.21.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.21."),
				"single_blocks.22.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.22."),
				"single_blocks.23.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.23."),
				"single_blocks.24.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.24."),
				"single_blocks.25.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.25."),
				"single_blocks.26.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.26."),
				"single_blocks.27.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.27."),
				"single_blocks.28.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.28."),
				"single_blocks.29.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.29."),
				"single_blocks.30.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.30."),
				"single_blocks.31.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.31."),
				"single_blocks.32.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.32."),
				"single_blocks.33.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.33."),
				"single_blocks.34.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.34."),
				"single_blocks.35.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.35."),
				"single_blocks.36.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.36."),
				"single_blocks.37.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.37."),
			},
			outputs: Object.create(Object.prototype, {
				"blocks": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<FluxBlockLoraSelectInputs>) {
		if (typeof sources["double_blocks.0."] === "object") {
			this.sockets.inputs["double_blocks.0."].connectTo(sources["double_blocks.0."])
		} else {
			this.sockets.inputs["double_blocks.0."].value = sources["double_blocks.0."]
		}

		if (typeof sources["double_blocks.1."] === "object") {
			this.sockets.inputs["double_blocks.1."].connectTo(sources["double_blocks.1."])
		} else {
			this.sockets.inputs["double_blocks.1."].value = sources["double_blocks.1."]
		}

		if (typeof sources["double_blocks.2."] === "object") {
			this.sockets.inputs["double_blocks.2."].connectTo(sources["double_blocks.2."])
		} else {
			this.sockets.inputs["double_blocks.2."].value = sources["double_blocks.2."]
		}

		if (typeof sources["double_blocks.3."] === "object") {
			this.sockets.inputs["double_blocks.3."].connectTo(sources["double_blocks.3."])
		} else {
			this.sockets.inputs["double_blocks.3."].value = sources["double_blocks.3."]
		}

		if (typeof sources["double_blocks.4."] === "object") {
			this.sockets.inputs["double_blocks.4."].connectTo(sources["double_blocks.4."])
		} else {
			this.sockets.inputs["double_blocks.4."].value = sources["double_blocks.4."]
		}

		if (typeof sources["double_blocks.5."] === "object") {
			this.sockets.inputs["double_blocks.5."].connectTo(sources["double_blocks.5."])
		} else {
			this.sockets.inputs["double_blocks.5."].value = sources["double_blocks.5."]
		}

		if (typeof sources["double_blocks.6."] === "object") {
			this.sockets.inputs["double_blocks.6."].connectTo(sources["double_blocks.6."])
		} else {
			this.sockets.inputs["double_blocks.6."].value = sources["double_blocks.6."]
		}

		if (typeof sources["double_blocks.7."] === "object") {
			this.sockets.inputs["double_blocks.7."].connectTo(sources["double_blocks.7."])
		} else {
			this.sockets.inputs["double_blocks.7."].value = sources["double_blocks.7."]
		}

		if (typeof sources["double_blocks.8."] === "object") {
			this.sockets.inputs["double_blocks.8."].connectTo(sources["double_blocks.8."])
		} else {
			this.sockets.inputs["double_blocks.8."].value = sources["double_blocks.8."]
		}

		if (typeof sources["double_blocks.9."] === "object") {
			this.sockets.inputs["double_blocks.9."].connectTo(sources["double_blocks.9."])
		} else {
			this.sockets.inputs["double_blocks.9."].value = sources["double_blocks.9."]
		}

		if (typeof sources["double_blocks.10."] === "object") {
			this.sockets.inputs["double_blocks.10."].connectTo(sources["double_blocks.10."])
		} else {
			this.sockets.inputs["double_blocks.10."].value = sources["double_blocks.10."]
		}

		if (typeof sources["double_blocks.11."] === "object") {
			this.sockets.inputs["double_blocks.11."].connectTo(sources["double_blocks.11."])
		} else {
			this.sockets.inputs["double_blocks.11."].value = sources["double_blocks.11."]
		}

		if (typeof sources["double_blocks.12."] === "object") {
			this.sockets.inputs["double_blocks.12."].connectTo(sources["double_blocks.12."])
		} else {
			this.sockets.inputs["double_blocks.12."].value = sources["double_blocks.12."]
		}

		if (typeof sources["double_blocks.13."] === "object") {
			this.sockets.inputs["double_blocks.13."].connectTo(sources["double_blocks.13."])
		} else {
			this.sockets.inputs["double_blocks.13."].value = sources["double_blocks.13."]
		}

		if (typeof sources["double_blocks.14."] === "object") {
			this.sockets.inputs["double_blocks.14."].connectTo(sources["double_blocks.14."])
		} else {
			this.sockets.inputs["double_blocks.14."].value = sources["double_blocks.14."]
		}

		if (typeof sources["double_blocks.15."] === "object") {
			this.sockets.inputs["double_blocks.15."].connectTo(sources["double_blocks.15."])
		} else {
			this.sockets.inputs["double_blocks.15."].value = sources["double_blocks.15."]
		}

		if (typeof sources["double_blocks.16."] === "object") {
			this.sockets.inputs["double_blocks.16."].connectTo(sources["double_blocks.16."])
		} else {
			this.sockets.inputs["double_blocks.16."].value = sources["double_blocks.16."]
		}

		if (typeof sources["double_blocks.17."] === "object") {
			this.sockets.inputs["double_blocks.17."].connectTo(sources["double_blocks.17."])
		} else {
			this.sockets.inputs["double_blocks.17."].value = sources["double_blocks.17."]
		}

		if (typeof sources["double_blocks.18."] === "object") {
			this.sockets.inputs["double_blocks.18."].connectTo(sources["double_blocks.18."])
		} else {
			this.sockets.inputs["double_blocks.18."].value = sources["double_blocks.18."]
		}

		if (typeof sources["single_blocks.0."] === "object") {
			this.sockets.inputs["single_blocks.0."].connectTo(sources["single_blocks.0."])
		} else {
			this.sockets.inputs["single_blocks.0."].value = sources["single_blocks.0."]
		}

		if (typeof sources["single_blocks.1."] === "object") {
			this.sockets.inputs["single_blocks.1."].connectTo(sources["single_blocks.1."])
		} else {
			this.sockets.inputs["single_blocks.1."].value = sources["single_blocks.1."]
		}

		if (typeof sources["single_blocks.2."] === "object") {
			this.sockets.inputs["single_blocks.2."].connectTo(sources["single_blocks.2."])
		} else {
			this.sockets.inputs["single_blocks.2."].value = sources["single_blocks.2."]
		}

		if (typeof sources["single_blocks.3."] === "object") {
			this.sockets.inputs["single_blocks.3."].connectTo(sources["single_blocks.3."])
		} else {
			this.sockets.inputs["single_blocks.3."].value = sources["single_blocks.3."]
		}

		if (typeof sources["single_blocks.4."] === "object") {
			this.sockets.inputs["single_blocks.4."].connectTo(sources["single_blocks.4."])
		} else {
			this.sockets.inputs["single_blocks.4."].value = sources["single_blocks.4."]
		}

		if (typeof sources["single_blocks.5."] === "object") {
			this.sockets.inputs["single_blocks.5."].connectTo(sources["single_blocks.5."])
		} else {
			this.sockets.inputs["single_blocks.5."].value = sources["single_blocks.5."]
		}

		if (typeof sources["single_blocks.6."] === "object") {
			this.sockets.inputs["single_blocks.6."].connectTo(sources["single_blocks.6."])
		} else {
			this.sockets.inputs["single_blocks.6."].value = sources["single_blocks.6."]
		}

		if (typeof sources["single_blocks.7."] === "object") {
			this.sockets.inputs["single_blocks.7."].connectTo(sources["single_blocks.7."])
		} else {
			this.sockets.inputs["single_blocks.7."].value = sources["single_blocks.7."]
		}

		if (typeof sources["single_blocks.8."] === "object") {
			this.sockets.inputs["single_blocks.8."].connectTo(sources["single_blocks.8."])
		} else {
			this.sockets.inputs["single_blocks.8."].value = sources["single_blocks.8."]
		}

		if (typeof sources["single_blocks.9."] === "object") {
			this.sockets.inputs["single_blocks.9."].connectTo(sources["single_blocks.9."])
		} else {
			this.sockets.inputs["single_blocks.9."].value = sources["single_blocks.9."]
		}

		if (typeof sources["single_blocks.10."] === "object") {
			this.sockets.inputs["single_blocks.10."].connectTo(sources["single_blocks.10."])
		} else {
			this.sockets.inputs["single_blocks.10."].value = sources["single_blocks.10."]
		}

		if (typeof sources["single_blocks.11."] === "object") {
			this.sockets.inputs["single_blocks.11."].connectTo(sources["single_blocks.11."])
		} else {
			this.sockets.inputs["single_blocks.11."].value = sources["single_blocks.11."]
		}

		if (typeof sources["single_blocks.12."] === "object") {
			this.sockets.inputs["single_blocks.12."].connectTo(sources["single_blocks.12."])
		} else {
			this.sockets.inputs["single_blocks.12."].value = sources["single_blocks.12."]
		}

		if (typeof sources["single_blocks.13."] === "object") {
			this.sockets.inputs["single_blocks.13."].connectTo(sources["single_blocks.13."])
		} else {
			this.sockets.inputs["single_blocks.13."].value = sources["single_blocks.13."]
		}

		if (typeof sources["single_blocks.14."] === "object") {
			this.sockets.inputs["single_blocks.14."].connectTo(sources["single_blocks.14."])
		} else {
			this.sockets.inputs["single_blocks.14."].value = sources["single_blocks.14."]
		}

		if (typeof sources["single_blocks.15."] === "object") {
			this.sockets.inputs["single_blocks.15."].connectTo(sources["single_blocks.15."])
		} else {
			this.sockets.inputs["single_blocks.15."].value = sources["single_blocks.15."]
		}

		if (typeof sources["single_blocks.16."] === "object") {
			this.sockets.inputs["single_blocks.16."].connectTo(sources["single_blocks.16."])
		} else {
			this.sockets.inputs["single_blocks.16."].value = sources["single_blocks.16."]
		}

		if (typeof sources["single_blocks.17."] === "object") {
			this.sockets.inputs["single_blocks.17."].connectTo(sources["single_blocks.17."])
		} else {
			this.sockets.inputs["single_blocks.17."].value = sources["single_blocks.17."]
		}

		if (typeof sources["single_blocks.18."] === "object") {
			this.sockets.inputs["single_blocks.18."].connectTo(sources["single_blocks.18."])
		} else {
			this.sockets.inputs["single_blocks.18."].value = sources["single_blocks.18."]
		}

		if (typeof sources["single_blocks.19."] === "object") {
			this.sockets.inputs["single_blocks.19."].connectTo(sources["single_blocks.19."])
		} else {
			this.sockets.inputs["single_blocks.19."].value = sources["single_blocks.19."]
		}

		if (typeof sources["single_blocks.20."] === "object") {
			this.sockets.inputs["single_blocks.20."].connectTo(sources["single_blocks.20."])
		} else {
			this.sockets.inputs["single_blocks.20."].value = sources["single_blocks.20."]
		}

		if (typeof sources["single_blocks.21."] === "object") {
			this.sockets.inputs["single_blocks.21."].connectTo(sources["single_blocks.21."])
		} else {
			this.sockets.inputs["single_blocks.21."].value = sources["single_blocks.21."]
		}

		if (typeof sources["single_blocks.22."] === "object") {
			this.sockets.inputs["single_blocks.22."].connectTo(sources["single_blocks.22."])
		} else {
			this.sockets.inputs["single_blocks.22."].value = sources["single_blocks.22."]
		}

		if (typeof sources["single_blocks.23."] === "object") {
			this.sockets.inputs["single_blocks.23."].connectTo(sources["single_blocks.23."])
		} else {
			this.sockets.inputs["single_blocks.23."].value = sources["single_blocks.23."]
		}

		if (typeof sources["single_blocks.24."] === "object") {
			this.sockets.inputs["single_blocks.24."].connectTo(sources["single_blocks.24."])
		} else {
			this.sockets.inputs["single_blocks.24."].value = sources["single_blocks.24."]
		}

		if (typeof sources["single_blocks.25."] === "object") {
			this.sockets.inputs["single_blocks.25."].connectTo(sources["single_blocks.25."])
		} else {
			this.sockets.inputs["single_blocks.25."].value = sources["single_blocks.25."]
		}

		if (typeof sources["single_blocks.26."] === "object") {
			this.sockets.inputs["single_blocks.26."].connectTo(sources["single_blocks.26."])
		} else {
			this.sockets.inputs["single_blocks.26."].value = sources["single_blocks.26."]
		}

		if (typeof sources["single_blocks.27."] === "object") {
			this.sockets.inputs["single_blocks.27."].connectTo(sources["single_blocks.27."])
		} else {
			this.sockets.inputs["single_blocks.27."].value = sources["single_blocks.27."]
		}

		if (typeof sources["single_blocks.28."] === "object") {
			this.sockets.inputs["single_blocks.28."].connectTo(sources["single_blocks.28."])
		} else {
			this.sockets.inputs["single_blocks.28."].value = sources["single_blocks.28."]
		}

		if (typeof sources["single_blocks.29."] === "object") {
			this.sockets.inputs["single_blocks.29."].connectTo(sources["single_blocks.29."])
		} else {
			this.sockets.inputs["single_blocks.29."].value = sources["single_blocks.29."]
		}

		if (typeof sources["single_blocks.30."] === "object") {
			this.sockets.inputs["single_blocks.30."].connectTo(sources["single_blocks.30."])
		} else {
			this.sockets.inputs["single_blocks.30."].value = sources["single_blocks.30."]
		}

		if (typeof sources["single_blocks.31."] === "object") {
			this.sockets.inputs["single_blocks.31."].connectTo(sources["single_blocks.31."])
		} else {
			this.sockets.inputs["single_blocks.31."].value = sources["single_blocks.31."]
		}

		if (typeof sources["single_blocks.32."] === "object") {
			this.sockets.inputs["single_blocks.32."].connectTo(sources["single_blocks.32."])
		} else {
			this.sockets.inputs["single_blocks.32."].value = sources["single_blocks.32."]
		}

		if (typeof sources["single_blocks.33."] === "object") {
			this.sockets.inputs["single_blocks.33."].connectTo(sources["single_blocks.33."])
		} else {
			this.sockets.inputs["single_blocks.33."].value = sources["single_blocks.33."]
		}

		if (typeof sources["single_blocks.34."] === "object") {
			this.sockets.inputs["single_blocks.34."].connectTo(sources["single_blocks.34."])
		} else {
			this.sockets.inputs["single_blocks.34."].value = sources["single_blocks.34."]
		}

		if (typeof sources["single_blocks.35."] === "object") {
			this.sockets.inputs["single_blocks.35."].connectTo(sources["single_blocks.35."])
		} else {
			this.sockets.inputs["single_blocks.35."].value = sources["single_blocks.35."]
		}

		if (typeof sources["single_blocks.36."] === "object") {
			this.sockets.inputs["single_blocks.36."].connectTo(sources["single_blocks.36."])
		} else {
			this.sockets.inputs["single_blocks.36."].value = sources["single_blocks.36."]
		}

		if (typeof sources["single_blocks.37."] === "object") {
			this.sockets.inputs["single_blocks.37."].connectTo(sources["single_blocks.37."])
		} else {
			this.sockets.inputs["single_blocks.37."].value = sources["single_blocks.37."]
		}

	}
}

type FluxBlockLoraSelectInputs = {
			"double_blocks.0.": ComfyNodeTypedInputRef<number>
			"double_blocks.1.": ComfyNodeTypedInputRef<number>
			"double_blocks.2.": ComfyNodeTypedInputRef<number>
			"double_blocks.3.": ComfyNodeTypedInputRef<number>
			"double_blocks.4.": ComfyNodeTypedInputRef<number>
			"double_blocks.5.": ComfyNodeTypedInputRef<number>
			"double_blocks.6.": ComfyNodeTypedInputRef<number>
			"double_blocks.7.": ComfyNodeTypedInputRef<number>
			"double_blocks.8.": ComfyNodeTypedInputRef<number>
			"double_blocks.9.": ComfyNodeTypedInputRef<number>
			"double_blocks.10.": ComfyNodeTypedInputRef<number>
			"double_blocks.11.": ComfyNodeTypedInputRef<number>
			"double_blocks.12.": ComfyNodeTypedInputRef<number>
			"double_blocks.13.": ComfyNodeTypedInputRef<number>
			"double_blocks.14.": ComfyNodeTypedInputRef<number>
			"double_blocks.15.": ComfyNodeTypedInputRef<number>
			"double_blocks.16.": ComfyNodeTypedInputRef<number>
			"double_blocks.17.": ComfyNodeTypedInputRef<number>
			"double_blocks.18.": ComfyNodeTypedInputRef<number>
			"single_blocks.0.": ComfyNodeTypedInputRef<number>
			"single_blocks.1.": ComfyNodeTypedInputRef<number>
			"single_blocks.2.": ComfyNodeTypedInputRef<number>
			"single_blocks.3.": ComfyNodeTypedInputRef<number>
			"single_blocks.4.": ComfyNodeTypedInputRef<number>
			"single_blocks.5.": ComfyNodeTypedInputRef<number>
			"single_blocks.6.": ComfyNodeTypedInputRef<number>
			"single_blocks.7.": ComfyNodeTypedInputRef<number>
			"single_blocks.8.": ComfyNodeTypedInputRef<number>
			"single_blocks.9.": ComfyNodeTypedInputRef<number>
			"single_blocks.10.": ComfyNodeTypedInputRef<number>
			"single_blocks.11.": ComfyNodeTypedInputRef<number>
			"single_blocks.12.": ComfyNodeTypedInputRef<number>
			"single_blocks.13.": ComfyNodeTypedInputRef<number>
			"single_blocks.14.": ComfyNodeTypedInputRef<number>
			"single_blocks.15.": ComfyNodeTypedInputRef<number>
			"single_blocks.16.": ComfyNodeTypedInputRef<number>
			"single_blocks.17.": ComfyNodeTypedInputRef<number>
			"single_blocks.18.": ComfyNodeTypedInputRef<number>
			"single_blocks.19.": ComfyNodeTypedInputRef<number>
			"single_blocks.20.": ComfyNodeTypedInputRef<number>
			"single_blocks.21.": ComfyNodeTypedInputRef<number>
			"single_blocks.22.": ComfyNodeTypedInputRef<number>
			"single_blocks.23.": ComfyNodeTypedInputRef<number>
			"single_blocks.24.": ComfyNodeTypedInputRef<number>
			"single_blocks.25.": ComfyNodeTypedInputRef<number>
			"single_blocks.26.": ComfyNodeTypedInputRef<number>
			"single_blocks.27.": ComfyNodeTypedInputRef<number>
			"single_blocks.28.": ComfyNodeTypedInputRef<number>
			"single_blocks.29.": ComfyNodeTypedInputRef<number>
			"single_blocks.30.": ComfyNodeTypedInputRef<number>
			"single_blocks.31.": ComfyNodeTypedInputRef<number>
			"single_blocks.32.": ComfyNodeTypedInputRef<number>
			"single_blocks.33.": ComfyNodeTypedInputRef<number>
			"single_blocks.34.": ComfyNodeTypedInputRef<number>
			"single_blocks.35.": ComfyNodeTypedInputRef<number>
			"single_blocks.36.": ComfyNodeTypedInputRef<number>
			"single_blocks.37.": ComfyNodeTypedInputRef<number>
}


export class HunyuanVideoBlockLoraSelect extends ComfyNode {
	classType: string = "HunyuanVideoBlockLoraSelect"

	sockets: {
		inputs: Required<HunyuanVideoBlockLoraSelectInputs>
		outputs: {
			/** The modified diffusion model.*/
			blocks: ComfyNodeTypedSourceRef<ComfyValueType_SELECTEDDITBLOCKS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"double_blocks.0.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.0."),
				"double_blocks.1.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.1."),
				"double_blocks.2.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.2."),
				"double_blocks.3.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.3."),
				"double_blocks.4.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.4."),
				"double_blocks.5.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.5."),
				"double_blocks.6.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.6."),
				"double_blocks.7.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.7."),
				"double_blocks.8.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.8."),
				"double_blocks.9.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.9."),
				"double_blocks.10.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.10."),
				"double_blocks.11.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.11."),
				"double_blocks.12.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.12."),
				"double_blocks.13.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.13."),
				"double_blocks.14.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.14."),
				"double_blocks.15.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.15."),
				"double_blocks.16.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.16."),
				"double_blocks.17.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.17."),
				"double_blocks.18.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.18."),
				"double_blocks.19.": new ComfyNodeTypedInputRef<number>(this, "double_blocks.19."),
				"single_blocks.0.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.0."),
				"single_blocks.1.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.1."),
				"single_blocks.2.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.2."),
				"single_blocks.3.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.3."),
				"single_blocks.4.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.4."),
				"single_blocks.5.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.5."),
				"single_blocks.6.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.6."),
				"single_blocks.7.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.7."),
				"single_blocks.8.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.8."),
				"single_blocks.9.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.9."),
				"single_blocks.10.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.10."),
				"single_blocks.11.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.11."),
				"single_blocks.12.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.12."),
				"single_blocks.13.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.13."),
				"single_blocks.14.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.14."),
				"single_blocks.15.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.15."),
				"single_blocks.16.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.16."),
				"single_blocks.17.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.17."),
				"single_blocks.18.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.18."),
				"single_blocks.19.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.19."),
				"single_blocks.20.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.20."),
				"single_blocks.21.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.21."),
				"single_blocks.22.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.22."),
				"single_blocks.23.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.23."),
				"single_blocks.24.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.24."),
				"single_blocks.25.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.25."),
				"single_blocks.26.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.26."),
				"single_blocks.27.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.27."),
				"single_blocks.28.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.28."),
				"single_blocks.29.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.29."),
				"single_blocks.30.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.30."),
				"single_blocks.31.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.31."),
				"single_blocks.32.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.32."),
				"single_blocks.33.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.33."),
				"single_blocks.34.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.34."),
				"single_blocks.35.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.35."),
				"single_blocks.36.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.36."),
				"single_blocks.37.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.37."),
				"single_blocks.38.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.38."),
				"single_blocks.39.": new ComfyNodeTypedInputRef<number>(this, "single_blocks.39."),
			},
			outputs: Object.create(Object.prototype, {
				"blocks": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<HunyuanVideoBlockLoraSelectInputs>) {
		if (typeof sources["double_blocks.0."] === "object") {
			this.sockets.inputs["double_blocks.0."].connectTo(sources["double_blocks.0."])
		} else {
			this.sockets.inputs["double_blocks.0."].value = sources["double_blocks.0."]
		}

		if (typeof sources["double_blocks.1."] === "object") {
			this.sockets.inputs["double_blocks.1."].connectTo(sources["double_blocks.1."])
		} else {
			this.sockets.inputs["double_blocks.1."].value = sources["double_blocks.1."]
		}

		if (typeof sources["double_blocks.2."] === "object") {
			this.sockets.inputs["double_blocks.2."].connectTo(sources["double_blocks.2."])
		} else {
			this.sockets.inputs["double_blocks.2."].value = sources["double_blocks.2."]
		}

		if (typeof sources["double_blocks.3."] === "object") {
			this.sockets.inputs["double_blocks.3."].connectTo(sources["double_blocks.3."])
		} else {
			this.sockets.inputs["double_blocks.3."].value = sources["double_blocks.3."]
		}

		if (typeof sources["double_blocks.4."] === "object") {
			this.sockets.inputs["double_blocks.4."].connectTo(sources["double_blocks.4."])
		} else {
			this.sockets.inputs["double_blocks.4."].value = sources["double_blocks.4."]
		}

		if (typeof sources["double_blocks.5."] === "object") {
			this.sockets.inputs["double_blocks.5."].connectTo(sources["double_blocks.5."])
		} else {
			this.sockets.inputs["double_blocks.5."].value = sources["double_blocks.5."]
		}

		if (typeof sources["double_blocks.6."] === "object") {
			this.sockets.inputs["double_blocks.6."].connectTo(sources["double_blocks.6."])
		} else {
			this.sockets.inputs["double_blocks.6."].value = sources["double_blocks.6."]
		}

		if (typeof sources["double_blocks.7."] === "object") {
			this.sockets.inputs["double_blocks.7."].connectTo(sources["double_blocks.7."])
		} else {
			this.sockets.inputs["double_blocks.7."].value = sources["double_blocks.7."]
		}

		if (typeof sources["double_blocks.8."] === "object") {
			this.sockets.inputs["double_blocks.8."].connectTo(sources["double_blocks.8."])
		} else {
			this.sockets.inputs["double_blocks.8."].value = sources["double_blocks.8."]
		}

		if (typeof sources["double_blocks.9."] === "object") {
			this.sockets.inputs["double_blocks.9."].connectTo(sources["double_blocks.9."])
		} else {
			this.sockets.inputs["double_blocks.9."].value = sources["double_blocks.9."]
		}

		if (typeof sources["double_blocks.10."] === "object") {
			this.sockets.inputs["double_blocks.10."].connectTo(sources["double_blocks.10."])
		} else {
			this.sockets.inputs["double_blocks.10."].value = sources["double_blocks.10."]
		}

		if (typeof sources["double_blocks.11."] === "object") {
			this.sockets.inputs["double_blocks.11."].connectTo(sources["double_blocks.11."])
		} else {
			this.sockets.inputs["double_blocks.11."].value = sources["double_blocks.11."]
		}

		if (typeof sources["double_blocks.12."] === "object") {
			this.sockets.inputs["double_blocks.12."].connectTo(sources["double_blocks.12."])
		} else {
			this.sockets.inputs["double_blocks.12."].value = sources["double_blocks.12."]
		}

		if (typeof sources["double_blocks.13."] === "object") {
			this.sockets.inputs["double_blocks.13."].connectTo(sources["double_blocks.13."])
		} else {
			this.sockets.inputs["double_blocks.13."].value = sources["double_blocks.13."]
		}

		if (typeof sources["double_blocks.14."] === "object") {
			this.sockets.inputs["double_blocks.14."].connectTo(sources["double_blocks.14."])
		} else {
			this.sockets.inputs["double_blocks.14."].value = sources["double_blocks.14."]
		}

		if (typeof sources["double_blocks.15."] === "object") {
			this.sockets.inputs["double_blocks.15."].connectTo(sources["double_blocks.15."])
		} else {
			this.sockets.inputs["double_blocks.15."].value = sources["double_blocks.15."]
		}

		if (typeof sources["double_blocks.16."] === "object") {
			this.sockets.inputs["double_blocks.16."].connectTo(sources["double_blocks.16."])
		} else {
			this.sockets.inputs["double_blocks.16."].value = sources["double_blocks.16."]
		}

		if (typeof sources["double_blocks.17."] === "object") {
			this.sockets.inputs["double_blocks.17."].connectTo(sources["double_blocks.17."])
		} else {
			this.sockets.inputs["double_blocks.17."].value = sources["double_blocks.17."]
		}

		if (typeof sources["double_blocks.18."] === "object") {
			this.sockets.inputs["double_blocks.18."].connectTo(sources["double_blocks.18."])
		} else {
			this.sockets.inputs["double_blocks.18."].value = sources["double_blocks.18."]
		}

		if (typeof sources["double_blocks.19."] === "object") {
			this.sockets.inputs["double_blocks.19."].connectTo(sources["double_blocks.19."])
		} else {
			this.sockets.inputs["double_blocks.19."].value = sources["double_blocks.19."]
		}

		if (typeof sources["single_blocks.0."] === "object") {
			this.sockets.inputs["single_blocks.0."].connectTo(sources["single_blocks.0."])
		} else {
			this.sockets.inputs["single_blocks.0."].value = sources["single_blocks.0."]
		}

		if (typeof sources["single_blocks.1."] === "object") {
			this.sockets.inputs["single_blocks.1."].connectTo(sources["single_blocks.1."])
		} else {
			this.sockets.inputs["single_blocks.1."].value = sources["single_blocks.1."]
		}

		if (typeof sources["single_blocks.2."] === "object") {
			this.sockets.inputs["single_blocks.2."].connectTo(sources["single_blocks.2."])
		} else {
			this.sockets.inputs["single_blocks.2."].value = sources["single_blocks.2."]
		}

		if (typeof sources["single_blocks.3."] === "object") {
			this.sockets.inputs["single_blocks.3."].connectTo(sources["single_blocks.3."])
		} else {
			this.sockets.inputs["single_blocks.3."].value = sources["single_blocks.3."]
		}

		if (typeof sources["single_blocks.4."] === "object") {
			this.sockets.inputs["single_blocks.4."].connectTo(sources["single_blocks.4."])
		} else {
			this.sockets.inputs["single_blocks.4."].value = sources["single_blocks.4."]
		}

		if (typeof sources["single_blocks.5."] === "object") {
			this.sockets.inputs["single_blocks.5."].connectTo(sources["single_blocks.5."])
		} else {
			this.sockets.inputs["single_blocks.5."].value = sources["single_blocks.5."]
		}

		if (typeof sources["single_blocks.6."] === "object") {
			this.sockets.inputs["single_blocks.6."].connectTo(sources["single_blocks.6."])
		} else {
			this.sockets.inputs["single_blocks.6."].value = sources["single_blocks.6."]
		}

		if (typeof sources["single_blocks.7."] === "object") {
			this.sockets.inputs["single_blocks.7."].connectTo(sources["single_blocks.7."])
		} else {
			this.sockets.inputs["single_blocks.7."].value = sources["single_blocks.7."]
		}

		if (typeof sources["single_blocks.8."] === "object") {
			this.sockets.inputs["single_blocks.8."].connectTo(sources["single_blocks.8."])
		} else {
			this.sockets.inputs["single_blocks.8."].value = sources["single_blocks.8."]
		}

		if (typeof sources["single_blocks.9."] === "object") {
			this.sockets.inputs["single_blocks.9."].connectTo(sources["single_blocks.9."])
		} else {
			this.sockets.inputs["single_blocks.9."].value = sources["single_blocks.9."]
		}

		if (typeof sources["single_blocks.10."] === "object") {
			this.sockets.inputs["single_blocks.10."].connectTo(sources["single_blocks.10."])
		} else {
			this.sockets.inputs["single_blocks.10."].value = sources["single_blocks.10."]
		}

		if (typeof sources["single_blocks.11."] === "object") {
			this.sockets.inputs["single_blocks.11."].connectTo(sources["single_blocks.11."])
		} else {
			this.sockets.inputs["single_blocks.11."].value = sources["single_blocks.11."]
		}

		if (typeof sources["single_blocks.12."] === "object") {
			this.sockets.inputs["single_blocks.12."].connectTo(sources["single_blocks.12."])
		} else {
			this.sockets.inputs["single_blocks.12."].value = sources["single_blocks.12."]
		}

		if (typeof sources["single_blocks.13."] === "object") {
			this.sockets.inputs["single_blocks.13."].connectTo(sources["single_blocks.13."])
		} else {
			this.sockets.inputs["single_blocks.13."].value = sources["single_blocks.13."]
		}

		if (typeof sources["single_blocks.14."] === "object") {
			this.sockets.inputs["single_blocks.14."].connectTo(sources["single_blocks.14."])
		} else {
			this.sockets.inputs["single_blocks.14."].value = sources["single_blocks.14."]
		}

		if (typeof sources["single_blocks.15."] === "object") {
			this.sockets.inputs["single_blocks.15."].connectTo(sources["single_blocks.15."])
		} else {
			this.sockets.inputs["single_blocks.15."].value = sources["single_blocks.15."]
		}

		if (typeof sources["single_blocks.16."] === "object") {
			this.sockets.inputs["single_blocks.16."].connectTo(sources["single_blocks.16."])
		} else {
			this.sockets.inputs["single_blocks.16."].value = sources["single_blocks.16."]
		}

		if (typeof sources["single_blocks.17."] === "object") {
			this.sockets.inputs["single_blocks.17."].connectTo(sources["single_blocks.17."])
		} else {
			this.sockets.inputs["single_blocks.17."].value = sources["single_blocks.17."]
		}

		if (typeof sources["single_blocks.18."] === "object") {
			this.sockets.inputs["single_blocks.18."].connectTo(sources["single_blocks.18."])
		} else {
			this.sockets.inputs["single_blocks.18."].value = sources["single_blocks.18."]
		}

		if (typeof sources["single_blocks.19."] === "object") {
			this.sockets.inputs["single_blocks.19."].connectTo(sources["single_blocks.19."])
		} else {
			this.sockets.inputs["single_blocks.19."].value = sources["single_blocks.19."]
		}

		if (typeof sources["single_blocks.20."] === "object") {
			this.sockets.inputs["single_blocks.20."].connectTo(sources["single_blocks.20."])
		} else {
			this.sockets.inputs["single_blocks.20."].value = sources["single_blocks.20."]
		}

		if (typeof sources["single_blocks.21."] === "object") {
			this.sockets.inputs["single_blocks.21."].connectTo(sources["single_blocks.21."])
		} else {
			this.sockets.inputs["single_blocks.21."].value = sources["single_blocks.21."]
		}

		if (typeof sources["single_blocks.22."] === "object") {
			this.sockets.inputs["single_blocks.22."].connectTo(sources["single_blocks.22."])
		} else {
			this.sockets.inputs["single_blocks.22."].value = sources["single_blocks.22."]
		}

		if (typeof sources["single_blocks.23."] === "object") {
			this.sockets.inputs["single_blocks.23."].connectTo(sources["single_blocks.23."])
		} else {
			this.sockets.inputs["single_blocks.23."].value = sources["single_blocks.23."]
		}

		if (typeof sources["single_blocks.24."] === "object") {
			this.sockets.inputs["single_blocks.24."].connectTo(sources["single_blocks.24."])
		} else {
			this.sockets.inputs["single_blocks.24."].value = sources["single_blocks.24."]
		}

		if (typeof sources["single_blocks.25."] === "object") {
			this.sockets.inputs["single_blocks.25."].connectTo(sources["single_blocks.25."])
		} else {
			this.sockets.inputs["single_blocks.25."].value = sources["single_blocks.25."]
		}

		if (typeof sources["single_blocks.26."] === "object") {
			this.sockets.inputs["single_blocks.26."].connectTo(sources["single_blocks.26."])
		} else {
			this.sockets.inputs["single_blocks.26."].value = sources["single_blocks.26."]
		}

		if (typeof sources["single_blocks.27."] === "object") {
			this.sockets.inputs["single_blocks.27."].connectTo(sources["single_blocks.27."])
		} else {
			this.sockets.inputs["single_blocks.27."].value = sources["single_blocks.27."]
		}

		if (typeof sources["single_blocks.28."] === "object") {
			this.sockets.inputs["single_blocks.28."].connectTo(sources["single_blocks.28."])
		} else {
			this.sockets.inputs["single_blocks.28."].value = sources["single_blocks.28."]
		}

		if (typeof sources["single_blocks.29."] === "object") {
			this.sockets.inputs["single_blocks.29."].connectTo(sources["single_blocks.29."])
		} else {
			this.sockets.inputs["single_blocks.29."].value = sources["single_blocks.29."]
		}

		if (typeof sources["single_blocks.30."] === "object") {
			this.sockets.inputs["single_blocks.30."].connectTo(sources["single_blocks.30."])
		} else {
			this.sockets.inputs["single_blocks.30."].value = sources["single_blocks.30."]
		}

		if (typeof sources["single_blocks.31."] === "object") {
			this.sockets.inputs["single_blocks.31."].connectTo(sources["single_blocks.31."])
		} else {
			this.sockets.inputs["single_blocks.31."].value = sources["single_blocks.31."]
		}

		if (typeof sources["single_blocks.32."] === "object") {
			this.sockets.inputs["single_blocks.32."].connectTo(sources["single_blocks.32."])
		} else {
			this.sockets.inputs["single_blocks.32."].value = sources["single_blocks.32."]
		}

		if (typeof sources["single_blocks.33."] === "object") {
			this.sockets.inputs["single_blocks.33."].connectTo(sources["single_blocks.33."])
		} else {
			this.sockets.inputs["single_blocks.33."].value = sources["single_blocks.33."]
		}

		if (typeof sources["single_blocks.34."] === "object") {
			this.sockets.inputs["single_blocks.34."].connectTo(sources["single_blocks.34."])
		} else {
			this.sockets.inputs["single_blocks.34."].value = sources["single_blocks.34."]
		}

		if (typeof sources["single_blocks.35."] === "object") {
			this.sockets.inputs["single_blocks.35."].connectTo(sources["single_blocks.35."])
		} else {
			this.sockets.inputs["single_blocks.35."].value = sources["single_blocks.35."]
		}

		if (typeof sources["single_blocks.36."] === "object") {
			this.sockets.inputs["single_blocks.36."].connectTo(sources["single_blocks.36."])
		} else {
			this.sockets.inputs["single_blocks.36."].value = sources["single_blocks.36."]
		}

		if (typeof sources["single_blocks.37."] === "object") {
			this.sockets.inputs["single_blocks.37."].connectTo(sources["single_blocks.37."])
		} else {
			this.sockets.inputs["single_blocks.37."].value = sources["single_blocks.37."]
		}

		if (typeof sources["single_blocks.38."] === "object") {
			this.sockets.inputs["single_blocks.38."].connectTo(sources["single_blocks.38."])
		} else {
			this.sockets.inputs["single_blocks.38."].value = sources["single_blocks.38."]
		}

		if (typeof sources["single_blocks.39."] === "object") {
			this.sockets.inputs["single_blocks.39."].connectTo(sources["single_blocks.39."])
		} else {
			this.sockets.inputs["single_blocks.39."].value = sources["single_blocks.39."]
		}

	}
}

type HunyuanVideoBlockLoraSelectInputs = {
			"double_blocks.0.": ComfyNodeTypedInputRef<number>
			"double_blocks.1.": ComfyNodeTypedInputRef<number>
			"double_blocks.2.": ComfyNodeTypedInputRef<number>
			"double_blocks.3.": ComfyNodeTypedInputRef<number>
			"double_blocks.4.": ComfyNodeTypedInputRef<number>
			"double_blocks.5.": ComfyNodeTypedInputRef<number>
			"double_blocks.6.": ComfyNodeTypedInputRef<number>
			"double_blocks.7.": ComfyNodeTypedInputRef<number>
			"double_blocks.8.": ComfyNodeTypedInputRef<number>
			"double_blocks.9.": ComfyNodeTypedInputRef<number>
			"double_blocks.10.": ComfyNodeTypedInputRef<number>
			"double_blocks.11.": ComfyNodeTypedInputRef<number>
			"double_blocks.12.": ComfyNodeTypedInputRef<number>
			"double_blocks.13.": ComfyNodeTypedInputRef<number>
			"double_blocks.14.": ComfyNodeTypedInputRef<number>
			"double_blocks.15.": ComfyNodeTypedInputRef<number>
			"double_blocks.16.": ComfyNodeTypedInputRef<number>
			"double_blocks.17.": ComfyNodeTypedInputRef<number>
			"double_blocks.18.": ComfyNodeTypedInputRef<number>
			"double_blocks.19.": ComfyNodeTypedInputRef<number>
			"single_blocks.0.": ComfyNodeTypedInputRef<number>
			"single_blocks.1.": ComfyNodeTypedInputRef<number>
			"single_blocks.2.": ComfyNodeTypedInputRef<number>
			"single_blocks.3.": ComfyNodeTypedInputRef<number>
			"single_blocks.4.": ComfyNodeTypedInputRef<number>
			"single_blocks.5.": ComfyNodeTypedInputRef<number>
			"single_blocks.6.": ComfyNodeTypedInputRef<number>
			"single_blocks.7.": ComfyNodeTypedInputRef<number>
			"single_blocks.8.": ComfyNodeTypedInputRef<number>
			"single_blocks.9.": ComfyNodeTypedInputRef<number>
			"single_blocks.10.": ComfyNodeTypedInputRef<number>
			"single_blocks.11.": ComfyNodeTypedInputRef<number>
			"single_blocks.12.": ComfyNodeTypedInputRef<number>
			"single_blocks.13.": ComfyNodeTypedInputRef<number>
			"single_blocks.14.": ComfyNodeTypedInputRef<number>
			"single_blocks.15.": ComfyNodeTypedInputRef<number>
			"single_blocks.16.": ComfyNodeTypedInputRef<number>
			"single_blocks.17.": ComfyNodeTypedInputRef<number>
			"single_blocks.18.": ComfyNodeTypedInputRef<number>
			"single_blocks.19.": ComfyNodeTypedInputRef<number>
			"single_blocks.20.": ComfyNodeTypedInputRef<number>
			"single_blocks.21.": ComfyNodeTypedInputRef<number>
			"single_blocks.22.": ComfyNodeTypedInputRef<number>
			"single_blocks.23.": ComfyNodeTypedInputRef<number>
			"single_blocks.24.": ComfyNodeTypedInputRef<number>
			"single_blocks.25.": ComfyNodeTypedInputRef<number>
			"single_blocks.26.": ComfyNodeTypedInputRef<number>
			"single_blocks.27.": ComfyNodeTypedInputRef<number>
			"single_blocks.28.": ComfyNodeTypedInputRef<number>
			"single_blocks.29.": ComfyNodeTypedInputRef<number>
			"single_blocks.30.": ComfyNodeTypedInputRef<number>
			"single_blocks.31.": ComfyNodeTypedInputRef<number>
			"single_blocks.32.": ComfyNodeTypedInputRef<number>
			"single_blocks.33.": ComfyNodeTypedInputRef<number>
			"single_blocks.34.": ComfyNodeTypedInputRef<number>
			"single_blocks.35.": ComfyNodeTypedInputRef<number>
			"single_blocks.36.": ComfyNodeTypedInputRef<number>
			"single_blocks.37.": ComfyNodeTypedInputRef<number>
			"single_blocks.38.": ComfyNodeTypedInputRef<number>
			"single_blocks.39.": ComfyNodeTypedInputRef<number>
}


export class Wan21BlockLoraSelect extends ComfyNode {
	classType: string = "Wan21BlockLoraSelect"

	sockets: {
		inputs: Required<Wan21BlockLoraSelectInputs>
		outputs: {
			/** The modified diffusion model.*/
			blocks: ComfyNodeTypedSourceRef<ComfyValueType_SELECTEDDITBLOCKS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"blocks.0.": new ComfyNodeTypedInputRef<number>(this, "blocks.0."),
				"blocks.1.": new ComfyNodeTypedInputRef<number>(this, "blocks.1."),
				"blocks.2.": new ComfyNodeTypedInputRef<number>(this, "blocks.2."),
				"blocks.3.": new ComfyNodeTypedInputRef<number>(this, "blocks.3."),
				"blocks.4.": new ComfyNodeTypedInputRef<number>(this, "blocks.4."),
				"blocks.5.": new ComfyNodeTypedInputRef<number>(this, "blocks.5."),
				"blocks.6.": new ComfyNodeTypedInputRef<number>(this, "blocks.6."),
				"blocks.7.": new ComfyNodeTypedInputRef<number>(this, "blocks.7."),
				"blocks.8.": new ComfyNodeTypedInputRef<number>(this, "blocks.8."),
				"blocks.9.": new ComfyNodeTypedInputRef<number>(this, "blocks.9."),
				"blocks.10.": new ComfyNodeTypedInputRef<number>(this, "blocks.10."),
				"blocks.11.": new ComfyNodeTypedInputRef<number>(this, "blocks.11."),
				"blocks.12.": new ComfyNodeTypedInputRef<number>(this, "blocks.12."),
				"blocks.13.": new ComfyNodeTypedInputRef<number>(this, "blocks.13."),
				"blocks.14.": new ComfyNodeTypedInputRef<number>(this, "blocks.14."),
				"blocks.15.": new ComfyNodeTypedInputRef<number>(this, "blocks.15."),
				"blocks.16.": new ComfyNodeTypedInputRef<number>(this, "blocks.16."),
				"blocks.17.": new ComfyNodeTypedInputRef<number>(this, "blocks.17."),
				"blocks.18.": new ComfyNodeTypedInputRef<number>(this, "blocks.18."),
				"blocks.19.": new ComfyNodeTypedInputRef<number>(this, "blocks.19."),
				"blocks.20.": new ComfyNodeTypedInputRef<number>(this, "blocks.20."),
				"blocks.21.": new ComfyNodeTypedInputRef<number>(this, "blocks.21."),
				"blocks.22.": new ComfyNodeTypedInputRef<number>(this, "blocks.22."),
				"blocks.23.": new ComfyNodeTypedInputRef<number>(this, "blocks.23."),
				"blocks.24.": new ComfyNodeTypedInputRef<number>(this, "blocks.24."),
				"blocks.25.": new ComfyNodeTypedInputRef<number>(this, "blocks.25."),
				"blocks.26.": new ComfyNodeTypedInputRef<number>(this, "blocks.26."),
				"blocks.27.": new ComfyNodeTypedInputRef<number>(this, "blocks.27."),
				"blocks.28.": new ComfyNodeTypedInputRef<number>(this, "blocks.28."),
				"blocks.29.": new ComfyNodeTypedInputRef<number>(this, "blocks.29."),
				"blocks.30.": new ComfyNodeTypedInputRef<number>(this, "blocks.30."),
				"blocks.31.": new ComfyNodeTypedInputRef<number>(this, "blocks.31."),
				"blocks.32.": new ComfyNodeTypedInputRef<number>(this, "blocks.32."),
				"blocks.33.": new ComfyNodeTypedInputRef<number>(this, "blocks.33."),
				"blocks.34.": new ComfyNodeTypedInputRef<number>(this, "blocks.34."),
				"blocks.35.": new ComfyNodeTypedInputRef<number>(this, "blocks.35."),
				"blocks.36.": new ComfyNodeTypedInputRef<number>(this, "blocks.36."),
				"blocks.37.": new ComfyNodeTypedInputRef<number>(this, "blocks.37."),
				"blocks.38.": new ComfyNodeTypedInputRef<number>(this, "blocks.38."),
				"blocks.39.": new ComfyNodeTypedInputRef<number>(this, "blocks.39."),
			},
			outputs: Object.create(Object.prototype, {
				"blocks": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<Wan21BlockLoraSelectInputs>) {
		if (typeof sources["blocks.0."] === "object") {
			this.sockets.inputs["blocks.0."].connectTo(sources["blocks.0."])
		} else {
			this.sockets.inputs["blocks.0."].value = sources["blocks.0."]
		}

		if (typeof sources["blocks.1."] === "object") {
			this.sockets.inputs["blocks.1."].connectTo(sources["blocks.1."])
		} else {
			this.sockets.inputs["blocks.1."].value = sources["blocks.1."]
		}

		if (typeof sources["blocks.2."] === "object") {
			this.sockets.inputs["blocks.2."].connectTo(sources["blocks.2."])
		} else {
			this.sockets.inputs["blocks.2."].value = sources["blocks.2."]
		}

		if (typeof sources["blocks.3."] === "object") {
			this.sockets.inputs["blocks.3."].connectTo(sources["blocks.3."])
		} else {
			this.sockets.inputs["blocks.3."].value = sources["blocks.3."]
		}

		if (typeof sources["blocks.4."] === "object") {
			this.sockets.inputs["blocks.4."].connectTo(sources["blocks.4."])
		} else {
			this.sockets.inputs["blocks.4."].value = sources["blocks.4."]
		}

		if (typeof sources["blocks.5."] === "object") {
			this.sockets.inputs["blocks.5."].connectTo(sources["blocks.5."])
		} else {
			this.sockets.inputs["blocks.5."].value = sources["blocks.5."]
		}

		if (typeof sources["blocks.6."] === "object") {
			this.sockets.inputs["blocks.6."].connectTo(sources["blocks.6."])
		} else {
			this.sockets.inputs["blocks.6."].value = sources["blocks.6."]
		}

		if (typeof sources["blocks.7."] === "object") {
			this.sockets.inputs["blocks.7."].connectTo(sources["blocks.7."])
		} else {
			this.sockets.inputs["blocks.7."].value = sources["blocks.7."]
		}

		if (typeof sources["blocks.8."] === "object") {
			this.sockets.inputs["blocks.8."].connectTo(sources["blocks.8."])
		} else {
			this.sockets.inputs["blocks.8."].value = sources["blocks.8."]
		}

		if (typeof sources["blocks.9."] === "object") {
			this.sockets.inputs["blocks.9."].connectTo(sources["blocks.9."])
		} else {
			this.sockets.inputs["blocks.9."].value = sources["blocks.9."]
		}

		if (typeof sources["blocks.10."] === "object") {
			this.sockets.inputs["blocks.10."].connectTo(sources["blocks.10."])
		} else {
			this.sockets.inputs["blocks.10."].value = sources["blocks.10."]
		}

		if (typeof sources["blocks.11."] === "object") {
			this.sockets.inputs["blocks.11."].connectTo(sources["blocks.11."])
		} else {
			this.sockets.inputs["blocks.11."].value = sources["blocks.11."]
		}

		if (typeof sources["blocks.12."] === "object") {
			this.sockets.inputs["blocks.12."].connectTo(sources["blocks.12."])
		} else {
			this.sockets.inputs["blocks.12."].value = sources["blocks.12."]
		}

		if (typeof sources["blocks.13."] === "object") {
			this.sockets.inputs["blocks.13."].connectTo(sources["blocks.13."])
		} else {
			this.sockets.inputs["blocks.13."].value = sources["blocks.13."]
		}

		if (typeof sources["blocks.14."] === "object") {
			this.sockets.inputs["blocks.14."].connectTo(sources["blocks.14."])
		} else {
			this.sockets.inputs["blocks.14."].value = sources["blocks.14."]
		}

		if (typeof sources["blocks.15."] === "object") {
			this.sockets.inputs["blocks.15."].connectTo(sources["blocks.15."])
		} else {
			this.sockets.inputs["blocks.15."].value = sources["blocks.15."]
		}

		if (typeof sources["blocks.16."] === "object") {
			this.sockets.inputs["blocks.16."].connectTo(sources["blocks.16."])
		} else {
			this.sockets.inputs["blocks.16."].value = sources["blocks.16."]
		}

		if (typeof sources["blocks.17."] === "object") {
			this.sockets.inputs["blocks.17."].connectTo(sources["blocks.17."])
		} else {
			this.sockets.inputs["blocks.17."].value = sources["blocks.17."]
		}

		if (typeof sources["blocks.18."] === "object") {
			this.sockets.inputs["blocks.18."].connectTo(sources["blocks.18."])
		} else {
			this.sockets.inputs["blocks.18."].value = sources["blocks.18."]
		}

		if (typeof sources["blocks.19."] === "object") {
			this.sockets.inputs["blocks.19."].connectTo(sources["blocks.19."])
		} else {
			this.sockets.inputs["blocks.19."].value = sources["blocks.19."]
		}

		if (typeof sources["blocks.20."] === "object") {
			this.sockets.inputs["blocks.20."].connectTo(sources["blocks.20."])
		} else {
			this.sockets.inputs["blocks.20."].value = sources["blocks.20."]
		}

		if (typeof sources["blocks.21."] === "object") {
			this.sockets.inputs["blocks.21."].connectTo(sources["blocks.21."])
		} else {
			this.sockets.inputs["blocks.21."].value = sources["blocks.21."]
		}

		if (typeof sources["blocks.22."] === "object") {
			this.sockets.inputs["blocks.22."].connectTo(sources["blocks.22."])
		} else {
			this.sockets.inputs["blocks.22."].value = sources["blocks.22."]
		}

		if (typeof sources["blocks.23."] === "object") {
			this.sockets.inputs["blocks.23."].connectTo(sources["blocks.23."])
		} else {
			this.sockets.inputs["blocks.23."].value = sources["blocks.23."]
		}

		if (typeof sources["blocks.24."] === "object") {
			this.sockets.inputs["blocks.24."].connectTo(sources["blocks.24."])
		} else {
			this.sockets.inputs["blocks.24."].value = sources["blocks.24."]
		}

		if (typeof sources["blocks.25."] === "object") {
			this.sockets.inputs["blocks.25."].connectTo(sources["blocks.25."])
		} else {
			this.sockets.inputs["blocks.25."].value = sources["blocks.25."]
		}

		if (typeof sources["blocks.26."] === "object") {
			this.sockets.inputs["blocks.26."].connectTo(sources["blocks.26."])
		} else {
			this.sockets.inputs["blocks.26."].value = sources["blocks.26."]
		}

		if (typeof sources["blocks.27."] === "object") {
			this.sockets.inputs["blocks.27."].connectTo(sources["blocks.27."])
		} else {
			this.sockets.inputs["blocks.27."].value = sources["blocks.27."]
		}

		if (typeof sources["blocks.28."] === "object") {
			this.sockets.inputs["blocks.28."].connectTo(sources["blocks.28."])
		} else {
			this.sockets.inputs["blocks.28."].value = sources["blocks.28."]
		}

		if (typeof sources["blocks.29."] === "object") {
			this.sockets.inputs["blocks.29."].connectTo(sources["blocks.29."])
		} else {
			this.sockets.inputs["blocks.29."].value = sources["blocks.29."]
		}

		if (typeof sources["blocks.30."] === "object") {
			this.sockets.inputs["blocks.30."].connectTo(sources["blocks.30."])
		} else {
			this.sockets.inputs["blocks.30."].value = sources["blocks.30."]
		}

		if (typeof sources["blocks.31."] === "object") {
			this.sockets.inputs["blocks.31."].connectTo(sources["blocks.31."])
		} else {
			this.sockets.inputs["blocks.31."].value = sources["blocks.31."]
		}

		if (typeof sources["blocks.32."] === "object") {
			this.sockets.inputs["blocks.32."].connectTo(sources["blocks.32."])
		} else {
			this.sockets.inputs["blocks.32."].value = sources["blocks.32."]
		}

		if (typeof sources["blocks.33."] === "object") {
			this.sockets.inputs["blocks.33."].connectTo(sources["blocks.33."])
		} else {
			this.sockets.inputs["blocks.33."].value = sources["blocks.33."]
		}

		if (typeof sources["blocks.34."] === "object") {
			this.sockets.inputs["blocks.34."].connectTo(sources["blocks.34."])
		} else {
			this.sockets.inputs["blocks.34."].value = sources["blocks.34."]
		}

		if (typeof sources["blocks.35."] === "object") {
			this.sockets.inputs["blocks.35."].connectTo(sources["blocks.35."])
		} else {
			this.sockets.inputs["blocks.35."].value = sources["blocks.35."]
		}

		if (typeof sources["blocks.36."] === "object") {
			this.sockets.inputs["blocks.36."].connectTo(sources["blocks.36."])
		} else {
			this.sockets.inputs["blocks.36."].value = sources["blocks.36."]
		}

		if (typeof sources["blocks.37."] === "object") {
			this.sockets.inputs["blocks.37."].connectTo(sources["blocks.37."])
		} else {
			this.sockets.inputs["blocks.37."].value = sources["blocks.37."]
		}

		if (typeof sources["blocks.38."] === "object") {
			this.sockets.inputs["blocks.38."].connectTo(sources["blocks.38."])
		} else {
			this.sockets.inputs["blocks.38."].value = sources["blocks.38."]
		}

		if (typeof sources["blocks.39."] === "object") {
			this.sockets.inputs["blocks.39."].connectTo(sources["blocks.39."])
		} else {
			this.sockets.inputs["blocks.39."].value = sources["blocks.39."]
		}

	}
}

type Wan21BlockLoraSelectInputs = {
			"blocks.0.": ComfyNodeTypedInputRef<number>
			"blocks.1.": ComfyNodeTypedInputRef<number>
			"blocks.2.": ComfyNodeTypedInputRef<number>
			"blocks.3.": ComfyNodeTypedInputRef<number>
			"blocks.4.": ComfyNodeTypedInputRef<number>
			"blocks.5.": ComfyNodeTypedInputRef<number>
			"blocks.6.": ComfyNodeTypedInputRef<number>
			"blocks.7.": ComfyNodeTypedInputRef<number>
			"blocks.8.": ComfyNodeTypedInputRef<number>
			"blocks.9.": ComfyNodeTypedInputRef<number>
			"blocks.10.": ComfyNodeTypedInputRef<number>
			"blocks.11.": ComfyNodeTypedInputRef<number>
			"blocks.12.": ComfyNodeTypedInputRef<number>
			"blocks.13.": ComfyNodeTypedInputRef<number>
			"blocks.14.": ComfyNodeTypedInputRef<number>
			"blocks.15.": ComfyNodeTypedInputRef<number>
			"blocks.16.": ComfyNodeTypedInputRef<number>
			"blocks.17.": ComfyNodeTypedInputRef<number>
			"blocks.18.": ComfyNodeTypedInputRef<number>
			"blocks.19.": ComfyNodeTypedInputRef<number>
			"blocks.20.": ComfyNodeTypedInputRef<number>
			"blocks.21.": ComfyNodeTypedInputRef<number>
			"blocks.22.": ComfyNodeTypedInputRef<number>
			"blocks.23.": ComfyNodeTypedInputRef<number>
			"blocks.24.": ComfyNodeTypedInputRef<number>
			"blocks.25.": ComfyNodeTypedInputRef<number>
			"blocks.26.": ComfyNodeTypedInputRef<number>
			"blocks.27.": ComfyNodeTypedInputRef<number>
			"blocks.28.": ComfyNodeTypedInputRef<number>
			"blocks.29.": ComfyNodeTypedInputRef<number>
			"blocks.30.": ComfyNodeTypedInputRef<number>
			"blocks.31.": ComfyNodeTypedInputRef<number>
			"blocks.32.": ComfyNodeTypedInputRef<number>
			"blocks.33.": ComfyNodeTypedInputRef<number>
			"blocks.34.": ComfyNodeTypedInputRef<number>
			"blocks.35.": ComfyNodeTypedInputRef<number>
			"blocks.36.": ComfyNodeTypedInputRef<number>
			"blocks.37.": ComfyNodeTypedInputRef<number>
			"blocks.38.": ComfyNodeTypedInputRef<number>
			"blocks.39.": ComfyNodeTypedInputRef<number>
}


export class CustomControlNetWeightsFluxFromList extends ComfyNode {
	classType: string = "CustomControlNetWeightsFluxFromList"

	sockets: {
		inputs: Required<CustomControlNetWeightsFluxFromListInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"list_of_floats": new ComfyNodeTypedInputRef<number>(this, "list_of_floats"),
				"uncond_multiplier": new ComfyNodeTypedInputRef<number>(this, "uncond_multiplier"),
				"cn_extras": new ComfyNodeTypedInputRef<ComfyValueType_CN_WEIGHTS_EXTRAS>(this, "cn_extras"),
				"autosize": new ComfyNodeTypedInputRef<ComfyValueType_ACNAUTOSIZE>(this, "autosize"),
			},
			outputs: Object.create(Object.prototype, {
				"CN_WEIGHTS": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"TK_SHORTCUT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CustomControlNetWeightsFluxFromListInputs>) {
		if (typeof sources["list_of_floats"] === "object") {
			this.sockets.inputs["list_of_floats"].connectTo(sources["list_of_floats"])
		} else {
			this.sockets.inputs["list_of_floats"].value = sources["list_of_floats"]
		}

		if (sources["uncond_multiplier"] !== undefined) {
		if (typeof sources["uncond_multiplier"] === "object") {
			this.sockets.inputs["uncond_multiplier"].connectTo(sources["uncond_multiplier"])
		} else {
			this.sockets.inputs["uncond_multiplier"].value = sources["uncond_multiplier"]
		}
		}

		if (sources["cn_extras"] !== undefined) {
		if (typeof sources["cn_extras"] === "object") {
			this.sockets.inputs["cn_extras"].connectTo(sources["cn_extras"])
		} else {
			this.sockets.inputs["cn_extras"].value = sources["cn_extras"]
		}
		}

		if (sources["autosize"] !== undefined) {
		if (typeof sources["autosize"] === "object") {
			this.sockets.inputs["autosize"].connectTo(sources["autosize"])
		} else {
			this.sockets.inputs["autosize"].value = sources["autosize"]
		}
		}

	}
}

type CustomControlNetWeightsFluxFromListInputs = {
			"list_of_floats": ComfyNodeTypedInputRef<number>
			"uncond_multiplier"?: ComfyNodeTypedInputRef<number>
			"cn_extras"?: ComfyNodeTypedInputRef<ComfyValueType_CN_WEIGHTS_EXTRAS>
			"autosize"?: ComfyNodeTypedInputRef<ComfyValueType_ACNAUTOSIZE>
}


export class CheckpointLoaderKJ extends ComfyNode {
	classType: string = "CheckpointLoaderKJ"

	sockets: {
		inputs: Required<CheckpointLoaderKJInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
			VAE: ComfyNodeTypedSourceRef<ComfyValueType_VAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"ckpt_name": new ComfyNodeTypedInputRef<string>(this, "ckpt_name"),
				"weight_dtype": new ComfyNodeTypedInputRef<string>(this, "weight_dtype"),
				"compute_dtype": new ComfyNodeTypedInputRef<string>(this, "compute_dtype"),
				"patch_cublaslinear": new ComfyNodeTypedInputRef<boolean>(this, "patch_cublaslinear"),
				"sage_attention": new ComfyNodeTypedInputRef<string>(this, "sage_attention"),
				"enable_fp16_accumulation": new ComfyNodeTypedInputRef<boolean>(this, "enable_fp16_accumulation"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"VAE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CheckpointLoaderKJInputs>) {
		if (typeof sources["ckpt_name"] === "object") {
			this.sockets.inputs["ckpt_name"].connectTo(sources["ckpt_name"])
		} else {
			this.sockets.inputs["ckpt_name"].value = sources["ckpt_name"]
		}

		if (typeof sources["weight_dtype"] === "object") {
			this.sockets.inputs["weight_dtype"].connectTo(sources["weight_dtype"])
		} else {
			this.sockets.inputs["weight_dtype"].value = sources["weight_dtype"]
		}

		if (typeof sources["compute_dtype"] === "object") {
			this.sockets.inputs["compute_dtype"].connectTo(sources["compute_dtype"])
		} else {
			this.sockets.inputs["compute_dtype"].value = sources["compute_dtype"]
		}

		if (typeof sources["patch_cublaslinear"] === "object") {
			this.sockets.inputs["patch_cublaslinear"].connectTo(sources["patch_cublaslinear"])
		} else {
			this.sockets.inputs["patch_cublaslinear"].value = sources["patch_cublaslinear"]
		}

		if (typeof sources["sage_attention"] === "object") {
			this.sockets.inputs["sage_attention"].connectTo(sources["sage_attention"])
		} else {
			this.sockets.inputs["sage_attention"].value = sources["sage_attention"]
		}

		if (typeof sources["enable_fp16_accumulation"] === "object") {
			this.sockets.inputs["enable_fp16_accumulation"].connectTo(sources["enable_fp16_accumulation"])
		} else {
			this.sockets.inputs["enable_fp16_accumulation"].value = sources["enable_fp16_accumulation"]
		}

	}
}

type CheckpointLoaderKJInputs = {
			/** The name of the checkpoint (model) to load.*/
			"ckpt_name": ComfyNodeTypedInputRef<string>
			"weight_dtype": ComfyNodeTypedInputRef<string>
			/** The compute dtype to use for the model.*/
			"compute_dtype": ComfyNodeTypedInputRef<string>
			/** Enable or disable the patching, won't take effect on already loaded models!*/
			"patch_cublaslinear": ComfyNodeTypedInputRef<boolean>
			/** Patch comfy attention to use sageattn.*/
			"sage_attention": ComfyNodeTypedInputRef<string>
			/** Enable torch.backends.cuda.matmul.allow_fp16_accumulation, required minimum pytorch version 2.7.1*/
			"enable_fp16_accumulation": ComfyNodeTypedInputRef<boolean>
}


export class DiffusionModelLoaderKJ extends ComfyNode {
	classType: string = "DiffusionModelLoaderKJ"

	sockets: {
		inputs: Required<DiffusionModelLoaderKJInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_name": new ComfyNodeTypedInputRef<string>(this, "model_name"),
				"weight_dtype": new ComfyNodeTypedInputRef<string>(this, "weight_dtype"),
				"compute_dtype": new ComfyNodeTypedInputRef<string>(this, "compute_dtype"),
				"patch_cublaslinear": new ComfyNodeTypedInputRef<boolean>(this, "patch_cublaslinear"),
				"sage_attention": new ComfyNodeTypedInputRef<string>(this, "sage_attention"),
				"enable_fp16_accumulation": new ComfyNodeTypedInputRef<boolean>(this, "enable_fp16_accumulation"),
				"extra_state_dict": new ComfyNodeTypedInputRef<string>(this, "extra_state_dict"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DiffusionModelLoaderKJInputs>) {
		if (typeof sources["model_name"] === "object") {
			this.sockets.inputs["model_name"].connectTo(sources["model_name"])
		} else {
			this.sockets.inputs["model_name"].value = sources["model_name"]
		}

		if (typeof sources["weight_dtype"] === "object") {
			this.sockets.inputs["weight_dtype"].connectTo(sources["weight_dtype"])
		} else {
			this.sockets.inputs["weight_dtype"].value = sources["weight_dtype"]
		}

		if (typeof sources["compute_dtype"] === "object") {
			this.sockets.inputs["compute_dtype"].connectTo(sources["compute_dtype"])
		} else {
			this.sockets.inputs["compute_dtype"].value = sources["compute_dtype"]
		}

		if (typeof sources["patch_cublaslinear"] === "object") {
			this.sockets.inputs["patch_cublaslinear"].connectTo(sources["patch_cublaslinear"])
		} else {
			this.sockets.inputs["patch_cublaslinear"].value = sources["patch_cublaslinear"]
		}

		if (typeof sources["sage_attention"] === "object") {
			this.sockets.inputs["sage_attention"].connectTo(sources["sage_attention"])
		} else {
			this.sockets.inputs["sage_attention"].value = sources["sage_attention"]
		}

		if (typeof sources["enable_fp16_accumulation"] === "object") {
			this.sockets.inputs["enable_fp16_accumulation"].connectTo(sources["enable_fp16_accumulation"])
		} else {
			this.sockets.inputs["enable_fp16_accumulation"].value = sources["enable_fp16_accumulation"]
		}

		if (sources["extra_state_dict"] !== undefined) {
		if (typeof sources["extra_state_dict"] === "object") {
			this.sockets.inputs["extra_state_dict"].connectTo(sources["extra_state_dict"])
		} else {
			this.sockets.inputs["extra_state_dict"].value = sources["extra_state_dict"]
		}
		}

	}
}

type DiffusionModelLoaderKJInputs = {
			/** The name of the checkpoint (model) to load.*/
			"model_name": ComfyNodeTypedInputRef<string>
			"weight_dtype": ComfyNodeTypedInputRef<string>
			/** The compute dtype to use for the model.*/
			"compute_dtype": ComfyNodeTypedInputRef<string>
			/** Enable or disable the patching, won't take effect on already loaded models!*/
			"patch_cublaslinear": ComfyNodeTypedInputRef<boolean>
			/** Patch comfy attention to use sageattn.*/
			"sage_attention": ComfyNodeTypedInputRef<string>
			/** Enable torch.backends.cuda.matmul.allow_fp16_accumulation, requires pytorch 2.7.0 nightly.*/
			"enable_fp16_accumulation": ComfyNodeTypedInputRef<boolean>
			/** The full path to an additional state dict to load, this will be merged with the main state dict. Useful for example to add VACE module to a WanVideoModel. You can use DiffusionModelSelector to easily get the path.*/
			"extra_state_dict"?: ComfyNodeTypedInputRef<string>
}


export class TorchCompileModelFluxAdvanced extends ComfyNode {
	classType: string = "TorchCompileModelFluxAdvanced"

	sockets: {
		inputs: Required<TorchCompileModelFluxAdvancedInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"backend": new ComfyNodeTypedInputRef<string>(this, "backend"),
				"fullgraph": new ComfyNodeTypedInputRef<boolean>(this, "fullgraph"),
				"mode": new ComfyNodeTypedInputRef<string>(this, "mode"),
				"double_blocks": new ComfyNodeTypedInputRef<string>(this, "double_blocks"),
				"single_blocks": new ComfyNodeTypedInputRef<string>(this, "single_blocks"),
				"dynamic": new ComfyNodeTypedInputRef<boolean>(this, "dynamic"),
				"dynamo_cache_size_limit": new ComfyNodeTypedInputRef<number>(this, "dynamo_cache_size_limit"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TorchCompileModelFluxAdvancedInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["backend"] === "object") {
			this.sockets.inputs["backend"].connectTo(sources["backend"])
		} else {
			this.sockets.inputs["backend"].value = sources["backend"]
		}

		if (typeof sources["fullgraph"] === "object") {
			this.sockets.inputs["fullgraph"].connectTo(sources["fullgraph"])
		} else {
			this.sockets.inputs["fullgraph"].value = sources["fullgraph"]
		}

		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}

		if (typeof sources["double_blocks"] === "object") {
			this.sockets.inputs["double_blocks"].connectTo(sources["double_blocks"])
		} else {
			this.sockets.inputs["double_blocks"].value = sources["double_blocks"]
		}

		if (typeof sources["single_blocks"] === "object") {
			this.sockets.inputs["single_blocks"].connectTo(sources["single_blocks"])
		} else {
			this.sockets.inputs["single_blocks"].value = sources["single_blocks"]
		}

		if (typeof sources["dynamic"] === "object") {
			this.sockets.inputs["dynamic"].connectTo(sources["dynamic"])
		} else {
			this.sockets.inputs["dynamic"].value = sources["dynamic"]
		}

		if (sources["dynamo_cache_size_limit"] !== undefined) {
		if (typeof sources["dynamo_cache_size_limit"] === "object") {
			this.sockets.inputs["dynamo_cache_size_limit"].connectTo(sources["dynamo_cache_size_limit"])
		} else {
			this.sockets.inputs["dynamo_cache_size_limit"].value = sources["dynamo_cache_size_limit"]
		}
		}

	}
}

type TorchCompileModelFluxAdvancedInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"backend": ComfyNodeTypedInputRef<string>
			/** Enable full graph mode*/
			"fullgraph": ComfyNodeTypedInputRef<boolean>
			"mode": ComfyNodeTypedInputRef<string>
			"double_blocks": ComfyNodeTypedInputRef<string>
			"single_blocks": ComfyNodeTypedInputRef<string>
			/** Enable dynamic mode*/
			"dynamic": ComfyNodeTypedInputRef<boolean>
			/** torch._dynamo.config.cache_size_limit*/
			"dynamo_cache_size_limit"?: ComfyNodeTypedInputRef<number>
}


export class TorchCompileModelFluxAdvancedV2 extends ComfyNode {
	classType: string = "TorchCompileModelFluxAdvancedV2"

	sockets: {
		inputs: Required<TorchCompileModelFluxAdvancedV2Inputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"backend": new ComfyNodeTypedInputRef<string>(this, "backend"),
				"fullgraph": new ComfyNodeTypedInputRef<boolean>(this, "fullgraph"),
				"mode": new ComfyNodeTypedInputRef<string>(this, "mode"),
				"double_blocks": new ComfyNodeTypedInputRef<boolean>(this, "double_blocks"),
				"single_blocks": new ComfyNodeTypedInputRef<boolean>(this, "single_blocks"),
				"dynamic": new ComfyNodeTypedInputRef<boolean>(this, "dynamic"),
				"dynamo_cache_size_limit": new ComfyNodeTypedInputRef<number>(this, "dynamo_cache_size_limit"),
				"force_parameter_static_shapes": new ComfyNodeTypedInputRef<boolean>(this, "force_parameter_static_shapes"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TorchCompileModelFluxAdvancedV2Inputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["backend"] === "object") {
			this.sockets.inputs["backend"].connectTo(sources["backend"])
		} else {
			this.sockets.inputs["backend"].value = sources["backend"]
		}

		if (typeof sources["fullgraph"] === "object") {
			this.sockets.inputs["fullgraph"].connectTo(sources["fullgraph"])
		} else {
			this.sockets.inputs["fullgraph"].value = sources["fullgraph"]
		}

		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}

		if (typeof sources["double_blocks"] === "object") {
			this.sockets.inputs["double_blocks"].connectTo(sources["double_blocks"])
		} else {
			this.sockets.inputs["double_blocks"].value = sources["double_blocks"]
		}

		if (typeof sources["single_blocks"] === "object") {
			this.sockets.inputs["single_blocks"].connectTo(sources["single_blocks"])
		} else {
			this.sockets.inputs["single_blocks"].value = sources["single_blocks"]
		}

		if (typeof sources["dynamic"] === "object") {
			this.sockets.inputs["dynamic"].connectTo(sources["dynamic"])
		} else {
			this.sockets.inputs["dynamic"].value = sources["dynamic"]
		}

		if (sources["dynamo_cache_size_limit"] !== undefined) {
		if (typeof sources["dynamo_cache_size_limit"] === "object") {
			this.sockets.inputs["dynamo_cache_size_limit"].connectTo(sources["dynamo_cache_size_limit"])
		} else {
			this.sockets.inputs["dynamo_cache_size_limit"].value = sources["dynamo_cache_size_limit"]
		}
		}

		if (sources["force_parameter_static_shapes"] !== undefined) {
		if (typeof sources["force_parameter_static_shapes"] === "object") {
			this.sockets.inputs["force_parameter_static_shapes"].connectTo(sources["force_parameter_static_shapes"])
		} else {
			this.sockets.inputs["force_parameter_static_shapes"].value = sources["force_parameter_static_shapes"]
		}
		}

	}
}

type TorchCompileModelFluxAdvancedV2Inputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"backend": ComfyNodeTypedInputRef<string>
			/** Enable full graph mode*/
			"fullgraph": ComfyNodeTypedInputRef<boolean>
			"mode": ComfyNodeTypedInputRef<string>
			/** Compile double blocks*/
			"double_blocks": ComfyNodeTypedInputRef<boolean>
			/** Compile single blocks*/
			"single_blocks": ComfyNodeTypedInputRef<boolean>
			/** Enable dynamic mode*/
			"dynamic": ComfyNodeTypedInputRef<boolean>
			/** torch._dynamo.config.cache_size_limit*/
			"dynamo_cache_size_limit"?: ComfyNodeTypedInputRef<number>
			/** torch._dynamo.config.force_parameter_static_shapes*/
			"force_parameter_static_shapes"?: ComfyNodeTypedInputRef<boolean>
}


export class TorchCompileModelHyVideo extends ComfyNode {
	classType: string = "TorchCompileModelHyVideo"

	sockets: {
		inputs: Required<TorchCompileModelHyVideoInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"backend": new ComfyNodeTypedInputRef<string>(this, "backend"),
				"fullgraph": new ComfyNodeTypedInputRef<boolean>(this, "fullgraph"),
				"mode": new ComfyNodeTypedInputRef<string>(this, "mode"),
				"dynamic": new ComfyNodeTypedInputRef<boolean>(this, "dynamic"),
				"dynamo_cache_size_limit": new ComfyNodeTypedInputRef<number>(this, "dynamo_cache_size_limit"),
				"compile_single_blocks": new ComfyNodeTypedInputRef<boolean>(this, "compile_single_blocks"),
				"compile_double_blocks": new ComfyNodeTypedInputRef<boolean>(this, "compile_double_blocks"),
				"compile_txt_in": new ComfyNodeTypedInputRef<boolean>(this, "compile_txt_in"),
				"compile_vector_in": new ComfyNodeTypedInputRef<boolean>(this, "compile_vector_in"),
				"compile_final_layer": new ComfyNodeTypedInputRef<boolean>(this, "compile_final_layer"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TorchCompileModelHyVideoInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["backend"] === "object") {
			this.sockets.inputs["backend"].connectTo(sources["backend"])
		} else {
			this.sockets.inputs["backend"].value = sources["backend"]
		}

		if (typeof sources["fullgraph"] === "object") {
			this.sockets.inputs["fullgraph"].connectTo(sources["fullgraph"])
		} else {
			this.sockets.inputs["fullgraph"].value = sources["fullgraph"]
		}

		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}

		if (typeof sources["dynamic"] === "object") {
			this.sockets.inputs["dynamic"].connectTo(sources["dynamic"])
		} else {
			this.sockets.inputs["dynamic"].value = sources["dynamic"]
		}

		if (typeof sources["dynamo_cache_size_limit"] === "object") {
			this.sockets.inputs["dynamo_cache_size_limit"].connectTo(sources["dynamo_cache_size_limit"])
		} else {
			this.sockets.inputs["dynamo_cache_size_limit"].value = sources["dynamo_cache_size_limit"]
		}

		if (typeof sources["compile_single_blocks"] === "object") {
			this.sockets.inputs["compile_single_blocks"].connectTo(sources["compile_single_blocks"])
		} else {
			this.sockets.inputs["compile_single_blocks"].value = sources["compile_single_blocks"]
		}

		if (typeof sources["compile_double_blocks"] === "object") {
			this.sockets.inputs["compile_double_blocks"].connectTo(sources["compile_double_blocks"])
		} else {
			this.sockets.inputs["compile_double_blocks"].value = sources["compile_double_blocks"]
		}

		if (typeof sources["compile_txt_in"] === "object") {
			this.sockets.inputs["compile_txt_in"].connectTo(sources["compile_txt_in"])
		} else {
			this.sockets.inputs["compile_txt_in"].value = sources["compile_txt_in"]
		}

		if (typeof sources["compile_vector_in"] === "object") {
			this.sockets.inputs["compile_vector_in"].connectTo(sources["compile_vector_in"])
		} else {
			this.sockets.inputs["compile_vector_in"].value = sources["compile_vector_in"]
		}

		if (typeof sources["compile_final_layer"] === "object") {
			this.sockets.inputs["compile_final_layer"].connectTo(sources["compile_final_layer"])
		} else {
			this.sockets.inputs["compile_final_layer"].value = sources["compile_final_layer"]
		}

	}
}

type TorchCompileModelHyVideoInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"backend": ComfyNodeTypedInputRef<string>
			/** Enable full graph mode*/
			"fullgraph": ComfyNodeTypedInputRef<boolean>
			"mode": ComfyNodeTypedInputRef<string>
			/** Enable dynamic mode*/
			"dynamic": ComfyNodeTypedInputRef<boolean>
			/** torch._dynamo.config.cache_size_limit*/
			"dynamo_cache_size_limit": ComfyNodeTypedInputRef<number>
			/** Compile single blocks*/
			"compile_single_blocks": ComfyNodeTypedInputRef<boolean>
			/** Compile double blocks*/
			"compile_double_blocks": ComfyNodeTypedInputRef<boolean>
			/** Compile txt_in layers*/
			"compile_txt_in": ComfyNodeTypedInputRef<boolean>
			/** Compile vector_in layers*/
			"compile_vector_in": ComfyNodeTypedInputRef<boolean>
			/** Compile final layer*/
			"compile_final_layer": ComfyNodeTypedInputRef<boolean>
}


export class TorchCompileVAE extends ComfyNode {
	classType: string = "TorchCompileVAE"

	sockets: {
		inputs: Required<TorchCompileVAEInputs>
		outputs: {
			VAE: ComfyNodeTypedSourceRef<ComfyValueType_VAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"backend": new ComfyNodeTypedInputRef<string>(this, "backend"),
				"fullgraph": new ComfyNodeTypedInputRef<boolean>(this, "fullgraph"),
				"mode": new ComfyNodeTypedInputRef<string>(this, "mode"),
				"compile_encoder": new ComfyNodeTypedInputRef<boolean>(this, "compile_encoder"),
				"compile_decoder": new ComfyNodeTypedInputRef<boolean>(this, "compile_decoder"),
			},
			outputs: Object.create(Object.prototype, {
				"VAE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TorchCompileVAEInputs>) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["backend"] === "object") {
			this.sockets.inputs["backend"].connectTo(sources["backend"])
		} else {
			this.sockets.inputs["backend"].value = sources["backend"]
		}

		if (typeof sources["fullgraph"] === "object") {
			this.sockets.inputs["fullgraph"].connectTo(sources["fullgraph"])
		} else {
			this.sockets.inputs["fullgraph"].value = sources["fullgraph"]
		}

		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}

		if (typeof sources["compile_encoder"] === "object") {
			this.sockets.inputs["compile_encoder"].connectTo(sources["compile_encoder"])
		} else {
			this.sockets.inputs["compile_encoder"].value = sources["compile_encoder"]
		}

		if (typeof sources["compile_decoder"] === "object") {
			this.sockets.inputs["compile_decoder"].connectTo(sources["compile_decoder"])
		} else {
			this.sockets.inputs["compile_decoder"].value = sources["compile_decoder"]
		}

	}
}

type TorchCompileVAEInputs = {
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"backend": ComfyNodeTypedInputRef<string>
			/** Enable full graph mode*/
			"fullgraph": ComfyNodeTypedInputRef<boolean>
			"mode": ComfyNodeTypedInputRef<string>
			/** Compile encoder*/
			"compile_encoder": ComfyNodeTypedInputRef<boolean>
			/** Compile decoder*/
			"compile_decoder": ComfyNodeTypedInputRef<boolean>
}


export class TorchCompileControlNet extends ComfyNode {
	classType: string = "TorchCompileControlNet"

	sockets: {
		inputs: Required<TorchCompileControlNetInputs>
		outputs: {
			CONTROL_NET: ComfyNodeTypedSourceRef<ComfyValueType_CONTROL_NET>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"controlnet": new ComfyNodeTypedInputRef<ComfyValueType_CONTROL_NET>(this, "controlnet"),
				"backend": new ComfyNodeTypedInputRef<string>(this, "backend"),
				"fullgraph": new ComfyNodeTypedInputRef<boolean>(this, "fullgraph"),
				"mode": new ComfyNodeTypedInputRef<string>(this, "mode"),
			},
			outputs: Object.create(Object.prototype, {
				"CONTROL_NET": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TorchCompileControlNetInputs>) {
		if (typeof sources["controlnet"] === "object") {
			this.sockets.inputs["controlnet"].connectTo(sources["controlnet"])
		} else {
			this.sockets.inputs["controlnet"].value = sources["controlnet"]
		}

		if (typeof sources["backend"] === "object") {
			this.sockets.inputs["backend"].connectTo(sources["backend"])
		} else {
			this.sockets.inputs["backend"].value = sources["backend"]
		}

		if (typeof sources["fullgraph"] === "object") {
			this.sockets.inputs["fullgraph"].connectTo(sources["fullgraph"])
		} else {
			this.sockets.inputs["fullgraph"].value = sources["fullgraph"]
		}

		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}

	}
}

type TorchCompileControlNetInputs = {
			"controlnet": ComfyNodeTypedInputRef<ComfyValueType_CONTROL_NET>
			"backend": ComfyNodeTypedInputRef<string>
			/** Enable full graph mode*/
			"fullgraph": ComfyNodeTypedInputRef<boolean>
			"mode": ComfyNodeTypedInputRef<string>
}


export class PatchModelPatcherOrder extends ComfyNode {
	classType: string = "PatchModelPatcherOrder"

	sockets: {
		inputs: Required<PatchModelPatcherOrderInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"patch_order": new ComfyNodeTypedInputRef<string>(this, "patch_order"),
				"full_load": new ComfyNodeTypedInputRef<string>(this, "full_load"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PatchModelPatcherOrderInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["patch_order"] === "object") {
			this.sockets.inputs["patch_order"].connectTo(sources["patch_order"])
		} else {
			this.sockets.inputs["patch_order"].value = sources["patch_order"]
		}

		if (typeof sources["full_load"] === "object") {
			this.sockets.inputs["full_load"].connectTo(sources["full_load"])
		} else {
			this.sockets.inputs["full_load"].value = sources["full_load"]
		}

	}
}

type PatchModelPatcherOrderInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** Patch the comfy patch_model function to load weight patches (LoRAs) before compiling the model*/
			"patch_order": ComfyNodeTypedInputRef<string>
			/** Disabling may help with memory issues when loading large models, when changing this you should probably force model reload to avoid issues!*/
			"full_load": ComfyNodeTypedInputRef<string>
}


export class TorchCompileLTXModel extends ComfyNode {
	classType: string = "TorchCompileLTXModel"

	sockets: {
		inputs: Required<TorchCompileLTXModelInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"backend": new ComfyNodeTypedInputRef<string>(this, "backend"),
				"fullgraph": new ComfyNodeTypedInputRef<boolean>(this, "fullgraph"),
				"mode": new ComfyNodeTypedInputRef<string>(this, "mode"),
				"dynamic": new ComfyNodeTypedInputRef<boolean>(this, "dynamic"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TorchCompileLTXModelInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["backend"] === "object") {
			this.sockets.inputs["backend"].connectTo(sources["backend"])
		} else {
			this.sockets.inputs["backend"].value = sources["backend"]
		}

		if (typeof sources["fullgraph"] === "object") {
			this.sockets.inputs["fullgraph"].connectTo(sources["fullgraph"])
		} else {
			this.sockets.inputs["fullgraph"].value = sources["fullgraph"]
		}

		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}

		if (typeof sources["dynamic"] === "object") {
			this.sockets.inputs["dynamic"].connectTo(sources["dynamic"])
		} else {
			this.sockets.inputs["dynamic"].value = sources["dynamic"]
		}

	}
}

type TorchCompileLTXModelInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"backend": ComfyNodeTypedInputRef<string>
			/** Enable full graph mode*/
			"fullgraph": ComfyNodeTypedInputRef<boolean>
			"mode": ComfyNodeTypedInputRef<string>
			/** Enable dynamic mode*/
			"dynamic": ComfyNodeTypedInputRef<boolean>
}


export class TorchCompileCosmosModel extends ComfyNode {
	classType: string = "TorchCompileCosmosModel"

	sockets: {
		inputs: Required<TorchCompileCosmosModelInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"backend": new ComfyNodeTypedInputRef<string>(this, "backend"),
				"fullgraph": new ComfyNodeTypedInputRef<boolean>(this, "fullgraph"),
				"mode": new ComfyNodeTypedInputRef<string>(this, "mode"),
				"dynamic": new ComfyNodeTypedInputRef<boolean>(this, "dynamic"),
				"dynamo_cache_size_limit": new ComfyNodeTypedInputRef<number>(this, "dynamo_cache_size_limit"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TorchCompileCosmosModelInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["backend"] === "object") {
			this.sockets.inputs["backend"].connectTo(sources["backend"])
		} else {
			this.sockets.inputs["backend"].value = sources["backend"]
		}

		if (typeof sources["fullgraph"] === "object") {
			this.sockets.inputs["fullgraph"].connectTo(sources["fullgraph"])
		} else {
			this.sockets.inputs["fullgraph"].value = sources["fullgraph"]
		}

		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}

		if (typeof sources["dynamic"] === "object") {
			this.sockets.inputs["dynamic"].connectTo(sources["dynamic"])
		} else {
			this.sockets.inputs["dynamic"].value = sources["dynamic"]
		}

		if (typeof sources["dynamo_cache_size_limit"] === "object") {
			this.sockets.inputs["dynamo_cache_size_limit"].connectTo(sources["dynamo_cache_size_limit"])
		} else {
			this.sockets.inputs["dynamo_cache_size_limit"].value = sources["dynamo_cache_size_limit"]
		}

	}
}

type TorchCompileCosmosModelInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"backend": ComfyNodeTypedInputRef<string>
			/** Enable full graph mode*/
			"fullgraph": ComfyNodeTypedInputRef<boolean>
			"mode": ComfyNodeTypedInputRef<string>
			/** Enable dynamic mode*/
			"dynamic": ComfyNodeTypedInputRef<boolean>
			/** Set the dynamo cache size limit*/
			"dynamo_cache_size_limit": ComfyNodeTypedInputRef<number>
}


export class TorchCompileModelQwenImage extends ComfyNode {
	classType: string = "TorchCompileModelQwenImage"

	sockets: {
		inputs: Required<TorchCompileModelQwenImageInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"backend": new ComfyNodeTypedInputRef<string>(this, "backend"),
				"fullgraph": new ComfyNodeTypedInputRef<boolean>(this, "fullgraph"),
				"mode": new ComfyNodeTypedInputRef<string>(this, "mode"),
				"dynamic": new ComfyNodeTypedInputRef<boolean>(this, "dynamic"),
				"compile_transformer_blocks_only": new ComfyNodeTypedInputRef<boolean>(this, "compile_transformer_blocks_only"),
				"dynamo_cache_size_limit": new ComfyNodeTypedInputRef<number>(this, "dynamo_cache_size_limit"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TorchCompileModelQwenImageInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["backend"] === "object") {
			this.sockets.inputs["backend"].connectTo(sources["backend"])
		} else {
			this.sockets.inputs["backend"].value = sources["backend"]
		}

		if (typeof sources["fullgraph"] === "object") {
			this.sockets.inputs["fullgraph"].connectTo(sources["fullgraph"])
		} else {
			this.sockets.inputs["fullgraph"].value = sources["fullgraph"]
		}

		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}

		if (typeof sources["dynamic"] === "object") {
			this.sockets.inputs["dynamic"].connectTo(sources["dynamic"])
		} else {
			this.sockets.inputs["dynamic"].value = sources["dynamic"]
		}

		if (typeof sources["compile_transformer_blocks_only"] === "object") {
			this.sockets.inputs["compile_transformer_blocks_only"].connectTo(sources["compile_transformer_blocks_only"])
		} else {
			this.sockets.inputs["compile_transformer_blocks_only"].value = sources["compile_transformer_blocks_only"]
		}

		if (typeof sources["dynamo_cache_size_limit"] === "object") {
			this.sockets.inputs["dynamo_cache_size_limit"].connectTo(sources["dynamo_cache_size_limit"])
		} else {
			this.sockets.inputs["dynamo_cache_size_limit"].value = sources["dynamo_cache_size_limit"]
		}

	}
}

type TorchCompileModelQwenImageInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"backend": ComfyNodeTypedInputRef<string>
			/** Enable full graph mode*/
			"fullgraph": ComfyNodeTypedInputRef<boolean>
			"mode": ComfyNodeTypedInputRef<string>
			/** Enable dynamic mode*/
			"dynamic": ComfyNodeTypedInputRef<boolean>
			/** Compile only transformer blocks, faster compile and less error prone*/
			"compile_transformer_blocks_only": ComfyNodeTypedInputRef<boolean>
			/** torch._dynamo.config.cache_size_limit*/
			"dynamo_cache_size_limit": ComfyNodeTypedInputRef<number>
}


export class TorchCompileModelWanVideo extends ComfyNode {
	classType: string = "TorchCompileModelWanVideo"

	sockets: {
		inputs: Required<TorchCompileModelWanVideoInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"backend": new ComfyNodeTypedInputRef<string>(this, "backend"),
				"fullgraph": new ComfyNodeTypedInputRef<boolean>(this, "fullgraph"),
				"mode": new ComfyNodeTypedInputRef<string>(this, "mode"),
				"dynamic": new ComfyNodeTypedInputRef<boolean>(this, "dynamic"),
				"dynamo_cache_size_limit": new ComfyNodeTypedInputRef<number>(this, "dynamo_cache_size_limit"),
				"compile_transformer_blocks_only": new ComfyNodeTypedInputRef<boolean>(this, "compile_transformer_blocks_only"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TorchCompileModelWanVideoInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["backend"] === "object") {
			this.sockets.inputs["backend"].connectTo(sources["backend"])
		} else {
			this.sockets.inputs["backend"].value = sources["backend"]
		}

		if (typeof sources["fullgraph"] === "object") {
			this.sockets.inputs["fullgraph"].connectTo(sources["fullgraph"])
		} else {
			this.sockets.inputs["fullgraph"].value = sources["fullgraph"]
		}

		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}

		if (typeof sources["dynamic"] === "object") {
			this.sockets.inputs["dynamic"].connectTo(sources["dynamic"])
		} else {
			this.sockets.inputs["dynamic"].value = sources["dynamic"]
		}

		if (typeof sources["dynamo_cache_size_limit"] === "object") {
			this.sockets.inputs["dynamo_cache_size_limit"].connectTo(sources["dynamo_cache_size_limit"])
		} else {
			this.sockets.inputs["dynamo_cache_size_limit"].value = sources["dynamo_cache_size_limit"]
		}

		if (typeof sources["compile_transformer_blocks_only"] === "object") {
			this.sockets.inputs["compile_transformer_blocks_only"].connectTo(sources["compile_transformer_blocks_only"])
		} else {
			this.sockets.inputs["compile_transformer_blocks_only"].value = sources["compile_transformer_blocks_only"]
		}

	}
}

type TorchCompileModelWanVideoInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"backend": ComfyNodeTypedInputRef<string>
			/** Enable full graph mode*/
			"fullgraph": ComfyNodeTypedInputRef<boolean>
			"mode": ComfyNodeTypedInputRef<string>
			/** Enable dynamic mode*/
			"dynamic": ComfyNodeTypedInputRef<boolean>
			/** torch._dynamo.config.cache_size_limit*/
			"dynamo_cache_size_limit": ComfyNodeTypedInputRef<number>
			/** Compile only transformer blocks*/
			"compile_transformer_blocks_only": ComfyNodeTypedInputRef<boolean>
}


export class TorchCompileModelWanVideoV2 extends ComfyNode {
	classType: string = "TorchCompileModelWanVideoV2"

	sockets: {
		inputs: Required<TorchCompileModelWanVideoV2Inputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"backend": new ComfyNodeTypedInputRef<string>(this, "backend"),
				"fullgraph": new ComfyNodeTypedInputRef<boolean>(this, "fullgraph"),
				"mode": new ComfyNodeTypedInputRef<string>(this, "mode"),
				"dynamic": new ComfyNodeTypedInputRef<boolean>(this, "dynamic"),
				"compile_transformer_blocks_only": new ComfyNodeTypedInputRef<boolean>(this, "compile_transformer_blocks_only"),
				"dynamo_cache_size_limit": new ComfyNodeTypedInputRef<number>(this, "dynamo_cache_size_limit"),
				"force_parameter_static_shapes": new ComfyNodeTypedInputRef<boolean>(this, "force_parameter_static_shapes"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TorchCompileModelWanVideoV2Inputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["backend"] === "object") {
			this.sockets.inputs["backend"].connectTo(sources["backend"])
		} else {
			this.sockets.inputs["backend"].value = sources["backend"]
		}

		if (typeof sources["fullgraph"] === "object") {
			this.sockets.inputs["fullgraph"].connectTo(sources["fullgraph"])
		} else {
			this.sockets.inputs["fullgraph"].value = sources["fullgraph"]
		}

		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}

		if (typeof sources["dynamic"] === "object") {
			this.sockets.inputs["dynamic"].connectTo(sources["dynamic"])
		} else {
			this.sockets.inputs["dynamic"].value = sources["dynamic"]
		}

		if (typeof sources["compile_transformer_blocks_only"] === "object") {
			this.sockets.inputs["compile_transformer_blocks_only"].connectTo(sources["compile_transformer_blocks_only"])
		} else {
			this.sockets.inputs["compile_transformer_blocks_only"].value = sources["compile_transformer_blocks_only"]
		}

		if (typeof sources["dynamo_cache_size_limit"] === "object") {
			this.sockets.inputs["dynamo_cache_size_limit"].connectTo(sources["dynamo_cache_size_limit"])
		} else {
			this.sockets.inputs["dynamo_cache_size_limit"].value = sources["dynamo_cache_size_limit"]
		}

		if (sources["force_parameter_static_shapes"] !== undefined) {
		if (typeof sources["force_parameter_static_shapes"] === "object") {
			this.sockets.inputs["force_parameter_static_shapes"].connectTo(sources["force_parameter_static_shapes"])
		} else {
			this.sockets.inputs["force_parameter_static_shapes"].value = sources["force_parameter_static_shapes"]
		}
		}

	}
}

type TorchCompileModelWanVideoV2Inputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"backend": ComfyNodeTypedInputRef<string>
			/** Enable full graph mode*/
			"fullgraph": ComfyNodeTypedInputRef<boolean>
			"mode": ComfyNodeTypedInputRef<string>
			/** Enable dynamic mode*/
			"dynamic": ComfyNodeTypedInputRef<boolean>
			/** Compile only transformer blocks, faster compile and less error prone*/
			"compile_transformer_blocks_only": ComfyNodeTypedInputRef<boolean>
			/** torch._dynamo.config.cache_size_limit*/
			"dynamo_cache_size_limit": ComfyNodeTypedInputRef<number>
			/** torch._dynamo.config.force_parameter_static_shapes*/
			"force_parameter_static_shapes"?: ComfyNodeTypedInputRef<boolean>
}


export class PathchSageAttentionKJ extends ComfyNode {
	classType: string = "PathchSageAttentionKJ"

	sockets: {
		inputs: Required<PathchSageAttentionKJInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"sage_attention": new ComfyNodeTypedInputRef<string>(this, "sage_attention"),
				"allow_compile": new ComfyNodeTypedInputRef<boolean>(this, "allow_compile"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<PathchSageAttentionKJInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["sage_attention"] === "object") {
			this.sockets.inputs["sage_attention"].connectTo(sources["sage_attention"])
		} else {
			this.sockets.inputs["sage_attention"].value = sources["sage_attention"]
		}

		if (sources["allow_compile"] !== undefined) {
		if (typeof sources["allow_compile"] === "object") {
			this.sockets.inputs["allow_compile"].connectTo(sources["allow_compile"])
		} else {
			this.sockets.inputs["allow_compile"].value = sources["allow_compile"]
		}
		}

	}
}

type PathchSageAttentionKJInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** Global patch comfy attention to use sageattn, once patched to revert back to normal you would need to run this node again with disabled option.*/
			"sage_attention": ComfyNodeTypedInputRef<string>
			/** Allow the use of torch.compile for the sage attention function, requires latest sageattn 2.2.0 or higher.*/
			"allow_compile"?: ComfyNodeTypedInputRef<boolean>
}


export class LeapfusionHunyuanI2VPatcher extends ComfyNode {
	classType: string = "LeapfusionHunyuanI2VPatcher"

	sockets: {
		inputs: Required<LeapfusionHunyuanI2VPatcherInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latent"),
				"index": new ComfyNodeTypedInputRef<number>(this, "index"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LeapfusionHunyuanI2VPatcherInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["latent"] === "object") {
			this.sockets.inputs["latent"].connectTo(sources["latent"])
		} else {
			this.sockets.inputs["latent"].value = sources["latent"]
		}

		if (typeof sources["index"] === "object") {
			this.sockets.inputs["index"].connectTo(sources["index"])
		} else {
			this.sockets.inputs["index"].value = sources["index"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

	}
}

type LeapfusionHunyuanI2VPatcherInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"latent": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** The index of the latent to be replaced. 0 for first frame and -1 for last*/
			"index": ComfyNodeTypedInputRef<number>
			/** The start percentage of steps to apply*/
			"start_percent": ComfyNodeTypedInputRef<number>
			/** The end percentage of steps to apply*/
			"end_percent": ComfyNodeTypedInputRef<number>
			"strength": ComfyNodeTypedInputRef<number>
}


export class VAELoaderKJ extends ComfyNode {
	classType: string = "VAELoaderKJ"

	sockets: {
		inputs: Required<VAELoaderKJInputs>
		outputs: {
			VAE: ComfyNodeTypedSourceRef<ComfyValueType_VAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vae_name": new ComfyNodeTypedInputRef<string>(this, "vae_name"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
				"weight_dtype": new ComfyNodeTypedInputRef<string>(this, "weight_dtype"),
			},
			outputs: Object.create(Object.prototype, {
				"VAE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VAELoaderKJInputs>) {
		if (typeof sources["vae_name"] === "object") {
			this.sockets.inputs["vae_name"].connectTo(sources["vae_name"])
		} else {
			this.sockets.inputs["vae_name"].value = sources["vae_name"]
		}

		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}

		if (typeof sources["weight_dtype"] === "object") {
			this.sockets.inputs["weight_dtype"].connectTo(sources["weight_dtype"])
		} else {
			this.sockets.inputs["weight_dtype"].value = sources["weight_dtype"]
		}

	}
}

type VAELoaderKJInputs = {
			"vae_name": ComfyNodeTypedInputRef<string>
			"device": ComfyNodeTypedInputRef<string>
			"weight_dtype": ComfyNodeTypedInputRef<string>
}


export class ScheduledCFGGuidance extends ComfyNode {
	classType: string = "ScheduledCFGGuidance"

	sockets: {
		inputs: Required<ScheduledCFGGuidanceInputs>
		outputs: {
			GUIDER: ComfyNodeTypedSourceRef<ComfyValueType_GUIDER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
				"cfg": new ComfyNodeTypedInputRef<number>(this, "cfg"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
			},
			outputs: Object.create(Object.prototype, {
				"GUIDER": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ScheduledCFGGuidanceInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}

		if (typeof sources["cfg"] === "object") {
			this.sockets.inputs["cfg"].connectTo(sources["cfg"])
		} else {
			this.sockets.inputs["cfg"].value = sources["cfg"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

	}
}

type ScheduledCFGGuidanceInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"cfg": ComfyNodeTypedInputRef<number>
			"start_percent": ComfyNodeTypedInputRef<number>
			"end_percent": ComfyNodeTypedInputRef<number>
}


export class ApplyRifleXRoPE_HunuyanVideo extends ComfyNode {
	classType: string = "ApplyRifleXRoPE_HunuyanVideo"

	sockets: {
		inputs: Required<ApplyRifleXRoPE_HunuyanVideoInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latent"),
				"k": new ComfyNodeTypedInputRef<number>(this, "k"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ApplyRifleXRoPE_HunuyanVideoInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["latent"] === "object") {
			this.sockets.inputs["latent"].connectTo(sources["latent"])
		} else {
			this.sockets.inputs["latent"].value = sources["latent"]
		}

		if (typeof sources["k"] === "object") {
			this.sockets.inputs["k"].connectTo(sources["k"])
		} else {
			this.sockets.inputs["k"].value = sources["k"]
		}

	}
}

type ApplyRifleXRoPE_HunuyanVideoInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** Only used to get the latent count*/
			"latent": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** Index of intrinsic frequency*/
			"k": ComfyNodeTypedInputRef<number>
}


export class ApplyRifleXRoPE_WanVideo extends ComfyNode {
	classType: string = "ApplyRifleXRoPE_WanVideo"

	sockets: {
		inputs: Required<ApplyRifleXRoPE_WanVideoInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latent"),
				"k": new ComfyNodeTypedInputRef<number>(this, "k"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ApplyRifleXRoPE_WanVideoInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["latent"] === "object") {
			this.sockets.inputs["latent"].connectTo(sources["latent"])
		} else {
			this.sockets.inputs["latent"].value = sources["latent"]
		}

		if (typeof sources["k"] === "object") {
			this.sockets.inputs["k"].connectTo(sources["k"])
		} else {
			this.sockets.inputs["k"].value = sources["k"]
		}

	}
}

type ApplyRifleXRoPE_WanVideoInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** Only used to get the latent count*/
			"latent": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** Index of intrinsic frequency*/
			"k": ComfyNodeTypedInputRef<number>
}


export class WanVideoTeaCacheKJ extends ComfyNode {
	classType: string = "WanVideoTeaCacheKJ"

	sockets: {
		inputs: Required<WanVideoTeaCacheKJInputs>
		outputs: {
			model: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"rel_l1_thresh": new ComfyNodeTypedInputRef<number>(this, "rel_l1_thresh"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
				"cache_device": new ComfyNodeTypedInputRef<string>(this, "cache_device"),
				"coefficients": new ComfyNodeTypedInputRef<string>(this, "coefficients"),
			},
			outputs: Object.create(Object.prototype, {
				"model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoTeaCacheKJInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["rel_l1_thresh"] === "object") {
			this.sockets.inputs["rel_l1_thresh"].connectTo(sources["rel_l1_thresh"])
		} else {
			this.sockets.inputs["rel_l1_thresh"].value = sources["rel_l1_thresh"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

		if (typeof sources["cache_device"] === "object") {
			this.sockets.inputs["cache_device"].connectTo(sources["cache_device"])
		} else {
			this.sockets.inputs["cache_device"].value = sources["cache_device"]
		}

		if (typeof sources["coefficients"] === "object") {
			this.sockets.inputs["coefficients"].connectTo(sources["coefficients"])
		} else {
			this.sockets.inputs["coefficients"].value = sources["coefficients"]
		}

	}
}

type WanVideoTeaCacheKJInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** Threshold for to determine when to apply the cache, compromise between speed and accuracy. When using coefficients a good value range is something between 0.2-0.4 for all but 1.3B model, which should be about 10 times smaller, same as when not using coefficients.*/
			"rel_l1_thresh": ComfyNodeTypedInputRef<number>
			/** The start percentage of the steps to use with TeaCache.*/
			"start_percent": ComfyNodeTypedInputRef<number>
			/** The end percentage of the steps to use with TeaCache.*/
			"end_percent": ComfyNodeTypedInputRef<number>
			/** Device to cache to*/
			"cache_device": ComfyNodeTypedInputRef<string>
			/** Coefficients for rescaling the relative l1 distance, if disabled the threshold value should be about 10 times smaller than the value used with coefficients.*/
			"coefficients": ComfyNodeTypedInputRef<string>
}


export class WanVideoEnhanceAVideoKJ extends ComfyNode {
	classType: string = "WanVideoEnhanceAVideoKJ"

	sockets: {
		inputs: Required<WanVideoEnhanceAVideoKJInputs>
		outputs: {
			model: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latent"),
				"weight": new ComfyNodeTypedInputRef<number>(this, "weight"),
			},
			outputs: Object.create(Object.prototype, {
				"model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoEnhanceAVideoKJInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["latent"] === "object") {
			this.sockets.inputs["latent"].connectTo(sources["latent"])
		} else {
			this.sockets.inputs["latent"].value = sources["latent"]
		}

		if (typeof sources["weight"] === "object") {
			this.sockets.inputs["weight"].connectTo(sources["weight"])
		} else {
			this.sockets.inputs["weight"].value = sources["weight"]
		}

	}
}

type WanVideoEnhanceAVideoKJInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** Only used to get the latent count*/
			"latent": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** Strength of the enhance effect*/
			"weight": ComfyNodeTypedInputRef<number>
}


export class SkipLayerGuidanceWanVideo extends ComfyNode {
	classType: string = "SkipLayerGuidanceWanVideo"

	sockets: {
		inputs: Required<SkipLayerGuidanceWanVideoInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"blocks": new ComfyNodeTypedInputRef<string>(this, "blocks"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<SkipLayerGuidanceWanVideoInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["blocks"] === "object") {
			this.sockets.inputs["blocks"].connectTo(sources["blocks"])
		} else {
			this.sockets.inputs["blocks"].value = sources["blocks"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

	}
}

type SkipLayerGuidanceWanVideoInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"blocks": ComfyNodeTypedInputRef<string>
			"start_percent": ComfyNodeTypedInputRef<number>
			"end_percent": ComfyNodeTypedInputRef<number>
}


export class TimerNodeKJ extends ComfyNode {
	classType: string = "TimerNodeKJ"

	sockets: {
		inputs: Required<TimerNodeKJInputs>
		outputs: {
			any_output: ComfyNodeTypedSourceRef<ComfyValueType_$STAR>
			timer: ComfyNodeTypedSourceRef<ComfyValueType_TIMER>
			time: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"any_input": new ComfyNodeTypedInputRef<ComfyValueType_$STAR>(this, "any_input"),
				"mode": new ComfyNodeTypedInputRef<string>(this, "mode"),
				"name": new ComfyNodeTypedInputRef<string>(this, "name"),
				"timer": new ComfyNodeTypedInputRef<ComfyValueType_TIMER>(this, "timer"),
			},
			outputs: Object.create(Object.prototype, {
				"any_output": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"timer": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"time": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TimerNodeKJInputs>) {
		if (typeof sources["any_input"] === "object") {
			this.sockets.inputs["any_input"].connectTo(sources["any_input"])
		} else {
			this.sockets.inputs["any_input"].value = sources["any_input"]
		}

		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}

		if (typeof sources["name"] === "object") {
			this.sockets.inputs["name"].connectTo(sources["name"])
		} else {
			this.sockets.inputs["name"].value = sources["name"]
		}

		if (sources["timer"] !== undefined) {
		if (typeof sources["timer"] === "object") {
			this.sockets.inputs["timer"].connectTo(sources["timer"])
		} else {
			this.sockets.inputs["timer"].value = sources["timer"]
		}
		}

	}
}

type TimerNodeKJInputs = {
			"any_input": ComfyNodeTypedInputRef<ComfyValueType_$STAR>
			"mode": ComfyNodeTypedInputRef<string>
			"name": ComfyNodeTypedInputRef<string>
			"timer"?: ComfyNodeTypedInputRef<ComfyValueType_TIMER>
}


export class HunyuanVideoEncodeKeyframesToCond extends ComfyNode {
	classType: string = "HunyuanVideoEncodeKeyframesToCond"

	sockets: {
		inputs: Required<HunyuanVideoEncodeKeyframesToCondInputs>
		outputs: {
			model: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
			positive: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			negative: ComfyNodeTypedSourceRef<ComfyValueType_CONDITIONING>
			latent: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"start_frame": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "start_frame"),
				"end_frame": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "end_frame"),
				"num_frames": new ComfyNodeTypedInputRef<number>(this, "num_frames"),
				"tile_size": new ComfyNodeTypedInputRef<number>(this, "tile_size"),
				"overlap": new ComfyNodeTypedInputRef<number>(this, "overlap"),
				"temporal_size": new ComfyNodeTypedInputRef<number>(this, "temporal_size"),
				"temporal_overlap": new ComfyNodeTypedInputRef<number>(this, "temporal_overlap"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
			},
			outputs: Object.create(Object.prototype, {
				"model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"positive": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"negative": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"latent": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<HunyuanVideoEncodeKeyframesToCondInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["start_frame"] === "object") {
			this.sockets.inputs["start_frame"].connectTo(sources["start_frame"])
		} else {
			this.sockets.inputs["start_frame"].value = sources["start_frame"]
		}

		if (typeof sources["end_frame"] === "object") {
			this.sockets.inputs["end_frame"].connectTo(sources["end_frame"])
		} else {
			this.sockets.inputs["end_frame"].value = sources["end_frame"]
		}

		if (typeof sources["num_frames"] === "object") {
			this.sockets.inputs["num_frames"].connectTo(sources["num_frames"])
		} else {
			this.sockets.inputs["num_frames"].value = sources["num_frames"]
		}

		if (typeof sources["tile_size"] === "object") {
			this.sockets.inputs["tile_size"].connectTo(sources["tile_size"])
		} else {
			this.sockets.inputs["tile_size"].value = sources["tile_size"]
		}

		if (typeof sources["overlap"] === "object") {
			this.sockets.inputs["overlap"].connectTo(sources["overlap"])
		} else {
			this.sockets.inputs["overlap"].value = sources["overlap"]
		}

		if (typeof sources["temporal_size"] === "object") {
			this.sockets.inputs["temporal_size"].connectTo(sources["temporal_size"])
		} else {
			this.sockets.inputs["temporal_size"].value = sources["temporal_size"]
		}

		if (typeof sources["temporal_overlap"] === "object") {
			this.sockets.inputs["temporal_overlap"].connectTo(sources["temporal_overlap"])
		} else {
			this.sockets.inputs["temporal_overlap"].value = sources["temporal_overlap"]
		}

		if (sources["negative"] !== undefined) {
		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}
		}

	}
}

type HunyuanVideoEncodeKeyframesToCondInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"start_frame": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"end_frame": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"num_frames": ComfyNodeTypedInputRef<number>
			"tile_size": ComfyNodeTypedInputRef<number>
			"overlap": ComfyNodeTypedInputRef<number>
			/** Only used for video VAEs: Amount of frames to encode at a time.*/
			"temporal_size": ComfyNodeTypedInputRef<number>
			/** Only used for video VAEs: Amount of frames to overlap.*/
			"temporal_overlap": ComfyNodeTypedInputRef<number>
			"negative"?: ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
}


export class CFGZeroStarAndInit extends ComfyNode {
	classType: string = "CFGZeroStarAndInit"

	sockets: {
		inputs: Required<CFGZeroStarAndInitInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"use_zero_init": new ComfyNodeTypedInputRef<boolean>(this, "use_zero_init"),
				"zero_init_steps": new ComfyNodeTypedInputRef<number>(this, "zero_init_steps"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CFGZeroStarAndInitInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["use_zero_init"] === "object") {
			this.sockets.inputs["use_zero_init"].connectTo(sources["use_zero_init"])
		} else {
			this.sockets.inputs["use_zero_init"].value = sources["use_zero_init"]
		}

		if (typeof sources["zero_init_steps"] === "object") {
			this.sockets.inputs["zero_init_steps"].connectTo(sources["zero_init_steps"])
		} else {
			this.sockets.inputs["zero_init_steps"].value = sources["zero_init_steps"]
		}

	}
}

type CFGZeroStarAndInitInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"use_zero_init": ComfyNodeTypedInputRef<boolean>
			/** for zero init, starts from 0 so first step is always zeroed out if use_zero_init enabled*/
			"zero_init_steps": ComfyNodeTypedInputRef<number>
}


export class ModelPatchTorchSettings extends ComfyNode {
	classType: string = "ModelPatchTorchSettings"

	sockets: {
		inputs: Required<ModelPatchTorchSettingsInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"enable_fp16_accumulation": new ComfyNodeTypedInputRef<boolean>(this, "enable_fp16_accumulation"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ModelPatchTorchSettingsInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["enable_fp16_accumulation"] === "object") {
			this.sockets.inputs["enable_fp16_accumulation"].connectTo(sources["enable_fp16_accumulation"])
		} else {
			this.sockets.inputs["enable_fp16_accumulation"].value = sources["enable_fp16_accumulation"]
		}

	}
}

type ModelPatchTorchSettingsInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** Enable torch.backends.cuda.matmul.allow_fp16_accumulation, requires pytorch 2.7.0 nightly.*/
			"enable_fp16_accumulation": ComfyNodeTypedInputRef<boolean>
}


export class WanVideoNAG extends ComfyNode {
	classType: string = "WanVideoNAG"

	sockets: {
		inputs: Required<WanVideoNAGInputs>
		outputs: {
			model: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"conditioning": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "conditioning"),
				"nag_scale": new ComfyNodeTypedInputRef<number>(this, "nag_scale"),
				"nag_alpha": new ComfyNodeTypedInputRef<number>(this, "nag_alpha"),
				"nag_tau": new ComfyNodeTypedInputRef<number>(this, "nag_tau"),
				"input_type": new ComfyNodeTypedInputRef<string>(this, "input_type"),
			},
			outputs: Object.create(Object.prototype, {
				"model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoNAGInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["conditioning"] === "object") {
			this.sockets.inputs["conditioning"].connectTo(sources["conditioning"])
		} else {
			this.sockets.inputs["conditioning"].value = sources["conditioning"]
		}

		if (typeof sources["nag_scale"] === "object") {
			this.sockets.inputs["nag_scale"].connectTo(sources["nag_scale"])
		} else {
			this.sockets.inputs["nag_scale"].value = sources["nag_scale"]
		}

		if (typeof sources["nag_alpha"] === "object") {
			this.sockets.inputs["nag_alpha"].connectTo(sources["nag_alpha"])
		} else {
			this.sockets.inputs["nag_alpha"].value = sources["nag_alpha"]
		}

		if (typeof sources["nag_tau"] === "object") {
			this.sockets.inputs["nag_tau"].connectTo(sources["nag_tau"])
		} else {
			this.sockets.inputs["nag_tau"].value = sources["nag_tau"]
		}

		if (sources["input_type"] !== undefined) {
		if (typeof sources["input_type"] === "object") {
			this.sockets.inputs["input_type"].connectTo(sources["input_type"])
		} else {
			this.sockets.inputs["input_type"].value = sources["input_type"]
		}
		}

	}
}

type WanVideoNAGInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"conditioning": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			/** Strength of negative guidance effect*/
			"nag_scale": ComfyNodeTypedInputRef<number>
			/** Mixing coefficient in that controls the balance between the normalized guided representation and the original positive representation.*/
			"nag_alpha": ComfyNodeTypedInputRef<number>
			/** Clipping threshold that controls how much the guided attention can deviate from the positive attention.*/
			"nag_tau": ComfyNodeTypedInputRef<number>
			/** Type of the model input*/
			"input_type"?: ComfyNodeTypedInputRef<string>
}


export class GGUFLoaderKJ extends ComfyNode {
	classType: string = "GGUFLoaderKJ"

	sockets: {
		inputs: Required<GGUFLoaderKJInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_name": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "model_name"),
				"extra_model_name": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "extra_model_name"),
				"dequant_dtype": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "dequant_dtype"),
				"patch_dtype": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "patch_dtype"),
				"patch_on_device": new ComfyNodeTypedInputRef<boolean>(this, "patch_on_device"),
				"enable_fp16_accumulation": new ComfyNodeTypedInputRef<boolean>(this, "enable_fp16_accumulation"),
				"attention_override": new ComfyNodeTypedInputRef<ComfyValueType_COMBO>(this, "attention_override"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<GGUFLoaderKJInputs>) {
		if (typeof sources["model_name"] === "object") {
			this.sockets.inputs["model_name"].connectTo(sources["model_name"])
		} else {
			this.sockets.inputs["model_name"].value = sources["model_name"]
		}

		if (typeof sources["extra_model_name"] === "object") {
			this.sockets.inputs["extra_model_name"].connectTo(sources["extra_model_name"])
		} else {
			this.sockets.inputs["extra_model_name"].value = sources["extra_model_name"]
		}

		if (typeof sources["dequant_dtype"] === "object") {
			this.sockets.inputs["dequant_dtype"].connectTo(sources["dequant_dtype"])
		} else {
			this.sockets.inputs["dequant_dtype"].value = sources["dequant_dtype"]
		}

		if (typeof sources["patch_dtype"] === "object") {
			this.sockets.inputs["patch_dtype"].connectTo(sources["patch_dtype"])
		} else {
			this.sockets.inputs["patch_dtype"].value = sources["patch_dtype"]
		}

		if (typeof sources["patch_on_device"] === "object") {
			this.sockets.inputs["patch_on_device"].connectTo(sources["patch_on_device"])
		} else {
			this.sockets.inputs["patch_on_device"].value = sources["patch_on_device"]
		}

		if (typeof sources["enable_fp16_accumulation"] === "object") {
			this.sockets.inputs["enable_fp16_accumulation"].connectTo(sources["enable_fp16_accumulation"])
		} else {
			this.sockets.inputs["enable_fp16_accumulation"].value = sources["enable_fp16_accumulation"]
		}

		if (typeof sources["attention_override"] === "object") {
			this.sockets.inputs["attention_override"].connectTo(sources["attention_override"])
		} else {
			this.sockets.inputs["attention_override"].value = sources["attention_override"]
		}

	}
}

type GGUFLoaderKJInputs = {
			"model_name": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			/** An extra gguf model to load and merge into the main model, for example VACE module*/
			"extra_model_name": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"dequant_dtype": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"patch_dtype": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
			"patch_on_device": ComfyNodeTypedInputRef<boolean>
			/** Enable torch.backends.cuda.matmul.allow_fp16_accumulation, required minimum pytorch version 2.7.1*/
			"enable_fp16_accumulation": ComfyNodeTypedInputRef<boolean>
			/** Overrides the used attention implementation, requires the respective library to be installed*/
			"attention_override": ComfyNodeTypedInputRef<ComfyValueType_COMBO>
}


export class CreateInstanceDiffusionTracking extends ComfyNode {
	classType: string = "CreateInstanceDiffusionTracking"

	sockets: {
		inputs: Required<CreateInstanceDiffusionTrackingInputs>
		outputs: {
			tracking: ComfyNodeTypedSourceRef<ComfyValueType_TRACKING>
			prompt: ComfyNodeTypedSourceRef<string>
			width: ComfyNodeTypedSourceRef<number>
			height: ComfyNodeTypedSourceRef<number>
			bbox_width: ComfyNodeTypedSourceRef<number>
			bbox_height: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"coordinates": new ComfyNodeTypedInputRef<string>(this, "coordinates"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"bbox_width": new ComfyNodeTypedInputRef<number>(this, "bbox_width"),
				"bbox_height": new ComfyNodeTypedInputRef<number>(this, "bbox_height"),
				"class_name": new ComfyNodeTypedInputRef<string>(this, "class_name"),
				"class_id": new ComfyNodeTypedInputRef<number>(this, "class_id"),
				"prompt": new ComfyNodeTypedInputRef<string>(this, "prompt"),
				"size_multiplier": new ComfyNodeTypedInputRef<number>(this, "size_multiplier"),
				"fit_in_frame": new ComfyNodeTypedInputRef<boolean>(this, "fit_in_frame"),
			},
			outputs: Object.create(Object.prototype, {
				"tracking": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"prompt": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
				"bbox_width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 4 }
					}
				},
				"bbox_height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 5 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateInstanceDiffusionTrackingInputs>) {
		if (typeof sources["coordinates"] === "object") {
			this.sockets.inputs["coordinates"].connectTo(sources["coordinates"])
		} else {
			this.sockets.inputs["coordinates"].value = sources["coordinates"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["bbox_width"] === "object") {
			this.sockets.inputs["bbox_width"].connectTo(sources["bbox_width"])
		} else {
			this.sockets.inputs["bbox_width"].value = sources["bbox_width"]
		}

		if (typeof sources["bbox_height"] === "object") {
			this.sockets.inputs["bbox_height"].connectTo(sources["bbox_height"])
		} else {
			this.sockets.inputs["bbox_height"].value = sources["bbox_height"]
		}

		if (typeof sources["class_name"] === "object") {
			this.sockets.inputs["class_name"].connectTo(sources["class_name"])
		} else {
			this.sockets.inputs["class_name"].value = sources["class_name"]
		}

		if (typeof sources["class_id"] === "object") {
			this.sockets.inputs["class_id"].connectTo(sources["class_id"])
		} else {
			this.sockets.inputs["class_id"].value = sources["class_id"]
		}

		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}

		if (sources["size_multiplier"] !== undefined) {
		if (typeof sources["size_multiplier"] === "object") {
			this.sockets.inputs["size_multiplier"].connectTo(sources["size_multiplier"])
		} else {
			this.sockets.inputs["size_multiplier"].value = sources["size_multiplier"]
		}
		}

		if (sources["fit_in_frame"] !== undefined) {
		if (typeof sources["fit_in_frame"] === "object") {
			this.sockets.inputs["fit_in_frame"].connectTo(sources["fit_in_frame"])
		} else {
			this.sockets.inputs["fit_in_frame"].value = sources["fit_in_frame"]
		}
		}

	}
}

type CreateInstanceDiffusionTrackingInputs = {
			"coordinates": ComfyNodeTypedInputRef<string>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
			"bbox_width": ComfyNodeTypedInputRef<number>
			"bbox_height": ComfyNodeTypedInputRef<number>
			"class_name": ComfyNodeTypedInputRef<string>
			"class_id": ComfyNodeTypedInputRef<number>
			"prompt": ComfyNodeTypedInputRef<string>
			"size_multiplier"?: ComfyNodeTypedInputRef<number>
			"fit_in_frame"?: ComfyNodeTypedInputRef<boolean>
}


export class AppendInstanceDiffusionTracking extends ComfyNode {
	classType: string = "AppendInstanceDiffusionTracking"

	sockets: {
		inputs: Required<AppendInstanceDiffusionTrackingInputs>
		outputs: {
			tracking: ComfyNodeTypedSourceRef<ComfyValueType_TRACKING>
			prompt: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"tracking_1": new ComfyNodeTypedInputRef<ComfyValueType_TRACKING>(this, "tracking_1"),
				"tracking_2": new ComfyNodeTypedInputRef<ComfyValueType_TRACKING>(this, "tracking_2"),
				"prompt_1": new ComfyNodeTypedInputRef<string>(this, "prompt_1"),
				"prompt_2": new ComfyNodeTypedInputRef<string>(this, "prompt_2"),
			},
			outputs: Object.create(Object.prototype, {
				"tracking": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"prompt": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<AppendInstanceDiffusionTrackingInputs>) {
		if (typeof sources["tracking_1"] === "object") {
			this.sockets.inputs["tracking_1"].connectTo(sources["tracking_1"])
		} else {
			this.sockets.inputs["tracking_1"].value = sources["tracking_1"]
		}

		if (typeof sources["tracking_2"] === "object") {
			this.sockets.inputs["tracking_2"].connectTo(sources["tracking_2"])
		} else {
			this.sockets.inputs["tracking_2"].value = sources["tracking_2"]
		}

		if (sources["prompt_1"] !== undefined) {
		if (typeof sources["prompt_1"] === "object") {
			this.sockets.inputs["prompt_1"].connectTo(sources["prompt_1"])
		} else {
			this.sockets.inputs["prompt_1"].value = sources["prompt_1"]
		}
		}

		if (sources["prompt_2"] !== undefined) {
		if (typeof sources["prompt_2"] === "object") {
			this.sockets.inputs["prompt_2"].connectTo(sources["prompt_2"])
		} else {
			this.sockets.inputs["prompt_2"].value = sources["prompt_2"]
		}
		}

	}
}

type AppendInstanceDiffusionTrackingInputs = {
			"tracking_1": ComfyNodeTypedInputRef<ComfyValueType_TRACKING>
			"tracking_2": ComfyNodeTypedInputRef<ComfyValueType_TRACKING>
			"prompt_1"?: ComfyNodeTypedInputRef<string>
			"prompt_2"?: ComfyNodeTypedInputRef<string>
}


export class DrawInstanceDiffusionTracking extends ComfyNode {
	classType: string = "DrawInstanceDiffusionTracking"

	sockets: {
		inputs: Required<DrawInstanceDiffusionTrackingInputs>
		outputs: {
			image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"tracking": new ComfyNodeTypedInputRef<ComfyValueType_TRACKING>(this, "tracking"),
				"box_line_width": new ComfyNodeTypedInputRef<number>(this, "box_line_width"),
				"draw_text": new ComfyNodeTypedInputRef<boolean>(this, "draw_text"),
				"font": new ComfyNodeTypedInputRef<string>(this, "font"),
				"font_size": new ComfyNodeTypedInputRef<number>(this, "font_size"),
			},
			outputs: Object.create(Object.prototype, {
				"image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DrawInstanceDiffusionTrackingInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["tracking"] === "object") {
			this.sockets.inputs["tracking"].connectTo(sources["tracking"])
		} else {
			this.sockets.inputs["tracking"].value = sources["tracking"]
		}

		if (typeof sources["box_line_width"] === "object") {
			this.sockets.inputs["box_line_width"].connectTo(sources["box_line_width"])
		} else {
			this.sockets.inputs["box_line_width"].value = sources["box_line_width"]
		}

		if (typeof sources["draw_text"] === "object") {
			this.sockets.inputs["draw_text"].connectTo(sources["draw_text"])
		} else {
			this.sockets.inputs["draw_text"].value = sources["draw_text"]
		}

		if (typeof sources["font"] === "object") {
			this.sockets.inputs["font"].connectTo(sources["font"])
		} else {
			this.sockets.inputs["font"].value = sources["font"]
		}

		if (typeof sources["font_size"] === "object") {
			this.sockets.inputs["font_size"].connectTo(sources["font_size"])
		} else {
			this.sockets.inputs["font_size"].value = sources["font_size"]
		}

	}
}

type DrawInstanceDiffusionTrackingInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"tracking": ComfyNodeTypedInputRef<ComfyValueType_TRACKING>
			"box_line_width": ComfyNodeTypedInputRef<number>
			"draw_text": ComfyNodeTypedInputRef<boolean>
			"font": ComfyNodeTypedInputRef<string>
			"font_size": ComfyNodeTypedInputRef<number>
}


export class LoraExtractKJ extends ComfyNode {
	classType: string = "LoraExtractKJ"

	sockets: {
		inputs: Required<LoraExtractKJInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"finetuned_model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "finetuned_model"),
				"original_model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "original_model"),
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"rank": new ComfyNodeTypedInputRef<number>(this, "rank"),
				"lora_type": new ComfyNodeTypedInputRef<string>(this, "lora_type"),
				"algorithm": new ComfyNodeTypedInputRef<string>(this, "algorithm"),
				"lowrank_iters": new ComfyNodeTypedInputRef<number>(this, "lowrank_iters"),
				"output_dtype": new ComfyNodeTypedInputRef<string>(this, "output_dtype"),
				"bias_diff": new ComfyNodeTypedInputRef<boolean>(this, "bias_diff"),
				"adaptive_param": new ComfyNodeTypedInputRef<number>(this, "adaptive_param"),
				"clamp_quantile": new ComfyNodeTypedInputRef<boolean>(this, "clamp_quantile"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<LoraExtractKJInputs>) {
		if (typeof sources["finetuned_model"] === "object") {
			this.sockets.inputs["finetuned_model"].connectTo(sources["finetuned_model"])
		} else {
			this.sockets.inputs["finetuned_model"].value = sources["finetuned_model"]
		}

		if (typeof sources["original_model"] === "object") {
			this.sockets.inputs["original_model"].connectTo(sources["original_model"])
		} else {
			this.sockets.inputs["original_model"].value = sources["original_model"]
		}

		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (typeof sources["rank"] === "object") {
			this.sockets.inputs["rank"].connectTo(sources["rank"])
		} else {
			this.sockets.inputs["rank"].value = sources["rank"]
		}

		if (typeof sources["lora_type"] === "object") {
			this.sockets.inputs["lora_type"].connectTo(sources["lora_type"])
		} else {
			this.sockets.inputs["lora_type"].value = sources["lora_type"]
		}

		if (typeof sources["algorithm"] === "object") {
			this.sockets.inputs["algorithm"].connectTo(sources["algorithm"])
		} else {
			this.sockets.inputs["algorithm"].value = sources["algorithm"]
		}

		if (typeof sources["lowrank_iters"] === "object") {
			this.sockets.inputs["lowrank_iters"].connectTo(sources["lowrank_iters"])
		} else {
			this.sockets.inputs["lowrank_iters"].value = sources["lowrank_iters"]
		}

		if (typeof sources["output_dtype"] === "object") {
			this.sockets.inputs["output_dtype"].connectTo(sources["output_dtype"])
		} else {
			this.sockets.inputs["output_dtype"].value = sources["output_dtype"]
		}

		if (typeof sources["bias_diff"] === "object") {
			this.sockets.inputs["bias_diff"].connectTo(sources["bias_diff"])
		} else {
			this.sockets.inputs["bias_diff"].value = sources["bias_diff"]
		}

		if (typeof sources["adaptive_param"] === "object") {
			this.sockets.inputs["adaptive_param"].connectTo(sources["adaptive_param"])
		} else {
			this.sockets.inputs["adaptive_param"].value = sources["adaptive_param"]
		}

		if (typeof sources["clamp_quantile"] === "object") {
			this.sockets.inputs["clamp_quantile"].connectTo(sources["clamp_quantile"])
		} else {
			this.sockets.inputs["clamp_quantile"].value = sources["clamp_quantile"]
		}

	}
}

type LoraExtractKJInputs = {
			"finetuned_model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"original_model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"filename_prefix": ComfyNodeTypedInputRef<string>
			/** The rank to use for standard LoRA, or maximum rank limit for adaptive methods.*/
			"rank": ComfyNodeTypedInputRef<number>
			"lora_type": ComfyNodeTypedInputRef<string>
			/** SVD algorithm to use, svd_lowrank is faster but less accurate.*/
			"algorithm": ComfyNodeTypedInputRef<string>
			/** The number of subspace iterations for lowrank SVD algorithm.*/
			"lowrank_iters": ComfyNodeTypedInputRef<number>
			"output_dtype": ComfyNodeTypedInputRef<string>
			"bias_diff": ComfyNodeTypedInputRef<boolean>
			/** For ratio mode, this is the ratio of the maximum singular value. For quantile mode, this is the quantile of the singular values. For fro mode, this is the Frobenius norm retention ratio.*/
			"adaptive_param": ComfyNodeTypedInputRef<number>
			"clamp_quantile": ComfyNodeTypedInputRef<boolean>
}


export class LoraReduceRankKJ extends ComfyNode {
	classType: string = "LoraReduceRankKJ"

	sockets: {
		inputs: Required<LoraReduceRankKJInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"lora_name": new ComfyNodeTypedInputRef<string>(this, "lora_name"),
				"new_rank": new ComfyNodeTypedInputRef<number>(this, "new_rank"),
				"dynamic_method": new ComfyNodeTypedInputRef<string>(this, "dynamic_method"),
				"dynamic_param": new ComfyNodeTypedInputRef<number>(this, "dynamic_param"),
				"output_dtype": new ComfyNodeTypedInputRef<string>(this, "output_dtype"),
				"verbose": new ComfyNodeTypedInputRef<boolean>(this, "verbose"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<LoraReduceRankKJInputs>) {
		if (typeof sources["lora_name"] === "object") {
			this.sockets.inputs["lora_name"].connectTo(sources["lora_name"])
		} else {
			this.sockets.inputs["lora_name"].value = sources["lora_name"]
		}

		if (typeof sources["new_rank"] === "object") {
			this.sockets.inputs["new_rank"].connectTo(sources["new_rank"])
		} else {
			this.sockets.inputs["new_rank"].value = sources["new_rank"]
		}

		if (typeof sources["dynamic_method"] === "object") {
			this.sockets.inputs["dynamic_method"].connectTo(sources["dynamic_method"])
		} else {
			this.sockets.inputs["dynamic_method"].value = sources["dynamic_method"]
		}

		if (typeof sources["dynamic_param"] === "object") {
			this.sockets.inputs["dynamic_param"].connectTo(sources["dynamic_param"])
		} else {
			this.sockets.inputs["dynamic_param"].value = sources["dynamic_param"]
		}

		if (typeof sources["output_dtype"] === "object") {
			this.sockets.inputs["output_dtype"].connectTo(sources["output_dtype"])
		} else {
			this.sockets.inputs["output_dtype"].value = sources["output_dtype"]
		}

		if (typeof sources["verbose"] === "object") {
			this.sockets.inputs["verbose"].connectTo(sources["verbose"])
		} else {
			this.sockets.inputs["verbose"].value = sources["verbose"]
		}

	}
}

type LoraReduceRankKJInputs = {
			/** The name of the LoRA.*/
			"lora_name": ComfyNodeTypedInputRef<string>
			/** The new rank to resize the LoRA. Acts as max rank when using dynamic_method.*/
			"new_rank": ComfyNodeTypedInputRef<number>
			/** Method to use for dynamically determining new alphas and dims*/
			"dynamic_method": ComfyNodeTypedInputRef<string>
			/** Method to use for dynamically determining new alphas and dims*/
			"dynamic_param": ComfyNodeTypedInputRef<number>
			/** Data type to save the LoRA as.*/
			"output_dtype": ComfyNodeTypedInputRef<string>
			"verbose": ComfyNodeTypedInputRef<boolean>
}


export class WanVideoDecode extends ComfyNode {
	classType: string = "WanVideoDecode"

	sockets: {
		inputs: Required<WanVideoDecodeInputs>
		outputs: {
			images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_WANVAE>(this, "vae"),
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"enable_vae_tiling": new ComfyNodeTypedInputRef<boolean>(this, "enable_vae_tiling"),
				"tile_x": new ComfyNodeTypedInputRef<number>(this, "tile_x"),
				"tile_y": new ComfyNodeTypedInputRef<number>(this, "tile_y"),
				"tile_stride_x": new ComfyNodeTypedInputRef<number>(this, "tile_stride_x"),
				"tile_stride_y": new ComfyNodeTypedInputRef<number>(this, "tile_stride_y"),
				"normalization": new ComfyNodeTypedInputRef<string>(this, "normalization"),
			},
			outputs: Object.create(Object.prototype, {
				"images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoDecodeInputs>) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["enable_vae_tiling"] === "object") {
			this.sockets.inputs["enable_vae_tiling"].connectTo(sources["enable_vae_tiling"])
		} else {
			this.sockets.inputs["enable_vae_tiling"].value = sources["enable_vae_tiling"]
		}

		if (typeof sources["tile_x"] === "object") {
			this.sockets.inputs["tile_x"].connectTo(sources["tile_x"])
		} else {
			this.sockets.inputs["tile_x"].value = sources["tile_x"]
		}

		if (typeof sources["tile_y"] === "object") {
			this.sockets.inputs["tile_y"].connectTo(sources["tile_y"])
		} else {
			this.sockets.inputs["tile_y"].value = sources["tile_y"]
		}

		if (typeof sources["tile_stride_x"] === "object") {
			this.sockets.inputs["tile_stride_x"].connectTo(sources["tile_stride_x"])
		} else {
			this.sockets.inputs["tile_stride_x"].value = sources["tile_stride_x"]
		}

		if (typeof sources["tile_stride_y"] === "object") {
			this.sockets.inputs["tile_stride_y"].connectTo(sources["tile_stride_y"])
		} else {
			this.sockets.inputs["tile_stride_y"].value = sources["tile_stride_y"]
		}

		if (sources["normalization"] !== undefined) {
		if (typeof sources["normalization"] === "object") {
			this.sockets.inputs["normalization"].connectTo(sources["normalization"])
		} else {
			this.sockets.inputs["normalization"].value = sources["normalization"]
		}
		}

	}
}

type WanVideoDecodeInputs = {
			"vae": ComfyNodeTypedInputRef<ComfyValueType_WANVAE>
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** Drastically reduces memory use but will introduce seams at tile stride boundaries. The location and number of seams is dictated by the tile stride size. The visibility of seams can be controlled by increasing the tile size. Seams become less obvious at 1.5x stride and are barely noticeable at 2x stride size. Which is to say if you use a stride width of 160, the seams are barely noticeable with a tile width of 320.*/
			"enable_vae_tiling": ComfyNodeTypedInputRef<boolean>
			/** Tile width in pixels. Smaller values use less VRAM but will make seams more obvious.*/
			"tile_x": ComfyNodeTypedInputRef<number>
			/** Tile height in pixels. Smaller values use less VRAM but will make seams more obvious.*/
			"tile_y": ComfyNodeTypedInputRef<number>
			/** Tile stride width in pixels. Smaller values use less VRAM but will introduce more seams.*/
			"tile_stride_x": ComfyNodeTypedInputRef<number>
			/** Tile stride height in pixels. Smaller values use less VRAM but will introduce more seams.*/
			"tile_stride_y": ComfyNodeTypedInputRef<number>
			"normalization"?: ComfyNodeTypedInputRef<string>
}


export class WanVideoTextEncode extends ComfyNode {
	classType: string = "WanVideoTextEncode"

	sockets: {
		inputs: Required<WanVideoTextEncodeInputs>
		outputs: {
			text_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOTEXTEMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive_prompt": new ComfyNodeTypedInputRef<string>(this, "positive_prompt"),
				"negative_prompt": new ComfyNodeTypedInputRef<string>(this, "negative_prompt"),
				"t5": new ComfyNodeTypedInputRef<ComfyValueType_WANTEXTENCODER>(this, "t5"),
				"force_offload": new ComfyNodeTypedInputRef<boolean>(this, "force_offload"),
				"model_to_offload": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>(this, "model_to_offload"),
				"use_disk_cache": new ComfyNodeTypedInputRef<boolean>(this, "use_disk_cache"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"text_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoTextEncodeInputs>) {
		if (typeof sources["positive_prompt"] === "object") {
			this.sockets.inputs["positive_prompt"].connectTo(sources["positive_prompt"])
		} else {
			this.sockets.inputs["positive_prompt"].value = sources["positive_prompt"]
		}

		if (typeof sources["negative_prompt"] === "object") {
			this.sockets.inputs["negative_prompt"].connectTo(sources["negative_prompt"])
		} else {
			this.sockets.inputs["negative_prompt"].value = sources["negative_prompt"]
		}

		if (sources["t5"] !== undefined) {
		if (typeof sources["t5"] === "object") {
			this.sockets.inputs["t5"].connectTo(sources["t5"])
		} else {
			this.sockets.inputs["t5"].value = sources["t5"]
		}
		}

		if (sources["force_offload"] !== undefined) {
		if (typeof sources["force_offload"] === "object") {
			this.sockets.inputs["force_offload"].connectTo(sources["force_offload"])
		} else {
			this.sockets.inputs["force_offload"].value = sources["force_offload"]
		}
		}

		if (sources["model_to_offload"] !== undefined) {
		if (typeof sources["model_to_offload"] === "object") {
			this.sockets.inputs["model_to_offload"].connectTo(sources["model_to_offload"])
		} else {
			this.sockets.inputs["model_to_offload"].value = sources["model_to_offload"]
		}
		}

		if (sources["use_disk_cache"] !== undefined) {
		if (typeof sources["use_disk_cache"] === "object") {
			this.sockets.inputs["use_disk_cache"].connectTo(sources["use_disk_cache"])
		} else {
			this.sockets.inputs["use_disk_cache"].value = sources["use_disk_cache"]
		}
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type WanVideoTextEncodeInputs = {
			"positive_prompt": ComfyNodeTypedInputRef<string>
			"negative_prompt": ComfyNodeTypedInputRef<string>
			"t5"?: ComfyNodeTypedInputRef<ComfyValueType_WANTEXTENCODER>
			"force_offload"?: ComfyNodeTypedInputRef<boolean>
			/** Model to move to offload_device before encoding*/
			"model_to_offload"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>
			/** Cache the text embeddings to disk for faster re-use, under the custom_nodes/ComfyUI-WanVideoWrapper/text_embed_cache directory*/
			"use_disk_cache"?: ComfyNodeTypedInputRef<boolean>
			/** Device to run the text encoding on.*/
			"device"?: ComfyNodeTypedInputRef<string>
}


export class WanVideoTextEncodeSingle extends ComfyNode {
	classType: string = "WanVideoTextEncodeSingle"

	sockets: {
		inputs: Required<WanVideoTextEncodeSingleInputs>
		outputs: {
			text_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOTEXTEMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"prompt": new ComfyNodeTypedInputRef<string>(this, "prompt"),
				"t5": new ComfyNodeTypedInputRef<ComfyValueType_WANTEXTENCODER>(this, "t5"),
				"force_offload": new ComfyNodeTypedInputRef<boolean>(this, "force_offload"),
				"model_to_offload": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>(this, "model_to_offload"),
				"use_disk_cache": new ComfyNodeTypedInputRef<boolean>(this, "use_disk_cache"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"text_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoTextEncodeSingleInputs>) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}

		if (sources["t5"] !== undefined) {
		if (typeof sources["t5"] === "object") {
			this.sockets.inputs["t5"].connectTo(sources["t5"])
		} else {
			this.sockets.inputs["t5"].value = sources["t5"]
		}
		}

		if (sources["force_offload"] !== undefined) {
		if (typeof sources["force_offload"] === "object") {
			this.sockets.inputs["force_offload"].connectTo(sources["force_offload"])
		} else {
			this.sockets.inputs["force_offload"].value = sources["force_offload"]
		}
		}

		if (sources["model_to_offload"] !== undefined) {
		if (typeof sources["model_to_offload"] === "object") {
			this.sockets.inputs["model_to_offload"].connectTo(sources["model_to_offload"])
		} else {
			this.sockets.inputs["model_to_offload"].value = sources["model_to_offload"]
		}
		}

		if (sources["use_disk_cache"] !== undefined) {
		if (typeof sources["use_disk_cache"] === "object") {
			this.sockets.inputs["use_disk_cache"].connectTo(sources["use_disk_cache"])
		} else {
			this.sockets.inputs["use_disk_cache"].value = sources["use_disk_cache"]
		}
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type WanVideoTextEncodeSingleInputs = {
			"prompt": ComfyNodeTypedInputRef<string>
			"t5"?: ComfyNodeTypedInputRef<ComfyValueType_WANTEXTENCODER>
			"force_offload"?: ComfyNodeTypedInputRef<boolean>
			/** Model to move to offload_device before encoding*/
			"model_to_offload"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>
			/** Cache the text embeddings to disk for faster re-use, under the custom_nodes/ComfyUI-WanVideoWrapper/text_embed_cache directory*/
			"use_disk_cache"?: ComfyNodeTypedInputRef<boolean>
			/** Device to run the text encoding on.*/
			"device"?: ComfyNodeTypedInputRef<string>
}


export class WanVideoClipVisionEncode extends ComfyNode {
	classType: string = "WanVideoClipVisionEncode"

	sockets: {
		inputs: Required<WanVideoClipVisionEncodeInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_CLIPEMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_vision": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>(this, "clip_vision"),
				"image_1": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image_1"),
				"strength_1": new ComfyNodeTypedInputRef<number>(this, "strength_1"),
				"strength_2": new ComfyNodeTypedInputRef<number>(this, "strength_2"),
				"crop": new ComfyNodeTypedInputRef<string>(this, "crop"),
				"combine_embeds": new ComfyNodeTypedInputRef<string>(this, "combine_embeds"),
				"force_offload": new ComfyNodeTypedInputRef<boolean>(this, "force_offload"),
				"image_2": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image_2"),
				"negative_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "negative_image"),
				"tiles": new ComfyNodeTypedInputRef<number>(this, "tiles"),
				"ratio": new ComfyNodeTypedInputRef<number>(this, "ratio"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoClipVisionEncodeInputs>) {
		if (typeof sources["clip_vision"] === "object") {
			this.sockets.inputs["clip_vision"].connectTo(sources["clip_vision"])
		} else {
			this.sockets.inputs["clip_vision"].value = sources["clip_vision"]
		}

		if (typeof sources["image_1"] === "object") {
			this.sockets.inputs["image_1"].connectTo(sources["image_1"])
		} else {
			this.sockets.inputs["image_1"].value = sources["image_1"]
		}

		if (typeof sources["strength_1"] === "object") {
			this.sockets.inputs["strength_1"].connectTo(sources["strength_1"])
		} else {
			this.sockets.inputs["strength_1"].value = sources["strength_1"]
		}

		if (typeof sources["strength_2"] === "object") {
			this.sockets.inputs["strength_2"].connectTo(sources["strength_2"])
		} else {
			this.sockets.inputs["strength_2"].value = sources["strength_2"]
		}

		if (typeof sources["crop"] === "object") {
			this.sockets.inputs["crop"].connectTo(sources["crop"])
		} else {
			this.sockets.inputs["crop"].value = sources["crop"]
		}

		if (typeof sources["combine_embeds"] === "object") {
			this.sockets.inputs["combine_embeds"].connectTo(sources["combine_embeds"])
		} else {
			this.sockets.inputs["combine_embeds"].value = sources["combine_embeds"]
		}

		if (typeof sources["force_offload"] === "object") {
			this.sockets.inputs["force_offload"].connectTo(sources["force_offload"])
		} else {
			this.sockets.inputs["force_offload"].value = sources["force_offload"]
		}

		if (sources["image_2"] !== undefined) {
		if (typeof sources["image_2"] === "object") {
			this.sockets.inputs["image_2"].connectTo(sources["image_2"])
		} else {
			this.sockets.inputs["image_2"].value = sources["image_2"]
		}
		}

		if (sources["negative_image"] !== undefined) {
		if (typeof sources["negative_image"] === "object") {
			this.sockets.inputs["negative_image"].connectTo(sources["negative_image"])
		} else {
			this.sockets.inputs["negative_image"].value = sources["negative_image"]
		}
		}

		if (sources["tiles"] !== undefined) {
		if (typeof sources["tiles"] === "object") {
			this.sockets.inputs["tiles"].connectTo(sources["tiles"])
		} else {
			this.sockets.inputs["tiles"].value = sources["tiles"]
		}
		}

		if (sources["ratio"] !== undefined) {
		if (typeof sources["ratio"] === "object") {
			this.sockets.inputs["ratio"].connectTo(sources["ratio"])
		} else {
			this.sockets.inputs["ratio"].value = sources["ratio"]
		}
		}

	}
}

type WanVideoClipVisionEncodeInputs = {
			"clip_vision": ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>
			/** Image to encode*/
			"image_1": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Additional clip embed multiplier*/
			"strength_1": ComfyNodeTypedInputRef<number>
			/** Additional clip embed multiplier*/
			"strength_2": ComfyNodeTypedInputRef<number>
			/** Crop image to 224x224 before encoding*/
			"crop": ComfyNodeTypedInputRef<string>
			/** Method to combine multiple clip embeds*/
			"combine_embeds": ComfyNodeTypedInputRef<string>
			"force_offload": ComfyNodeTypedInputRef<boolean>
			"image_2"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** image to use for uncond*/
			"negative_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Use matteo's tiled image encoding for improved accuracy*/
			"tiles"?: ComfyNodeTypedInputRef<number>
			/** Ratio of the tile average*/
			"ratio"?: ComfyNodeTypedInputRef<number>
}


export class WanVideoImageToVideoEncode extends ComfyNode {
	classType: string = "WanVideoImageToVideoEncode"

	sockets: {
		inputs: Required<WanVideoImageToVideoEncodeInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"num_frames": new ComfyNodeTypedInputRef<number>(this, "num_frames"),
				"noise_aug_strength": new ComfyNodeTypedInputRef<number>(this, "noise_aug_strength"),
				"start_latent_strength": new ComfyNodeTypedInputRef<number>(this, "start_latent_strength"),
				"end_latent_strength": new ComfyNodeTypedInputRef<number>(this, "end_latent_strength"),
				"force_offload": new ComfyNodeTypedInputRef<boolean>(this, "force_offload"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_WANVAE>(this, "vae"),
				"clip_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_CLIPEMBEDS>(this, "clip_embeds"),
				"start_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "start_image"),
				"end_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "end_image"),
				"control_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>(this, "control_embeds"),
				"fun_or_fl2v_model": new ComfyNodeTypedInputRef<boolean>(this, "fun_or_fl2v_model"),
				"temporal_mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "temporal_mask"),
				"extra_latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "extra_latents"),
				"tiled_vae": new ComfyNodeTypedInputRef<boolean>(this, "tiled_vae"),
				"add_cond_latents": new ComfyNodeTypedInputRef<ComfyValueType_ADD_COND_LATENTS>(this, "add_cond_latents"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoImageToVideoEncodeInputs>) {
		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["num_frames"] === "object") {
			this.sockets.inputs["num_frames"].connectTo(sources["num_frames"])
		} else {
			this.sockets.inputs["num_frames"].value = sources["num_frames"]
		}

		if (typeof sources["noise_aug_strength"] === "object") {
			this.sockets.inputs["noise_aug_strength"].connectTo(sources["noise_aug_strength"])
		} else {
			this.sockets.inputs["noise_aug_strength"].value = sources["noise_aug_strength"]
		}

		if (typeof sources["start_latent_strength"] === "object") {
			this.sockets.inputs["start_latent_strength"].connectTo(sources["start_latent_strength"])
		} else {
			this.sockets.inputs["start_latent_strength"].value = sources["start_latent_strength"]
		}

		if (typeof sources["end_latent_strength"] === "object") {
			this.sockets.inputs["end_latent_strength"].connectTo(sources["end_latent_strength"])
		} else {
			this.sockets.inputs["end_latent_strength"].value = sources["end_latent_strength"]
		}

		if (typeof sources["force_offload"] === "object") {
			this.sockets.inputs["force_offload"].connectTo(sources["force_offload"])
		} else {
			this.sockets.inputs["force_offload"].value = sources["force_offload"]
		}

		if (sources["vae"] !== undefined) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}
		}

		if (sources["clip_embeds"] !== undefined) {
		if (typeof sources["clip_embeds"] === "object") {
			this.sockets.inputs["clip_embeds"].connectTo(sources["clip_embeds"])
		} else {
			this.sockets.inputs["clip_embeds"].value = sources["clip_embeds"]
		}
		}

		if (sources["start_image"] !== undefined) {
		if (typeof sources["start_image"] === "object") {
			this.sockets.inputs["start_image"].connectTo(sources["start_image"])
		} else {
			this.sockets.inputs["start_image"].value = sources["start_image"]
		}
		}

		if (sources["end_image"] !== undefined) {
		if (typeof sources["end_image"] === "object") {
			this.sockets.inputs["end_image"].connectTo(sources["end_image"])
		} else {
			this.sockets.inputs["end_image"].value = sources["end_image"]
		}
		}

		if (sources["control_embeds"] !== undefined) {
		if (typeof sources["control_embeds"] === "object") {
			this.sockets.inputs["control_embeds"].connectTo(sources["control_embeds"])
		} else {
			this.sockets.inputs["control_embeds"].value = sources["control_embeds"]
		}
		}

		if (sources["fun_or_fl2v_model"] !== undefined) {
		if (typeof sources["fun_or_fl2v_model"] === "object") {
			this.sockets.inputs["fun_or_fl2v_model"].connectTo(sources["fun_or_fl2v_model"])
		} else {
			this.sockets.inputs["fun_or_fl2v_model"].value = sources["fun_or_fl2v_model"]
		}
		}

		if (sources["temporal_mask"] !== undefined) {
		if (typeof sources["temporal_mask"] === "object") {
			this.sockets.inputs["temporal_mask"].connectTo(sources["temporal_mask"])
		} else {
			this.sockets.inputs["temporal_mask"].value = sources["temporal_mask"]
		}
		}

		if (sources["extra_latents"] !== undefined) {
		if (typeof sources["extra_latents"] === "object") {
			this.sockets.inputs["extra_latents"].connectTo(sources["extra_latents"])
		} else {
			this.sockets.inputs["extra_latents"].value = sources["extra_latents"]
		}
		}

		if (sources["tiled_vae"] !== undefined) {
		if (typeof sources["tiled_vae"] === "object") {
			this.sockets.inputs["tiled_vae"].connectTo(sources["tiled_vae"])
		} else {
			this.sockets.inputs["tiled_vae"].value = sources["tiled_vae"]
		}
		}

		if (sources["add_cond_latents"] !== undefined) {
		if (typeof sources["add_cond_latents"] === "object") {
			this.sockets.inputs["add_cond_latents"].connectTo(sources["add_cond_latents"])
		} else {
			this.sockets.inputs["add_cond_latents"].value = sources["add_cond_latents"]
		}
		}

	}
}

type WanVideoImageToVideoEncodeInputs = {
			/** Width of the image to encode*/
			"width": ComfyNodeTypedInputRef<number>
			/** Height of the image to encode*/
			"height": ComfyNodeTypedInputRef<number>
			/** Number of frames to encode*/
			"num_frames": ComfyNodeTypedInputRef<number>
			/** Strength of noise augmentation, helpful for I2V where some noise can add motion and give sharper results*/
			"noise_aug_strength": ComfyNodeTypedInputRef<number>
			/** Additional latent multiplier, helpful for I2V where lower values allow for more motion*/
			"start_latent_strength": ComfyNodeTypedInputRef<number>
			/** Additional latent multiplier, helpful for I2V where lower values allow for more motion*/
			"end_latent_strength": ComfyNodeTypedInputRef<number>
			"force_offload": ComfyNodeTypedInputRef<boolean>
			"vae"?: ComfyNodeTypedInputRef<ComfyValueType_WANVAE>
			/** Clip vision encoded image*/
			"clip_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_CLIPEMBEDS>
			/** Image to encode*/
			"start_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** end frame*/
			"end_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Control signal for the Fun -model*/
			"control_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			/** Enable when using official FLF2V or Fun model*/
			"fun_or_fl2v_model"?: ComfyNodeTypedInputRef<boolean>
			/** mask*/
			"temporal_mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
			/** Extra latents to add to the input front, used for Skyreels A2 reference images*/
			"extra_latents"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** Use tiled VAE encoding for reduced memory use*/
			"tiled_vae"?: ComfyNodeTypedInputRef<boolean>
			/** Additional cond latents WIP*/
			"add_cond_latents"?: ComfyNodeTypedInputRef<ComfyValueType_ADD_COND_LATENTS>
}


export class WanVideoEncode extends ComfyNode {
	classType: string = "WanVideoEncode"

	sockets: {
		inputs: Required<WanVideoEncodeInputs>
		outputs: {
			samples: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_WANVAE>(this, "vae"),
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"enable_vae_tiling": new ComfyNodeTypedInputRef<boolean>(this, "enable_vae_tiling"),
				"tile_x": new ComfyNodeTypedInputRef<number>(this, "tile_x"),
				"tile_y": new ComfyNodeTypedInputRef<number>(this, "tile_y"),
				"tile_stride_x": new ComfyNodeTypedInputRef<number>(this, "tile_stride_x"),
				"tile_stride_y": new ComfyNodeTypedInputRef<number>(this, "tile_stride_y"),
				"noise_aug_strength": new ComfyNodeTypedInputRef<number>(this, "noise_aug_strength"),
				"latent_strength": new ComfyNodeTypedInputRef<number>(this, "latent_strength"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
			},
			outputs: Object.create(Object.prototype, {
				"samples": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoEncodeInputs>) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["enable_vae_tiling"] === "object") {
			this.sockets.inputs["enable_vae_tiling"].connectTo(sources["enable_vae_tiling"])
		} else {
			this.sockets.inputs["enable_vae_tiling"].value = sources["enable_vae_tiling"]
		}

		if (typeof sources["tile_x"] === "object") {
			this.sockets.inputs["tile_x"].connectTo(sources["tile_x"])
		} else {
			this.sockets.inputs["tile_x"].value = sources["tile_x"]
		}

		if (typeof sources["tile_y"] === "object") {
			this.sockets.inputs["tile_y"].connectTo(sources["tile_y"])
		} else {
			this.sockets.inputs["tile_y"].value = sources["tile_y"]
		}

		if (typeof sources["tile_stride_x"] === "object") {
			this.sockets.inputs["tile_stride_x"].connectTo(sources["tile_stride_x"])
		} else {
			this.sockets.inputs["tile_stride_x"].value = sources["tile_stride_x"]
		}

		if (typeof sources["tile_stride_y"] === "object") {
			this.sockets.inputs["tile_stride_y"].connectTo(sources["tile_stride_y"])
		} else {
			this.sockets.inputs["tile_stride_y"].value = sources["tile_stride_y"]
		}

		if (sources["noise_aug_strength"] !== undefined) {
		if (typeof sources["noise_aug_strength"] === "object") {
			this.sockets.inputs["noise_aug_strength"].connectTo(sources["noise_aug_strength"])
		} else {
			this.sockets.inputs["noise_aug_strength"].value = sources["noise_aug_strength"]
		}
		}

		if (sources["latent_strength"] !== undefined) {
		if (typeof sources["latent_strength"] === "object") {
			this.sockets.inputs["latent_strength"].connectTo(sources["latent_strength"])
		} else {
			this.sockets.inputs["latent_strength"].value = sources["latent_strength"]
		}
		}

		if (sources["mask"] !== undefined) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}
		}

	}
}

type WanVideoEncodeInputs = {
			"vae": ComfyNodeTypedInputRef<ComfyValueType_WANVAE>
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Drastically reduces memory use but may introduce seams*/
			"enable_vae_tiling": ComfyNodeTypedInputRef<boolean>
			/** Tile size in pixels, smaller values use less VRAM, may introduce more seams*/
			"tile_x": ComfyNodeTypedInputRef<number>
			/** Tile size in pixels, smaller values use less VRAM, may introduce more seams*/
			"tile_y": ComfyNodeTypedInputRef<number>
			/** Tile stride in pixels, smaller values use less VRAM, may introduce more seams*/
			"tile_stride_x": ComfyNodeTypedInputRef<number>
			/** Tile stride in pixels, smaller values use less VRAM, may introduce more seams*/
			"tile_stride_y": ComfyNodeTypedInputRef<number>
			/** Strength of noise augmentation, helpful for leapfusion I2V where some noise can add motion and give sharper results*/
			"noise_aug_strength"?: ComfyNodeTypedInputRef<number>
			/** Additional latent multiplier, helpful for leapfusion I2V where lower values allow for more motion*/
			"latent_strength"?: ComfyNodeTypedInputRef<number>
			"mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class WanVideoEncodeLatentBatch extends ComfyNode {
	classType: string = "WanVideoEncodeLatentBatch"

	sockets: {
		inputs: Required<WanVideoEncodeLatentBatchInputs>
		outputs: {
			samples: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_WANVAE>(this, "vae"),
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"enable_vae_tiling": new ComfyNodeTypedInputRef<boolean>(this, "enable_vae_tiling"),
				"tile_x": new ComfyNodeTypedInputRef<number>(this, "tile_x"),
				"tile_y": new ComfyNodeTypedInputRef<number>(this, "tile_y"),
				"tile_stride_x": new ComfyNodeTypedInputRef<number>(this, "tile_stride_x"),
				"tile_stride_y": new ComfyNodeTypedInputRef<number>(this, "tile_stride_y"),
			},
			outputs: Object.create(Object.prototype, {
				"samples": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoEncodeLatentBatchInputs>) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["enable_vae_tiling"] === "object") {
			this.sockets.inputs["enable_vae_tiling"].connectTo(sources["enable_vae_tiling"])
		} else {
			this.sockets.inputs["enable_vae_tiling"].value = sources["enable_vae_tiling"]
		}

		if (typeof sources["tile_x"] === "object") {
			this.sockets.inputs["tile_x"].connectTo(sources["tile_x"])
		} else {
			this.sockets.inputs["tile_x"].value = sources["tile_x"]
		}

		if (typeof sources["tile_y"] === "object") {
			this.sockets.inputs["tile_y"].connectTo(sources["tile_y"])
		} else {
			this.sockets.inputs["tile_y"].value = sources["tile_y"]
		}

		if (typeof sources["tile_stride_x"] === "object") {
			this.sockets.inputs["tile_stride_x"].connectTo(sources["tile_stride_x"])
		} else {
			this.sockets.inputs["tile_stride_x"].value = sources["tile_stride_x"]
		}

		if (typeof sources["tile_stride_y"] === "object") {
			this.sockets.inputs["tile_stride_y"].connectTo(sources["tile_stride_y"])
		} else {
			this.sockets.inputs["tile_stride_y"].value = sources["tile_stride_y"]
		}

	}
}

type WanVideoEncodeLatentBatchInputs = {
			"vae": ComfyNodeTypedInputRef<ComfyValueType_WANVAE>
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Drastically reduces memory use but may introduce seams*/
			"enable_vae_tiling": ComfyNodeTypedInputRef<boolean>
			/** Tile size in pixels, smaller values use less VRAM, may introduce more seams*/
			"tile_x": ComfyNodeTypedInputRef<number>
			/** Tile size in pixels, smaller values use less VRAM, may introduce more seams*/
			"tile_y": ComfyNodeTypedInputRef<number>
			/** Tile stride in pixels, smaller values use less VRAM, may introduce more seams*/
			"tile_stride_x": ComfyNodeTypedInputRef<number>
			/** Tile stride in pixels, smaller values use less VRAM, may introduce more seams*/
			"tile_stride_y": ComfyNodeTypedInputRef<number>
}


export class WanVideoEmptyEmbeds extends ComfyNode {
	classType: string = "WanVideoEmptyEmbeds"

	sockets: {
		inputs: Required<WanVideoEmptyEmbedsInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"num_frames": new ComfyNodeTypedInputRef<number>(this, "num_frames"),
				"control_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>(this, "control_embeds"),
				"extra_latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "extra_latents"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoEmptyEmbedsInputs>) {
		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["num_frames"] === "object") {
			this.sockets.inputs["num_frames"].connectTo(sources["num_frames"])
		} else {
			this.sockets.inputs["num_frames"].value = sources["num_frames"]
		}

		if (sources["control_embeds"] !== undefined) {
		if (typeof sources["control_embeds"] === "object") {
			this.sockets.inputs["control_embeds"].connectTo(sources["control_embeds"])
		} else {
			this.sockets.inputs["control_embeds"].value = sources["control_embeds"]
		}
		}

		if (sources["extra_latents"] !== undefined) {
		if (typeof sources["extra_latents"] === "object") {
			this.sockets.inputs["extra_latents"].connectTo(sources["extra_latents"])
		} else {
			this.sockets.inputs["extra_latents"].value = sources["extra_latents"]
		}
		}

	}
}

type WanVideoEmptyEmbedsInputs = {
			/** Width of the image to encode*/
			"width": ComfyNodeTypedInputRef<number>
			/** Height of the image to encode*/
			"height": ComfyNodeTypedInputRef<number>
			/** Number of frames to encode*/
			"num_frames": ComfyNodeTypedInputRef<number>
			/** control signal for the Fun -model*/
			"control_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			/** First latent to use for the Pusa -model*/
			"extra_latents"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class WanVideoEnhanceAVideo extends ComfyNode {
	classType: string = "WanVideoEnhanceAVideo"

	sockets: {
		inputs: Required<WanVideoEnhanceAVideoInputs>
		outputs: {
			feta_args: ComfyNodeTypedSourceRef<ComfyValueType_FETAARGS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"weight": new ComfyNodeTypedInputRef<number>(this, "weight"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
			},
			outputs: Object.create(Object.prototype, {
				"feta_args": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoEnhanceAVideoInputs>) {
		if (typeof sources["weight"] === "object") {
			this.sockets.inputs["weight"].connectTo(sources["weight"])
		} else {
			this.sockets.inputs["weight"].value = sources["weight"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

	}
}

type WanVideoEnhanceAVideoInputs = {
			/** The feta Weight of the Enhance-A-Video*/
			"weight": ComfyNodeTypedInputRef<number>
			/** Start percentage of the steps to apply Enhance-A-Video*/
			"start_percent": ComfyNodeTypedInputRef<number>
			/** End percentage of the steps to apply Enhance-A-Video*/
			"end_percent": ComfyNodeTypedInputRef<number>
}


export class WanVideoContextOptions extends ComfyNode {
	classType: string = "WanVideoContextOptions"

	sockets: {
		inputs: Required<WanVideoContextOptionsInputs>
		outputs: {
			context_options: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDCONTEXT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"context_schedule": new ComfyNodeTypedInputRef<string>(this, "context_schedule"),
				"context_frames": new ComfyNodeTypedInputRef<number>(this, "context_frames"),
				"context_stride": new ComfyNodeTypedInputRef<number>(this, "context_stride"),
				"context_overlap": new ComfyNodeTypedInputRef<number>(this, "context_overlap"),
				"freenoise": new ComfyNodeTypedInputRef<boolean>(this, "freenoise"),
				"verbose": new ComfyNodeTypedInputRef<boolean>(this, "verbose"),
				"fuse_method": new ComfyNodeTypedInputRef<string>(this, "fuse_method"),
				"reference_latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "reference_latent"),
			},
			outputs: Object.create(Object.prototype, {
				"context_options": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoContextOptionsInputs>) {
		if (typeof sources["context_schedule"] === "object") {
			this.sockets.inputs["context_schedule"].connectTo(sources["context_schedule"])
		} else {
			this.sockets.inputs["context_schedule"].value = sources["context_schedule"]
		}

		if (typeof sources["context_frames"] === "object") {
			this.sockets.inputs["context_frames"].connectTo(sources["context_frames"])
		} else {
			this.sockets.inputs["context_frames"].value = sources["context_frames"]
		}

		if (typeof sources["context_stride"] === "object") {
			this.sockets.inputs["context_stride"].connectTo(sources["context_stride"])
		} else {
			this.sockets.inputs["context_stride"].value = sources["context_stride"]
		}

		if (typeof sources["context_overlap"] === "object") {
			this.sockets.inputs["context_overlap"].connectTo(sources["context_overlap"])
		} else {
			this.sockets.inputs["context_overlap"].value = sources["context_overlap"]
		}

		if (typeof sources["freenoise"] === "object") {
			this.sockets.inputs["freenoise"].connectTo(sources["freenoise"])
		} else {
			this.sockets.inputs["freenoise"].value = sources["freenoise"]
		}

		if (typeof sources["verbose"] === "object") {
			this.sockets.inputs["verbose"].connectTo(sources["verbose"])
		} else {
			this.sockets.inputs["verbose"].value = sources["verbose"]
		}

		if (sources["fuse_method"] !== undefined) {
		if (typeof sources["fuse_method"] === "object") {
			this.sockets.inputs["fuse_method"].connectTo(sources["fuse_method"])
		} else {
			this.sockets.inputs["fuse_method"].value = sources["fuse_method"]
		}
		}

		if (sources["reference_latent"] !== undefined) {
		if (typeof sources["reference_latent"] === "object") {
			this.sockets.inputs["reference_latent"].connectTo(sources["reference_latent"])
		} else {
			this.sockets.inputs["reference_latent"].value = sources["reference_latent"]
		}
		}

	}
}

type WanVideoContextOptionsInputs = {
			"context_schedule": ComfyNodeTypedInputRef<string>
			/** Number of pixel frames in the context, NOTE: the latent space has 4 frames in 1*/
			"context_frames": ComfyNodeTypedInputRef<number>
			/** Context stride as pixel frames, NOTE: the latent space has 4 frames in 1*/
			"context_stride": ComfyNodeTypedInputRef<number>
			/** Context overlap as pixel frames, NOTE: the latent space has 4 frames in 1*/
			"context_overlap": ComfyNodeTypedInputRef<number>
			/** Shuffle the noise*/
			"freenoise": ComfyNodeTypedInputRef<boolean>
			/** Print debug output*/
			"verbose": ComfyNodeTypedInputRef<boolean>
			/** Window weight function: linear=ramps at edges only, pyramid=triangular weights peaking in middle*/
			"fuse_method"?: ComfyNodeTypedInputRef<string>
			/** Image to be used as init for I2V models for windows where first frame is not the actual first frame. Mostly useful with MAGREF model*/
			"reference_latent"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class WanVideoTextEmbedBridge extends ComfyNode {
	classType: string = "WanVideoTextEmbedBridge"

	sockets: {
		inputs: Required<WanVideoTextEmbedBridgeInputs>
		outputs: {
			text_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOTEXTEMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "positive"),
				"negative": new ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>(this, "negative"),
			},
			outputs: Object.create(Object.prototype, {
				"text_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoTextEmbedBridgeInputs>) {
		if (typeof sources["positive"] === "object") {
			this.sockets.inputs["positive"].connectTo(sources["positive"])
		} else {
			this.sockets.inputs["positive"].value = sources["positive"]
		}

		if (sources["negative"] !== undefined) {
		if (typeof sources["negative"] === "object") {
			this.sockets.inputs["negative"].connectTo(sources["negative"])
		} else {
			this.sockets.inputs["negative"].value = sources["negative"]
		}
		}

	}
}

type WanVideoTextEmbedBridgeInputs = {
			"positive": ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
			"negative"?: ComfyNodeTypedInputRef<ComfyValueType_CONDITIONING>
}


export class WanVideoFlowEdit extends ComfyNode {
	classType: string = "WanVideoFlowEdit"

	sockets: {
		inputs: Required<WanVideoFlowEditInputs>
		outputs: {
			flowedit_args: ComfyNodeTypedSourceRef<ComfyValueType_FLOWEDITARGS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"source_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOTEXTEMBEDS>(this, "source_embeds"),
				"skip_steps": new ComfyNodeTypedInputRef<number>(this, "skip_steps"),
				"drift_steps": new ComfyNodeTypedInputRef<number>(this, "drift_steps"),
				"drift_flow_shift": new ComfyNodeTypedInputRef<number>(this, "drift_flow_shift"),
				"source_cfg": new ComfyNodeTypedInputRef<number>(this, "source_cfg"),
				"drift_cfg": new ComfyNodeTypedInputRef<number>(this, "drift_cfg"),
				"source_image_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>(this, "source_image_embeds"),
			},
			outputs: Object.create(Object.prototype, {
				"flowedit_args": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoFlowEditInputs>) {
		if (typeof sources["source_embeds"] === "object") {
			this.sockets.inputs["source_embeds"].connectTo(sources["source_embeds"])
		} else {
			this.sockets.inputs["source_embeds"].value = sources["source_embeds"]
		}

		if (typeof sources["skip_steps"] === "object") {
			this.sockets.inputs["skip_steps"].connectTo(sources["skip_steps"])
		} else {
			this.sockets.inputs["skip_steps"].value = sources["skip_steps"]
		}

		if (typeof sources["drift_steps"] === "object") {
			this.sockets.inputs["drift_steps"].connectTo(sources["drift_steps"])
		} else {
			this.sockets.inputs["drift_steps"].value = sources["drift_steps"]
		}

		if (typeof sources["drift_flow_shift"] === "object") {
			this.sockets.inputs["drift_flow_shift"].connectTo(sources["drift_flow_shift"])
		} else {
			this.sockets.inputs["drift_flow_shift"].value = sources["drift_flow_shift"]
		}

		if (typeof sources["source_cfg"] === "object") {
			this.sockets.inputs["source_cfg"].connectTo(sources["source_cfg"])
		} else {
			this.sockets.inputs["source_cfg"].value = sources["source_cfg"]
		}

		if (typeof sources["drift_cfg"] === "object") {
			this.sockets.inputs["drift_cfg"].connectTo(sources["drift_cfg"])
		} else {
			this.sockets.inputs["drift_cfg"].value = sources["drift_cfg"]
		}

		if (sources["source_image_embeds"] !== undefined) {
		if (typeof sources["source_image_embeds"] === "object") {
			this.sockets.inputs["source_image_embeds"].connectTo(sources["source_image_embeds"])
		} else {
			this.sockets.inputs["source_image_embeds"].value = sources["source_image_embeds"]
		}
		}

	}
}

type WanVideoFlowEditInputs = {
			"source_embeds": ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOTEXTEMBEDS>
			"skip_steps": ComfyNodeTypedInputRef<number>
			"drift_steps": ComfyNodeTypedInputRef<number>
			"drift_flow_shift": ComfyNodeTypedInputRef<number>
			"source_cfg": ComfyNodeTypedInputRef<number>
			"drift_cfg": ComfyNodeTypedInputRef<number>
			"source_image_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
}


export class WanVideoControlEmbeds extends ComfyNode {
	classType: string = "WanVideoControlEmbeds"

	sockets: {
		inputs: Required<WanVideoControlEmbedsInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
				"latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latents"),
				"fun_ref_image": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "fun_ref_image"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoControlEmbedsInputs>) {
		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

		if (typeof sources["latents"] === "object") {
			this.sockets.inputs["latents"].connectTo(sources["latents"])
		} else {
			this.sockets.inputs["latents"].value = sources["latents"]
		}

		if (sources["fun_ref_image"] !== undefined) {
		if (typeof sources["fun_ref_image"] === "object") {
			this.sockets.inputs["fun_ref_image"].connectTo(sources["fun_ref_image"])
		} else {
			this.sockets.inputs["fun_ref_image"].value = sources["fun_ref_image"]
		}
		}

	}
}

type WanVideoControlEmbedsInputs = {
			/** Start percent of the control signal*/
			"start_percent": ComfyNodeTypedInputRef<number>
			/** End percent of the control signal*/
			"end_percent": ComfyNodeTypedInputRef<number>
			/** Encoded latents to use as control signals*/
			"latents": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** Reference latent for the Fun 1.1 -model*/
			"fun_ref_image"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class WanVideoSLG extends ComfyNode {
	classType: string = "WanVideoSLG"

	sockets: {
		inputs: Required<WanVideoSLGInputs>
		outputs: {
			slg_args: ComfyNodeTypedSourceRef<ComfyValueType_SLGARGS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"blocks": new ComfyNodeTypedInputRef<string>(this, "blocks"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
			},
			outputs: Object.create(Object.prototype, {
				"slg_args": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoSLGInputs>) {
		if (typeof sources["blocks"] === "object") {
			this.sockets.inputs["blocks"].connectTo(sources["blocks"])
		} else {
			this.sockets.inputs["blocks"].value = sources["blocks"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

	}
}

type WanVideoSLGInputs = {
			/** Blocks to skip uncond on, separated by comma, index starts from 0*/
			"blocks": ComfyNodeTypedInputRef<string>
			/** Start percent of the control signal*/
			"start_percent": ComfyNodeTypedInputRef<number>
			/** End percent of the control signal*/
			"end_percent": ComfyNodeTypedInputRef<number>
}


export class WanVideoLoopArgs extends ComfyNode {
	classType: string = "WanVideoLoopArgs"

	sockets: {
		inputs: Required<WanVideoLoopArgsInputs>
		outputs: {
			loop_args: ComfyNodeTypedSourceRef<ComfyValueType_LOOPARGS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"shift_skip": new ComfyNodeTypedInputRef<number>(this, "shift_skip"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
			},
			outputs: Object.create(Object.prototype, {
				"loop_args": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoLoopArgsInputs>) {
		if (typeof sources["shift_skip"] === "object") {
			this.sockets.inputs["shift_skip"].connectTo(sources["shift_skip"])
		} else {
			this.sockets.inputs["shift_skip"].value = sources["shift_skip"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

	}
}

type WanVideoLoopArgsInputs = {
			/** Skip step of latent shift*/
			"shift_skip": ComfyNodeTypedInputRef<number>
			/** Start percent of the looping effect*/
			"start_percent": ComfyNodeTypedInputRef<number>
			/** End percent of the looping effect*/
			"end_percent": ComfyNodeTypedInputRef<number>
}


export class WanVideoSetBlockSwap extends ComfyNode {
	classType: string = "WanVideoSetBlockSwap"

	sockets: {
		inputs: Required<WanVideoSetBlockSwapInputs>
		outputs: {
			model: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOMODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>(this, "model"),
				"block_swap_args": new ComfyNodeTypedInputRef<ComfyValueType_BLOCKSWAPARGS>(this, "block_swap_args"),
			},
			outputs: Object.create(Object.prototype, {
				"model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoSetBlockSwapInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (sources["block_swap_args"] !== undefined) {
		if (typeof sources["block_swap_args"] === "object") {
			this.sockets.inputs["block_swap_args"].connectTo(sources["block_swap_args"])
		} else {
			this.sockets.inputs["block_swap_args"].value = sources["block_swap_args"]
		}
		}

	}
}

type WanVideoSetBlockSwapInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>
			"block_swap_args"?: ComfyNodeTypedInputRef<ComfyValueType_BLOCKSWAPARGS>
}


export class WanVideoExperimentalArgs extends ComfyNode {
	classType: string = "WanVideoExperimentalArgs"

	sockets: {
		inputs: Required<WanVideoExperimentalArgsInputs>
		outputs: {
			exp_args: ComfyNodeTypedSourceRef<ComfyValueType_EXPERIMENTALARGS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"video_attention_split_steps": new ComfyNodeTypedInputRef<string>(this, "video_attention_split_steps"),
				"cfg_zero_star": new ComfyNodeTypedInputRef<boolean>(this, "cfg_zero_star"),
				"use_zero_init": new ComfyNodeTypedInputRef<boolean>(this, "use_zero_init"),
				"zero_star_steps": new ComfyNodeTypedInputRef<number>(this, "zero_star_steps"),
				"use_fresca": new ComfyNodeTypedInputRef<boolean>(this, "use_fresca"),
				"fresca_scale_low": new ComfyNodeTypedInputRef<number>(this, "fresca_scale_low"),
				"fresca_scale_high": new ComfyNodeTypedInputRef<number>(this, "fresca_scale_high"),
				"fresca_freq_cutoff": new ComfyNodeTypedInputRef<number>(this, "fresca_freq_cutoff"),
				"use_tcfg": new ComfyNodeTypedInputRef<boolean>(this, "use_tcfg"),
				"raag_alpha": new ComfyNodeTypedInputRef<number>(this, "raag_alpha"),
				"bidirectional_sampling": new ComfyNodeTypedInputRef<boolean>(this, "bidirectional_sampling"),
				"temporal_score_rescaling": new ComfyNodeTypedInputRef<boolean>(this, "temporal_score_rescaling"),
				"tsr_k": new ComfyNodeTypedInputRef<number>(this, "tsr_k"),
				"tsr_sigma": new ComfyNodeTypedInputRef<number>(this, "tsr_sigma"),
			},
			outputs: Object.create(Object.prototype, {
				"exp_args": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoExperimentalArgsInputs>) {
		if (typeof sources["video_attention_split_steps"] === "object") {
			this.sockets.inputs["video_attention_split_steps"].connectTo(sources["video_attention_split_steps"])
		} else {
			this.sockets.inputs["video_attention_split_steps"].value = sources["video_attention_split_steps"]
		}

		if (typeof sources["cfg_zero_star"] === "object") {
			this.sockets.inputs["cfg_zero_star"].connectTo(sources["cfg_zero_star"])
		} else {
			this.sockets.inputs["cfg_zero_star"].value = sources["cfg_zero_star"]
		}

		if (typeof sources["use_zero_init"] === "object") {
			this.sockets.inputs["use_zero_init"].connectTo(sources["use_zero_init"])
		} else {
			this.sockets.inputs["use_zero_init"].value = sources["use_zero_init"]
		}

		if (typeof sources["zero_star_steps"] === "object") {
			this.sockets.inputs["zero_star_steps"].connectTo(sources["zero_star_steps"])
		} else {
			this.sockets.inputs["zero_star_steps"].value = sources["zero_star_steps"]
		}

		if (typeof sources["use_fresca"] === "object") {
			this.sockets.inputs["use_fresca"].connectTo(sources["use_fresca"])
		} else {
			this.sockets.inputs["use_fresca"].value = sources["use_fresca"]
		}

		if (typeof sources["fresca_scale_low"] === "object") {
			this.sockets.inputs["fresca_scale_low"].connectTo(sources["fresca_scale_low"])
		} else {
			this.sockets.inputs["fresca_scale_low"].value = sources["fresca_scale_low"]
		}

		if (typeof sources["fresca_scale_high"] === "object") {
			this.sockets.inputs["fresca_scale_high"].connectTo(sources["fresca_scale_high"])
		} else {
			this.sockets.inputs["fresca_scale_high"].value = sources["fresca_scale_high"]
		}

		if (typeof sources["fresca_freq_cutoff"] === "object") {
			this.sockets.inputs["fresca_freq_cutoff"].connectTo(sources["fresca_freq_cutoff"])
		} else {
			this.sockets.inputs["fresca_freq_cutoff"].value = sources["fresca_freq_cutoff"]
		}

		if (typeof sources["use_tcfg"] === "object") {
			this.sockets.inputs["use_tcfg"].connectTo(sources["use_tcfg"])
		} else {
			this.sockets.inputs["use_tcfg"].value = sources["use_tcfg"]
		}

		if (typeof sources["raag_alpha"] === "object") {
			this.sockets.inputs["raag_alpha"].connectTo(sources["raag_alpha"])
		} else {
			this.sockets.inputs["raag_alpha"].value = sources["raag_alpha"]
		}

		if (typeof sources["bidirectional_sampling"] === "object") {
			this.sockets.inputs["bidirectional_sampling"].connectTo(sources["bidirectional_sampling"])
		} else {
			this.sockets.inputs["bidirectional_sampling"].value = sources["bidirectional_sampling"]
		}

		if (typeof sources["temporal_score_rescaling"] === "object") {
			this.sockets.inputs["temporal_score_rescaling"].connectTo(sources["temporal_score_rescaling"])
		} else {
			this.sockets.inputs["temporal_score_rescaling"].value = sources["temporal_score_rescaling"]
		}

		if (typeof sources["tsr_k"] === "object") {
			this.sockets.inputs["tsr_k"].connectTo(sources["tsr_k"])
		} else {
			this.sockets.inputs["tsr_k"].value = sources["tsr_k"]
		}

		if (typeof sources["tsr_sigma"] === "object") {
			this.sockets.inputs["tsr_sigma"].connectTo(sources["tsr_sigma"])
		} else {
			this.sockets.inputs["tsr_sigma"].value = sources["tsr_sigma"]
		}

	}
}

type WanVideoExperimentalArgsInputs = {
			/** Steps to split self attention when using multiple prompts*/
			"video_attention_split_steps": ComfyNodeTypedInputRef<string>
			/** https://github.com/WeichenFan/CFG-Zero-star*/
			"cfg_zero_star": ComfyNodeTypedInputRef<boolean>
			"use_zero_init": ComfyNodeTypedInputRef<boolean>
			/** Steps to split self attention when using multiple prompts*/
			"zero_star_steps": ComfyNodeTypedInputRef<number>
			/** https://github.com/WikiChao/FreSca*/
			"use_fresca": ComfyNodeTypedInputRef<boolean>
			"fresca_scale_low": ComfyNodeTypedInputRef<number>
			"fresca_scale_high": ComfyNodeTypedInputRef<number>
			"fresca_freq_cutoff": ComfyNodeTypedInputRef<number>
			/** https://arxiv.org/abs/2503.18137 TCFG: Tangential Damping Classifier-free Guidance. CFG artifacts reduction.*/
			"use_tcfg": ComfyNodeTypedInputRef<boolean>
			/** Alpha value for RAAG, 1.0 is default, 0.0 is disabled.*/
			"raag_alpha": ComfyNodeTypedInputRef<number>
			/** Enable bidirectional sampling, based on https://github.com/ff2416/WanFM*/
			"bidirectional_sampling": ComfyNodeTypedInputRef<boolean>
			/** Enable temporal score rescaling: https://github.com/temporalscorerescaling/TSR/*/
			"temporal_score_rescaling": ComfyNodeTypedInputRef<boolean>
			/** The sampling temperature*/
			"tsr_k": ComfyNodeTypedInputRef<number>
			/** How early TSR steer the sampling process*/
			"tsr_sigma": ComfyNodeTypedInputRef<number>
}


export class WanVideoVACEEncode extends ComfyNode {
	classType: string = "WanVideoVACEEncode"

	sockets: {
		inputs: Required<WanVideoVACEEncodeInputs>
		outputs: {
			vace_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_WANVAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"num_frames": new ComfyNodeTypedInputRef<number>(this, "num_frames"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"vace_start_percent": new ComfyNodeTypedInputRef<number>(this, "vace_start_percent"),
				"vace_end_percent": new ComfyNodeTypedInputRef<number>(this, "vace_end_percent"),
				"input_frames": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "input_frames"),
				"ref_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "ref_images"),
				"input_masks": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "input_masks"),
				"prev_vace_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>(this, "prev_vace_embeds"),
				"tiled_vae": new ComfyNodeTypedInputRef<boolean>(this, "tiled_vae"),
			},
			outputs: Object.create(Object.prototype, {
				"vace_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoVACEEncodeInputs>) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["num_frames"] === "object") {
			this.sockets.inputs["num_frames"].connectTo(sources["num_frames"])
		} else {
			this.sockets.inputs["num_frames"].value = sources["num_frames"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (typeof sources["vace_start_percent"] === "object") {
			this.sockets.inputs["vace_start_percent"].connectTo(sources["vace_start_percent"])
		} else {
			this.sockets.inputs["vace_start_percent"].value = sources["vace_start_percent"]
		}

		if (typeof sources["vace_end_percent"] === "object") {
			this.sockets.inputs["vace_end_percent"].connectTo(sources["vace_end_percent"])
		} else {
			this.sockets.inputs["vace_end_percent"].value = sources["vace_end_percent"]
		}

		if (sources["input_frames"] !== undefined) {
		if (typeof sources["input_frames"] === "object") {
			this.sockets.inputs["input_frames"].connectTo(sources["input_frames"])
		} else {
			this.sockets.inputs["input_frames"].value = sources["input_frames"]
		}
		}

		if (sources["ref_images"] !== undefined) {
		if (typeof sources["ref_images"] === "object") {
			this.sockets.inputs["ref_images"].connectTo(sources["ref_images"])
		} else {
			this.sockets.inputs["ref_images"].value = sources["ref_images"]
		}
		}

		if (sources["input_masks"] !== undefined) {
		if (typeof sources["input_masks"] === "object") {
			this.sockets.inputs["input_masks"].connectTo(sources["input_masks"])
		} else {
			this.sockets.inputs["input_masks"].value = sources["input_masks"]
		}
		}

		if (sources["prev_vace_embeds"] !== undefined) {
		if (typeof sources["prev_vace_embeds"] === "object") {
			this.sockets.inputs["prev_vace_embeds"].connectTo(sources["prev_vace_embeds"])
		} else {
			this.sockets.inputs["prev_vace_embeds"].value = sources["prev_vace_embeds"]
		}
		}

		if (sources["tiled_vae"] !== undefined) {
		if (typeof sources["tiled_vae"] === "object") {
			this.sockets.inputs["tiled_vae"].connectTo(sources["tiled_vae"])
		} else {
			this.sockets.inputs["tiled_vae"].value = sources["tiled_vae"]
		}
		}

	}
}

type WanVideoVACEEncodeInputs = {
			"vae": ComfyNodeTypedInputRef<ComfyValueType_WANVAE>
			/** Width of the image to encode*/
			"width": ComfyNodeTypedInputRef<number>
			/** Height of the image to encode*/
			"height": ComfyNodeTypedInputRef<number>
			/** Number of frames to encode*/
			"num_frames": ComfyNodeTypedInputRef<number>
			"strength": ComfyNodeTypedInputRef<number>
			/** Start percent of the steps to apply VACE*/
			"vace_start_percent": ComfyNodeTypedInputRef<number>
			/** End percent of the steps to apply VACE*/
			"vace_end_percent": ComfyNodeTypedInputRef<number>
			"input_frames"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"ref_images"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"input_masks"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"prev_vace_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			/** Use tiled VAE encoding for reduced memory use*/
			"tiled_vae"?: ComfyNodeTypedInputRef<boolean>
}


export class WanVideoPhantomEmbeds extends ComfyNode {
	classType: string = "WanVideoPhantomEmbeds"

	sockets: {
		inputs: Required<WanVideoPhantomEmbedsInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"num_frames": new ComfyNodeTypedInputRef<number>(this, "num_frames"),
				"phantom_latent_1": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "phantom_latent_1"),
				"phantom_cfg_scale": new ComfyNodeTypedInputRef<number>(this, "phantom_cfg_scale"),
				"phantom_start_percent": new ComfyNodeTypedInputRef<number>(this, "phantom_start_percent"),
				"phantom_end_percent": new ComfyNodeTypedInputRef<number>(this, "phantom_end_percent"),
				"phantom_latent_2": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "phantom_latent_2"),
				"phantom_latent_3": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "phantom_latent_3"),
				"phantom_latent_4": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "phantom_latent_4"),
				"vace_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>(this, "vace_embeds"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoPhantomEmbedsInputs>) {
		if (typeof sources["num_frames"] === "object") {
			this.sockets.inputs["num_frames"].connectTo(sources["num_frames"])
		} else {
			this.sockets.inputs["num_frames"].value = sources["num_frames"]
		}

		if (typeof sources["phantom_latent_1"] === "object") {
			this.sockets.inputs["phantom_latent_1"].connectTo(sources["phantom_latent_1"])
		} else {
			this.sockets.inputs["phantom_latent_1"].value = sources["phantom_latent_1"]
		}

		if (typeof sources["phantom_cfg_scale"] === "object") {
			this.sockets.inputs["phantom_cfg_scale"].connectTo(sources["phantom_cfg_scale"])
		} else {
			this.sockets.inputs["phantom_cfg_scale"].value = sources["phantom_cfg_scale"]
		}

		if (typeof sources["phantom_start_percent"] === "object") {
			this.sockets.inputs["phantom_start_percent"].connectTo(sources["phantom_start_percent"])
		} else {
			this.sockets.inputs["phantom_start_percent"].value = sources["phantom_start_percent"]
		}

		if (typeof sources["phantom_end_percent"] === "object") {
			this.sockets.inputs["phantom_end_percent"].connectTo(sources["phantom_end_percent"])
		} else {
			this.sockets.inputs["phantom_end_percent"].value = sources["phantom_end_percent"]
		}

		if (sources["phantom_latent_2"] !== undefined) {
		if (typeof sources["phantom_latent_2"] === "object") {
			this.sockets.inputs["phantom_latent_2"].connectTo(sources["phantom_latent_2"])
		} else {
			this.sockets.inputs["phantom_latent_2"].value = sources["phantom_latent_2"]
		}
		}

		if (sources["phantom_latent_3"] !== undefined) {
		if (typeof sources["phantom_latent_3"] === "object") {
			this.sockets.inputs["phantom_latent_3"].connectTo(sources["phantom_latent_3"])
		} else {
			this.sockets.inputs["phantom_latent_3"].value = sources["phantom_latent_3"]
		}
		}

		if (sources["phantom_latent_4"] !== undefined) {
		if (typeof sources["phantom_latent_4"] === "object") {
			this.sockets.inputs["phantom_latent_4"].connectTo(sources["phantom_latent_4"])
		} else {
			this.sockets.inputs["phantom_latent_4"].value = sources["phantom_latent_4"]
		}
		}

		if (sources["vace_embeds"] !== undefined) {
		if (typeof sources["vace_embeds"] === "object") {
			this.sockets.inputs["vace_embeds"].connectTo(sources["vace_embeds"])
		} else {
			this.sockets.inputs["vace_embeds"].value = sources["vace_embeds"]
		}
		}

	}
}

type WanVideoPhantomEmbedsInputs = {
			/** Number of frames to encode*/
			"num_frames": ComfyNodeTypedInputRef<number>
			/** reference latents for the phantom model*/
			"phantom_latent_1": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** CFG scale for the extra phantom cond pass*/
			"phantom_cfg_scale": ComfyNodeTypedInputRef<number>
			/** Start percent of the phantom model*/
			"phantom_start_percent": ComfyNodeTypedInputRef<number>
			/** End percent of the phantom model*/
			"phantom_end_percent": ComfyNodeTypedInputRef<number>
			/** reference latents for the phantom model*/
			"phantom_latent_2"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** reference latents for the phantom model*/
			"phantom_latent_3"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** reference latents for the phantom model*/
			"phantom_latent_4"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** VACE embeds*/
			"vace_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
}


export class WanVideoRealisDanceLatents extends ComfyNode {
	classType: string = "WanVideoRealisDanceLatents"

	sockets: {
		inputs: Required<WanVideoRealisDanceLatentsInputs>
		outputs: {
			add_cond_latents: ComfyNodeTypedSourceRef<ComfyValueType_ADD_COND_LATENTS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"ref_latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "ref_latent"),
				"pose_cond_start_percent": new ComfyNodeTypedInputRef<number>(this, "pose_cond_start_percent"),
				"pose_cond_end_percent": new ComfyNodeTypedInputRef<number>(this, "pose_cond_end_percent"),
				"smpl_latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "smpl_latent"),
				"hamer_latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "hamer_latent"),
			},
			outputs: Object.create(Object.prototype, {
				"add_cond_latents": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoRealisDanceLatentsInputs>) {
		if (typeof sources["ref_latent"] === "object") {
			this.sockets.inputs["ref_latent"].connectTo(sources["ref_latent"])
		} else {
			this.sockets.inputs["ref_latent"].value = sources["ref_latent"]
		}

		if (typeof sources["pose_cond_start_percent"] === "object") {
			this.sockets.inputs["pose_cond_start_percent"].connectTo(sources["pose_cond_start_percent"])
		} else {
			this.sockets.inputs["pose_cond_start_percent"].value = sources["pose_cond_start_percent"]
		}

		if (typeof sources["pose_cond_end_percent"] === "object") {
			this.sockets.inputs["pose_cond_end_percent"].connectTo(sources["pose_cond_end_percent"])
		} else {
			this.sockets.inputs["pose_cond_end_percent"].value = sources["pose_cond_end_percent"]
		}

		if (sources["smpl_latent"] !== undefined) {
		if (typeof sources["smpl_latent"] === "object") {
			this.sockets.inputs["smpl_latent"].connectTo(sources["smpl_latent"])
		} else {
			this.sockets.inputs["smpl_latent"].value = sources["smpl_latent"]
		}
		}

		if (sources["hamer_latent"] !== undefined) {
		if (typeof sources["hamer_latent"] === "object") {
			this.sockets.inputs["hamer_latent"].connectTo(sources["hamer_latent"])
		} else {
			this.sockets.inputs["hamer_latent"].value = sources["hamer_latent"]
		}
		}

	}
}

type WanVideoRealisDanceLatentsInputs = {
			/** Reference image to encode*/
			"ref_latent": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** Start percent of the SMPL model*/
			"pose_cond_start_percent": ComfyNodeTypedInputRef<number>
			/** End percent of the SMPL model*/
			"pose_cond_end_percent": ComfyNodeTypedInputRef<number>
			/** SMPL pose image to encode*/
			"smpl_latent"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** Hamer hand pose image to encode*/
			"hamer_latent"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class WanVideoApplyNAG extends ComfyNode {
	classType: string = "WanVideoApplyNAG"

	sockets: {
		inputs: Required<WanVideoApplyNAGInputs>
		outputs: {
			text_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOTEXTEMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"original_text_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOTEXTEMBEDS>(this, "original_text_embeds"),
				"nag_text_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOTEXTEMBEDS>(this, "nag_text_embeds"),
				"nag_scale": new ComfyNodeTypedInputRef<number>(this, "nag_scale"),
				"nag_tau": new ComfyNodeTypedInputRef<number>(this, "nag_tau"),
				"nag_alpha": new ComfyNodeTypedInputRef<number>(this, "nag_alpha"),
			},
			outputs: Object.create(Object.prototype, {
				"text_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoApplyNAGInputs>) {
		if (typeof sources["original_text_embeds"] === "object") {
			this.sockets.inputs["original_text_embeds"].connectTo(sources["original_text_embeds"])
		} else {
			this.sockets.inputs["original_text_embeds"].value = sources["original_text_embeds"]
		}

		if (typeof sources["nag_text_embeds"] === "object") {
			this.sockets.inputs["nag_text_embeds"].connectTo(sources["nag_text_embeds"])
		} else {
			this.sockets.inputs["nag_text_embeds"].value = sources["nag_text_embeds"]
		}

		if (typeof sources["nag_scale"] === "object") {
			this.sockets.inputs["nag_scale"].connectTo(sources["nag_scale"])
		} else {
			this.sockets.inputs["nag_scale"].value = sources["nag_scale"]
		}

		if (typeof sources["nag_tau"] === "object") {
			this.sockets.inputs["nag_tau"].connectTo(sources["nag_tau"])
		} else {
			this.sockets.inputs["nag_tau"].value = sources["nag_tau"]
		}

		if (typeof sources["nag_alpha"] === "object") {
			this.sockets.inputs["nag_alpha"].connectTo(sources["nag_alpha"])
		} else {
			this.sockets.inputs["nag_alpha"].value = sources["nag_alpha"]
		}

	}
}

type WanVideoApplyNAGInputs = {
			"original_text_embeds": ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOTEXTEMBEDS>
			"nag_text_embeds": ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOTEXTEMBEDS>
			"nag_scale": ComfyNodeTypedInputRef<number>
			"nag_tau": ComfyNodeTypedInputRef<number>
			"nag_alpha": ComfyNodeTypedInputRef<number>
}


export class WanVideoMiniMaxRemoverEmbeds extends ComfyNode {
	classType: string = "WanVideoMiniMaxRemoverEmbeds"

	sockets: {
		inputs: Required<WanVideoMiniMaxRemoverEmbedsInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"num_frames": new ComfyNodeTypedInputRef<number>(this, "num_frames"),
				"latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latents"),
				"mask_latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "mask_latents"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoMiniMaxRemoverEmbedsInputs>) {
		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["num_frames"] === "object") {
			this.sockets.inputs["num_frames"].connectTo(sources["num_frames"])
		} else {
			this.sockets.inputs["num_frames"].value = sources["num_frames"]
		}

		if (typeof sources["latents"] === "object") {
			this.sockets.inputs["latents"].connectTo(sources["latents"])
		} else {
			this.sockets.inputs["latents"].value = sources["latents"]
		}

		if (typeof sources["mask_latents"] === "object") {
			this.sockets.inputs["mask_latents"].connectTo(sources["mask_latents"])
		} else {
			this.sockets.inputs["mask_latents"].value = sources["mask_latents"]
		}

	}
}

type WanVideoMiniMaxRemoverEmbedsInputs = {
			/** Width of the image to encode*/
			"width": ComfyNodeTypedInputRef<number>
			/** Height of the image to encode*/
			"height": ComfyNodeTypedInputRef<number>
			/** Number of frames to encode*/
			"num_frames": ComfyNodeTypedInputRef<number>
			/** Encoded latents to use as control signals*/
			"latents": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** Encoded latents to use as mask*/
			"mask_latents": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class WanVideoFreeInitArgs extends ComfyNode {
	classType: string = "WanVideoFreeInitArgs"

	sockets: {
		inputs: Required<WanVideoFreeInitArgsInputs>
		outputs: {
			freeinit_args: ComfyNodeTypedSourceRef<ComfyValueType_FREEINITARGS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"freeinit_num_iters": new ComfyNodeTypedInputRef<number>(this, "freeinit_num_iters"),
				"freeinit_method": new ComfyNodeTypedInputRef<string>(this, "freeinit_method"),
				"freeinit_n": new ComfyNodeTypedInputRef<number>(this, "freeinit_n"),
				"freeinit_d_s": new ComfyNodeTypedInputRef<number>(this, "freeinit_d_s"),
				"freeinit_d_t": new ComfyNodeTypedInputRef<number>(this, "freeinit_d_t"),
			},
			outputs: Object.create(Object.prototype, {
				"freeinit_args": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoFreeInitArgsInputs>) {
		if (typeof sources["freeinit_num_iters"] === "object") {
			this.sockets.inputs["freeinit_num_iters"].connectTo(sources["freeinit_num_iters"])
		} else {
			this.sockets.inputs["freeinit_num_iters"].value = sources["freeinit_num_iters"]
		}

		if (typeof sources["freeinit_method"] === "object") {
			this.sockets.inputs["freeinit_method"].connectTo(sources["freeinit_method"])
		} else {
			this.sockets.inputs["freeinit_method"].value = sources["freeinit_method"]
		}

		if (typeof sources["freeinit_n"] === "object") {
			this.sockets.inputs["freeinit_n"].connectTo(sources["freeinit_n"])
		} else {
			this.sockets.inputs["freeinit_n"].value = sources["freeinit_n"]
		}

		if (typeof sources["freeinit_d_s"] === "object") {
			this.sockets.inputs["freeinit_d_s"].connectTo(sources["freeinit_d_s"])
		} else {
			this.sockets.inputs["freeinit_d_s"].value = sources["freeinit_d_s"]
		}

		if (typeof sources["freeinit_d_t"] === "object") {
			this.sockets.inputs["freeinit_d_t"].connectTo(sources["freeinit_d_t"])
		} else {
			this.sockets.inputs["freeinit_d_t"].value = sources["freeinit_d_t"]
		}

	}
}

type WanVideoFreeInitArgsInputs = {
			/** Number of FreeInit iterations*/
			"freeinit_num_iters": ComfyNodeTypedInputRef<number>
			/** Frequency filter type*/
			"freeinit_method": ComfyNodeTypedInputRef<string>
			/** Butterworth filter order (only for butterworth)*/
			"freeinit_n": ComfyNodeTypedInputRef<number>
			/** Spatial filter cutoff*/
			"freeinit_d_s": ComfyNodeTypedInputRef<number>
			/** Temporal filter cutoff*/
			"freeinit_d_t": ComfyNodeTypedInputRef<number>
}


export class WanVideoSetRadialAttention extends ComfyNode {
	classType: string = "WanVideoSetRadialAttention"

	sockets: {
		inputs: Required<WanVideoSetRadialAttentionInputs>
		outputs: {
			model: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOMODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>(this, "model"),
				"dense_attention_mode": new ComfyNodeTypedInputRef<string>(this, "dense_attention_mode"),
				"dense_blocks": new ComfyNodeTypedInputRef<number>(this, "dense_blocks"),
				"dense_vace_blocks": new ComfyNodeTypedInputRef<number>(this, "dense_vace_blocks"),
				"dense_timesteps": new ComfyNodeTypedInputRef<number>(this, "dense_timesteps"),
				"decay_factor": new ComfyNodeTypedInputRef<number>(this, "decay_factor"),
				"block_size": new ComfyNodeTypedInputRef<string>(this, "block_size"),
			},
			outputs: Object.create(Object.prototype, {
				"model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoSetRadialAttentionInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["dense_attention_mode"] === "object") {
			this.sockets.inputs["dense_attention_mode"].connectTo(sources["dense_attention_mode"])
		} else {
			this.sockets.inputs["dense_attention_mode"].value = sources["dense_attention_mode"]
		}

		if (typeof sources["dense_blocks"] === "object") {
			this.sockets.inputs["dense_blocks"].connectTo(sources["dense_blocks"])
		} else {
			this.sockets.inputs["dense_blocks"].value = sources["dense_blocks"]
		}

		if (typeof sources["dense_vace_blocks"] === "object") {
			this.sockets.inputs["dense_vace_blocks"].connectTo(sources["dense_vace_blocks"])
		} else {
			this.sockets.inputs["dense_vace_blocks"].value = sources["dense_vace_blocks"]
		}

		if (typeof sources["dense_timesteps"] === "object") {
			this.sockets.inputs["dense_timesteps"].connectTo(sources["dense_timesteps"])
		} else {
			this.sockets.inputs["dense_timesteps"].value = sources["dense_timesteps"]
		}

		if (typeof sources["decay_factor"] === "object") {
			this.sockets.inputs["decay_factor"].connectTo(sources["decay_factor"])
		} else {
			this.sockets.inputs["decay_factor"].value = sources["decay_factor"]
		}

		if (typeof sources["block_size"] === "object") {
			this.sockets.inputs["block_size"].connectTo(sources["block_size"])
		} else {
			this.sockets.inputs["block_size"].value = sources["block_size"]
		}

	}
}

type WanVideoSetRadialAttentionInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>
			/** The attention mode for dense attention*/
			"dense_attention_mode": ComfyNodeTypedInputRef<string>
			/** Number of blocks to apply normal attention to*/
			"dense_blocks": ComfyNodeTypedInputRef<number>
			/** Number of vace blocks to apply normal attention to*/
			"dense_vace_blocks": ComfyNodeTypedInputRef<number>
			/** The step to start applying sparse attention*/
			"dense_timesteps": ComfyNodeTypedInputRef<number>
			/** Controls how quickly the attention window shrinks as the distance between frames increases in the sparse attention mask.*/
			"decay_factor": ComfyNodeTypedInputRef<number>
			/** Radial attention block size, larger blocks are faster but restricts usable dimensions more.*/
			"block_size": ComfyNodeTypedInputRef<string>
}


export class WanVideoBlockList extends ComfyNode {
	classType: string = "WanVideoBlockList"

	sockets: {
		inputs: Required<WanVideoBlockListInputs>
		outputs: {
			block_list: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"blocks": new ComfyNodeTypedInputRef<string>(this, "blocks"),
			},
			outputs: Object.create(Object.prototype, {
				"block_list": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoBlockListInputs>) {
		if (typeof sources["blocks"] === "object") {
			this.sockets.inputs["blocks"].connectTo(sources["blocks"])
		} else {
			this.sockets.inputs["blocks"].value = sources["blocks"]
		}

	}
}

type WanVideoBlockListInputs = {
			"blocks": ComfyNodeTypedInputRef<string>
}


export class WanVideoTextEncodeCached extends ComfyNode {
	classType: string = "WanVideoTextEncodeCached"

	sockets: {
		inputs: Required<WanVideoTextEncodeCachedInputs>
		outputs: {
			/** The text embeddings for both prompts*/
			text_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOTEXTEMBEDS>
			/** The text embeddings for the negative prompt only (for NAG)*/
			negative_text_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOTEXTEMBEDS>
			/** Positive prompt to display prompt extender results*/
			positive_prompt: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_name": new ComfyNodeTypedInputRef<string>(this, "model_name"),
				"precision": new ComfyNodeTypedInputRef<string>(this, "precision"),
				"positive_prompt": new ComfyNodeTypedInputRef<string>(this, "positive_prompt"),
				"negative_prompt": new ComfyNodeTypedInputRef<string>(this, "negative_prompt"),
				"quantization": new ComfyNodeTypedInputRef<string>(this, "quantization"),
				"use_disk_cache": new ComfyNodeTypedInputRef<boolean>(this, "use_disk_cache"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
				"extender_args": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOPROMPTEXTENDER_ARGS>(this, "extender_args"),
			},
			outputs: Object.create(Object.prototype, {
				"text_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative_text_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"positive_prompt": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoTextEncodeCachedInputs>) {
		if (typeof sources["model_name"] === "object") {
			this.sockets.inputs["model_name"].connectTo(sources["model_name"])
		} else {
			this.sockets.inputs["model_name"].value = sources["model_name"]
		}

		if (typeof sources["precision"] === "object") {
			this.sockets.inputs["precision"].connectTo(sources["precision"])
		} else {
			this.sockets.inputs["precision"].value = sources["precision"]
		}

		if (typeof sources["positive_prompt"] === "object") {
			this.sockets.inputs["positive_prompt"].connectTo(sources["positive_prompt"])
		} else {
			this.sockets.inputs["positive_prompt"].value = sources["positive_prompt"]
		}

		if (typeof sources["negative_prompt"] === "object") {
			this.sockets.inputs["negative_prompt"].connectTo(sources["negative_prompt"])
		} else {
			this.sockets.inputs["negative_prompt"].value = sources["negative_prompt"]
		}

		if (typeof sources["quantization"] === "object") {
			this.sockets.inputs["quantization"].connectTo(sources["quantization"])
		} else {
			this.sockets.inputs["quantization"].value = sources["quantization"]
		}

		if (typeof sources["use_disk_cache"] === "object") {
			this.sockets.inputs["use_disk_cache"].connectTo(sources["use_disk_cache"])
		} else {
			this.sockets.inputs["use_disk_cache"].value = sources["use_disk_cache"]
		}

		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}

		if (sources["extender_args"] !== undefined) {
		if (typeof sources["extender_args"] === "object") {
			this.sockets.inputs["extender_args"].connectTo(sources["extender_args"])
		} else {
			this.sockets.inputs["extender_args"].value = sources["extender_args"]
		}
		}

	}
}

type WanVideoTextEncodeCachedInputs = {
			/** These models are loaded from 'ComfyUI/models/text_encoders'*/
			"model_name": ComfyNodeTypedInputRef<string>
			"precision": ComfyNodeTypedInputRef<string>
			"positive_prompt": ComfyNodeTypedInputRef<string>
			"negative_prompt": ComfyNodeTypedInputRef<string>
			/** optional quantization method*/
			"quantization": ComfyNodeTypedInputRef<string>
			/** Cache the text embeddings to disk for faster re-use, under the custom_nodes/ComfyUI-WanVideoWrapper/text_embed_cache directory*/
			"use_disk_cache": ComfyNodeTypedInputRef<boolean>
			/** Device to run the text encoding on.*/
			"device": ComfyNodeTypedInputRef<string>
			/** Use this node to extend the prompt with additional text.*/
			"extender_args"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOPROMPTEXTENDER_ARGS>
}


export class WanVideoAddExtraLatent extends ComfyNode {
	classType: string = "WanVideoAddExtraLatent"

	sockets: {
		inputs: Required<WanVideoAddExtraLatentInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>(this, "embeds"),
				"extra_latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "extra_latents"),
				"latent_index": new ComfyNodeTypedInputRef<number>(this, "latent_index"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoAddExtraLatentInputs>) {
		if (typeof sources["embeds"] === "object") {
			this.sockets.inputs["embeds"].connectTo(sources["embeds"])
		} else {
			this.sockets.inputs["embeds"].value = sources["embeds"]
		}

		if (typeof sources["extra_latents"] === "object") {
			this.sockets.inputs["extra_latents"].connectTo(sources["extra_latents"])
		} else {
			this.sockets.inputs["extra_latents"].value = sources["extra_latents"]
		}

		if (typeof sources["latent_index"] === "object") {
			this.sockets.inputs["latent_index"].connectTo(sources["latent_index"])
		} else {
			this.sockets.inputs["latent_index"].value = sources["latent_index"]
		}

	}
}

type WanVideoAddExtraLatentInputs = {
			"embeds": ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			"extra_latents": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** Index to insert the extra latents at in latent space*/
			"latent_index": ComfyNodeTypedInputRef<number>
}


export class WanVideoScheduler extends ComfyNode {
	classType: string = "WanVideoScheduler"

	sockets: {
		inputs: Required<WanVideoSchedulerInputs>
		outputs: {
			sigmas: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
			steps: ComfyNodeTypedSourceRef<number>
			shift: ComfyNodeTypedSourceRef<number>
			start_step: ComfyNodeTypedSourceRef<number>
			end_step: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"scheduler": new ComfyNodeTypedInputRef<string>(this, "scheduler"),
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"shift": new ComfyNodeTypedInputRef<number>(this, "shift"),
				"start_step": new ComfyNodeTypedInputRef<number>(this, "start_step"),
				"end_step": new ComfyNodeTypedInputRef<number>(this, "end_step"),
				"sigmas": new ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>(this, "sigmas"),
				"unique_id": new ComfyNodeTypedInputRef<ComfyValueType_U>(this, "unique_id"),
			},
			outputs: Object.create(Object.prototype, {
				"sigmas": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"steps": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"shift": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"scheduler": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
				"start_step": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 4 }
					}
				},
				"end_step": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 5 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoSchedulerInputs>) {
		if (typeof sources["scheduler"] === "object") {
			this.sockets.inputs["scheduler"].connectTo(sources["scheduler"])
		} else {
			this.sockets.inputs["scheduler"].value = sources["scheduler"]
		}

		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["shift"] === "object") {
			this.sockets.inputs["shift"].connectTo(sources["shift"])
		} else {
			this.sockets.inputs["shift"].value = sources["shift"]
		}

		if (typeof sources["start_step"] === "object") {
			this.sockets.inputs["start_step"].connectTo(sources["start_step"])
		} else {
			this.sockets.inputs["start_step"].value = sources["start_step"]
		}

		if (typeof sources["end_step"] === "object") {
			this.sockets.inputs["end_step"].connectTo(sources["end_step"])
		} else {
			this.sockets.inputs["end_step"].value = sources["end_step"]
		}

		if (sources["sigmas"] !== undefined) {
		if (typeof sources["sigmas"] === "object") {
			this.sockets.inputs["sigmas"].connectTo(sources["sigmas"])
		} else {
			this.sockets.inputs["sigmas"].value = sources["sigmas"]
		}
		}

		if (sources["unique_id"] !== undefined) {
		if (typeof sources["unique_id"] === "object") {
			this.sockets.inputs["unique_id"].connectTo(sources["unique_id"])
		} else {
			this.sockets.inputs["unique_id"].value = sources["unique_id"]
		}
		}

	}
}

type WanVideoSchedulerInputs = {
			"scheduler": ComfyNodeTypedInputRef<string>
			/** Number of steps for the scheduler*/
			"steps": ComfyNodeTypedInputRef<number>
			"shift": ComfyNodeTypedInputRef<number>
			/** Starting step for the scheduler*/
			"start_step": ComfyNodeTypedInputRef<number>
			/** Ending step for the scheduler*/
			"end_step": ComfyNodeTypedInputRef<number>
			"sigmas"?: ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>
			"unique_id"?: ComfyNodeTypedInputRef<ComfyValueType_U>
}


export class WanVideoAddStandInLatent extends ComfyNode {
	classType: string = "WanVideoAddStandInLatent"

	sockets: {
		inputs: Required<WanVideoAddStandInLatentInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>(this, "embeds"),
				"ip_image_latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "ip_image_latent"),
				"freq_offset": new ComfyNodeTypedInputRef<number>(this, "freq_offset"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoAddStandInLatentInputs>) {
		if (typeof sources["embeds"] === "object") {
			this.sockets.inputs["embeds"].connectTo(sources["embeds"])
		} else {
			this.sockets.inputs["embeds"].value = sources["embeds"]
		}

		if (typeof sources["ip_image_latent"] === "object") {
			this.sockets.inputs["ip_image_latent"].connectTo(sources["ip_image_latent"])
		} else {
			this.sockets.inputs["ip_image_latent"].value = sources["ip_image_latent"]
		}

		if (typeof sources["freq_offset"] === "object") {
			this.sockets.inputs["freq_offset"].connectTo(sources["freq_offset"])
		} else {
			this.sockets.inputs["freq_offset"].value = sources["freq_offset"]
		}

	}
}

type WanVideoAddStandInLatentInputs = {
			"embeds": ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			/** Reference image to encode*/
			"ip_image_latent": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** EXPERIMENTAL: RoPE frequency offset between the reference and rest of the sequence*/
			"freq_offset": ComfyNodeTypedInputRef<number>
}


export class WanVideoAddControlEmbeds extends ComfyNode {
	classType: string = "WanVideoAddControlEmbeds"

	sockets: {
		inputs: Required<WanVideoAddControlEmbedsInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>(this, "embeds"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
				"latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latents"),
				"fun_ref_image": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "fun_ref_image"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoAddControlEmbedsInputs>) {
		if (typeof sources["embeds"] === "object") {
			this.sockets.inputs["embeds"].connectTo(sources["embeds"])
		} else {
			this.sockets.inputs["embeds"].value = sources["embeds"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

		if (sources["latents"] !== undefined) {
		if (typeof sources["latents"] === "object") {
			this.sockets.inputs["latents"].connectTo(sources["latents"])
		} else {
			this.sockets.inputs["latents"].value = sources["latents"]
		}
		}

		if (sources["fun_ref_image"] !== undefined) {
		if (typeof sources["fun_ref_image"] === "object") {
			this.sockets.inputs["fun_ref_image"].connectTo(sources["fun_ref_image"])
		} else {
			this.sockets.inputs["fun_ref_image"].value = sources["fun_ref_image"]
		}
		}

	}
}

type WanVideoAddControlEmbedsInputs = {
			"embeds": ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			/** Start percent of the control signal*/
			"start_percent": ComfyNodeTypedInputRef<number>
			/** End percent of the control signal*/
			"end_percent": ComfyNodeTypedInputRef<number>
			/** Encoded latents to use as control signals*/
			"latents"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** Reference latent for the Fun 1.1 -model*/
			"fun_ref_image"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class WanVideoAddMTVMotion extends ComfyNode {
	classType: string = "WanVideoAddMTVMotion"

	sockets: {
		inputs: Required<WanVideoAddMTVMotionInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>(this, "embeds"),
				"mtv_crafter_motion": new ComfyNodeTypedInputRef<ComfyValueType_MTVCRAFTERMOTION>(this, "mtv_crafter_motion"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoAddMTVMotionInputs>) {
		if (typeof sources["embeds"] === "object") {
			this.sockets.inputs["embeds"].connectTo(sources["embeds"])
		} else {
			this.sockets.inputs["embeds"].value = sources["embeds"]
		}

		if (typeof sources["mtv_crafter_motion"] === "object") {
			this.sockets.inputs["mtv_crafter_motion"].connectTo(sources["mtv_crafter_motion"])
		} else {
			this.sockets.inputs["mtv_crafter_motion"].value = sources["mtv_crafter_motion"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

	}
}

type WanVideoAddMTVMotionInputs = {
			"embeds": ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			"mtv_crafter_motion": ComfyNodeTypedInputRef<ComfyValueType_MTVCRAFTERMOTION>
			/** Strength of the MTV motion*/
			"strength": ComfyNodeTypedInputRef<number>
			/** Start percent to apply the ref */
			"start_percent": ComfyNodeTypedInputRef<number>
			/** End percent to apply the ref */
			"end_percent": ComfyNodeTypedInputRef<number>
}


export class WanVideoRoPEFunction extends ComfyNode {
	classType: string = "WanVideoRoPEFunction"

	sockets: {
		inputs: Required<WanVideoRoPEFunctionInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"rope_function": new ComfyNodeTypedInputRef<string>(this, "rope_function"),
				"ntk_scale_f": new ComfyNodeTypedInputRef<number>(this, "ntk_scale_f"),
				"ntk_scale_h": new ComfyNodeTypedInputRef<number>(this, "ntk_scale_h"),
				"ntk_scale_w": new ComfyNodeTypedInputRef<number>(this, "ntk_scale_w"),
			},
			outputs: Object.create(Object.prototype, {
				"rope_function": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoRoPEFunctionInputs>) {
		if (typeof sources["rope_function"] === "object") {
			this.sockets.inputs["rope_function"].connectTo(sources["rope_function"])
		} else {
			this.sockets.inputs["rope_function"].value = sources["rope_function"]
		}

		if (typeof sources["ntk_scale_f"] === "object") {
			this.sockets.inputs["ntk_scale_f"].connectTo(sources["ntk_scale_f"])
		} else {
			this.sockets.inputs["ntk_scale_f"].value = sources["ntk_scale_f"]
		}

		if (typeof sources["ntk_scale_h"] === "object") {
			this.sockets.inputs["ntk_scale_h"].connectTo(sources["ntk_scale_h"])
		} else {
			this.sockets.inputs["ntk_scale_h"].value = sources["ntk_scale_h"]
		}

		if (typeof sources["ntk_scale_w"] === "object") {
			this.sockets.inputs["ntk_scale_w"].connectTo(sources["ntk_scale_w"])
		} else {
			this.sockets.inputs["ntk_scale_w"].value = sources["ntk_scale_w"]
		}

	}
}

type WanVideoRoPEFunctionInputs = {
			"rope_function": ComfyNodeTypedInputRef<string>
			"ntk_scale_f": ComfyNodeTypedInputRef<number>
			"ntk_scale_h": ComfyNodeTypedInputRef<number>
			"ntk_scale_w": ComfyNodeTypedInputRef<number>
}


export class WanVideoAddPusaNoise extends ComfyNode {
	classType: string = "WanVideoAddPusaNoise"

	sockets: {
		inputs: Required<WanVideoAddPusaNoiseInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>(this, "embeds"),
				"noise_multipliers": new ComfyNodeTypedInputRef<number>(this, "noise_multipliers"),
				"noisy_steps": new ComfyNodeTypedInputRef<number>(this, "noisy_steps"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoAddPusaNoiseInputs>) {
		if (typeof sources["embeds"] === "object") {
			this.sockets.inputs["embeds"].connectTo(sources["embeds"])
		} else {
			this.sockets.inputs["embeds"].value = sources["embeds"]
		}

		if (typeof sources["noise_multipliers"] === "object") {
			this.sockets.inputs["noise_multipliers"].connectTo(sources["noise_multipliers"])
		} else {
			this.sockets.inputs["noise_multipliers"].value = sources["noise_multipliers"]
		}

		if (typeof sources["noisy_steps"] === "object") {
			this.sockets.inputs["noisy_steps"].connectTo(sources["noisy_steps"])
		} else {
			this.sockets.inputs["noisy_steps"].value = sources["noisy_steps"]
		}

	}
}

type WanVideoAddPusaNoiseInputs = {
			"embeds": ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			/** Noise multipliers for Pusa, can be a list of floats*/
			"noise_multipliers": ComfyNodeTypedInputRef<number>
			/** Number steps to apply the extra noise*/
			"noisy_steps": ComfyNodeTypedInputRef<number>
}


export class WanVideoAnimateEmbeds extends ComfyNode {
	classType: string = "WanVideoAnimateEmbeds"

	sockets: {
		inputs: Required<WanVideoAnimateEmbedsInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_WANVAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"num_frames": new ComfyNodeTypedInputRef<number>(this, "num_frames"),
				"force_offload": new ComfyNodeTypedInputRef<boolean>(this, "force_offload"),
				"frame_window_size": new ComfyNodeTypedInputRef<number>(this, "frame_window_size"),
				"colormatch": new ComfyNodeTypedInputRef<string>(this, "colormatch"),
				"pose_strength": new ComfyNodeTypedInputRef<number>(this, "pose_strength"),
				"face_strength": new ComfyNodeTypedInputRef<number>(this, "face_strength"),
				"clip_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_CLIPEMBEDS>(this, "clip_embeds"),
				"ref_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "ref_images"),
				"pose_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "pose_images"),
				"face_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "face_images"),
				"bg_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "bg_images"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"tiled_vae": new ComfyNodeTypedInputRef<boolean>(this, "tiled_vae"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoAnimateEmbedsInputs>) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["num_frames"] === "object") {
			this.sockets.inputs["num_frames"].connectTo(sources["num_frames"])
		} else {
			this.sockets.inputs["num_frames"].value = sources["num_frames"]
		}

		if (typeof sources["force_offload"] === "object") {
			this.sockets.inputs["force_offload"].connectTo(sources["force_offload"])
		} else {
			this.sockets.inputs["force_offload"].value = sources["force_offload"]
		}

		if (typeof sources["frame_window_size"] === "object") {
			this.sockets.inputs["frame_window_size"].connectTo(sources["frame_window_size"])
		} else {
			this.sockets.inputs["frame_window_size"].value = sources["frame_window_size"]
		}

		if (typeof sources["colormatch"] === "object") {
			this.sockets.inputs["colormatch"].connectTo(sources["colormatch"])
		} else {
			this.sockets.inputs["colormatch"].value = sources["colormatch"]
		}

		if (typeof sources["pose_strength"] === "object") {
			this.sockets.inputs["pose_strength"].connectTo(sources["pose_strength"])
		} else {
			this.sockets.inputs["pose_strength"].value = sources["pose_strength"]
		}

		if (typeof sources["face_strength"] === "object") {
			this.sockets.inputs["face_strength"].connectTo(sources["face_strength"])
		} else {
			this.sockets.inputs["face_strength"].value = sources["face_strength"]
		}

		if (sources["clip_embeds"] !== undefined) {
		if (typeof sources["clip_embeds"] === "object") {
			this.sockets.inputs["clip_embeds"].connectTo(sources["clip_embeds"])
		} else {
			this.sockets.inputs["clip_embeds"].value = sources["clip_embeds"]
		}
		}

		if (sources["ref_images"] !== undefined) {
		if (typeof sources["ref_images"] === "object") {
			this.sockets.inputs["ref_images"].connectTo(sources["ref_images"])
		} else {
			this.sockets.inputs["ref_images"].value = sources["ref_images"]
		}
		}

		if (sources["pose_images"] !== undefined) {
		if (typeof sources["pose_images"] === "object") {
			this.sockets.inputs["pose_images"].connectTo(sources["pose_images"])
		} else {
			this.sockets.inputs["pose_images"].value = sources["pose_images"]
		}
		}

		if (sources["face_images"] !== undefined) {
		if (typeof sources["face_images"] === "object") {
			this.sockets.inputs["face_images"].connectTo(sources["face_images"])
		} else {
			this.sockets.inputs["face_images"].value = sources["face_images"]
		}
		}

		if (sources["bg_images"] !== undefined) {
		if (typeof sources["bg_images"] === "object") {
			this.sockets.inputs["bg_images"].connectTo(sources["bg_images"])
		} else {
			this.sockets.inputs["bg_images"].value = sources["bg_images"]
		}
		}

		if (sources["mask"] !== undefined) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}
		}

		if (sources["tiled_vae"] !== undefined) {
		if (typeof sources["tiled_vae"] === "object") {
			this.sockets.inputs["tiled_vae"].connectTo(sources["tiled_vae"])
		} else {
			this.sockets.inputs["tiled_vae"].value = sources["tiled_vae"]
		}
		}

	}
}

type WanVideoAnimateEmbedsInputs = {
			"vae": ComfyNodeTypedInputRef<ComfyValueType_WANVAE>
			/** Width of the image to encode*/
			"width": ComfyNodeTypedInputRef<number>
			/** Height of the image to encode*/
			"height": ComfyNodeTypedInputRef<number>
			/** Number of frames to encode*/
			"num_frames": ComfyNodeTypedInputRef<number>
			"force_offload": ComfyNodeTypedInputRef<boolean>
			/** Number of frames to use for temporal attention window*/
			"frame_window_size": ComfyNodeTypedInputRef<number>
			/** Color matching method to use between the windows*/
			"colormatch": ComfyNodeTypedInputRef<string>
			/** Additional multiplier for the pose*/
			"pose_strength": ComfyNodeTypedInputRef<number>
			/** Additional multiplier for the face*/
			"face_strength": ComfyNodeTypedInputRef<number>
			/** Clip vision encoded image*/
			"clip_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_CLIPEMBEDS>
			/** Image to encode*/
			"ref_images"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** end frame*/
			"pose_images"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** end frame*/
			"face_images"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** background images*/
			"bg_images"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** mask*/
			"mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
			/** Use tiled VAE encoding for reduced memory use*/
			"tiled_vae"?: ComfyNodeTypedInputRef<boolean>
}


export class WanVideoAddLucyEditLatents extends ComfyNode {
	classType: string = "WanVideoAddLucyEditLatents"

	sockets: {
		inputs: Required<WanVideoAddLucyEditLatentsInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>(this, "embeds"),
				"extra_latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "extra_latents"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoAddLucyEditLatentsInputs>) {
		if (typeof sources["embeds"] === "object") {
			this.sockets.inputs["embeds"].connectTo(sources["embeds"])
		} else {
			this.sockets.inputs["embeds"].value = sources["embeds"]
		}

		if (typeof sources["extra_latents"] === "object") {
			this.sockets.inputs["extra_latents"].connectTo(sources["extra_latents"])
		} else {
			this.sockets.inputs["extra_latents"].value = sources["extra_latents"]
		}

	}
}

type WanVideoAddLucyEditLatentsInputs = {
			"embeds": ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			"extra_latents": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class WanVideoSchedulerSA_ODE extends ComfyNode {
	classType: string = "WanVideoSchedulerSA_ODE"

	sockets: {
		inputs: Required<WanVideoSchedulerSA_ODEInputs>
		outputs: {
			sigmas: ComfyNodeTypedSourceRef<ComfyValueType_SIGMAS>
			steps: ComfyNodeTypedSourceRef<number>
			shift: ComfyNodeTypedSourceRef<number>
			start_step: ComfyNodeTypedSourceRef<number>
			end_step: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"use_adaptive_order": new ComfyNodeTypedInputRef<boolean>(this, "use_adaptive_order"),
				"use_velocity_smoothing": new ComfyNodeTypedInputRef<boolean>(this, "use_velocity_smoothing"),
				"convergence_threshold": new ComfyNodeTypedInputRef<number>(this, "convergence_threshold"),
				"smoothing_factor": new ComfyNodeTypedInputRef<number>(this, "smoothing_factor"),
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"shift": new ComfyNodeTypedInputRef<number>(this, "shift"),
				"start_step": new ComfyNodeTypedInputRef<number>(this, "start_step"),
				"end_step": new ComfyNodeTypedInputRef<number>(this, "end_step"),
				"sigmas": new ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>(this, "sigmas"),
			},
			outputs: Object.create(Object.prototype, {
				"sigmas": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"steps": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"shift": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"scheduler": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
				"start_step": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 4 }
					}
				},
				"end_step": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 5 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoSchedulerSA_ODEInputs>) {
		if (typeof sources["use_adaptive_order"] === "object") {
			this.sockets.inputs["use_adaptive_order"].connectTo(sources["use_adaptive_order"])
		} else {
			this.sockets.inputs["use_adaptive_order"].value = sources["use_adaptive_order"]
		}

		if (typeof sources["use_velocity_smoothing"] === "object") {
			this.sockets.inputs["use_velocity_smoothing"].connectTo(sources["use_velocity_smoothing"])
		} else {
			this.sockets.inputs["use_velocity_smoothing"].value = sources["use_velocity_smoothing"]
		}

		if (typeof sources["convergence_threshold"] === "object") {
			this.sockets.inputs["convergence_threshold"].connectTo(sources["convergence_threshold"])
		} else {
			this.sockets.inputs["convergence_threshold"].value = sources["convergence_threshold"]
		}

		if (typeof sources["smoothing_factor"] === "object") {
			this.sockets.inputs["smoothing_factor"].connectTo(sources["smoothing_factor"])
		} else {
			this.sockets.inputs["smoothing_factor"].value = sources["smoothing_factor"]
		}

		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["shift"] === "object") {
			this.sockets.inputs["shift"].connectTo(sources["shift"])
		} else {
			this.sockets.inputs["shift"].value = sources["shift"]
		}

		if (typeof sources["start_step"] === "object") {
			this.sockets.inputs["start_step"].connectTo(sources["start_step"])
		} else {
			this.sockets.inputs["start_step"].value = sources["start_step"]
		}

		if (typeof sources["end_step"] === "object") {
			this.sockets.inputs["end_step"].connectTo(sources["end_step"])
		} else {
			this.sockets.inputs["end_step"].value = sources["end_step"]
		}

		if (sources["sigmas"] !== undefined) {
		if (typeof sources["sigmas"] === "object") {
			this.sockets.inputs["sigmas"].connectTo(sources["sigmas"])
		} else {
			this.sockets.inputs["sigmas"].value = sources["sigmas"]
		}
		}

	}
}

type WanVideoSchedulerSA_ODEInputs = {
			/** Use adaptive order*/
			"use_adaptive_order": ComfyNodeTypedInputRef<boolean>
			/** Use velocity smoothing*/
			"use_velocity_smoothing": ComfyNodeTypedInputRef<boolean>
			/** Convergence threshold for velocity smoothing*/
			"convergence_threshold": ComfyNodeTypedInputRef<number>
			/** Smoothing factor for velocity smoothing*/
			"smoothing_factor": ComfyNodeTypedInputRef<number>
			/** Number of steps for the scheduler*/
			"steps": ComfyNodeTypedInputRef<number>
			"shift": ComfyNodeTypedInputRef<number>
			/** Starting step for the scheduler*/
			"start_step": ComfyNodeTypedInputRef<number>
			/** Ending step for the scheduler*/
			"end_step": ComfyNodeTypedInputRef<number>
			"sigmas"?: ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>
}


export class WanVideoReCamMasterCameraEmbed extends ComfyNode {
	classType: string = "WanVideoReCamMasterCameraEmbed"

	sockets: {
		inputs: Required<WanVideoReCamMasterCameraEmbedInputs>
		outputs: {
			camera_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			camera_poses: ComfyNodeTypedSourceRef<ComfyValueType_CAMERAPOSES>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"camera_poses": new ComfyNodeTypedInputRef<ComfyValueType_CAMERAPOSES>(this, "camera_poses"),
				"latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latents"),
			},
			outputs: Object.create(Object.prototype, {
				"camera_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"camera_poses": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoReCamMasterCameraEmbedInputs>) {
		if (typeof sources["camera_poses"] === "object") {
			this.sockets.inputs["camera_poses"].connectTo(sources["camera_poses"])
		} else {
			this.sockets.inputs["camera_poses"].value = sources["camera_poses"]
		}

		if (typeof sources["latents"] === "object") {
			this.sockets.inputs["latents"].connectTo(sources["latents"])
		} else {
			this.sockets.inputs["latents"].value = sources["latents"]
		}

	}
}

type WanVideoReCamMasterCameraEmbedInputs = {
			"camera_poses": ComfyNodeTypedInputRef<ComfyValueType_CAMERAPOSES>
			/** source video*/
			"latents": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class ReCamMasterPoseVisualizer extends ComfyNode {
	classType: string = "ReCamMasterPoseVisualizer"

	sockets: {
		inputs: Required<ReCamMasterPoseVisualizerInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"camera_poses": new ComfyNodeTypedInputRef<ComfyValueType_CAMERAPOSES>(this, "camera_poses"),
				"base_xval": new ComfyNodeTypedInputRef<number>(this, "base_xval"),
				"zval": new ComfyNodeTypedInputRef<number>(this, "zval"),
				"scale": new ComfyNodeTypedInputRef<number>(this, "scale"),
				"arrow_length": new ComfyNodeTypedInputRef<number>(this, "arrow_length"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ReCamMasterPoseVisualizerInputs>) {
		if (typeof sources["camera_poses"] === "object") {
			this.sockets.inputs["camera_poses"].connectTo(sources["camera_poses"])
		} else {
			this.sockets.inputs["camera_poses"].value = sources["camera_poses"]
		}

		if (typeof sources["base_xval"] === "object") {
			this.sockets.inputs["base_xval"].connectTo(sources["base_xval"])
		} else {
			this.sockets.inputs["base_xval"].value = sources["base_xval"]
		}

		if (typeof sources["zval"] === "object") {
			this.sockets.inputs["zval"].connectTo(sources["zval"])
		} else {
			this.sockets.inputs["zval"].value = sources["zval"]
		}

		if (typeof sources["scale"] === "object") {
			this.sockets.inputs["scale"].connectTo(sources["scale"])
		} else {
			this.sockets.inputs["scale"].value = sources["scale"]
		}

		if (typeof sources["arrow_length"] === "object") {
			this.sockets.inputs["arrow_length"].connectTo(sources["arrow_length"])
		} else {
			this.sockets.inputs["arrow_length"].value = sources["arrow_length"]
		}

	}
}

type ReCamMasterPoseVisualizerInputs = {
			"camera_poses": ComfyNodeTypedInputRef<ComfyValueType_CAMERAPOSES>
			"base_xval": ComfyNodeTypedInputRef<number>
			"zval": ComfyNodeTypedInputRef<number>
			"scale": ComfyNodeTypedInputRef<number>
			"arrow_length": ComfyNodeTypedInputRef<number>
}


export class WanVideoReCamMasterGenerateOrbitCamera extends ComfyNode {
	classType: string = "WanVideoReCamMasterGenerateOrbitCamera"

	sockets: {
		inputs: Required<WanVideoReCamMasterGenerateOrbitCameraInputs>
		outputs: {
			camera_poses: ComfyNodeTypedSourceRef<ComfyValueType_CAMERAPOSES>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"num_frames": new ComfyNodeTypedInputRef<number>(this, "num_frames"),
				"degrees": new ComfyNodeTypedInputRef<number>(this, "degrees"),
			},
			outputs: Object.create(Object.prototype, {
				"camera_poses": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoReCamMasterGenerateOrbitCameraInputs>) {
		if (typeof sources["num_frames"] === "object") {
			this.sockets.inputs["num_frames"].connectTo(sources["num_frames"])
		} else {
			this.sockets.inputs["num_frames"].value = sources["num_frames"]
		}

		if (typeof sources["degrees"] === "object") {
			this.sockets.inputs["degrees"].connectTo(sources["degrees"])
		} else {
			this.sockets.inputs["degrees"].value = sources["degrees"]
		}

	}
}

type WanVideoReCamMasterGenerateOrbitCameraInputs = {
			/** Number of frames to generate*/
			"num_frames": ComfyNodeTypedInputRef<number>
			/** Degrees to orbit*/
			"degrees": ComfyNodeTypedInputRef<number>
}


export class WanVideoReCamMasterDefaultCamera extends ComfyNode {
	classType: string = "WanVideoReCamMasterDefaultCamera"

	sockets: {
		inputs: Required<WanVideoReCamMasterDefaultCameraInputs>
		outputs: {
			camera_poses: ComfyNodeTypedSourceRef<ComfyValueType_CAMERAPOSES>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"camera_type": new ComfyNodeTypedInputRef<string>(this, "camera_type"),
				"latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latents"),
			},
			outputs: Object.create(Object.prototype, {
				"camera_poses": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoReCamMasterDefaultCameraInputs>) {
		if (typeof sources["camera_type"] === "object") {
			this.sockets.inputs["camera_type"].connectTo(sources["camera_type"])
		} else {
			this.sockets.inputs["camera_type"].value = sources["camera_type"]
		}

		if (typeof sources["latents"] === "object") {
			this.sockets.inputs["latents"].connectTo(sources["latents"])
		} else {
			this.sockets.inputs["latents"].value = sources["latents"]
		}

	}
}

type WanVideoReCamMasterDefaultCameraInputs = {
			/** Camera type to use*/
			"camera_type": ComfyNodeTypedInputRef<string>
			/** source video*/
			"latents": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class WanVideoUniAnimatePoseInput extends ComfyNode {
	classType: string = "WanVideoUniAnimatePoseInput"

	sockets: {
		inputs: Required<WanVideoUniAnimatePoseInputInputs>
		outputs: {
			unianimate_poses: ComfyNodeTypedSourceRef<ComfyValueType_UNIANIMATE_POSE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"pose_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "pose_images"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
				"reference_pose_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "reference_pose_image"),
			},
			outputs: Object.create(Object.prototype, {
				"unianimate_poses": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoUniAnimatePoseInputInputs>) {
		if (typeof sources["pose_images"] === "object") {
			this.sockets.inputs["pose_images"].connectTo(sources["pose_images"])
		} else {
			this.sockets.inputs["pose_images"].value = sources["pose_images"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

		if (sources["reference_pose_image"] !== undefined) {
		if (typeof sources["reference_pose_image"] === "object") {
			this.sockets.inputs["reference_pose_image"].connectTo(sources["reference_pose_image"])
		} else {
			this.sockets.inputs["reference_pose_image"].value = sources["reference_pose_image"]
		}
		}

	}
}

type WanVideoUniAnimatePoseInputInputs = {
			/** Pose images*/
			"pose_images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Strength of the pose control*/
			"strength": ComfyNodeTypedInputRef<number>
			/** Start percentage for the pose control*/
			"start_percent": ComfyNodeTypedInputRef<number>
			/** End percentage for the pose control*/
			"end_percent": ComfyNodeTypedInputRef<number>
			/** Reference pose image*/
			"reference_pose_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class WanVideoUniAnimateDWPoseDetector extends ComfyNode {
	classType: string = "WanVideoUniAnimateDWPoseDetector"

	sockets: {
		inputs: Required<WanVideoUniAnimateDWPoseDetectorInputs>
		outputs: {
			poses: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			reference_pose: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"pose_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "pose_images"),
				"score_threshold": new ComfyNodeTypedInputRef<number>(this, "score_threshold"),
				"stick_width": new ComfyNodeTypedInputRef<number>(this, "stick_width"),
				"draw_body": new ComfyNodeTypedInputRef<boolean>(this, "draw_body"),
				"body_keypoint_size": new ComfyNodeTypedInputRef<number>(this, "body_keypoint_size"),
				"draw_feet": new ComfyNodeTypedInputRef<boolean>(this, "draw_feet"),
				"draw_hands": new ComfyNodeTypedInputRef<boolean>(this, "draw_hands"),
				"hand_keypoint_size": new ComfyNodeTypedInputRef<number>(this, "hand_keypoint_size"),
				"colorspace": new ComfyNodeTypedInputRef<string>(this, "colorspace"),
				"handle_not_detected": new ComfyNodeTypedInputRef<string>(this, "handle_not_detected"),
				"draw_head": new ComfyNodeTypedInputRef<boolean>(this, "draw_head"),
				"reference_pose_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "reference_pose_image"),
			},
			outputs: Object.create(Object.prototype, {
				"poses": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"reference_pose": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoUniAnimateDWPoseDetectorInputs>) {
		if (typeof sources["pose_images"] === "object") {
			this.sockets.inputs["pose_images"].connectTo(sources["pose_images"])
		} else {
			this.sockets.inputs["pose_images"].value = sources["pose_images"]
		}

		if (typeof sources["score_threshold"] === "object") {
			this.sockets.inputs["score_threshold"].connectTo(sources["score_threshold"])
		} else {
			this.sockets.inputs["score_threshold"].value = sources["score_threshold"]
		}

		if (typeof sources["stick_width"] === "object") {
			this.sockets.inputs["stick_width"].connectTo(sources["stick_width"])
		} else {
			this.sockets.inputs["stick_width"].value = sources["stick_width"]
		}

		if (typeof sources["draw_body"] === "object") {
			this.sockets.inputs["draw_body"].connectTo(sources["draw_body"])
		} else {
			this.sockets.inputs["draw_body"].value = sources["draw_body"]
		}

		if (typeof sources["body_keypoint_size"] === "object") {
			this.sockets.inputs["body_keypoint_size"].connectTo(sources["body_keypoint_size"])
		} else {
			this.sockets.inputs["body_keypoint_size"].value = sources["body_keypoint_size"]
		}

		if (typeof sources["draw_feet"] === "object") {
			this.sockets.inputs["draw_feet"].connectTo(sources["draw_feet"])
		} else {
			this.sockets.inputs["draw_feet"].value = sources["draw_feet"]
		}

		if (typeof sources["draw_hands"] === "object") {
			this.sockets.inputs["draw_hands"].connectTo(sources["draw_hands"])
		} else {
			this.sockets.inputs["draw_hands"].value = sources["draw_hands"]
		}

		if (typeof sources["hand_keypoint_size"] === "object") {
			this.sockets.inputs["hand_keypoint_size"].connectTo(sources["hand_keypoint_size"])
		} else {
			this.sockets.inputs["hand_keypoint_size"].value = sources["hand_keypoint_size"]
		}

		if (typeof sources["colorspace"] === "object") {
			this.sockets.inputs["colorspace"].connectTo(sources["colorspace"])
		} else {
			this.sockets.inputs["colorspace"].value = sources["colorspace"]
		}

		if (typeof sources["handle_not_detected"] === "object") {
			this.sockets.inputs["handle_not_detected"].connectTo(sources["handle_not_detected"])
		} else {
			this.sockets.inputs["handle_not_detected"].value = sources["handle_not_detected"]
		}

		if (typeof sources["draw_head"] === "object") {
			this.sockets.inputs["draw_head"].connectTo(sources["draw_head"])
		} else {
			this.sockets.inputs["draw_head"].value = sources["draw_head"]
		}

		if (sources["reference_pose_image"] !== undefined) {
		if (typeof sources["reference_pose_image"] === "object") {
			this.sockets.inputs["reference_pose_image"].connectTo(sources["reference_pose_image"])
		} else {
			this.sockets.inputs["reference_pose_image"].value = sources["reference_pose_image"]
		}
		}

	}
}

type WanVideoUniAnimateDWPoseDetectorInputs = {
			/** Pose images*/
			"pose_images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Score threshold for pose detection*/
			"score_threshold": ComfyNodeTypedInputRef<number>
			/** Stick width for drawing keypoints*/
			"stick_width": ComfyNodeTypedInputRef<number>
			/** Draw body keypoints*/
			"draw_body": ComfyNodeTypedInputRef<boolean>
			/** Body keypoint size*/
			"body_keypoint_size": ComfyNodeTypedInputRef<number>
			/** Draw feet keypoints*/
			"draw_feet": ComfyNodeTypedInputRef<boolean>
			/** Draw hand keypoints*/
			"draw_hands": ComfyNodeTypedInputRef<boolean>
			/** Hand keypoint size*/
			"hand_keypoint_size": ComfyNodeTypedInputRef<number>
			/** Color space for the output image*/
			"colorspace": ComfyNodeTypedInputRef<string>
			/** How to handle undetected poses, empty inserts black and repeat inserts previous detection*/
			"handle_not_detected": ComfyNodeTypedInputRef<string>
			/** Draw head keypoints*/
			"draw_head": ComfyNodeTypedInputRef<boolean>
			/** Reference pose image*/
			"reference_pose_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class WanVideoDiffusionForcingSampler extends ComfyNode {
	classType: string = "WanVideoDiffusionForcingSampler"

	sockets: {
		inputs: Required<WanVideoDiffusionForcingSamplerInputs>
		outputs: {
			samples: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>(this, "model"),
				"text_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOTEXTEMBEDS>(this, "text_embeds"),
				"image_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>(this, "image_embeds"),
				"addnoise_condition": new ComfyNodeTypedInputRef<number>(this, "addnoise_condition"),
				"fps": new ComfyNodeTypedInputRef<number>(this, "fps"),
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"cfg": new ComfyNodeTypedInputRef<number>(this, "cfg"),
				"shift": new ComfyNodeTypedInputRef<number>(this, "shift"),
				"seed": new ComfyNodeTypedInputRef<number>(this, "seed"),
				"force_offload": new ComfyNodeTypedInputRef<boolean>(this, "force_offload"),
				"scheduler": new ComfyNodeTypedInputRef<string>(this, "scheduler"),
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"prefix_samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "prefix_samples"),
				"denoise_strength": new ComfyNodeTypedInputRef<number>(this, "denoise_strength"),
				"cache_args": new ComfyNodeTypedInputRef<ComfyValueType_CACHEARGS>(this, "cache_args"),
				"slg_args": new ComfyNodeTypedInputRef<ComfyValueType_SLGARGS>(this, "slg_args"),
				"rope_function": new ComfyNodeTypedInputRef<string>(this, "rope_function"),
				"experimental_args": new ComfyNodeTypedInputRef<ComfyValueType_EXPERIMENTALARGS>(this, "experimental_args"),
				"unianimate_poses": new ComfyNodeTypedInputRef<ComfyValueType_UNIANIMATE_POSE>(this, "unianimate_poses"),
			},
			outputs: Object.create(Object.prototype, {
				"samples": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoDiffusionForcingSamplerInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["text_embeds"] === "object") {
			this.sockets.inputs["text_embeds"].connectTo(sources["text_embeds"])
		} else {
			this.sockets.inputs["text_embeds"].value = sources["text_embeds"]
		}

		if (typeof sources["image_embeds"] === "object") {
			this.sockets.inputs["image_embeds"].connectTo(sources["image_embeds"])
		} else {
			this.sockets.inputs["image_embeds"].value = sources["image_embeds"]
		}

		if (typeof sources["addnoise_condition"] === "object") {
			this.sockets.inputs["addnoise_condition"].connectTo(sources["addnoise_condition"])
		} else {
			this.sockets.inputs["addnoise_condition"].value = sources["addnoise_condition"]
		}

		if (typeof sources["fps"] === "object") {
			this.sockets.inputs["fps"].connectTo(sources["fps"])
		} else {
			this.sockets.inputs["fps"].value = sources["fps"]
		}

		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["cfg"] === "object") {
			this.sockets.inputs["cfg"].connectTo(sources["cfg"])
		} else {
			this.sockets.inputs["cfg"].value = sources["cfg"]
		}

		if (typeof sources["shift"] === "object") {
			this.sockets.inputs["shift"].connectTo(sources["shift"])
		} else {
			this.sockets.inputs["shift"].value = sources["shift"]
		}

		if (typeof sources["seed"] === "object") {
			this.sockets.inputs["seed"].connectTo(sources["seed"])
		} else {
			this.sockets.inputs["seed"].value = sources["seed"]
		}

		if (typeof sources["force_offload"] === "object") {
			this.sockets.inputs["force_offload"].connectTo(sources["force_offload"])
		} else {
			this.sockets.inputs["force_offload"].value = sources["force_offload"]
		}

		if (typeof sources["scheduler"] === "object") {
			this.sockets.inputs["scheduler"].connectTo(sources["scheduler"])
		} else {
			this.sockets.inputs["scheduler"].value = sources["scheduler"]
		}

		if (sources["samples"] !== undefined) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}
		}

		if (sources["prefix_samples"] !== undefined) {
		if (typeof sources["prefix_samples"] === "object") {
			this.sockets.inputs["prefix_samples"].connectTo(sources["prefix_samples"])
		} else {
			this.sockets.inputs["prefix_samples"].value = sources["prefix_samples"]
		}
		}

		if (sources["denoise_strength"] !== undefined) {
		if (typeof sources["denoise_strength"] === "object") {
			this.sockets.inputs["denoise_strength"].connectTo(sources["denoise_strength"])
		} else {
			this.sockets.inputs["denoise_strength"].value = sources["denoise_strength"]
		}
		}

		if (sources["cache_args"] !== undefined) {
		if (typeof sources["cache_args"] === "object") {
			this.sockets.inputs["cache_args"].connectTo(sources["cache_args"])
		} else {
			this.sockets.inputs["cache_args"].value = sources["cache_args"]
		}
		}

		if (sources["slg_args"] !== undefined) {
		if (typeof sources["slg_args"] === "object") {
			this.sockets.inputs["slg_args"].connectTo(sources["slg_args"])
		} else {
			this.sockets.inputs["slg_args"].value = sources["slg_args"]
		}
		}

		if (sources["rope_function"] !== undefined) {
		if (typeof sources["rope_function"] === "object") {
			this.sockets.inputs["rope_function"].connectTo(sources["rope_function"])
		} else {
			this.sockets.inputs["rope_function"].value = sources["rope_function"]
		}
		}

		if (sources["experimental_args"] !== undefined) {
		if (typeof sources["experimental_args"] === "object") {
			this.sockets.inputs["experimental_args"].connectTo(sources["experimental_args"])
		} else {
			this.sockets.inputs["experimental_args"].value = sources["experimental_args"]
		}
		}

		if (sources["unianimate_poses"] !== undefined) {
		if (typeof sources["unianimate_poses"] === "object") {
			this.sockets.inputs["unianimate_poses"].connectTo(sources["unianimate_poses"])
		} else {
			this.sockets.inputs["unianimate_poses"].value = sources["unianimate_poses"]
		}
		}

	}
}

type WanVideoDiffusionForcingSamplerInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>
			"text_embeds": ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOTEXTEMBEDS>
			"image_embeds": ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			/** Improves consistency in long video generation*/
			"addnoise_condition": ComfyNodeTypedInputRef<number>
			"fps": ComfyNodeTypedInputRef<number>
			"steps": ComfyNodeTypedInputRef<number>
			"cfg": ComfyNodeTypedInputRef<number>
			"shift": ComfyNodeTypedInputRef<number>
			"seed": ComfyNodeTypedInputRef<number>
			/** Moves the model to the offload device after sampling*/
			"force_offload": ComfyNodeTypedInputRef<boolean>
			"scheduler": ComfyNodeTypedInputRef<string>
			/** init Latents to use for video2video process*/
			"samples"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** prefix latents*/
			"prefix_samples"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"denoise_strength"?: ComfyNodeTypedInputRef<number>
			"cache_args"?: ComfyNodeTypedInputRef<ComfyValueType_CACHEARGS>
			"slg_args"?: ComfyNodeTypedInputRef<ComfyValueType_SLGARGS>
			/** Comfy's RoPE implementation doesn't use complex numbers and can thus be compiled, that should be a lot faster when using torch.compile*/
			"rope_function"?: ComfyNodeTypedInputRef<string>
			"experimental_args"?: ComfyNodeTypedInputRef<ComfyValueType_EXPERIMENTALARGS>
			"unianimate_poses"?: ComfyNodeTypedInputRef<ComfyValueType_UNIANIMATE_POSE>
}


export class DownloadAndLoadWav2VecModel extends ComfyNode {
	classType: string = "DownloadAndLoadWav2VecModel"

	sockets: {
		inputs: Required<DownloadAndLoadWav2VecModelInputs>
		outputs: {
			wav2vec_model: ComfyNodeTypedSourceRef<ComfyValueType_WAV2VECMODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<string>(this, "model"),
				"base_precision": new ComfyNodeTypedInputRef<string>(this, "base_precision"),
				"load_device": new ComfyNodeTypedInputRef<string>(this, "load_device"),
			},
			outputs: Object.create(Object.prototype, {
				"wav2vec_model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DownloadAndLoadWav2VecModelInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["base_precision"] === "object") {
			this.sockets.inputs["base_precision"].connectTo(sources["base_precision"])
		} else {
			this.sockets.inputs["base_precision"].value = sources["base_precision"]
		}

		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}

	}
}

type DownloadAndLoadWav2VecModelInputs = {
			"model": ComfyNodeTypedInputRef<string>
			"base_precision": ComfyNodeTypedInputRef<string>
			/** Initial device to load the model to, NOT recommended with the larger models unless you have 48GB+ VRAM*/
			"load_device": ComfyNodeTypedInputRef<string>
}


export class FantasyTalkingModelLoader extends ComfyNode {
	classType: string = "FantasyTalkingModelLoader"

	sockets: {
		inputs: Required<FantasyTalkingModelLoaderInputs>
		outputs: {
			model: ComfyNodeTypedSourceRef<ComfyValueType_FANTASYTALKINGMODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<string>(this, "model"),
				"base_precision": new ComfyNodeTypedInputRef<string>(this, "base_precision"),
			},
			outputs: Object.create(Object.prototype, {
				"model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<FantasyTalkingModelLoaderInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["base_precision"] === "object") {
			this.sockets.inputs["base_precision"].connectTo(sources["base_precision"])
		} else {
			this.sockets.inputs["base_precision"].value = sources["base_precision"]
		}

	}
}

type FantasyTalkingModelLoaderInputs = {
			/** These models are loaded from the 'ComfyUI/models/diffusion_models' -folder*/
			"model": ComfyNodeTypedInputRef<string>
			"base_precision": ComfyNodeTypedInputRef<string>
}


export class FantasyTalkingWav2VecEmbeds extends ComfyNode {
	classType: string = "FantasyTalkingWav2VecEmbeds"

	sockets: {
		inputs: Required<FantasyTalkingWav2VecEmbedsInputs>
		outputs: {
			fantasytalking_embeds: ComfyNodeTypedSourceRef<ComfyValueType_FANTASYTALKING_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"wav2vec_model": new ComfyNodeTypedInputRef<ComfyValueType_WAV2VECMODEL>(this, "wav2vec_model"),
				"fantasytalking_model": new ComfyNodeTypedInputRef<ComfyValueType_FANTASYTALKINGMODEL>(this, "fantasytalking_model"),
				"audio": new ComfyNodeTypedInputRef<ComfyValueType_AUDIO>(this, "audio"),
				"num_frames": new ComfyNodeTypedInputRef<number>(this, "num_frames"),
				"fps": new ComfyNodeTypedInputRef<number>(this, "fps"),
				"audio_scale": new ComfyNodeTypedInputRef<number>(this, "audio_scale"),
				"audio_cfg_scale": new ComfyNodeTypedInputRef<number>(this, "audio_cfg_scale"),
			},
			outputs: Object.create(Object.prototype, {
				"fantasytalking_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<FantasyTalkingWav2VecEmbedsInputs>) {
		if (typeof sources["wav2vec_model"] === "object") {
			this.sockets.inputs["wav2vec_model"].connectTo(sources["wav2vec_model"])
		} else {
			this.sockets.inputs["wav2vec_model"].value = sources["wav2vec_model"]
		}

		if (typeof sources["fantasytalking_model"] === "object") {
			this.sockets.inputs["fantasytalking_model"].connectTo(sources["fantasytalking_model"])
		} else {
			this.sockets.inputs["fantasytalking_model"].value = sources["fantasytalking_model"]
		}

		if (typeof sources["audio"] === "object") {
			this.sockets.inputs["audio"].connectTo(sources["audio"])
		} else {
			this.sockets.inputs["audio"].value = sources["audio"]
		}

		if (typeof sources["num_frames"] === "object") {
			this.sockets.inputs["num_frames"].connectTo(sources["num_frames"])
		} else {
			this.sockets.inputs["num_frames"].value = sources["num_frames"]
		}

		if (typeof sources["fps"] === "object") {
			this.sockets.inputs["fps"].connectTo(sources["fps"])
		} else {
			this.sockets.inputs["fps"].value = sources["fps"]
		}

		if (typeof sources["audio_scale"] === "object") {
			this.sockets.inputs["audio_scale"].connectTo(sources["audio_scale"])
		} else {
			this.sockets.inputs["audio_scale"].value = sources["audio_scale"]
		}

		if (typeof sources["audio_cfg_scale"] === "object") {
			this.sockets.inputs["audio_cfg_scale"].connectTo(sources["audio_cfg_scale"])
		} else {
			this.sockets.inputs["audio_cfg_scale"].value = sources["audio_cfg_scale"]
		}

	}
}

type FantasyTalkingWav2VecEmbedsInputs = {
			"wav2vec_model": ComfyNodeTypedInputRef<ComfyValueType_WAV2VECMODEL>
			"fantasytalking_model": ComfyNodeTypedInputRef<ComfyValueType_FANTASYTALKINGMODEL>
			"audio": ComfyNodeTypedInputRef<ComfyValueType_AUDIO>
			"num_frames": ComfyNodeTypedInputRef<number>
			"fps": ComfyNodeTypedInputRef<number>
			/** Strength of the audio conditioning*/
			"audio_scale": ComfyNodeTypedInputRef<number>
			/** When not 1.0, an extra model pass without audio conditioning is done: slower inference but more motion is allowed*/
			"audio_cfg_scale": ComfyNodeTypedInputRef<number>
}


export class WanVideoFunCameraEmbeds extends ComfyNode {
	classType: string = "WanVideoFunCameraEmbeds"

	sockets: {
		inputs: Required<WanVideoFunCameraEmbedsInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"poses": new ComfyNodeTypedInputRef<ComfyValueType_CAMERACTRL_POSES>(this, "poses"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoFunCameraEmbedsInputs>) {
		if (typeof sources["poses"] === "object") {
			this.sockets.inputs["poses"].connectTo(sources["poses"])
		} else {
			this.sockets.inputs["poses"].value = sources["poses"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

	}
}

type WanVideoFunCameraEmbedsInputs = {
			"poses": ComfyNodeTypedInputRef<ComfyValueType_CAMERACTRL_POSES>
			/** Width of the image to encode*/
			"width": ComfyNodeTypedInputRef<number>
			/** Height of the image to encode*/
			"height": ComfyNodeTypedInputRef<number>
			/** Strength of the camera motion*/
			"strength": ComfyNodeTypedInputRef<number>
			/** Start percent of the steps to apply camera motion*/
			"start_percent": ComfyNodeTypedInputRef<number>
			/** End percent of the steps to apply camera motion*/
			"end_percent": ComfyNodeTypedInputRef<number>
}


export class WanVideoUni3C_ControlnetLoader extends ComfyNode {
	classType: string = "WanVideoUni3C_ControlnetLoader"

	sockets: {
		inputs: Required<WanVideoUni3C_ControlnetLoaderInputs>
		outputs: {
			controlnet: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOCONTROLNET>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<void>(this, "model"),
				"base_precision": new ComfyNodeTypedInputRef<string>(this, "base_precision"),
				"quantization": new ComfyNodeTypedInputRef<string>(this, "quantization"),
				"load_device": new ComfyNodeTypedInputRef<string>(this, "load_device"),
				"attention_mode": new ComfyNodeTypedInputRef<string>(this, "attention_mode"),
				"compile_args": new ComfyNodeTypedInputRef<ComfyValueType_WANCOMPILEARGS>(this, "compile_args"),
			},
			outputs: Object.create(Object.prototype, {
				"controlnet": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoUni3C_ControlnetLoaderInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["base_precision"] === "object") {
			this.sockets.inputs["base_precision"].connectTo(sources["base_precision"])
		} else {
			this.sockets.inputs["base_precision"].value = sources["base_precision"]
		}

		if (typeof sources["quantization"] === "object") {
			this.sockets.inputs["quantization"].connectTo(sources["quantization"])
		} else {
			this.sockets.inputs["quantization"].value = sources["quantization"]
		}

		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}

		if (typeof sources["attention_mode"] === "object") {
			this.sockets.inputs["attention_mode"].connectTo(sources["attention_mode"])
		} else {
			this.sockets.inputs["attention_mode"].value = sources["attention_mode"]
		}

		if (sources["compile_args"] !== undefined) {
		if (typeof sources["compile_args"] === "object") {
			this.sockets.inputs["compile_args"].connectTo(sources["compile_args"])
		} else {
			this.sockets.inputs["compile_args"].value = sources["compile_args"]
		}
		}

	}
}

type WanVideoUni3C_ControlnetLoaderInputs = {
			/** These models are loaded from the 'ComfyUI/models/controlnet' -folder*/
			"model": ComfyNodeTypedInputRef<void>
			"base_precision": ComfyNodeTypedInputRef<string>
			/** optional quantization method*/
			"quantization": ComfyNodeTypedInputRef<string>
			/** Initial device to load the model to, NOT recommended with the larger models unless you have 48GB+ VRAM*/
			"load_device": ComfyNodeTypedInputRef<string>
			"attention_mode": ComfyNodeTypedInputRef<string>
			"compile_args"?: ComfyNodeTypedInputRef<ComfyValueType_WANCOMPILEARGS>
}


export class WanVideoUni3C_embeds extends ComfyNode {
	classType: string = "WanVideoUni3C_embeds"

	sockets: {
		inputs: Required<WanVideoUni3C_embedsInputs>
		outputs: {
			uni3c_embeds: ComfyNodeTypedSourceRef<ComfyValueType_UNI3C_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"controlnet": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOCONTROLNET>(this, "controlnet"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
				"render_latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "render_latent"),
				"render_mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "render_mask"),
			},
			outputs: Object.create(Object.prototype, {
				"uni3c_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoUni3C_embedsInputs>) {
		if (typeof sources["controlnet"] === "object") {
			this.sockets.inputs["controlnet"].connectTo(sources["controlnet"])
		} else {
			this.sockets.inputs["controlnet"].value = sources["controlnet"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

		if (sources["render_latent"] !== undefined) {
		if (typeof sources["render_latent"] === "object") {
			this.sockets.inputs["render_latent"].connectTo(sources["render_latent"])
		} else {
			this.sockets.inputs["render_latent"].value = sources["render_latent"]
		}
		}

		if (sources["render_mask"] !== undefined) {
		if (typeof sources["render_mask"] === "object") {
			this.sockets.inputs["render_mask"].connectTo(sources["render_mask"])
		} else {
			this.sockets.inputs["render_mask"].value = sources["render_mask"]
		}
		}

	}
}

type WanVideoUni3C_embedsInputs = {
			"controlnet": ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOCONTROLNET>
			"strength": ComfyNodeTypedInputRef<number>
			/** Start percent of the steps to apply the controlnet*/
			"start_percent": ComfyNodeTypedInputRef<number>
			/** End percent of the steps to apply the controlnet*/
			"end_percent": ComfyNodeTypedInputRef<number>
			"render_latent"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** NOT IMPLEMENTED!*/
			"render_mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class WanVideoControlnetLoader extends ComfyNode {
	classType: string = "WanVideoControlnetLoader"

	sockets: {
		inputs: Required<WanVideoControlnetLoaderInputs>
		outputs: {
			controlnet: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOCONTROLNET>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<void>(this, "model"),
				"base_precision": new ComfyNodeTypedInputRef<string>(this, "base_precision"),
				"quantization": new ComfyNodeTypedInputRef<string>(this, "quantization"),
				"load_device": new ComfyNodeTypedInputRef<string>(this, "load_device"),
			},
			outputs: Object.create(Object.prototype, {
				"controlnet": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoControlnetLoaderInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["base_precision"] === "object") {
			this.sockets.inputs["base_precision"].connectTo(sources["base_precision"])
		} else {
			this.sockets.inputs["base_precision"].value = sources["base_precision"]
		}

		if (typeof sources["quantization"] === "object") {
			this.sockets.inputs["quantization"].connectTo(sources["quantization"])
		} else {
			this.sockets.inputs["quantization"].value = sources["quantization"]
		}

		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}

	}
}

type WanVideoControlnetLoaderInputs = {
			/** These models are loaded from the 'ComfyUI/models/controlnet' -folder*/
			"model": ComfyNodeTypedInputRef<void>
			"base_precision": ComfyNodeTypedInputRef<string>
			/** optional quantization method*/
			"quantization": ComfyNodeTypedInputRef<string>
			/** Initial device to load the model to, NOT recommended with the larger models unless you have 48GB+ VRAM*/
			"load_device": ComfyNodeTypedInputRef<string>
}


export class WanVideoControlnet extends ComfyNode {
	classType: string = "WanVideoControlnet"

	sockets: {
		inputs: Required<WanVideoControlnetInputs>
		outputs: {
			model: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOMODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>(this, "model"),
				"controlnet": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOCONTROLNET>(this, "controlnet"),
				"control_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "control_images"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"control_stride": new ComfyNodeTypedInputRef<number>(this, "control_stride"),
				"control_start_percent": new ComfyNodeTypedInputRef<number>(this, "control_start_percent"),
				"control_end_percent": new ComfyNodeTypedInputRef<number>(this, "control_end_percent"),
			},
			outputs: Object.create(Object.prototype, {
				"model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoControlnetInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["controlnet"] === "object") {
			this.sockets.inputs["controlnet"].connectTo(sources["controlnet"])
		} else {
			this.sockets.inputs["controlnet"].value = sources["controlnet"]
		}

		if (typeof sources["control_images"] === "object") {
			this.sockets.inputs["control_images"].connectTo(sources["control_images"])
		} else {
			this.sockets.inputs["control_images"].value = sources["control_images"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (typeof sources["control_stride"] === "object") {
			this.sockets.inputs["control_stride"].connectTo(sources["control_stride"])
		} else {
			this.sockets.inputs["control_stride"].value = sources["control_stride"]
		}

		if (typeof sources["control_start_percent"] === "object") {
			this.sockets.inputs["control_start_percent"].connectTo(sources["control_start_percent"])
		} else {
			this.sockets.inputs["control_start_percent"].value = sources["control_start_percent"]
		}

		if (typeof sources["control_end_percent"] === "object") {
			this.sockets.inputs["control_end_percent"].connectTo(sources["control_end_percent"])
		} else {
			this.sockets.inputs["control_end_percent"].value = sources["control_end_percent"]
		}

	}
}

type WanVideoControlnetInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>
			"controlnet": ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOCONTROLNET>
			"control_images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** controlnet strength*/
			"strength": ComfyNodeTypedInputRef<number>
			/** controlnet stride*/
			"control_stride": ComfyNodeTypedInputRef<number>
			/** Start percent of the steps to apply controlnet*/
			"control_start_percent": ComfyNodeTypedInputRef<number>
			/** End percent of the steps to apply controlnet*/
			"control_end_percent": ComfyNodeTypedInputRef<number>
}


export class WanVideoATITracks extends ComfyNode {
	classType: string = "WanVideoATITracks"

	sockets: {
		inputs: Required<WanVideoATITracksInputs>
		outputs: {
			model: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOMODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>(this, "model"),
				"tracks": new ComfyNodeTypedInputRef<string>(this, "tracks"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"temperature": new ComfyNodeTypedInputRef<number>(this, "temperature"),
				"topk": new ComfyNodeTypedInputRef<number>(this, "topk"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
			},
			outputs: Object.create(Object.prototype, {
				"model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoATITracksInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["tracks"] === "object") {
			this.sockets.inputs["tracks"].connectTo(sources["tracks"])
		} else {
			this.sockets.inputs["tracks"].value = sources["tracks"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["temperature"] === "object") {
			this.sockets.inputs["temperature"].connectTo(sources["temperature"])
		} else {
			this.sockets.inputs["temperature"].value = sources["temperature"]
		}

		if (typeof sources["topk"] === "object") {
			this.sockets.inputs["topk"].connectTo(sources["topk"])
		} else {
			this.sockets.inputs["topk"].value = sources["topk"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

	}
}

type WanVideoATITracksInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>
			"tracks": ComfyNodeTypedInputRef<string>
			/** Width of the image to encode*/
			"width": ComfyNodeTypedInputRef<number>
			/** Height of the image to encode*/
			"height": ComfyNodeTypedInputRef<number>
			"temperature": ComfyNodeTypedInputRef<number>
			"topk": ComfyNodeTypedInputRef<number>
			/** Start percent of the steps to apply ATI*/
			"start_percent": ComfyNodeTypedInputRef<number>
			/** End percent of the steps to apply ATI*/
			"end_percent": ComfyNodeTypedInputRef<number>
}


export class WanVideoATITracksVisualize extends ComfyNode {
	classType: string = "WanVideoATITracksVisualize"

	sockets: {
		inputs: Required<WanVideoATITracksVisualizeInputs>
		outputs: {
			images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"tracks": new ComfyNodeTypedInputRef<string>(this, "tracks"),
				"min_radius": new ComfyNodeTypedInputRef<number>(this, "min_radius"),
				"max_radius": new ComfyNodeTypedInputRef<number>(this, "max_radius"),
				"max_retain": new ComfyNodeTypedInputRef<number>(this, "max_retain"),
			},
			outputs: Object.create(Object.prototype, {
				"images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoATITracksVisualizeInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["tracks"] === "object") {
			this.sockets.inputs["tracks"].connectTo(sources["tracks"])
		} else {
			this.sockets.inputs["tracks"].value = sources["tracks"]
		}

		if (typeof sources["min_radius"] === "object") {
			this.sockets.inputs["min_radius"].connectTo(sources["min_radius"])
		} else {
			this.sockets.inputs["min_radius"].value = sources["min_radius"]
		}

		if (typeof sources["max_radius"] === "object") {
			this.sockets.inputs["max_radius"].connectTo(sources["max_radius"])
		} else {
			this.sockets.inputs["max_radius"].value = sources["max_radius"]
		}

		if (typeof sources["max_retain"] === "object") {
			this.sockets.inputs["max_retain"].connectTo(sources["max_retain"])
		} else {
			this.sockets.inputs["max_retain"].value = sources["max_retain"]
		}

	}
}

type WanVideoATITracksVisualizeInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"tracks": ComfyNodeTypedInputRef<string>
			/** radius for the very first point (oldest)*/
			"min_radius": ComfyNodeTypedInputRef<number>
			/** radius for the current point (newest)*/
			"max_radius": ComfyNodeTypedInputRef<number>
			/** Maximum number of points to retain*/
			"max_retain": ComfyNodeTypedInputRef<number>
}


export class WanVideoATI_comfy extends ComfyNode {
	classType: string = "WanVideoATI_comfy"

	sockets: {
		inputs: Required<WanVideoATI_comfyInputs>
		outputs: {
			model: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"tracks": new ComfyNodeTypedInputRef<string>(this, "tracks"),
				"temperature": new ComfyNodeTypedInputRef<number>(this, "temperature"),
				"topk": new ComfyNodeTypedInputRef<number>(this, "topk"),
			},
			outputs: Object.create(Object.prototype, {
				"model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoATI_comfyInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["tracks"] === "object") {
			this.sockets.inputs["tracks"].connectTo(sources["tracks"])
		} else {
			this.sockets.inputs["tracks"].value = sources["tracks"]
		}

		if (typeof sources["temperature"] === "object") {
			this.sockets.inputs["temperature"].connectTo(sources["temperature"])
		} else {
			this.sockets.inputs["temperature"].value = sources["temperature"]
		}

		if (typeof sources["topk"] === "object") {
			this.sockets.inputs["topk"].connectTo(sources["topk"])
		} else {
			this.sockets.inputs["topk"].value = sources["topk"]
		}

	}
}

type WanVideoATI_comfyInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			/** Width of the image to encode*/
			"width": ComfyNodeTypedInputRef<number>
			/** Height of the image to encode*/
			"height": ComfyNodeTypedInputRef<number>
			"tracks": ComfyNodeTypedInputRef<string>
			"temperature": ComfyNodeTypedInputRef<number>
			"topk": ComfyNodeTypedInputRef<number>
}


export class MultiTalkModelLoader extends ComfyNode {
	classType: string = "MultiTalkModelLoader"

	sockets: {
		inputs: Required<MultiTalkModelLoaderInputs>
		outputs: {
			model: ComfyNodeTypedSourceRef<ComfyValueType_MULTITALKMODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<string>(this, "model"),
			},
			outputs: Object.create(Object.prototype, {
				"model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<MultiTalkModelLoaderInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

	}
}

type MultiTalkModelLoaderInputs = {
			/** These models are loaded from the 'ComfyUI/models/diffusion_models' -folder*/
			"model": ComfyNodeTypedInputRef<string>
}


export class MultiTalkWav2VecEmbeds extends ComfyNode {
	classType: string = "MultiTalkWav2VecEmbeds"

	sockets: {
		inputs: Required<MultiTalkWav2VecEmbedsInputs>
		outputs: {
			multitalk_embeds: ComfyNodeTypedSourceRef<ComfyValueType_MULTITALK_EMBEDS>
			audio: ComfyNodeTypedSourceRef<ComfyValueType_AUDIO>
			num_frames: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"wav2vec_model": new ComfyNodeTypedInputRef<ComfyValueType_WAV2VECMODEL>(this, "wav2vec_model"),
				"audio_1": new ComfyNodeTypedInputRef<ComfyValueType_AUDIO>(this, "audio_1"),
				"normalize_loudness": new ComfyNodeTypedInputRef<boolean>(this, "normalize_loudness"),
				"num_frames": new ComfyNodeTypedInputRef<number>(this, "num_frames"),
				"fps": new ComfyNodeTypedInputRef<number>(this, "fps"),
				"audio_scale": new ComfyNodeTypedInputRef<number>(this, "audio_scale"),
				"audio_cfg_scale": new ComfyNodeTypedInputRef<number>(this, "audio_cfg_scale"),
				"multi_audio_type": new ComfyNodeTypedInputRef<string>(this, "multi_audio_type"),
				"audio_2": new ComfyNodeTypedInputRef<ComfyValueType_AUDIO>(this, "audio_2"),
				"audio_3": new ComfyNodeTypedInputRef<ComfyValueType_AUDIO>(this, "audio_3"),
				"audio_4": new ComfyNodeTypedInputRef<ComfyValueType_AUDIO>(this, "audio_4"),
				"ref_target_masks": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "ref_target_masks"),
			},
			outputs: Object.create(Object.prototype, {
				"multitalk_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"audio": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"num_frames": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<MultiTalkWav2VecEmbedsInputs>) {
		if (typeof sources["wav2vec_model"] === "object") {
			this.sockets.inputs["wav2vec_model"].connectTo(sources["wav2vec_model"])
		} else {
			this.sockets.inputs["wav2vec_model"].value = sources["wav2vec_model"]
		}

		if (typeof sources["audio_1"] === "object") {
			this.sockets.inputs["audio_1"].connectTo(sources["audio_1"])
		} else {
			this.sockets.inputs["audio_1"].value = sources["audio_1"]
		}

		if (typeof sources["normalize_loudness"] === "object") {
			this.sockets.inputs["normalize_loudness"].connectTo(sources["normalize_loudness"])
		} else {
			this.sockets.inputs["normalize_loudness"].value = sources["normalize_loudness"]
		}

		if (typeof sources["num_frames"] === "object") {
			this.sockets.inputs["num_frames"].connectTo(sources["num_frames"])
		} else {
			this.sockets.inputs["num_frames"].value = sources["num_frames"]
		}

		if (typeof sources["fps"] === "object") {
			this.sockets.inputs["fps"].connectTo(sources["fps"])
		} else {
			this.sockets.inputs["fps"].value = sources["fps"]
		}

		if (typeof sources["audio_scale"] === "object") {
			this.sockets.inputs["audio_scale"].connectTo(sources["audio_scale"])
		} else {
			this.sockets.inputs["audio_scale"].value = sources["audio_scale"]
		}

		if (typeof sources["audio_cfg_scale"] === "object") {
			this.sockets.inputs["audio_cfg_scale"].connectTo(sources["audio_cfg_scale"])
		} else {
			this.sockets.inputs["audio_cfg_scale"].value = sources["audio_cfg_scale"]
		}

		if (typeof sources["multi_audio_type"] === "object") {
			this.sockets.inputs["multi_audio_type"].connectTo(sources["multi_audio_type"])
		} else {
			this.sockets.inputs["multi_audio_type"].value = sources["multi_audio_type"]
		}

		if (sources["audio_2"] !== undefined) {
		if (typeof sources["audio_2"] === "object") {
			this.sockets.inputs["audio_2"].connectTo(sources["audio_2"])
		} else {
			this.sockets.inputs["audio_2"].value = sources["audio_2"]
		}
		}

		if (sources["audio_3"] !== undefined) {
		if (typeof sources["audio_3"] === "object") {
			this.sockets.inputs["audio_3"].connectTo(sources["audio_3"])
		} else {
			this.sockets.inputs["audio_3"].value = sources["audio_3"]
		}
		}

		if (sources["audio_4"] !== undefined) {
		if (typeof sources["audio_4"] === "object") {
			this.sockets.inputs["audio_4"].connectTo(sources["audio_4"])
		} else {
			this.sockets.inputs["audio_4"].value = sources["audio_4"]
		}
		}

		if (sources["ref_target_masks"] !== undefined) {
		if (typeof sources["ref_target_masks"] === "object") {
			this.sockets.inputs["ref_target_masks"].connectTo(sources["ref_target_masks"])
		} else {
			this.sockets.inputs["ref_target_masks"].value = sources["ref_target_masks"]
		}
		}

	}
}

type MultiTalkWav2VecEmbedsInputs = {
			"wav2vec_model": ComfyNodeTypedInputRef<ComfyValueType_WAV2VECMODEL>
			"audio_1": ComfyNodeTypedInputRef<ComfyValueType_AUDIO>
			/** Normalize the audio loudness to -23 LUFS*/
			"normalize_loudness": ComfyNodeTypedInputRef<boolean>
			/** The total frame count to generate.*/
			"num_frames": ComfyNodeTypedInputRef<number>
			"fps": ComfyNodeTypedInputRef<number>
			/** Strength of the audio conditioning*/
			"audio_scale": ComfyNodeTypedInputRef<number>
			/** When not 1.0, an extra model pass without audio conditioning is done: slower inference but more motion is allowed*/
			"audio_cfg_scale": ComfyNodeTypedInputRef<number>
			/** 'para' overlay speakers in parallel, 'add' concatenate sequentially*/
			"multi_audio_type": ComfyNodeTypedInputRef<string>
			"audio_2"?: ComfyNodeTypedInputRef<ComfyValueType_AUDIO>
			"audio_3"?: ComfyNodeTypedInputRef<ComfyValueType_AUDIO>
			"audio_4"?: ComfyNodeTypedInputRef<ComfyValueType_AUDIO>
			/** Per-speaker semantic mask(s) in pixel space. Supply one mask per speaker (plus optional background) to guide mouth assignment*/
			"ref_target_masks"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class WanVideoImageToVideoMultiTalk extends ComfyNode {
	classType: string = "WanVideoImageToVideoMultiTalk"

	sockets: {
		inputs: Required<WanVideoImageToVideoMultiTalkInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			output_path: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_WANVAE>(this, "vae"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"frame_window_size": new ComfyNodeTypedInputRef<number>(this, "frame_window_size"),
				"motion_frame": new ComfyNodeTypedInputRef<number>(this, "motion_frame"),
				"force_offload": new ComfyNodeTypedInputRef<boolean>(this, "force_offload"),
				"colormatch": new ComfyNodeTypedInputRef<string>(this, "colormatch"),
				"start_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "start_image"),
				"tiled_vae": new ComfyNodeTypedInputRef<boolean>(this, "tiled_vae"),
				"clip_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_CLIPEMBEDS>(this, "clip_embeds"),
				"mode": new ComfyNodeTypedInputRef<string>(this, "mode"),
				"output_path": new ComfyNodeTypedInputRef<string>(this, "output_path"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"output_path": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoImageToVideoMultiTalkInputs>) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["frame_window_size"] === "object") {
			this.sockets.inputs["frame_window_size"].connectTo(sources["frame_window_size"])
		} else {
			this.sockets.inputs["frame_window_size"].value = sources["frame_window_size"]
		}

		if (typeof sources["motion_frame"] === "object") {
			this.sockets.inputs["motion_frame"].connectTo(sources["motion_frame"])
		} else {
			this.sockets.inputs["motion_frame"].value = sources["motion_frame"]
		}

		if (typeof sources["force_offload"] === "object") {
			this.sockets.inputs["force_offload"].connectTo(sources["force_offload"])
		} else {
			this.sockets.inputs["force_offload"].value = sources["force_offload"]
		}

		if (typeof sources["colormatch"] === "object") {
			this.sockets.inputs["colormatch"].connectTo(sources["colormatch"])
		} else {
			this.sockets.inputs["colormatch"].value = sources["colormatch"]
		}

		if (sources["start_image"] !== undefined) {
		if (typeof sources["start_image"] === "object") {
			this.sockets.inputs["start_image"].connectTo(sources["start_image"])
		} else {
			this.sockets.inputs["start_image"].value = sources["start_image"]
		}
		}

		if (sources["tiled_vae"] !== undefined) {
		if (typeof sources["tiled_vae"] === "object") {
			this.sockets.inputs["tiled_vae"].connectTo(sources["tiled_vae"])
		} else {
			this.sockets.inputs["tiled_vae"].value = sources["tiled_vae"]
		}
		}

		if (sources["clip_embeds"] !== undefined) {
		if (typeof sources["clip_embeds"] === "object") {
			this.sockets.inputs["clip_embeds"].connectTo(sources["clip_embeds"])
		} else {
			this.sockets.inputs["clip_embeds"].value = sources["clip_embeds"]
		}
		}

		if (sources["mode"] !== undefined) {
		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}
		}

		if (sources["output_path"] !== undefined) {
		if (typeof sources["output_path"] === "object") {
			this.sockets.inputs["output_path"].connectTo(sources["output_path"])
		} else {
			this.sockets.inputs["output_path"].value = sources["output_path"]
		}
		}

	}
}

type WanVideoImageToVideoMultiTalkInputs = {
			"vae": ComfyNodeTypedInputRef<ComfyValueType_WANVAE>
			/** Width of the generation*/
			"width": ComfyNodeTypedInputRef<number>
			/** Height of the generation*/
			"height": ComfyNodeTypedInputRef<number>
			/** The number of frames to process at once, should be a value the model is generally good at.*/
			"frame_window_size": ComfyNodeTypedInputRef<number>
			/** Driven frame length used in the long video generation. Basically the overlap length.*/
			"motion_frame": ComfyNodeTypedInputRef<number>
			/** Whether to force offload the model within the loop for VAE operations, enable if you encounter memory issues.*/
			"force_offload": ComfyNodeTypedInputRef<boolean>
			/** Color matching method to use between the windows*/
			"colormatch": ComfyNodeTypedInputRef<string>
			/** Images to encode*/
			"start_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Use tiled VAE encoding for reduced memory use*/
			"tiled_vae"?: ComfyNodeTypedInputRef<boolean>
			/** Clip vision encoded image*/
			"clip_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_CLIPEMBEDS>
			/** The sampling strategy to use in the long video generation loop, should match the model used*/
			"mode"?: ComfyNodeTypedInputRef<string>
			/** If set, will save each window's resulting frames to this folder, also DISABLES returning the final video tensor to save memory*/
			"output_path"?: ComfyNodeTypedInputRef<string>
}


export class Wav2VecModelLoader extends ComfyNode {
	classType: string = "Wav2VecModelLoader"

	sockets: {
		inputs: Required<Wav2VecModelLoaderInputs>
		outputs: {
			wav2vec_model: ComfyNodeTypedSourceRef<ComfyValueType_WAV2VECMODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<void>(this, "model"),
				"base_precision": new ComfyNodeTypedInputRef<string>(this, "base_precision"),
				"load_device": new ComfyNodeTypedInputRef<string>(this, "load_device"),
			},
			outputs: Object.create(Object.prototype, {
				"wav2vec_model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<Wav2VecModelLoaderInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["base_precision"] === "object") {
			this.sockets.inputs["base_precision"].connectTo(sources["base_precision"])
		} else {
			this.sockets.inputs["base_precision"].value = sources["base_precision"]
		}

		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}

	}
}

type Wav2VecModelLoaderInputs = {
			/** These models are loaded from the 'ComfyUI/models/wav2vec2' -folder*/
			"model": ComfyNodeTypedInputRef<void>
			"base_precision": ComfyNodeTypedInputRef<string>
			/** Initial device to load the model to, NOT recommended with the larger models unless you have 48GB+ VRAM*/
			"load_device": ComfyNodeTypedInputRef<string>
}


export class MultiTalkSilentEmbeds extends ComfyNode {
	classType: string = "MultiTalkSilentEmbeds"

	sockets: {
		inputs: Required<MultiTalkSilentEmbedsInputs>
		outputs: {
			multitalk_embeds: ComfyNodeTypedSourceRef<ComfyValueType_MULTITALK_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"num_frames": new ComfyNodeTypedInputRef<number>(this, "num_frames"),
			},
			outputs: Object.create(Object.prototype, {
				"multitalk_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<MultiTalkSilentEmbedsInputs>) {
		if (typeof sources["num_frames"] === "object") {
			this.sockets.inputs["num_frames"].connectTo(sources["num_frames"])
		} else {
			this.sockets.inputs["num_frames"].value = sources["num_frames"]
		}

	}
}

type MultiTalkSilentEmbedsInputs = {
			/** The total frame count to generate.*/
			"num_frames": ComfyNodeTypedInputRef<number>
}


export class WanVideoModelLoader extends ComfyNode {
	classType: string = "WanVideoModelLoader"

	sockets: {
		inputs: Required<WanVideoModelLoaderInputs>
		outputs: {
			model: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOMODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<string>(this, "model"),
				"base_precision": new ComfyNodeTypedInputRef<string>(this, "base_precision"),
				"quantization": new ComfyNodeTypedInputRef<string>(this, "quantization"),
				"load_device": new ComfyNodeTypedInputRef<string>(this, "load_device"),
				"attention_mode": new ComfyNodeTypedInputRef<string>(this, "attention_mode"),
				"compile_args": new ComfyNodeTypedInputRef<ComfyValueType_WANCOMPILEARGS>(this, "compile_args"),
				"block_swap_args": new ComfyNodeTypedInputRef<ComfyValueType_BLOCKSWAPARGS>(this, "block_swap_args"),
				"lora": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDLORA>(this, "lora"),
				"vram_management_args": new ComfyNodeTypedInputRef<ComfyValueType_VRAM_MANAGEMENTARGS>(this, "vram_management_args"),
				"extra_model": new ComfyNodeTypedInputRef<ComfyValueType_VACEPATH>(this, "extra_model"),
				"fantasytalking_model": new ComfyNodeTypedInputRef<ComfyValueType_FANTASYTALKINGMODEL>(this, "fantasytalking_model"),
				"multitalk_model": new ComfyNodeTypedInputRef<ComfyValueType_MULTITALKMODEL>(this, "multitalk_model"),
				"fantasyportrait_model": new ComfyNodeTypedInputRef<ComfyValueType_FANTASYPORTRAITMODEL>(this, "fantasyportrait_model"),
				"rms_norm_function": new ComfyNodeTypedInputRef<string>(this, "rms_norm_function"),
			},
			outputs: Object.create(Object.prototype, {
				"model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoModelLoaderInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["base_precision"] === "object") {
			this.sockets.inputs["base_precision"].connectTo(sources["base_precision"])
		} else {
			this.sockets.inputs["base_precision"].value = sources["base_precision"]
		}

		if (typeof sources["quantization"] === "object") {
			this.sockets.inputs["quantization"].connectTo(sources["quantization"])
		} else {
			this.sockets.inputs["quantization"].value = sources["quantization"]
		}

		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}

		if (sources["attention_mode"] !== undefined) {
		if (typeof sources["attention_mode"] === "object") {
			this.sockets.inputs["attention_mode"].connectTo(sources["attention_mode"])
		} else {
			this.sockets.inputs["attention_mode"].value = sources["attention_mode"]
		}
		}

		if (sources["compile_args"] !== undefined) {
		if (typeof sources["compile_args"] === "object") {
			this.sockets.inputs["compile_args"].connectTo(sources["compile_args"])
		} else {
			this.sockets.inputs["compile_args"].value = sources["compile_args"]
		}
		}

		if (sources["block_swap_args"] !== undefined) {
		if (typeof sources["block_swap_args"] === "object") {
			this.sockets.inputs["block_swap_args"].connectTo(sources["block_swap_args"])
		} else {
			this.sockets.inputs["block_swap_args"].value = sources["block_swap_args"]
		}
		}

		if (sources["lora"] !== undefined) {
		if (typeof sources["lora"] === "object") {
			this.sockets.inputs["lora"].connectTo(sources["lora"])
		} else {
			this.sockets.inputs["lora"].value = sources["lora"]
		}
		}

		if (sources["vram_management_args"] !== undefined) {
		if (typeof sources["vram_management_args"] === "object") {
			this.sockets.inputs["vram_management_args"].connectTo(sources["vram_management_args"])
		} else {
			this.sockets.inputs["vram_management_args"].value = sources["vram_management_args"]
		}
		}

		if (sources["extra_model"] !== undefined) {
		if (typeof sources["extra_model"] === "object") {
			this.sockets.inputs["extra_model"].connectTo(sources["extra_model"])
		} else {
			this.sockets.inputs["extra_model"].value = sources["extra_model"]
		}
		}

		if (sources["fantasytalking_model"] !== undefined) {
		if (typeof sources["fantasytalking_model"] === "object") {
			this.sockets.inputs["fantasytalking_model"].connectTo(sources["fantasytalking_model"])
		} else {
			this.sockets.inputs["fantasytalking_model"].value = sources["fantasytalking_model"]
		}
		}

		if (sources["multitalk_model"] !== undefined) {
		if (typeof sources["multitalk_model"] === "object") {
			this.sockets.inputs["multitalk_model"].connectTo(sources["multitalk_model"])
		} else {
			this.sockets.inputs["multitalk_model"].value = sources["multitalk_model"]
		}
		}

		if (sources["fantasyportrait_model"] !== undefined) {
		if (typeof sources["fantasyportrait_model"] === "object") {
			this.sockets.inputs["fantasyportrait_model"].connectTo(sources["fantasyportrait_model"])
		} else {
			this.sockets.inputs["fantasyportrait_model"].value = sources["fantasyportrait_model"]
		}
		}

		if (sources["rms_norm_function"] !== undefined) {
		if (typeof sources["rms_norm_function"] === "object") {
			this.sockets.inputs["rms_norm_function"].connectTo(sources["rms_norm_function"])
		} else {
			this.sockets.inputs["rms_norm_function"].value = sources["rms_norm_function"]
		}
		}

	}
}

type WanVideoModelLoaderInputs = {
			/** These models are loaded from the 'ComfyUI/models/diffusion_models' -folder*/
			"model": ComfyNodeTypedInputRef<string>
			"base_precision": ComfyNodeTypedInputRef<string>
			/** Optional quantization method, 'disabled' acts as autoselect based by weights. Scaled modes only work with matching weights, _fast modes (fp8 matmul) require CUDA compute capability >= 8.9 (NVIDIA 4000 series and up), e4m3fn generally can not be torch.compiled on compute capability < 8.9 (3000 series and under)*/
			"quantization": ComfyNodeTypedInputRef<string>
			/** Initial device to load the model to, NOT recommended with the larger models unless you have 48GB+ VRAM*/
			"load_device": ComfyNodeTypedInputRef<string>
			"attention_mode"?: ComfyNodeTypedInputRef<string>
			"compile_args"?: ComfyNodeTypedInputRef<ComfyValueType_WANCOMPILEARGS>
			"block_swap_args"?: ComfyNodeTypedInputRef<ComfyValueType_BLOCKSWAPARGS>
			"lora"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDLORA>
			/** Alternative offloading method from DiffSynth-Studio, more aggressive in reducing memory use than block swapping, but can be slower*/
			"vram_management_args"?: ComfyNodeTypedInputRef<ComfyValueType_VRAM_MANAGEMENTARGS>
			/** Extra model to add to the main model, ie. VACE or MTV Crafter*/
			"extra_model"?: ComfyNodeTypedInputRef<ComfyValueType_VACEPATH>
			/** FantasyTalking model https://github.com/Fantasy-AMAP*/
			"fantasytalking_model"?: ComfyNodeTypedInputRef<ComfyValueType_FANTASYTALKINGMODEL>
			/** Multitalk model*/
			"multitalk_model"?: ComfyNodeTypedInputRef<ComfyValueType_MULTITALKMODEL>
			/** FantasyPortrait model*/
			"fantasyportrait_model"?: ComfyNodeTypedInputRef<ComfyValueType_FANTASYPORTRAITMODEL>
			/** RMSNorm function to use, 'pytorch' is the new native torch RMSNorm, which is faster (when not using torch.compile mostly) but changes results slightly. 'default' is the original WanRMSNorm*/
			"rms_norm_function"?: ComfyNodeTypedInputRef<string>
}


export class WanVideoVAELoader extends ComfyNode {
	classType: string = "WanVideoVAELoader"

	sockets: {
		inputs: Required<WanVideoVAELoaderInputs>
		outputs: {
			vae: ComfyNodeTypedSourceRef<ComfyValueType_WANVAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_name": new ComfyNodeTypedInputRef<string>(this, "model_name"),
				"precision": new ComfyNodeTypedInputRef<string>(this, "precision"),
				"compile_args": new ComfyNodeTypedInputRef<ComfyValueType_WANCOMPILEARGS>(this, "compile_args"),
			},
			outputs: Object.create(Object.prototype, {
				"vae": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoVAELoaderInputs>) {
		if (typeof sources["model_name"] === "object") {
			this.sockets.inputs["model_name"].connectTo(sources["model_name"])
		} else {
			this.sockets.inputs["model_name"].value = sources["model_name"]
		}

		if (sources["precision"] !== undefined) {
		if (typeof sources["precision"] === "object") {
			this.sockets.inputs["precision"].connectTo(sources["precision"])
		} else {
			this.sockets.inputs["precision"].value = sources["precision"]
		}
		}

		if (sources["compile_args"] !== undefined) {
		if (typeof sources["compile_args"] === "object") {
			this.sockets.inputs["compile_args"].connectTo(sources["compile_args"])
		} else {
			this.sockets.inputs["compile_args"].value = sources["compile_args"]
		}
		}

	}
}

type WanVideoVAELoaderInputs = {
			/** These models are loaded from 'ComfyUI/models/vae'*/
			"model_name": ComfyNodeTypedInputRef<string>
			"precision"?: ComfyNodeTypedInputRef<string>
			"compile_args"?: ComfyNodeTypedInputRef<ComfyValueType_WANCOMPILEARGS>
}


export class WanVideoLoraSelect extends ComfyNode {
	classType: string = "WanVideoLoraSelect"

	sockets: {
		inputs: Required<WanVideoLoraSelectInputs>
		outputs: {
			lora: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDLORA>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"lora": new ComfyNodeTypedInputRef<string>(this, "lora"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"prev_lora": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDLORA>(this, "prev_lora"),
				"blocks": new ComfyNodeTypedInputRef<ComfyValueType_SELECTEDBLOCKS>(this, "blocks"),
				"low_mem_load": new ComfyNodeTypedInputRef<boolean>(this, "low_mem_load"),
				"merge_loras": new ComfyNodeTypedInputRef<boolean>(this, "merge_loras"),
				"unique_id": new ComfyNodeTypedInputRef<ComfyValueType_U>(this, "unique_id"),
			},
			outputs: Object.create(Object.prototype, {
				"lora": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoLoraSelectInputs>) {
		if (typeof sources["lora"] === "object") {
			this.sockets.inputs["lora"].connectTo(sources["lora"])
		} else {
			this.sockets.inputs["lora"].value = sources["lora"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (sources["prev_lora"] !== undefined) {
		if (typeof sources["prev_lora"] === "object") {
			this.sockets.inputs["prev_lora"].connectTo(sources["prev_lora"])
		} else {
			this.sockets.inputs["prev_lora"].value = sources["prev_lora"]
		}
		}

		if (sources["blocks"] !== undefined) {
		if (typeof sources["blocks"] === "object") {
			this.sockets.inputs["blocks"].connectTo(sources["blocks"])
		} else {
			this.sockets.inputs["blocks"].value = sources["blocks"]
		}
		}

		if (sources["low_mem_load"] !== undefined) {
		if (typeof sources["low_mem_load"] === "object") {
			this.sockets.inputs["low_mem_load"].connectTo(sources["low_mem_load"])
		} else {
			this.sockets.inputs["low_mem_load"].value = sources["low_mem_load"]
		}
		}

		if (sources["merge_loras"] !== undefined) {
		if (typeof sources["merge_loras"] === "object") {
			this.sockets.inputs["merge_loras"].connectTo(sources["merge_loras"])
		} else {
			this.sockets.inputs["merge_loras"].value = sources["merge_loras"]
		}
		}

		if (sources["unique_id"] !== undefined) {
		if (typeof sources["unique_id"] === "object") {
			this.sockets.inputs["unique_id"].connectTo(sources["unique_id"])
		} else {
			this.sockets.inputs["unique_id"].value = sources["unique_id"]
		}
		}

	}
}

type WanVideoLoraSelectInputs = {
			/** LORA models are expected to be in ComfyUI/models/loras with .safetensors extension*/
			"lora": ComfyNodeTypedInputRef<string>
			/** LORA strength, set to 0.0 to unmerge the LORA*/
			"strength": ComfyNodeTypedInputRef<number>
			/** For loading multiple LoRAs*/
			"prev_lora"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDLORA>
			"blocks"?: ComfyNodeTypedInputRef<ComfyValueType_SELECTEDBLOCKS>
			/** Load the LORA model with less VRAM usage, slower loading. This affects ALL LoRAs, not just the current one. No effect if merge_loras is False*/
			"low_mem_load"?: ComfyNodeTypedInputRef<boolean>
			/** Merge LoRAs into the model, otherwise they are loaded on the fly. Always disabled for GGUF and scaled fp8 models. This affects ALL LoRAs, not just the current one*/
			"merge_loras"?: ComfyNodeTypedInputRef<boolean>
			"unique_id"?: ComfyNodeTypedInputRef<ComfyValueType_U>
}


export class WanVideoLoraSelectByName extends ComfyNode {
	classType: string = "WanVideoLoraSelectByName"

	sockets: {
		inputs: Required<WanVideoLoraSelectByNameInputs>
		outputs: {
			lora: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDLORA>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"lora_name": new ComfyNodeTypedInputRef<string>(this, "lora_name"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"prev_lora": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDLORA>(this, "prev_lora"),
				"blocks": new ComfyNodeTypedInputRef<ComfyValueType_SELECTEDBLOCKS>(this, "blocks"),
				"low_mem_load": new ComfyNodeTypedInputRef<boolean>(this, "low_mem_load"),
				"merge_loras": new ComfyNodeTypedInputRef<boolean>(this, "merge_loras"),
				"unique_id": new ComfyNodeTypedInputRef<ComfyValueType_U>(this, "unique_id"),
			},
			outputs: Object.create(Object.prototype, {
				"lora": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoLoraSelectByNameInputs>) {
		if (typeof sources["lora_name"] === "object") {
			this.sockets.inputs["lora_name"].connectTo(sources["lora_name"])
		} else {
			this.sockets.inputs["lora_name"].value = sources["lora_name"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (sources["prev_lora"] !== undefined) {
		if (typeof sources["prev_lora"] === "object") {
			this.sockets.inputs["prev_lora"].connectTo(sources["prev_lora"])
		} else {
			this.sockets.inputs["prev_lora"].value = sources["prev_lora"]
		}
		}

		if (sources["blocks"] !== undefined) {
		if (typeof sources["blocks"] === "object") {
			this.sockets.inputs["blocks"].connectTo(sources["blocks"])
		} else {
			this.sockets.inputs["blocks"].value = sources["blocks"]
		}
		}

		if (sources["low_mem_load"] !== undefined) {
		if (typeof sources["low_mem_load"] === "object") {
			this.sockets.inputs["low_mem_load"].connectTo(sources["low_mem_load"])
		} else {
			this.sockets.inputs["low_mem_load"].value = sources["low_mem_load"]
		}
		}

		if (sources["merge_loras"] !== undefined) {
		if (typeof sources["merge_loras"] === "object") {
			this.sockets.inputs["merge_loras"].connectTo(sources["merge_loras"])
		} else {
			this.sockets.inputs["merge_loras"].value = sources["merge_loras"]
		}
		}

		if (sources["unique_id"] !== undefined) {
		if (typeof sources["unique_id"] === "object") {
			this.sockets.inputs["unique_id"].connectTo(sources["unique_id"])
		} else {
			this.sockets.inputs["unique_id"].value = sources["unique_id"]
		}
		}

	}
}

type WanVideoLoraSelectByNameInputs = {
			/** Lora filename to load*/
			"lora_name": ComfyNodeTypedInputRef<string>
			/** LORA strength, set to 0.0 to unmerge the LORA*/
			"strength": ComfyNodeTypedInputRef<number>
			/** For loading multiple LoRAs*/
			"prev_lora"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDLORA>
			"blocks"?: ComfyNodeTypedInputRef<ComfyValueType_SELECTEDBLOCKS>
			/** Load the LORA model with less VRAM usage, slower loading. This affects ALL LoRAs, not just the current one. No effect if merge_loras is False*/
			"low_mem_load"?: ComfyNodeTypedInputRef<boolean>
			/** Merge LoRAs into the model, otherwise they are loaded on the fly. Always disabled for GGUF and scaled fp8 models. This affects ALL LoRAs, not just the current one*/
			"merge_loras"?: ComfyNodeTypedInputRef<boolean>
			"unique_id"?: ComfyNodeTypedInputRef<ComfyValueType_U>
}


export class WanVideoSetLoRAs extends ComfyNode {
	classType: string = "WanVideoSetLoRAs"

	sockets: {
		inputs: Required<WanVideoSetLoRAsInputs>
		outputs: {
			model: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOMODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>(this, "model"),
				"lora": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDLORA>(this, "lora"),
			},
			outputs: Object.create(Object.prototype, {
				"model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoSetLoRAsInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (sources["lora"] !== undefined) {
		if (typeof sources["lora"] === "object") {
			this.sockets.inputs["lora"].connectTo(sources["lora"])
		} else {
			this.sockets.inputs["lora"].value = sources["lora"]
		}
		}

	}
}

type WanVideoSetLoRAsInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>
			"lora"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDLORA>
}


export class WanVideoLoraBlockEdit extends ComfyNode {
	classType: string = "WanVideoLoraBlockEdit"

	sockets: {
		inputs: Required<WanVideoLoraBlockEditInputs>
		outputs: {
			/** The modified lora model*/
			blocks: ComfyNodeTypedSourceRef<ComfyValueType_SELECTEDBLOCKS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"blocks.0.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.0."),
				"blocks.1.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.1."),
				"blocks.2.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.2."),
				"blocks.3.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.3."),
				"blocks.4.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.4."),
				"blocks.5.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.5."),
				"blocks.6.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.6."),
				"blocks.7.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.7."),
				"blocks.8.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.8."),
				"blocks.9.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.9."),
				"blocks.10.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.10."),
				"blocks.11.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.11."),
				"blocks.12.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.12."),
				"blocks.13.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.13."),
				"blocks.14.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.14."),
				"blocks.15.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.15."),
				"blocks.16.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.16."),
				"blocks.17.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.17."),
				"blocks.18.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.18."),
				"blocks.19.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.19."),
				"blocks.20.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.20."),
				"blocks.21.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.21."),
				"blocks.22.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.22."),
				"blocks.23.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.23."),
				"blocks.24.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.24."),
				"blocks.25.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.25."),
				"blocks.26.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.26."),
				"blocks.27.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.27."),
				"blocks.28.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.28."),
				"blocks.29.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.29."),
				"blocks.30.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.30."),
				"blocks.31.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.31."),
				"blocks.32.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.32."),
				"blocks.33.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.33."),
				"blocks.34.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.34."),
				"blocks.35.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.35."),
				"blocks.36.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.36."),
				"blocks.37.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.37."),
				"blocks.38.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.38."),
				"blocks.39.": new ComfyNodeTypedInputRef<boolean>(this, "blocks.39."),
				"layer_filter": new ComfyNodeTypedInputRef<string>(this, "layer_filter"),
			},
			outputs: Object.create(Object.prototype, {
				"blocks": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoLoraBlockEditInputs>) {
		if (typeof sources["blocks.0."] === "object") {
			this.sockets.inputs["blocks.0."].connectTo(sources["blocks.0."])
		} else {
			this.sockets.inputs["blocks.0."].value = sources["blocks.0."]
		}

		if (typeof sources["blocks.1."] === "object") {
			this.sockets.inputs["blocks.1."].connectTo(sources["blocks.1."])
		} else {
			this.sockets.inputs["blocks.1."].value = sources["blocks.1."]
		}

		if (typeof sources["blocks.2."] === "object") {
			this.sockets.inputs["blocks.2."].connectTo(sources["blocks.2."])
		} else {
			this.sockets.inputs["blocks.2."].value = sources["blocks.2."]
		}

		if (typeof sources["blocks.3."] === "object") {
			this.sockets.inputs["blocks.3."].connectTo(sources["blocks.3."])
		} else {
			this.sockets.inputs["blocks.3."].value = sources["blocks.3."]
		}

		if (typeof sources["blocks.4."] === "object") {
			this.sockets.inputs["blocks.4."].connectTo(sources["blocks.4."])
		} else {
			this.sockets.inputs["blocks.4."].value = sources["blocks.4."]
		}

		if (typeof sources["blocks.5."] === "object") {
			this.sockets.inputs["blocks.5."].connectTo(sources["blocks.5."])
		} else {
			this.sockets.inputs["blocks.5."].value = sources["blocks.5."]
		}

		if (typeof sources["blocks.6."] === "object") {
			this.sockets.inputs["blocks.6."].connectTo(sources["blocks.6."])
		} else {
			this.sockets.inputs["blocks.6."].value = sources["blocks.6."]
		}

		if (typeof sources["blocks.7."] === "object") {
			this.sockets.inputs["blocks.7."].connectTo(sources["blocks.7."])
		} else {
			this.sockets.inputs["blocks.7."].value = sources["blocks.7."]
		}

		if (typeof sources["blocks.8."] === "object") {
			this.sockets.inputs["blocks.8."].connectTo(sources["blocks.8."])
		} else {
			this.sockets.inputs["blocks.8."].value = sources["blocks.8."]
		}

		if (typeof sources["blocks.9."] === "object") {
			this.sockets.inputs["blocks.9."].connectTo(sources["blocks.9."])
		} else {
			this.sockets.inputs["blocks.9."].value = sources["blocks.9."]
		}

		if (typeof sources["blocks.10."] === "object") {
			this.sockets.inputs["blocks.10."].connectTo(sources["blocks.10."])
		} else {
			this.sockets.inputs["blocks.10."].value = sources["blocks.10."]
		}

		if (typeof sources["blocks.11."] === "object") {
			this.sockets.inputs["blocks.11."].connectTo(sources["blocks.11."])
		} else {
			this.sockets.inputs["blocks.11."].value = sources["blocks.11."]
		}

		if (typeof sources["blocks.12."] === "object") {
			this.sockets.inputs["blocks.12."].connectTo(sources["blocks.12."])
		} else {
			this.sockets.inputs["blocks.12."].value = sources["blocks.12."]
		}

		if (typeof sources["blocks.13."] === "object") {
			this.sockets.inputs["blocks.13."].connectTo(sources["blocks.13."])
		} else {
			this.sockets.inputs["blocks.13."].value = sources["blocks.13."]
		}

		if (typeof sources["blocks.14."] === "object") {
			this.sockets.inputs["blocks.14."].connectTo(sources["blocks.14."])
		} else {
			this.sockets.inputs["blocks.14."].value = sources["blocks.14."]
		}

		if (typeof sources["blocks.15."] === "object") {
			this.sockets.inputs["blocks.15."].connectTo(sources["blocks.15."])
		} else {
			this.sockets.inputs["blocks.15."].value = sources["blocks.15."]
		}

		if (typeof sources["blocks.16."] === "object") {
			this.sockets.inputs["blocks.16."].connectTo(sources["blocks.16."])
		} else {
			this.sockets.inputs["blocks.16."].value = sources["blocks.16."]
		}

		if (typeof sources["blocks.17."] === "object") {
			this.sockets.inputs["blocks.17."].connectTo(sources["blocks.17."])
		} else {
			this.sockets.inputs["blocks.17."].value = sources["blocks.17."]
		}

		if (typeof sources["blocks.18."] === "object") {
			this.sockets.inputs["blocks.18."].connectTo(sources["blocks.18."])
		} else {
			this.sockets.inputs["blocks.18."].value = sources["blocks.18."]
		}

		if (typeof sources["blocks.19."] === "object") {
			this.sockets.inputs["blocks.19."].connectTo(sources["blocks.19."])
		} else {
			this.sockets.inputs["blocks.19."].value = sources["blocks.19."]
		}

		if (typeof sources["blocks.20."] === "object") {
			this.sockets.inputs["blocks.20."].connectTo(sources["blocks.20."])
		} else {
			this.sockets.inputs["blocks.20."].value = sources["blocks.20."]
		}

		if (typeof sources["blocks.21."] === "object") {
			this.sockets.inputs["blocks.21."].connectTo(sources["blocks.21."])
		} else {
			this.sockets.inputs["blocks.21."].value = sources["blocks.21."]
		}

		if (typeof sources["blocks.22."] === "object") {
			this.sockets.inputs["blocks.22."].connectTo(sources["blocks.22."])
		} else {
			this.sockets.inputs["blocks.22."].value = sources["blocks.22."]
		}

		if (typeof sources["blocks.23."] === "object") {
			this.sockets.inputs["blocks.23."].connectTo(sources["blocks.23."])
		} else {
			this.sockets.inputs["blocks.23."].value = sources["blocks.23."]
		}

		if (typeof sources["blocks.24."] === "object") {
			this.sockets.inputs["blocks.24."].connectTo(sources["blocks.24."])
		} else {
			this.sockets.inputs["blocks.24."].value = sources["blocks.24."]
		}

		if (typeof sources["blocks.25."] === "object") {
			this.sockets.inputs["blocks.25."].connectTo(sources["blocks.25."])
		} else {
			this.sockets.inputs["blocks.25."].value = sources["blocks.25."]
		}

		if (typeof sources["blocks.26."] === "object") {
			this.sockets.inputs["blocks.26."].connectTo(sources["blocks.26."])
		} else {
			this.sockets.inputs["blocks.26."].value = sources["blocks.26."]
		}

		if (typeof sources["blocks.27."] === "object") {
			this.sockets.inputs["blocks.27."].connectTo(sources["blocks.27."])
		} else {
			this.sockets.inputs["blocks.27."].value = sources["blocks.27."]
		}

		if (typeof sources["blocks.28."] === "object") {
			this.sockets.inputs["blocks.28."].connectTo(sources["blocks.28."])
		} else {
			this.sockets.inputs["blocks.28."].value = sources["blocks.28."]
		}

		if (typeof sources["blocks.29."] === "object") {
			this.sockets.inputs["blocks.29."].connectTo(sources["blocks.29."])
		} else {
			this.sockets.inputs["blocks.29."].value = sources["blocks.29."]
		}

		if (typeof sources["blocks.30."] === "object") {
			this.sockets.inputs["blocks.30."].connectTo(sources["blocks.30."])
		} else {
			this.sockets.inputs["blocks.30."].value = sources["blocks.30."]
		}

		if (typeof sources["blocks.31."] === "object") {
			this.sockets.inputs["blocks.31."].connectTo(sources["blocks.31."])
		} else {
			this.sockets.inputs["blocks.31."].value = sources["blocks.31."]
		}

		if (typeof sources["blocks.32."] === "object") {
			this.sockets.inputs["blocks.32."].connectTo(sources["blocks.32."])
		} else {
			this.sockets.inputs["blocks.32."].value = sources["blocks.32."]
		}

		if (typeof sources["blocks.33."] === "object") {
			this.sockets.inputs["blocks.33."].connectTo(sources["blocks.33."])
		} else {
			this.sockets.inputs["blocks.33."].value = sources["blocks.33."]
		}

		if (typeof sources["blocks.34."] === "object") {
			this.sockets.inputs["blocks.34."].connectTo(sources["blocks.34."])
		} else {
			this.sockets.inputs["blocks.34."].value = sources["blocks.34."]
		}

		if (typeof sources["blocks.35."] === "object") {
			this.sockets.inputs["blocks.35."].connectTo(sources["blocks.35."])
		} else {
			this.sockets.inputs["blocks.35."].value = sources["blocks.35."]
		}

		if (typeof sources["blocks.36."] === "object") {
			this.sockets.inputs["blocks.36."].connectTo(sources["blocks.36."])
		} else {
			this.sockets.inputs["blocks.36."].value = sources["blocks.36."]
		}

		if (typeof sources["blocks.37."] === "object") {
			this.sockets.inputs["blocks.37."].connectTo(sources["blocks.37."])
		} else {
			this.sockets.inputs["blocks.37."].value = sources["blocks.37."]
		}

		if (typeof sources["blocks.38."] === "object") {
			this.sockets.inputs["blocks.38."].connectTo(sources["blocks.38."])
		} else {
			this.sockets.inputs["blocks.38."].value = sources["blocks.38."]
		}

		if (typeof sources["blocks.39."] === "object") {
			this.sockets.inputs["blocks.39."].connectTo(sources["blocks.39."])
		} else {
			this.sockets.inputs["blocks.39."].value = sources["blocks.39."]
		}

		if (sources["layer_filter"] !== undefined) {
		if (typeof sources["layer_filter"] === "object") {
			this.sockets.inputs["layer_filter"].connectTo(sources["layer_filter"])
		} else {
			this.sockets.inputs["layer_filter"].value = sources["layer_filter"]
		}
		}

	}
}

type WanVideoLoraBlockEditInputs = {
			"blocks.0.": ComfyNodeTypedInputRef<boolean>
			"blocks.1.": ComfyNodeTypedInputRef<boolean>
			"blocks.2.": ComfyNodeTypedInputRef<boolean>
			"blocks.3.": ComfyNodeTypedInputRef<boolean>
			"blocks.4.": ComfyNodeTypedInputRef<boolean>
			"blocks.5.": ComfyNodeTypedInputRef<boolean>
			"blocks.6.": ComfyNodeTypedInputRef<boolean>
			"blocks.7.": ComfyNodeTypedInputRef<boolean>
			"blocks.8.": ComfyNodeTypedInputRef<boolean>
			"blocks.9.": ComfyNodeTypedInputRef<boolean>
			"blocks.10.": ComfyNodeTypedInputRef<boolean>
			"blocks.11.": ComfyNodeTypedInputRef<boolean>
			"blocks.12.": ComfyNodeTypedInputRef<boolean>
			"blocks.13.": ComfyNodeTypedInputRef<boolean>
			"blocks.14.": ComfyNodeTypedInputRef<boolean>
			"blocks.15.": ComfyNodeTypedInputRef<boolean>
			"blocks.16.": ComfyNodeTypedInputRef<boolean>
			"blocks.17.": ComfyNodeTypedInputRef<boolean>
			"blocks.18.": ComfyNodeTypedInputRef<boolean>
			"blocks.19.": ComfyNodeTypedInputRef<boolean>
			"blocks.20.": ComfyNodeTypedInputRef<boolean>
			"blocks.21.": ComfyNodeTypedInputRef<boolean>
			"blocks.22.": ComfyNodeTypedInputRef<boolean>
			"blocks.23.": ComfyNodeTypedInputRef<boolean>
			"blocks.24.": ComfyNodeTypedInputRef<boolean>
			"blocks.25.": ComfyNodeTypedInputRef<boolean>
			"blocks.26.": ComfyNodeTypedInputRef<boolean>
			"blocks.27.": ComfyNodeTypedInputRef<boolean>
			"blocks.28.": ComfyNodeTypedInputRef<boolean>
			"blocks.29.": ComfyNodeTypedInputRef<boolean>
			"blocks.30.": ComfyNodeTypedInputRef<boolean>
			"blocks.31.": ComfyNodeTypedInputRef<boolean>
			"blocks.32.": ComfyNodeTypedInputRef<boolean>
			"blocks.33.": ComfyNodeTypedInputRef<boolean>
			"blocks.34.": ComfyNodeTypedInputRef<boolean>
			"blocks.35.": ComfyNodeTypedInputRef<boolean>
			"blocks.36.": ComfyNodeTypedInputRef<boolean>
			"blocks.37.": ComfyNodeTypedInputRef<boolean>
			"blocks.38.": ComfyNodeTypedInputRef<boolean>
			"blocks.39.": ComfyNodeTypedInputRef<boolean>
			"layer_filter"?: ComfyNodeTypedInputRef<string>
}


export class WanVideoTinyVAELoader extends ComfyNode {
	classType: string = "WanVideoTinyVAELoader"

	sockets: {
		inputs: Required<WanVideoTinyVAELoaderInputs>
		outputs: {
			vae: ComfyNodeTypedSourceRef<ComfyValueType_WANVAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_name": new ComfyNodeTypedInputRef<void>(this, "model_name"),
				"precision": new ComfyNodeTypedInputRef<string>(this, "precision"),
				"parallel": new ComfyNodeTypedInputRef<boolean>(this, "parallel"),
			},
			outputs: Object.create(Object.prototype, {
				"vae": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoTinyVAELoaderInputs>) {
		if (typeof sources["model_name"] === "object") {
			this.sockets.inputs["model_name"].connectTo(sources["model_name"])
		} else {
			this.sockets.inputs["model_name"].value = sources["model_name"]
		}

		if (sources["precision"] !== undefined) {
		if (typeof sources["precision"] === "object") {
			this.sockets.inputs["precision"].connectTo(sources["precision"])
		} else {
			this.sockets.inputs["precision"].value = sources["precision"]
		}
		}

		if (sources["parallel"] !== undefined) {
		if (typeof sources["parallel"] === "object") {
			this.sockets.inputs["parallel"].connectTo(sources["parallel"])
		} else {
			this.sockets.inputs["parallel"].value = sources["parallel"]
		}
		}

	}
}

type WanVideoTinyVAELoaderInputs = {
			/** These models are loaded from 'ComfyUI/models/vae_approx'*/
			"model_name": ComfyNodeTypedInputRef<void>
			"precision"?: ComfyNodeTypedInputRef<string>
			/** uses more memory but is faster*/
			"parallel"?: ComfyNodeTypedInputRef<boolean>
}


export class WanVideoVACEModelSelect extends ComfyNode {
	classType: string = "WanVideoVACEModelSelect"

	sockets: {
		inputs: Required<WanVideoVACEModelSelectInputs>
		outputs: {
			extra_model: ComfyNodeTypedSourceRef<ComfyValueType_VACEPATH>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vace_model": new ComfyNodeTypedInputRef<string>(this, "vace_model"),
			},
			outputs: Object.create(Object.prototype, {
				"extra_model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoVACEModelSelectInputs>) {
		if (typeof sources["vace_model"] === "object") {
			this.sockets.inputs["vace_model"].connectTo(sources["vace_model"])
		} else {
			this.sockets.inputs["vace_model"].value = sources["vace_model"]
		}

	}
}

type WanVideoVACEModelSelectInputs = {
			/** These models are loaded from the 'ComfyUI/models/diffusion_models' VACE model to use when not using model that has it included*/
			"vace_model": ComfyNodeTypedInputRef<string>
}


export class WanVideoExtraModelSelect extends ComfyNode {
	classType: string = "WanVideoExtraModelSelect"

	sockets: {
		inputs: Required<WanVideoExtraModelSelectInputs>
		outputs: {
			extra_model: ComfyNodeTypedSourceRef<ComfyValueType_VACEPATH>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"extra_model": new ComfyNodeTypedInputRef<string>(this, "extra_model"),
				"prev_model": new ComfyNodeTypedInputRef<ComfyValueType_VACEPATH>(this, "prev_model"),
			},
			outputs: Object.create(Object.prototype, {
				"extra_model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoExtraModelSelectInputs>) {
		if (typeof sources["extra_model"] === "object") {
			this.sockets.inputs["extra_model"].connectTo(sources["extra_model"])
		} else {
			this.sockets.inputs["extra_model"].value = sources["extra_model"]
		}

		if (sources["prev_model"] !== undefined) {
		if (typeof sources["prev_model"] === "object") {
			this.sockets.inputs["prev_model"].connectTo(sources["prev_model"])
		} else {
			this.sockets.inputs["prev_model"].value = sources["prev_model"]
		}
		}

	}
}

type WanVideoExtraModelSelectInputs = {
			/** These models are loaded from the 'ComfyUI/models/diffusion_models' path to extra state dict to add to the main model*/
			"extra_model": ComfyNodeTypedInputRef<string>
			/** For loading multiple extra models*/
			"prev_model"?: ComfyNodeTypedInputRef<ComfyValueType_VACEPATH>
}


export class WanVideoLoraSelectMulti extends ComfyNode {
	classType: string = "WanVideoLoraSelectMulti"

	sockets: {
		inputs: Required<WanVideoLoraSelectMultiInputs>
		outputs: {
			lora: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDLORA>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"lora_0": new ComfyNodeTypedInputRef<string>(this, "lora_0"),
				"strength_0": new ComfyNodeTypedInputRef<number>(this, "strength_0"),
				"lora_1": new ComfyNodeTypedInputRef<string>(this, "lora_1"),
				"strength_1": new ComfyNodeTypedInputRef<number>(this, "strength_1"),
				"lora_2": new ComfyNodeTypedInputRef<string>(this, "lora_2"),
				"strength_2": new ComfyNodeTypedInputRef<number>(this, "strength_2"),
				"lora_3": new ComfyNodeTypedInputRef<string>(this, "lora_3"),
				"strength_3": new ComfyNodeTypedInputRef<number>(this, "strength_3"),
				"lora_4": new ComfyNodeTypedInputRef<string>(this, "lora_4"),
				"strength_4": new ComfyNodeTypedInputRef<number>(this, "strength_4"),
				"prev_lora": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDLORA>(this, "prev_lora"),
				"blocks": new ComfyNodeTypedInputRef<ComfyValueType_SELECTEDBLOCKS>(this, "blocks"),
				"low_mem_load": new ComfyNodeTypedInputRef<boolean>(this, "low_mem_load"),
				"merge_loras": new ComfyNodeTypedInputRef<boolean>(this, "merge_loras"),
			},
			outputs: Object.create(Object.prototype, {
				"lora": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoLoraSelectMultiInputs>) {
		if (typeof sources["lora_0"] === "object") {
			this.sockets.inputs["lora_0"].connectTo(sources["lora_0"])
		} else {
			this.sockets.inputs["lora_0"].value = sources["lora_0"]
		}

		if (typeof sources["strength_0"] === "object") {
			this.sockets.inputs["strength_0"].connectTo(sources["strength_0"])
		} else {
			this.sockets.inputs["strength_0"].value = sources["strength_0"]
		}

		if (typeof sources["lora_1"] === "object") {
			this.sockets.inputs["lora_1"].connectTo(sources["lora_1"])
		} else {
			this.sockets.inputs["lora_1"].value = sources["lora_1"]
		}

		if (typeof sources["strength_1"] === "object") {
			this.sockets.inputs["strength_1"].connectTo(sources["strength_1"])
		} else {
			this.sockets.inputs["strength_1"].value = sources["strength_1"]
		}

		if (typeof sources["lora_2"] === "object") {
			this.sockets.inputs["lora_2"].connectTo(sources["lora_2"])
		} else {
			this.sockets.inputs["lora_2"].value = sources["lora_2"]
		}

		if (typeof sources["strength_2"] === "object") {
			this.sockets.inputs["strength_2"].connectTo(sources["strength_2"])
		} else {
			this.sockets.inputs["strength_2"].value = sources["strength_2"]
		}

		if (typeof sources["lora_3"] === "object") {
			this.sockets.inputs["lora_3"].connectTo(sources["lora_3"])
		} else {
			this.sockets.inputs["lora_3"].value = sources["lora_3"]
		}

		if (typeof sources["strength_3"] === "object") {
			this.sockets.inputs["strength_3"].connectTo(sources["strength_3"])
		} else {
			this.sockets.inputs["strength_3"].value = sources["strength_3"]
		}

		if (typeof sources["lora_4"] === "object") {
			this.sockets.inputs["lora_4"].connectTo(sources["lora_4"])
		} else {
			this.sockets.inputs["lora_4"].value = sources["lora_4"]
		}

		if (typeof sources["strength_4"] === "object") {
			this.sockets.inputs["strength_4"].connectTo(sources["strength_4"])
		} else {
			this.sockets.inputs["strength_4"].value = sources["strength_4"]
		}

		if (sources["prev_lora"] !== undefined) {
		if (typeof sources["prev_lora"] === "object") {
			this.sockets.inputs["prev_lora"].connectTo(sources["prev_lora"])
		} else {
			this.sockets.inputs["prev_lora"].value = sources["prev_lora"]
		}
		}

		if (sources["blocks"] !== undefined) {
		if (typeof sources["blocks"] === "object") {
			this.sockets.inputs["blocks"].connectTo(sources["blocks"])
		} else {
			this.sockets.inputs["blocks"].value = sources["blocks"]
		}
		}

		if (sources["low_mem_load"] !== undefined) {
		if (typeof sources["low_mem_load"] === "object") {
			this.sockets.inputs["low_mem_load"].connectTo(sources["low_mem_load"])
		} else {
			this.sockets.inputs["low_mem_load"].value = sources["low_mem_load"]
		}
		}

		if (sources["merge_loras"] !== undefined) {
		if (typeof sources["merge_loras"] === "object") {
			this.sockets.inputs["merge_loras"].connectTo(sources["merge_loras"])
		} else {
			this.sockets.inputs["merge_loras"].value = sources["merge_loras"]
		}
		}

	}
}

type WanVideoLoraSelectMultiInputs = {
			"lora_0": ComfyNodeTypedInputRef<string>
			/** LORA strength, set to 0.0 to unmerge the LORA*/
			"strength_0": ComfyNodeTypedInputRef<number>
			"lora_1": ComfyNodeTypedInputRef<string>
			/** LORA strength, set to 0.0 to unmerge the LORA*/
			"strength_1": ComfyNodeTypedInputRef<number>
			"lora_2": ComfyNodeTypedInputRef<string>
			/** LORA strength, set to 0.0 to unmerge the LORA*/
			"strength_2": ComfyNodeTypedInputRef<number>
			"lora_3": ComfyNodeTypedInputRef<string>
			/** LORA strength, set to 0.0 to unmerge the LORA*/
			"strength_3": ComfyNodeTypedInputRef<number>
			"lora_4": ComfyNodeTypedInputRef<string>
			/** LORA strength, set to 0.0 to unmerge the LORA*/
			"strength_4": ComfyNodeTypedInputRef<number>
			/** For loading multiple LoRAs*/
			"prev_lora"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDLORA>
			"blocks"?: ComfyNodeTypedInputRef<ComfyValueType_SELECTEDBLOCKS>
			/** Load the LORA model with less VRAM usage, slower loading. No effect if merge_loras is False*/
			"low_mem_load"?: ComfyNodeTypedInputRef<boolean>
			/** Merge LoRAs into the model, otherwise they are loaded on the fly. Always disabled for GGUF and scaled fp8 models. This affects ALL LoRAs, not just the current one*/
			"merge_loras"?: ComfyNodeTypedInputRef<boolean>
}


export class WanVideoBlockSwap extends ComfyNode {
	classType: string = "WanVideoBlockSwap"

	sockets: {
		inputs: Required<WanVideoBlockSwapInputs>
		outputs: {
			block_swap_args: ComfyNodeTypedSourceRef<ComfyValueType_BLOCKSWAPARGS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"blocks_to_swap": new ComfyNodeTypedInputRef<number>(this, "blocks_to_swap"),
				"offload_img_emb": new ComfyNodeTypedInputRef<boolean>(this, "offload_img_emb"),
				"offload_txt_emb": new ComfyNodeTypedInputRef<boolean>(this, "offload_txt_emb"),
				"use_non_blocking": new ComfyNodeTypedInputRef<boolean>(this, "use_non_blocking"),
				"vace_blocks_to_swap": new ComfyNodeTypedInputRef<number>(this, "vace_blocks_to_swap"),
				"prefetch_blocks": new ComfyNodeTypedInputRef<number>(this, "prefetch_blocks"),
				"block_swap_debug": new ComfyNodeTypedInputRef<boolean>(this, "block_swap_debug"),
			},
			outputs: Object.create(Object.prototype, {
				"block_swap_args": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoBlockSwapInputs>) {
		if (typeof sources["blocks_to_swap"] === "object") {
			this.sockets.inputs["blocks_to_swap"].connectTo(sources["blocks_to_swap"])
		} else {
			this.sockets.inputs["blocks_to_swap"].value = sources["blocks_to_swap"]
		}

		if (typeof sources["offload_img_emb"] === "object") {
			this.sockets.inputs["offload_img_emb"].connectTo(sources["offload_img_emb"])
		} else {
			this.sockets.inputs["offload_img_emb"].value = sources["offload_img_emb"]
		}

		if (typeof sources["offload_txt_emb"] === "object") {
			this.sockets.inputs["offload_txt_emb"].connectTo(sources["offload_txt_emb"])
		} else {
			this.sockets.inputs["offload_txt_emb"].value = sources["offload_txt_emb"]
		}

		if (sources["use_non_blocking"] !== undefined) {
		if (typeof sources["use_non_blocking"] === "object") {
			this.sockets.inputs["use_non_blocking"].connectTo(sources["use_non_blocking"])
		} else {
			this.sockets.inputs["use_non_blocking"].value = sources["use_non_blocking"]
		}
		}

		if (sources["vace_blocks_to_swap"] !== undefined) {
		if (typeof sources["vace_blocks_to_swap"] === "object") {
			this.sockets.inputs["vace_blocks_to_swap"].connectTo(sources["vace_blocks_to_swap"])
		} else {
			this.sockets.inputs["vace_blocks_to_swap"].value = sources["vace_blocks_to_swap"]
		}
		}

		if (sources["prefetch_blocks"] !== undefined) {
		if (typeof sources["prefetch_blocks"] === "object") {
			this.sockets.inputs["prefetch_blocks"].connectTo(sources["prefetch_blocks"])
		} else {
			this.sockets.inputs["prefetch_blocks"].value = sources["prefetch_blocks"]
		}
		}

		if (sources["block_swap_debug"] !== undefined) {
		if (typeof sources["block_swap_debug"] === "object") {
			this.sockets.inputs["block_swap_debug"].connectTo(sources["block_swap_debug"])
		} else {
			this.sockets.inputs["block_swap_debug"].value = sources["block_swap_debug"]
		}
		}

	}
}

type WanVideoBlockSwapInputs = {
			/** Number of transformer blocks to swap, the 14B model has 40, while the 1.3B and 5B models have 30 blocks. LongCat-video has 48*/
			"blocks_to_swap": ComfyNodeTypedInputRef<number>
			/** Offload img_emb to offload_device*/
			"offload_img_emb": ComfyNodeTypedInputRef<boolean>
			/** Offload time_emb to offload_device*/
			"offload_txt_emb": ComfyNodeTypedInputRef<boolean>
			/** Use non-blocking memory transfer for offloading, reserves more RAM but is faster*/
			"use_non_blocking"?: ComfyNodeTypedInputRef<boolean>
			/** Number of VACE blocks to swap, the VACE model has 15 blocks*/
			"vace_blocks_to_swap"?: ComfyNodeTypedInputRef<number>
			/** Number of blocks to prefetch ahead, can speed up processing but increases memory usage. 1 is usually enough to offset speed loss from block swapping, use the debug option to confirm it for your system*/
			"prefetch_blocks"?: ComfyNodeTypedInputRef<number>
			/** Enable debug logging for block swapping*/
			"block_swap_debug"?: ComfyNodeTypedInputRef<boolean>
}


export class WanVideoVRAMManagement extends ComfyNode {
	classType: string = "WanVideoVRAMManagement"

	sockets: {
		inputs: Required<WanVideoVRAMManagementInputs>
		outputs: {
			vram_management_args: ComfyNodeTypedSourceRef<ComfyValueType_VRAM_MANAGEMENTARGS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"offload_percent": new ComfyNodeTypedInputRef<number>(this, "offload_percent"),
			},
			outputs: Object.create(Object.prototype, {
				"vram_management_args": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoVRAMManagementInputs>) {
		if (typeof sources["offload_percent"] === "object") {
			this.sockets.inputs["offload_percent"].connectTo(sources["offload_percent"])
		} else {
			this.sockets.inputs["offload_percent"].value = sources["offload_percent"]
		}

	}
}

type WanVideoVRAMManagementInputs = {
			/** Percentage of parameters to offload*/
			"offload_percent": ComfyNodeTypedInputRef<number>
}


export class WanVideoTorchCompileSettings extends ComfyNode {
	classType: string = "WanVideoTorchCompileSettings"

	sockets: {
		inputs: Required<WanVideoTorchCompileSettingsInputs>
		outputs: {
			torch_compile_args: ComfyNodeTypedSourceRef<ComfyValueType_WANCOMPILEARGS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"backend": new ComfyNodeTypedInputRef<string>(this, "backend"),
				"fullgraph": new ComfyNodeTypedInputRef<boolean>(this, "fullgraph"),
				"mode": new ComfyNodeTypedInputRef<string>(this, "mode"),
				"dynamic": new ComfyNodeTypedInputRef<boolean>(this, "dynamic"),
				"dynamo_cache_size_limit": new ComfyNodeTypedInputRef<number>(this, "dynamo_cache_size_limit"),
				"compile_transformer_blocks_only": new ComfyNodeTypedInputRef<boolean>(this, "compile_transformer_blocks_only"),
				"dynamo_recompile_limit": new ComfyNodeTypedInputRef<number>(this, "dynamo_recompile_limit"),
				"force_parameter_static_shapes": new ComfyNodeTypedInputRef<boolean>(this, "force_parameter_static_shapes"),
				"allow_unmerged_lora_compile": new ComfyNodeTypedInputRef<boolean>(this, "allow_unmerged_lora_compile"),
			},
			outputs: Object.create(Object.prototype, {
				"torch_compile_args": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoTorchCompileSettingsInputs>) {
		if (typeof sources["backend"] === "object") {
			this.sockets.inputs["backend"].connectTo(sources["backend"])
		} else {
			this.sockets.inputs["backend"].value = sources["backend"]
		}

		if (typeof sources["fullgraph"] === "object") {
			this.sockets.inputs["fullgraph"].connectTo(sources["fullgraph"])
		} else {
			this.sockets.inputs["fullgraph"].value = sources["fullgraph"]
		}

		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}

		if (typeof sources["dynamic"] === "object") {
			this.sockets.inputs["dynamic"].connectTo(sources["dynamic"])
		} else {
			this.sockets.inputs["dynamic"].value = sources["dynamic"]
		}

		if (typeof sources["dynamo_cache_size_limit"] === "object") {
			this.sockets.inputs["dynamo_cache_size_limit"].connectTo(sources["dynamo_cache_size_limit"])
		} else {
			this.sockets.inputs["dynamo_cache_size_limit"].value = sources["dynamo_cache_size_limit"]
		}

		if (typeof sources["compile_transformer_blocks_only"] === "object") {
			this.sockets.inputs["compile_transformer_blocks_only"].connectTo(sources["compile_transformer_blocks_only"])
		} else {
			this.sockets.inputs["compile_transformer_blocks_only"].value = sources["compile_transformer_blocks_only"]
		}

		if (sources["dynamo_recompile_limit"] !== undefined) {
		if (typeof sources["dynamo_recompile_limit"] === "object") {
			this.sockets.inputs["dynamo_recompile_limit"].connectTo(sources["dynamo_recompile_limit"])
		} else {
			this.sockets.inputs["dynamo_recompile_limit"].value = sources["dynamo_recompile_limit"]
		}
		}

		if (sources["force_parameter_static_shapes"] !== undefined) {
		if (typeof sources["force_parameter_static_shapes"] === "object") {
			this.sockets.inputs["force_parameter_static_shapes"].connectTo(sources["force_parameter_static_shapes"])
		} else {
			this.sockets.inputs["force_parameter_static_shapes"].value = sources["force_parameter_static_shapes"]
		}
		}

		if (sources["allow_unmerged_lora_compile"] !== undefined) {
		if (typeof sources["allow_unmerged_lora_compile"] === "object") {
			this.sockets.inputs["allow_unmerged_lora_compile"].connectTo(sources["allow_unmerged_lora_compile"])
		} else {
			this.sockets.inputs["allow_unmerged_lora_compile"].value = sources["allow_unmerged_lora_compile"]
		}
		}

	}
}

type WanVideoTorchCompileSettingsInputs = {
			"backend": ComfyNodeTypedInputRef<string>
			/** Enable full graph mode*/
			"fullgraph": ComfyNodeTypedInputRef<boolean>
			"mode": ComfyNodeTypedInputRef<string>
			/** Enable dynamic mode*/
			"dynamic": ComfyNodeTypedInputRef<boolean>
			/** torch._dynamo.config.cache_size_limit*/
			"dynamo_cache_size_limit": ComfyNodeTypedInputRef<number>
			/** Compile only the transformer blocks, usually enough and can make compilation faster and less error prone*/
			"compile_transformer_blocks_only": ComfyNodeTypedInputRef<boolean>
			/** torch._dynamo.config.recompile_limit*/
			"dynamo_recompile_limit"?: ComfyNodeTypedInputRef<number>
			/** torch._dynamo.config.force_parameter_static_shapes*/
			"force_parameter_static_shapes"?: ComfyNodeTypedInputRef<boolean>
			/** Allow LoRA application to be compiled with torch.compile to avoid graph breaks, causes issues with some LoRAs, mostly dynamic ones*/
			"allow_unmerged_lora_compile"?: ComfyNodeTypedInputRef<boolean>
}


export class LoadWanVideoT5TextEncoder extends ComfyNode {
	classType: string = "LoadWanVideoT5TextEncoder"

	sockets: {
		inputs: Required<LoadWanVideoT5TextEncoderInputs>
		outputs: {
			wan_t5_model: ComfyNodeTypedSourceRef<ComfyValueType_WANTEXTENCODER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_name": new ComfyNodeTypedInputRef<string>(this, "model_name"),
				"precision": new ComfyNodeTypedInputRef<string>(this, "precision"),
				"load_device": new ComfyNodeTypedInputRef<string>(this, "load_device"),
				"quantization": new ComfyNodeTypedInputRef<string>(this, "quantization"),
			},
			outputs: Object.create(Object.prototype, {
				"wan_t5_model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoadWanVideoT5TextEncoderInputs>) {
		if (typeof sources["model_name"] === "object") {
			this.sockets.inputs["model_name"].connectTo(sources["model_name"])
		} else {
			this.sockets.inputs["model_name"].value = sources["model_name"]
		}

		if (typeof sources["precision"] === "object") {
			this.sockets.inputs["precision"].connectTo(sources["precision"])
		} else {
			this.sockets.inputs["precision"].value = sources["precision"]
		}

		if (sources["load_device"] !== undefined) {
		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}
		}

		if (sources["quantization"] !== undefined) {
		if (typeof sources["quantization"] === "object") {
			this.sockets.inputs["quantization"].connectTo(sources["quantization"])
		} else {
			this.sockets.inputs["quantization"].value = sources["quantization"]
		}
		}

	}
}

type LoadWanVideoT5TextEncoderInputs = {
			/** These models are loaded from 'ComfyUI/models/text_encoders'*/
			"model_name": ComfyNodeTypedInputRef<string>
			"precision": ComfyNodeTypedInputRef<string>
			"load_device"?: ComfyNodeTypedInputRef<string>
			/** optional quantization method*/
			"quantization"?: ComfyNodeTypedInputRef<string>
}


export class LoadWanVideoClipTextEncoder extends ComfyNode {
	classType: string = "LoadWanVideoClipTextEncoder"

	sockets: {
		inputs: Required<LoadWanVideoClipTextEncoderInputs>
		outputs: {
			wan_clip_vision: ComfyNodeTypedSourceRef<ComfyValueType_CLIP_VISION>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_name": new ComfyNodeTypedInputRef<string>(this, "model_name"),
				"precision": new ComfyNodeTypedInputRef<string>(this, "precision"),
				"load_device": new ComfyNodeTypedInputRef<string>(this, "load_device"),
			},
			outputs: Object.create(Object.prototype, {
				"wan_clip_vision": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoadWanVideoClipTextEncoderInputs>) {
		if (typeof sources["model_name"] === "object") {
			this.sockets.inputs["model_name"].connectTo(sources["model_name"])
		} else {
			this.sockets.inputs["model_name"].value = sources["model_name"]
		}

		if (typeof sources["precision"] === "object") {
			this.sockets.inputs["precision"].connectTo(sources["precision"])
		} else {
			this.sockets.inputs["precision"].value = sources["precision"]
		}

		if (sources["load_device"] !== undefined) {
		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}
		}

	}
}

type LoadWanVideoClipTextEncoderInputs = {
			/** These models are loaded from 'ComfyUI/models/clip_vision'*/
			"model_name": ComfyNodeTypedInputRef<string>
			"precision": ComfyNodeTypedInputRef<string>
			"load_device"?: ComfyNodeTypedInputRef<string>
}


export class WanVideoImageResizeToClosest extends ComfyNode {
	classType: string = "WanVideoImageResizeToClosest"

	sockets: {
		inputs: Required<WanVideoImageResizeToClosestInputs>
		outputs: {
			image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			width: ComfyNodeTypedSourceRef<number>
			height: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"generation_width": new ComfyNodeTypedInputRef<number>(this, "generation_width"),
				"generation_height": new ComfyNodeTypedInputRef<number>(this, "generation_height"),
				"aspect_ratio_preservation": new ComfyNodeTypedInputRef<string>(this, "aspect_ratio_preservation"),
			},
			outputs: Object.create(Object.prototype, {
				"image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoImageResizeToClosestInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["generation_width"] === "object") {
			this.sockets.inputs["generation_width"].connectTo(sources["generation_width"])
		} else {
			this.sockets.inputs["generation_width"].value = sources["generation_width"]
		}

		if (typeof sources["generation_height"] === "object") {
			this.sockets.inputs["generation_height"].connectTo(sources["generation_height"])
		} else {
			this.sockets.inputs["generation_height"].value = sources["generation_height"]
		}

		if (typeof sources["aspect_ratio_preservation"] === "object") {
			this.sockets.inputs["aspect_ratio_preservation"].connectTo(sources["aspect_ratio_preservation"])
		} else {
			this.sockets.inputs["aspect_ratio_preservation"].value = sources["aspect_ratio_preservation"]
		}

	}
}

type WanVideoImageResizeToClosestInputs = {
			/** Image to resize*/
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Width of the image to encode*/
			"generation_width": ComfyNodeTypedInputRef<number>
			/** Height of the image to encode*/
			"generation_height": ComfyNodeTypedInputRef<number>
			"aspect_ratio_preservation": ComfyNodeTypedInputRef<string>
}


export class WanVideoVACEStartToEndFrame extends ComfyNode {
	classType: string = "WanVideoVACEStartToEndFrame"

	sockets: {
		inputs: Required<WanVideoVACEStartToEndFrameInputs>
		outputs: {
			images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			masks: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"num_frames": new ComfyNodeTypedInputRef<number>(this, "num_frames"),
				"empty_frame_level": new ComfyNodeTypedInputRef<number>(this, "empty_frame_level"),
				"start_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "start_image"),
				"end_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "end_image"),
				"control_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "control_images"),
				"inpaint_mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "inpaint_mask"),
				"start_index": new ComfyNodeTypedInputRef<number>(this, "start_index"),
				"end_index": new ComfyNodeTypedInputRef<number>(this, "end_index"),
			},
			outputs: Object.create(Object.prototype, {
				"images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"masks": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoVACEStartToEndFrameInputs>) {
		if (typeof sources["num_frames"] === "object") {
			this.sockets.inputs["num_frames"].connectTo(sources["num_frames"])
		} else {
			this.sockets.inputs["num_frames"].value = sources["num_frames"]
		}

		if (typeof sources["empty_frame_level"] === "object") {
			this.sockets.inputs["empty_frame_level"].connectTo(sources["empty_frame_level"])
		} else {
			this.sockets.inputs["empty_frame_level"].value = sources["empty_frame_level"]
		}

		if (sources["start_image"] !== undefined) {
		if (typeof sources["start_image"] === "object") {
			this.sockets.inputs["start_image"].connectTo(sources["start_image"])
		} else {
			this.sockets.inputs["start_image"].value = sources["start_image"]
		}
		}

		if (sources["end_image"] !== undefined) {
		if (typeof sources["end_image"] === "object") {
			this.sockets.inputs["end_image"].connectTo(sources["end_image"])
		} else {
			this.sockets.inputs["end_image"].value = sources["end_image"]
		}
		}

		if (sources["control_images"] !== undefined) {
		if (typeof sources["control_images"] === "object") {
			this.sockets.inputs["control_images"].connectTo(sources["control_images"])
		} else {
			this.sockets.inputs["control_images"].value = sources["control_images"]
		}
		}

		if (sources["inpaint_mask"] !== undefined) {
		if (typeof sources["inpaint_mask"] === "object") {
			this.sockets.inputs["inpaint_mask"].connectTo(sources["inpaint_mask"])
		} else {
			this.sockets.inputs["inpaint_mask"].value = sources["inpaint_mask"]
		}
		}

		if (sources["start_index"] !== undefined) {
		if (typeof sources["start_index"] === "object") {
			this.sockets.inputs["start_index"].connectTo(sources["start_index"])
		} else {
			this.sockets.inputs["start_index"].value = sources["start_index"]
		}
		}

		if (sources["end_index"] !== undefined) {
		if (typeof sources["end_index"] === "object") {
			this.sockets.inputs["end_index"].connectTo(sources["end_index"])
		} else {
			this.sockets.inputs["end_index"].value = sources["end_index"]
		}
		}

	}
}

type WanVideoVACEStartToEndFrameInputs = {
			/** Number of frames to encode*/
			"num_frames": ComfyNodeTypedInputRef<number>
			/** White level of empty frame to use*/
			"empty_frame_level": ComfyNodeTypedInputRef<number>
			"start_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"end_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"control_images"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Inpaint mask to use for the empty frames*/
			"inpaint_mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
			/** Index to start from*/
			"start_index"?: ComfyNodeTypedInputRef<number>
			/** Index to end at*/
			"end_index"?: ComfyNodeTypedInputRef<number>
}


export class ExtractStartFramesForContinuations extends ComfyNode {
	classType: string = "ExtractStartFramesForContinuations"

	sockets: {
		inputs: Required<ExtractStartFramesForContinuationsInputs>
		outputs: {
			start_frames: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"input_video_frames": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "input_video_frames"),
				"num_frames": new ComfyNodeTypedInputRef<number>(this, "num_frames"),
			},
			outputs: Object.create(Object.prototype, {
				"start_frames": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ExtractStartFramesForContinuationsInputs>) {
		if (typeof sources["input_video_frames"] === "object") {
			this.sockets.inputs["input_video_frames"].connectTo(sources["input_video_frames"])
		} else {
			this.sockets.inputs["input_video_frames"].value = sources["input_video_frames"]
		}

		if (typeof sources["num_frames"] === "object") {
			this.sockets.inputs["num_frames"].connectTo(sources["num_frames"])
		} else {
			this.sockets.inputs["num_frames"].value = sources["num_frames"]
		}

	}
}

type ExtractStartFramesForContinuationsInputs = {
			/** Input video frames to extract the start frames from.*/
			"input_video_frames": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Number of frames to get from the start of the video.*/
			"num_frames": ComfyNodeTypedInputRef<number>
}


export class CreateCFGScheduleFloatList extends ComfyNode {
	classType: string = "CreateCFGScheduleFloatList"

	sockets: {
		inputs: Required<CreateCFGScheduleFloatListInputs>
		outputs: {
			float_list: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"cfg_scale_start": new ComfyNodeTypedInputRef<number>(this, "cfg_scale_start"),
				"cfg_scale_end": new ComfyNodeTypedInputRef<number>(this, "cfg_scale_end"),
				"interpolation": new ComfyNodeTypedInputRef<string>(this, "interpolation"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
				"unique_id": new ComfyNodeTypedInputRef<ComfyValueType_U>(this, "unique_id"),
			},
			outputs: Object.create(Object.prototype, {
				"float_list": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateCFGScheduleFloatListInputs>) {
		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["cfg_scale_start"] === "object") {
			this.sockets.inputs["cfg_scale_start"].connectTo(sources["cfg_scale_start"])
		} else {
			this.sockets.inputs["cfg_scale_start"].value = sources["cfg_scale_start"]
		}

		if (typeof sources["cfg_scale_end"] === "object") {
			this.sockets.inputs["cfg_scale_end"].connectTo(sources["cfg_scale_end"])
		} else {
			this.sockets.inputs["cfg_scale_end"].value = sources["cfg_scale_end"]
		}

		if (typeof sources["interpolation"] === "object") {
			this.sockets.inputs["interpolation"].connectTo(sources["interpolation"])
		} else {
			this.sockets.inputs["interpolation"].value = sources["interpolation"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

		if (sources["unique_id"] !== undefined) {
		if (typeof sources["unique_id"] === "object") {
			this.sockets.inputs["unique_id"].connectTo(sources["unique_id"])
		} else {
			this.sockets.inputs["unique_id"].value = sources["unique_id"]
		}
		}

	}
}

type CreateCFGScheduleFloatListInputs = {
			/** Number of steps to schedule cfg for*/
			"steps": ComfyNodeTypedInputRef<number>
			/** CFG scale to use for the steps*/
			"cfg_scale_start": ComfyNodeTypedInputRef<number>
			/** CFG scale to use for the steps*/
			"cfg_scale_end": ComfyNodeTypedInputRef<number>
			/** Interpolation method to use for the cfg scale*/
			"interpolation": ComfyNodeTypedInputRef<string>
			/** Start percent of the steps to apply cfg*/
			"start_percent": ComfyNodeTypedInputRef<number>
			/** End percent of the steps to apply cfg*/
			"end_percent": ComfyNodeTypedInputRef<number>
			"unique_id"?: ComfyNodeTypedInputRef<ComfyValueType_U>
}


export class DummyComfyWanModelObject extends ComfyNode {
	classType: string = "DummyComfyWanModelObject"

	sockets: {
		inputs: Required<DummyComfyWanModelObjectInputs>
		outputs: {
			model: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"shift": new ComfyNodeTypedInputRef<number>(this, "shift"),
			},
			outputs: Object.create(Object.prototype, {
				"model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DummyComfyWanModelObjectInputs>) {
		if (typeof sources["shift"] === "object") {
			this.sockets.inputs["shift"].connectTo(sources["shift"])
		} else {
			this.sockets.inputs["shift"].value = sources["shift"]
		}

	}
}

type DummyComfyWanModelObjectInputs = {
			/** Sigma shift value*/
			"shift": ComfyNodeTypedInputRef<number>
}


export class WanVideoLatentReScale extends ComfyNode {
	classType: string = "WanVideoLatentReScale"

	sockets: {
		inputs: Required<WanVideoLatentReScaleInputs>
		outputs: {
			samples: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"direction": new ComfyNodeTypedInputRef<string>(this, "direction"),
			},
			outputs: Object.create(Object.prototype, {
				"samples": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoLatentReScaleInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["direction"] === "object") {
			this.sockets.inputs["direction"].connectTo(sources["direction"])
		} else {
			this.sockets.inputs["direction"].value = sources["direction"]
		}

	}
}

type WanVideoLatentReScaleInputs = {
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** Direction to rescale latents, from comfy to wrapper or vice versa*/
			"direction": ComfyNodeTypedInputRef<string>
}


export class CreateScheduleFloatList extends ComfyNode {
	classType: string = "CreateScheduleFloatList"

	sockets: {
		inputs: Required<CreateScheduleFloatListInputs>
		outputs: {
			float_list: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"start_value": new ComfyNodeTypedInputRef<number>(this, "start_value"),
				"end_value": new ComfyNodeTypedInputRef<number>(this, "end_value"),
				"default_value": new ComfyNodeTypedInputRef<number>(this, "default_value"),
				"interpolation": new ComfyNodeTypedInputRef<string>(this, "interpolation"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
				"unique_id": new ComfyNodeTypedInputRef<ComfyValueType_U>(this, "unique_id"),
			},
			outputs: Object.create(Object.prototype, {
				"float_list": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CreateScheduleFloatListInputs>) {
		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["start_value"] === "object") {
			this.sockets.inputs["start_value"].connectTo(sources["start_value"])
		} else {
			this.sockets.inputs["start_value"].value = sources["start_value"]
		}

		if (typeof sources["end_value"] === "object") {
			this.sockets.inputs["end_value"].connectTo(sources["end_value"])
		} else {
			this.sockets.inputs["end_value"].value = sources["end_value"]
		}

		if (typeof sources["default_value"] === "object") {
			this.sockets.inputs["default_value"].connectTo(sources["default_value"])
		} else {
			this.sockets.inputs["default_value"].value = sources["default_value"]
		}

		if (typeof sources["interpolation"] === "object") {
			this.sockets.inputs["interpolation"].connectTo(sources["interpolation"])
		} else {
			this.sockets.inputs["interpolation"].value = sources["interpolation"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

		if (sources["unique_id"] !== undefined) {
		if (typeof sources["unique_id"] === "object") {
			this.sockets.inputs["unique_id"].connectTo(sources["unique_id"])
		} else {
			this.sockets.inputs["unique_id"].value = sources["unique_id"]
		}
		}

	}
}

type CreateScheduleFloatListInputs = {
			/** Number of steps to schedule cfg for*/
			"steps": ComfyNodeTypedInputRef<number>
			/** CFG scale to use for the steps*/
			"start_value": ComfyNodeTypedInputRef<number>
			/** CFG scale to use for the steps*/
			"end_value": ComfyNodeTypedInputRef<number>
			/** Default value to use for the steps*/
			"default_value": ComfyNodeTypedInputRef<number>
			/** Interpolation method to use for the cfg scale*/
			"interpolation": ComfyNodeTypedInputRef<string>
			/** Start percent of the steps to apply cfg*/
			"start_percent": ComfyNodeTypedInputRef<number>
			/** End percent of the steps to apply cfg*/
			"end_percent": ComfyNodeTypedInputRef<number>
			"unique_id"?: ComfyNodeTypedInputRef<ComfyValueType_U>
}


export class WanVideoSigmaToStep extends ComfyNode {
	classType: string = "WanVideoSigmaToStep"

	sockets: {
		inputs: Required<WanVideoSigmaToStepInputs>
		outputs: {
			step: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"sigma": new ComfyNodeTypedInputRef<number>(this, "sigma"),
			},
			outputs: Object.create(Object.prototype, {
				"step": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoSigmaToStepInputs>) {
		if (typeof sources["sigma"] === "object") {
			this.sockets.inputs["sigma"].connectTo(sources["sigma"])
		} else {
			this.sockets.inputs["sigma"].value = sources["sigma"]
		}

	}
}

type WanVideoSigmaToStepInputs = {
			"sigma": ComfyNodeTypedInputRef<number>
}


export class NormalizeAudioLoudness extends ComfyNode {
	classType: string = "NormalizeAudioLoudness"

	sockets: {
		inputs: Required<NormalizeAudioLoudnessInputs>
		outputs: {
			audio: ComfyNodeTypedSourceRef<ComfyValueType_AUDIO>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"audio": new ComfyNodeTypedInputRef<ComfyValueType_AUDIO>(this, "audio"),
				"lufs": new ComfyNodeTypedInputRef<number>(this, "lufs"),
			},
			outputs: Object.create(Object.prototype, {
				"audio": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<NormalizeAudioLoudnessInputs>) {
		if (typeof sources["audio"] === "object") {
			this.sockets.inputs["audio"].connectTo(sources["audio"])
		} else {
			this.sockets.inputs["audio"].value = sources["audio"]
		}

		if (typeof sources["lufs"] === "object") {
			this.sockets.inputs["lufs"].connectTo(sources["lufs"])
		} else {
			this.sockets.inputs["lufs"].value = sources["lufs"]
		}

	}
}

type NormalizeAudioLoudnessInputs = {
			"audio": ComfyNodeTypedInputRef<ComfyValueType_AUDIO>
			"lufs": ComfyNodeTypedInputRef<number>
}


export class WanVideoPassImagesFromSamples extends ComfyNode {
	classType: string = "WanVideoPassImagesFromSamples"

	sockets: {
		inputs: Required<WanVideoPassImagesFromSamplesInputs>
		outputs: {
			/** Decoded images from the samples dictionary*/
			images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			/** Output path if provided in the samples dictionary*/
			output_path: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
			},
			outputs: Object.create(Object.prototype, {
				"images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"output_path": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoPassImagesFromSamplesInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

	}
}

type WanVideoPassImagesFromSamplesInputs = {
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class FaceMaskFromPoseKeypoints extends ComfyNode {
	classType: string = "FaceMaskFromPoseKeypoints"

	sockets: {
		inputs: Required<FaceMaskFromPoseKeypointsInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"pose_kps": new ComfyNodeTypedInputRef<ComfyValueType_POSE_KEYPOINT>(this, "pose_kps"),
				"person_index": new ComfyNodeTypedInputRef<number>(this, "person_index"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<FaceMaskFromPoseKeypointsInputs>) {
		if (typeof sources["pose_kps"] === "object") {
			this.sockets.inputs["pose_kps"].connectTo(sources["pose_kps"])
		} else {
			this.sockets.inputs["pose_kps"].value = sources["pose_kps"]
		}

		if (typeof sources["person_index"] === "object") {
			this.sockets.inputs["person_index"].connectTo(sources["person_index"])
		} else {
			this.sockets.inputs["person_index"].value = sources["person_index"]
		}

	}
}

type FaceMaskFromPoseKeypointsInputs = {
			"pose_kps": ComfyNodeTypedInputRef<ComfyValueType_POSE_KEYPOINT>
			/** Index of the person to start with*/
			"person_index": ComfyNodeTypedInputRef<number>
}


export class WanVideoTeaCache extends ComfyNode {
	classType: string = "WanVideoTeaCache"

	sockets: {
		inputs: Required<WanVideoTeaCacheInputs>
		outputs: {
			cache_args: ComfyNodeTypedSourceRef<ComfyValueType_CACHEARGS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"rel_l1_thresh": new ComfyNodeTypedInputRef<number>(this, "rel_l1_thresh"),
				"start_step": new ComfyNodeTypedInputRef<number>(this, "start_step"),
				"end_step": new ComfyNodeTypedInputRef<number>(this, "end_step"),
				"cache_device": new ComfyNodeTypedInputRef<string>(this, "cache_device"),
				"use_coefficients": new ComfyNodeTypedInputRef<boolean>(this, "use_coefficients"),
				"mode": new ComfyNodeTypedInputRef<string>(this, "mode"),
			},
			outputs: Object.create(Object.prototype, {
				"cache_args": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoTeaCacheInputs>) {
		if (typeof sources["rel_l1_thresh"] === "object") {
			this.sockets.inputs["rel_l1_thresh"].connectTo(sources["rel_l1_thresh"])
		} else {
			this.sockets.inputs["rel_l1_thresh"].value = sources["rel_l1_thresh"]
		}

		if (typeof sources["start_step"] === "object") {
			this.sockets.inputs["start_step"].connectTo(sources["start_step"])
		} else {
			this.sockets.inputs["start_step"].value = sources["start_step"]
		}

		if (typeof sources["end_step"] === "object") {
			this.sockets.inputs["end_step"].connectTo(sources["end_step"])
		} else {
			this.sockets.inputs["end_step"].value = sources["end_step"]
		}

		if (typeof sources["cache_device"] === "object") {
			this.sockets.inputs["cache_device"].connectTo(sources["cache_device"])
		} else {
			this.sockets.inputs["cache_device"].value = sources["cache_device"]
		}

		if (typeof sources["use_coefficients"] === "object") {
			this.sockets.inputs["use_coefficients"].connectTo(sources["use_coefficients"])
		} else {
			this.sockets.inputs["use_coefficients"].value = sources["use_coefficients"]
		}

		if (sources["mode"] !== undefined) {
		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}
		}

	}
}

type WanVideoTeaCacheInputs = {
			/** Higher values will make TeaCache more aggressive, faster, but may cause artifacts. Good value range for 1.3B: 0.05 - 0.08, for other models 0.15-0.30*/
			"rel_l1_thresh": ComfyNodeTypedInputRef<number>
			/** Start percentage of the steps to apply TeaCache*/
			"start_step": ComfyNodeTypedInputRef<number>
			/** End steps to apply TeaCache*/
			"end_step": ComfyNodeTypedInputRef<number>
			/** Device to cache to*/
			"cache_device": ComfyNodeTypedInputRef<string>
			/** Use calculated coefficients for more accuracy. When enabled therel_l1_thresh should be about 10 times higher than without*/
			"use_coefficients": ComfyNodeTypedInputRef<boolean>
			/** Choice between using e (time embeds, default) or e0 (modulated time embeds)*/
			"mode"?: ComfyNodeTypedInputRef<string>
}


export class WanVideoMagCache extends ComfyNode {
	classType: string = "WanVideoMagCache"

	sockets: {
		inputs: Required<WanVideoMagCacheInputs>
		outputs: {
			cache_args: ComfyNodeTypedSourceRef<ComfyValueType_CACHEARGS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"magcache_thresh": new ComfyNodeTypedInputRef<number>(this, "magcache_thresh"),
				"magcache_K": new ComfyNodeTypedInputRef<number>(this, "magcache_K"),
				"start_step": new ComfyNodeTypedInputRef<number>(this, "start_step"),
				"end_step": new ComfyNodeTypedInputRef<number>(this, "end_step"),
				"cache_device": new ComfyNodeTypedInputRef<string>(this, "cache_device"),
			},
			outputs: Object.create(Object.prototype, {
				"cache_args": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoMagCacheInputs>) {
		if (typeof sources["magcache_thresh"] === "object") {
			this.sockets.inputs["magcache_thresh"].connectTo(sources["magcache_thresh"])
		} else {
			this.sockets.inputs["magcache_thresh"].value = sources["magcache_thresh"]
		}

		if (typeof sources["magcache_K"] === "object") {
			this.sockets.inputs["magcache_K"].connectTo(sources["magcache_K"])
		} else {
			this.sockets.inputs["magcache_K"].value = sources["magcache_K"]
		}

		if (typeof sources["start_step"] === "object") {
			this.sockets.inputs["start_step"].connectTo(sources["start_step"])
		} else {
			this.sockets.inputs["start_step"].value = sources["start_step"]
		}

		if (typeof sources["end_step"] === "object") {
			this.sockets.inputs["end_step"].connectTo(sources["end_step"])
		} else {
			this.sockets.inputs["end_step"].value = sources["end_step"]
		}

		if (typeof sources["cache_device"] === "object") {
			this.sockets.inputs["cache_device"].connectTo(sources["cache_device"])
		} else {
			this.sockets.inputs["cache_device"].value = sources["cache_device"]
		}

	}
}

type WanVideoMagCacheInputs = {
			/** How strongly to cache the output of diffusion model. This value must be non-negative.*/
			"magcache_thresh": ComfyNodeTypedInputRef<number>
			/** The maxium skip steps of MagCache.*/
			"magcache_K": ComfyNodeTypedInputRef<number>
			/** Step to start applying MagCache*/
			"start_step": ComfyNodeTypedInputRef<number>
			/** Step to end applying MagCache*/
			"end_step": ComfyNodeTypedInputRef<number>
			/** Device to cache to*/
			"cache_device": ComfyNodeTypedInputRef<string>
}


export class WanVideoEasyCache extends ComfyNode {
	classType: string = "WanVideoEasyCache"

	sockets: {
		inputs: Required<WanVideoEasyCacheInputs>
		outputs: {
			cache_args: ComfyNodeTypedSourceRef<ComfyValueType_CACHEARGS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"easycache_thresh": new ComfyNodeTypedInputRef<number>(this, "easycache_thresh"),
				"start_step": new ComfyNodeTypedInputRef<number>(this, "start_step"),
				"end_step": new ComfyNodeTypedInputRef<number>(this, "end_step"),
				"cache_device": new ComfyNodeTypedInputRef<string>(this, "cache_device"),
			},
			outputs: Object.create(Object.prototype, {
				"cache_args": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoEasyCacheInputs>) {
		if (typeof sources["easycache_thresh"] === "object") {
			this.sockets.inputs["easycache_thresh"].connectTo(sources["easycache_thresh"])
		} else {
			this.sockets.inputs["easycache_thresh"].value = sources["easycache_thresh"]
		}

		if (typeof sources["start_step"] === "object") {
			this.sockets.inputs["start_step"].connectTo(sources["start_step"])
		} else {
			this.sockets.inputs["start_step"].value = sources["start_step"]
		}

		if (typeof sources["end_step"] === "object") {
			this.sockets.inputs["end_step"].connectTo(sources["end_step"])
		} else {
			this.sockets.inputs["end_step"].value = sources["end_step"]
		}

		if (typeof sources["cache_device"] === "object") {
			this.sockets.inputs["cache_device"].connectTo(sources["cache_device"])
		} else {
			this.sockets.inputs["cache_device"].value = sources["cache_device"]
		}

	}
}

type WanVideoEasyCacheInputs = {
			/** How strongly to cache the output of diffusion model. This value must be non-negative.*/
			"easycache_thresh": ComfyNodeTypedInputRef<number>
			/** Step to start applying EasyCache*/
			"start_step": ComfyNodeTypedInputRef<number>
			/** Step to end applying EasyCache*/
			"end_step": ComfyNodeTypedInputRef<number>
			/** Device to cache to*/
			"cache_device": ComfyNodeTypedInputRef<string>
}


export class WanVideoImageClipEncode extends ComfyNode {
	classType: string = "WanVideoImageClipEncode"

	sockets: {
		inputs: Required<WanVideoImageClipEncodeInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_vision": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>(this, "clip_vision"),
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_WANVAE>(this, "vae"),
				"generation_width": new ComfyNodeTypedInputRef<number>(this, "generation_width"),
				"generation_height": new ComfyNodeTypedInputRef<number>(this, "generation_height"),
				"num_frames": new ComfyNodeTypedInputRef<number>(this, "num_frames"),
				"force_offload": new ComfyNodeTypedInputRef<boolean>(this, "force_offload"),
				"noise_aug_strength": new ComfyNodeTypedInputRef<number>(this, "noise_aug_strength"),
				"latent_strength": new ComfyNodeTypedInputRef<number>(this, "latent_strength"),
				"clip_embed_strength": new ComfyNodeTypedInputRef<number>(this, "clip_embed_strength"),
				"adjust_resolution": new ComfyNodeTypedInputRef<boolean>(this, "adjust_resolution"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoImageClipEncodeInputs>) {
		if (typeof sources["clip_vision"] === "object") {
			this.sockets.inputs["clip_vision"].connectTo(sources["clip_vision"])
		} else {
			this.sockets.inputs["clip_vision"].value = sources["clip_vision"]
		}

		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["generation_width"] === "object") {
			this.sockets.inputs["generation_width"].connectTo(sources["generation_width"])
		} else {
			this.sockets.inputs["generation_width"].value = sources["generation_width"]
		}

		if (typeof sources["generation_height"] === "object") {
			this.sockets.inputs["generation_height"].connectTo(sources["generation_height"])
		} else {
			this.sockets.inputs["generation_height"].value = sources["generation_height"]
		}

		if (typeof sources["num_frames"] === "object") {
			this.sockets.inputs["num_frames"].connectTo(sources["num_frames"])
		} else {
			this.sockets.inputs["num_frames"].value = sources["num_frames"]
		}

		if (sources["force_offload"] !== undefined) {
		if (typeof sources["force_offload"] === "object") {
			this.sockets.inputs["force_offload"].connectTo(sources["force_offload"])
		} else {
			this.sockets.inputs["force_offload"].value = sources["force_offload"]
		}
		}

		if (sources["noise_aug_strength"] !== undefined) {
		if (typeof sources["noise_aug_strength"] === "object") {
			this.sockets.inputs["noise_aug_strength"].connectTo(sources["noise_aug_strength"])
		} else {
			this.sockets.inputs["noise_aug_strength"].value = sources["noise_aug_strength"]
		}
		}

		if (sources["latent_strength"] !== undefined) {
		if (typeof sources["latent_strength"] === "object") {
			this.sockets.inputs["latent_strength"].connectTo(sources["latent_strength"])
		} else {
			this.sockets.inputs["latent_strength"].value = sources["latent_strength"]
		}
		}

		if (sources["clip_embed_strength"] !== undefined) {
		if (typeof sources["clip_embed_strength"] === "object") {
			this.sockets.inputs["clip_embed_strength"].connectTo(sources["clip_embed_strength"])
		} else {
			this.sockets.inputs["clip_embed_strength"].value = sources["clip_embed_strength"]
		}
		}

		if (sources["adjust_resolution"] !== undefined) {
		if (typeof sources["adjust_resolution"] === "object") {
			this.sockets.inputs["adjust_resolution"].connectTo(sources["adjust_resolution"])
		} else {
			this.sockets.inputs["adjust_resolution"].value = sources["adjust_resolution"]
		}
		}

	}
}

type WanVideoImageClipEncodeInputs = {
			"clip_vision": ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>
			/** Image to encode*/
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_WANVAE>
			/** Width of the image to encode*/
			"generation_width": ComfyNodeTypedInputRef<number>
			/** Height of the image to encode*/
			"generation_height": ComfyNodeTypedInputRef<number>
			/** Number of frames to encode*/
			"num_frames": ComfyNodeTypedInputRef<number>
			"force_offload"?: ComfyNodeTypedInputRef<boolean>
			/** Strength of noise augmentation, helpful for I2V where some noise can add motion and give sharper results*/
			"noise_aug_strength"?: ComfyNodeTypedInputRef<number>
			/** Additional latent multiplier, helpful for I2V where lower values allow for more motion*/
			"latent_strength"?: ComfyNodeTypedInputRef<number>
			/** Additional clip embed multiplier*/
			"clip_embed_strength"?: ComfyNodeTypedInputRef<number>
			/** Performs the same resolution adjustment as in the original code*/
			"adjust_resolution"?: ComfyNodeTypedInputRef<boolean>
}


export class QwenLoader extends ComfyNode {
	classType: string = "QwenLoader"

	sockets: {
		inputs: Required<QwenLoaderInputs>
		outputs: {
			QWENMODEL: ComfyNodeTypedSourceRef<ComfyValueType_QWENMODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<string>(this, "model"),
				"load_device": new ComfyNodeTypedInputRef<string>(this, "load_device"),
				"precision": new ComfyNodeTypedInputRef<string>(this, "precision"),
			},
			outputs: Object.create(Object.prototype, {
				"QWENMODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<QwenLoaderInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}

		if (typeof sources["precision"] === "object") {
			this.sockets.inputs["precision"].connectTo(sources["precision"])
		} else {
			this.sockets.inputs["precision"].value = sources["precision"]
		}

	}
}

type QwenLoaderInputs = {
			"model": ComfyNodeTypedInputRef<string>
			"load_device": ComfyNodeTypedInputRef<string>
			"precision": ComfyNodeTypedInputRef<string>
}


export class WanVideoPromptExtender extends ComfyNode {
	classType: string = "WanVideoPromptExtender"

	sockets: {
		inputs: Required<WanVideoPromptExtenderInputs>
		outputs: {
			STRING: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"qwen": new ComfyNodeTypedInputRef<ComfyValueType_QWENMODEL>(this, "qwen"),
				"prompt": new ComfyNodeTypedInputRef<string>(this, "prompt"),
				"max_new_tokens": new ComfyNodeTypedInputRef<number>(this, "max_new_tokens"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
				"force_offload": new ComfyNodeTypedInputRef<boolean>(this, "force_offload"),
				"system_prompt": new ComfyNodeTypedInputRef<string>(this, "system_prompt"),
				"custom_system_prompt": new ComfyNodeTypedInputRef<string>(this, "custom_system_prompt"),
				"seed": new ComfyNodeTypedInputRef<number>(this, "seed"),
			},
			outputs: Object.create(Object.prototype, {
				"STRING": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoPromptExtenderInputs>) {
		if (typeof sources["qwen"] === "object") {
			this.sockets.inputs["qwen"].connectTo(sources["qwen"])
		} else {
			this.sockets.inputs["qwen"].value = sources["qwen"]
		}

		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}

		if (typeof sources["max_new_tokens"] === "object") {
			this.sockets.inputs["max_new_tokens"].connectTo(sources["max_new_tokens"])
		} else {
			this.sockets.inputs["max_new_tokens"].value = sources["max_new_tokens"]
		}

		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}

		if (typeof sources["force_offload"] === "object") {
			this.sockets.inputs["force_offload"].connectTo(sources["force_offload"])
		} else {
			this.sockets.inputs["force_offload"].value = sources["force_offload"]
		}

		if (sources["system_prompt"] !== undefined) {
		if (typeof sources["system_prompt"] === "object") {
			this.sockets.inputs["system_prompt"].connectTo(sources["system_prompt"])
		} else {
			this.sockets.inputs["system_prompt"].value = sources["system_prompt"]
		}
		}

		if (sources["custom_system_prompt"] !== undefined) {
		if (typeof sources["custom_system_prompt"] === "object") {
			this.sockets.inputs["custom_system_prompt"].connectTo(sources["custom_system_prompt"])
		} else {
			this.sockets.inputs["custom_system_prompt"].value = sources["custom_system_prompt"]
		}
		}

		if (sources["seed"] !== undefined) {
		if (typeof sources["seed"] === "object") {
			this.sockets.inputs["seed"].connectTo(sources["seed"])
		} else {
			this.sockets.inputs["seed"].value = sources["seed"]
		}
		}

	}
}

type WanVideoPromptExtenderInputs = {
			"qwen": ComfyNodeTypedInputRef<ComfyValueType_QWENMODEL>
			"prompt": ComfyNodeTypedInputRef<string>
			/** Maximum number of new tokens to generate.*/
			"max_new_tokens": ComfyNodeTypedInputRef<number>
			/** Device to run the model on. Default uses the main device.*/
			"device": ComfyNodeTypedInputRef<string>
			/** Force offload the model to the offload device after generation. Useful for large models.*/
			"force_offload": ComfyNodeTypedInputRef<boolean>
			/** System prompt to use for the model.*/
			"system_prompt"?: ComfyNodeTypedInputRef<string>
			/** Custom system prompt to use instead of the predefined ones.*/
			"custom_system_prompt"?: ComfyNodeTypedInputRef<string>
			"seed"?: ComfyNodeTypedInputRef<number>
}


export class WanVideoPromptExtenderSelect extends ComfyNode {
	classType: string = "WanVideoPromptExtenderSelect"

	sockets: {
		inputs: Required<WanVideoPromptExtenderSelectInputs>
		outputs: {
			extender_args: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOPROMPTEXTENDER_ARGS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<string>(this, "model"),
				"max_new_tokens": new ComfyNodeTypedInputRef<number>(this, "max_new_tokens"),
				"system_prompt": new ComfyNodeTypedInputRef<string>(this, "system_prompt"),
				"custom_system_prompt": new ComfyNodeTypedInputRef<string>(this, "custom_system_prompt"),
				"seed": new ComfyNodeTypedInputRef<number>(this, "seed"),
			},
			outputs: Object.create(Object.prototype, {
				"extender_args": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoPromptExtenderSelectInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["max_new_tokens"] === "object") {
			this.sockets.inputs["max_new_tokens"].connectTo(sources["max_new_tokens"])
		} else {
			this.sockets.inputs["max_new_tokens"].value = sources["max_new_tokens"]
		}

		if (typeof sources["system_prompt"] === "object") {
			this.sockets.inputs["system_prompt"].connectTo(sources["system_prompt"])
		} else {
			this.sockets.inputs["system_prompt"].value = sources["system_prompt"]
		}

		if (sources["custom_system_prompt"] !== undefined) {
		if (typeof sources["custom_system_prompt"] === "object") {
			this.sockets.inputs["custom_system_prompt"].connectTo(sources["custom_system_prompt"])
		} else {
			this.sockets.inputs["custom_system_prompt"].value = sources["custom_system_prompt"]
		}
		}

		if (sources["seed"] !== undefined) {
		if (typeof sources["seed"] === "object") {
			this.sockets.inputs["seed"].connectTo(sources["seed"])
		} else {
			this.sockets.inputs["seed"].value = sources["seed"]
		}
		}

	}
}

type WanVideoPromptExtenderSelectInputs = {
			"model": ComfyNodeTypedInputRef<string>
			/** Maximum number of new tokens to generate.*/
			"max_new_tokens": ComfyNodeTypedInputRef<number>
			/** System prompt to use for the model.*/
			"system_prompt": ComfyNodeTypedInputRef<string>
			/** Custom system prompt to use instead of the predefined ones.*/
			"custom_system_prompt"?: ComfyNodeTypedInputRef<string>
			"seed"?: ComfyNodeTypedInputRef<number>
}


export class DownloadAndLoadNLFModel extends ComfyNode {
	classType: string = "DownloadAndLoadNLFModel"

	sockets: {
		inputs: Required<DownloadAndLoadNLFModelInputs>
		outputs: {
			nlf_model: ComfyNodeTypedSourceRef<ComfyValueType_NLFMODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"url": new ComfyNodeTypedInputRef<string>(this, "url"),
			},
			outputs: Object.create(Object.prototype, {
				"nlf_model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DownloadAndLoadNLFModelInputs>) {
		if (typeof sources["url"] === "object") {
			this.sockets.inputs["url"].connectTo(sources["url"])
		} else {
			this.sockets.inputs["url"].value = sources["url"]
		}

	}
}

type DownloadAndLoadNLFModelInputs = {
			"url": ComfyNodeTypedInputRef<string>
}


export class NLFPredict extends ComfyNode {
	classType: string = "NLFPredict"

	sockets: {
		inputs: Required<NLFPredictInputs>
		outputs: {
			pose_results: ComfyNodeTypedSourceRef<ComfyValueType_NLFPRED>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_NLFMODEL>(this, "model"),
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
			},
			outputs: Object.create(Object.prototype, {
				"pose_results": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<NLFPredictInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

	}
}

type NLFPredictInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_NLFMODEL>
			/** Input images for the model*/
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class DrawNLFPoses extends ComfyNode {
	classType: string = "DrawNLFPoses"

	sockets: {
		inputs: Required<DrawNLFPosesInputs>
		outputs: {
			image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"poses": new ComfyNodeTypedInputRef<ComfyValueType_NLFPRED>(this, "poses"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
			},
			outputs: Object.create(Object.prototype, {
				"image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DrawNLFPosesInputs>) {
		if (typeof sources["poses"] === "object") {
			this.sockets.inputs["poses"].connectTo(sources["poses"])
		} else {
			this.sockets.inputs["poses"].value = sources["poses"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

	}
}

type DrawNLFPosesInputs = {
			/** Input poses for the model*/
			"poses": ComfyNodeTypedInputRef<ComfyValueType_NLFPRED>
			"width": ComfyNodeTypedInputRef<number>
			"height": ComfyNodeTypedInputRef<number>
}


export class LoadVQVAE extends ComfyNode {
	classType: string = "LoadVQVAE"

	sockets: {
		inputs: Required<LoadVQVAEInputs>
		outputs: {
			vqvae: ComfyNodeTypedSourceRef<ComfyValueType_VQVAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_name": new ComfyNodeTypedInputRef<string>(this, "model_name"),
			},
			outputs: Object.create(Object.prototype, {
				"vqvae": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoadVQVAEInputs>) {
		if (typeof sources["model_name"] === "object") {
			this.sockets.inputs["model_name"].connectTo(sources["model_name"])
		} else {
			this.sockets.inputs["model_name"].value = sources["model_name"]
		}

	}
}

type LoadVQVAEInputs = {
			/** These models are loaded from 'ComfyUI/models/vae'*/
			"model_name": ComfyNodeTypedInputRef<string>
}


export class MTVCrafterEncodePoses extends ComfyNode {
	classType: string = "MTVCrafterEncodePoses"

	sockets: {
		inputs: Required<MTVCrafterEncodePosesInputs>
		outputs: {
			mtvcrafter_motion: ComfyNodeTypedSourceRef<ComfyValueType_MTVCRAFTERMOTION>
			pose_results: ComfyNodeTypedSourceRef<ComfyValueType_NLFPRED>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vqvae": new ComfyNodeTypedInputRef<ComfyValueType_VQVAE>(this, "vqvae"),
				"poses": new ComfyNodeTypedInputRef<ComfyValueType_NLFPRED>(this, "poses"),
			},
			outputs: Object.create(Object.prototype, {
				"mtvcrafter_motion": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"pose_results": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<MTVCrafterEncodePosesInputs>) {
		if (typeof sources["vqvae"] === "object") {
			this.sockets.inputs["vqvae"].connectTo(sources["vqvae"])
		} else {
			this.sockets.inputs["vqvae"].value = sources["vqvae"]
		}

		if (typeof sources["poses"] === "object") {
			this.sockets.inputs["poses"].connectTo(sources["poses"])
		} else {
			this.sockets.inputs["poses"].value = sources["poses"]
		}

	}
}

type MTVCrafterEncodePosesInputs = {
			/** VQVAE model*/
			"vqvae": ComfyNodeTypedInputRef<ComfyValueType_VQVAE>
			/** Input poses for the model*/
			"poses": ComfyNodeTypedInputRef<ComfyValueType_NLFPRED>
}


export class WanVideoAddS2VEmbeds extends ComfyNode {
	classType: string = "WanVideoAddS2VEmbeds"

	sockets: {
		inputs: Required<WanVideoAddS2VEmbedsInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			audio_frame_count: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>(this, "embeds"),
				"frame_window_size": new ComfyNodeTypedInputRef<number>(this, "frame_window_size"),
				"audio_scale": new ComfyNodeTypedInputRef<number>(this, "audio_scale"),
				"pose_start_percent": new ComfyNodeTypedInputRef<number>(this, "pose_start_percent"),
				"pose_end_percent": new ComfyNodeTypedInputRef<number>(this, "pose_end_percent"),
				"audio_encoder_output": new ComfyNodeTypedInputRef<ComfyValueType_AUDIO_ENCODER_OUTPUT>(this, "audio_encoder_output"),
				"ref_latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "ref_latent"),
				"pose_latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "pose_latent"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_WANVAE>(this, "vae"),
				"enable_framepack": new ComfyNodeTypedInputRef<boolean>(this, "enable_framepack"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"audio_frame_count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoAddS2VEmbedsInputs>) {
		if (typeof sources["embeds"] === "object") {
			this.sockets.inputs["embeds"].connectTo(sources["embeds"])
		} else {
			this.sockets.inputs["embeds"].value = sources["embeds"]
		}

		if (typeof sources["frame_window_size"] === "object") {
			this.sockets.inputs["frame_window_size"].connectTo(sources["frame_window_size"])
		} else {
			this.sockets.inputs["frame_window_size"].value = sources["frame_window_size"]
		}

		if (typeof sources["audio_scale"] === "object") {
			this.sockets.inputs["audio_scale"].connectTo(sources["audio_scale"])
		} else {
			this.sockets.inputs["audio_scale"].value = sources["audio_scale"]
		}

		if (typeof sources["pose_start_percent"] === "object") {
			this.sockets.inputs["pose_start_percent"].connectTo(sources["pose_start_percent"])
		} else {
			this.sockets.inputs["pose_start_percent"].value = sources["pose_start_percent"]
		}

		if (typeof sources["pose_end_percent"] === "object") {
			this.sockets.inputs["pose_end_percent"].connectTo(sources["pose_end_percent"])
		} else {
			this.sockets.inputs["pose_end_percent"].value = sources["pose_end_percent"]
		}

		if (sources["audio_encoder_output"] !== undefined) {
		if (typeof sources["audio_encoder_output"] === "object") {
			this.sockets.inputs["audio_encoder_output"].connectTo(sources["audio_encoder_output"])
		} else {
			this.sockets.inputs["audio_encoder_output"].value = sources["audio_encoder_output"]
		}
		}

		if (sources["ref_latent"] !== undefined) {
		if (typeof sources["ref_latent"] === "object") {
			this.sockets.inputs["ref_latent"].connectTo(sources["ref_latent"])
		} else {
			this.sockets.inputs["ref_latent"].value = sources["ref_latent"]
		}
		}

		if (sources["pose_latent"] !== undefined) {
		if (typeof sources["pose_latent"] === "object") {
			this.sockets.inputs["pose_latent"].connectTo(sources["pose_latent"])
		} else {
			this.sockets.inputs["pose_latent"].value = sources["pose_latent"]
		}
		}

		if (sources["vae"] !== undefined) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}
		}

		if (sources["enable_framepack"] !== undefined) {
		if (typeof sources["enable_framepack"] === "object") {
			this.sockets.inputs["enable_framepack"].connectTo(sources["enable_framepack"])
		} else {
			this.sockets.inputs["enable_framepack"].value = sources["enable_framepack"]
		}
		}

	}
}

type WanVideoAddS2VEmbedsInputs = {
			"embeds": ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			/** Number of frames in a single window*/
			"frame_window_size": ComfyNodeTypedInputRef<number>
			/** Scale factor for audio embeddings*/
			"audio_scale": ComfyNodeTypedInputRef<number>
			/** Start percentage for pose embeddings*/
			"pose_start_percent": ComfyNodeTypedInputRef<number>
			/** End percentage for pose embeddings*/
			"pose_end_percent": ComfyNodeTypedInputRef<number>
			"audio_encoder_output"?: ComfyNodeTypedInputRef<ComfyValueType_AUDIO_ENCODER_OUTPUT>
			"ref_latent"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"pose_latent"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"vae"?: ComfyNodeTypedInputRef<ComfyValueType_WANVAE>
			/** Enable Framepack sampling loop, not compatible with context windows*/
			"enable_framepack"?: ComfyNodeTypedInputRef<boolean>
}


export class WanVideoSampler extends ComfyNode {
	classType: string = "WanVideoSampler"

	sockets: {
		inputs: Required<WanVideoSamplerInputs>
		outputs: {
			samples: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
			denoised_samples: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>(this, "model"),
				"image_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>(this, "image_embeds"),
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"cfg": new ComfyNodeTypedInputRef<number>(this, "cfg"),
				"shift": new ComfyNodeTypedInputRef<number>(this, "shift"),
				"seed": new ComfyNodeTypedInputRef<number>(this, "seed"),
				"force_offload": new ComfyNodeTypedInputRef<boolean>(this, "force_offload"),
				"scheduler": new ComfyNodeTypedInputRef<string>(this, "scheduler"),
				"riflex_freq_index": new ComfyNodeTypedInputRef<number>(this, "riflex_freq_index"),
				"text_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOTEXTEMBEDS>(this, "text_embeds"),
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"denoise_strength": new ComfyNodeTypedInputRef<number>(this, "denoise_strength"),
				"feta_args": new ComfyNodeTypedInputRef<ComfyValueType_FETAARGS>(this, "feta_args"),
				"context_options": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDCONTEXT>(this, "context_options"),
				"cache_args": new ComfyNodeTypedInputRef<ComfyValueType_CACHEARGS>(this, "cache_args"),
				"flowedit_args": new ComfyNodeTypedInputRef<ComfyValueType_FLOWEDITARGS>(this, "flowedit_args"),
				"batched_cfg": new ComfyNodeTypedInputRef<boolean>(this, "batched_cfg"),
				"slg_args": new ComfyNodeTypedInputRef<ComfyValueType_SLGARGS>(this, "slg_args"),
				"rope_function": new ComfyNodeTypedInputRef<string>(this, "rope_function"),
				"loop_args": new ComfyNodeTypedInputRef<ComfyValueType_LOOPARGS>(this, "loop_args"),
				"experimental_args": new ComfyNodeTypedInputRef<ComfyValueType_EXPERIMENTALARGS>(this, "experimental_args"),
				"sigmas": new ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>(this, "sigmas"),
				"unianimate_poses": new ComfyNodeTypedInputRef<ComfyValueType_UNIANIMATE_POSE>(this, "unianimate_poses"),
				"fantasytalking_embeds": new ComfyNodeTypedInputRef<ComfyValueType_FANTASYTALKING_EMBEDS>(this, "fantasytalking_embeds"),
				"uni3c_embeds": new ComfyNodeTypedInputRef<ComfyValueType_UNI3C_EMBEDS>(this, "uni3c_embeds"),
				"multitalk_embeds": new ComfyNodeTypedInputRef<ComfyValueType_MULTITALK_EMBEDS>(this, "multitalk_embeds"),
				"freeinit_args": new ComfyNodeTypedInputRef<ComfyValueType_FREEINITARGS>(this, "freeinit_args"),
				"start_step": new ComfyNodeTypedInputRef<number>(this, "start_step"),
				"end_step": new ComfyNodeTypedInputRef<number>(this, "end_step"),
				"add_noise_to_samples": new ComfyNodeTypedInputRef<boolean>(this, "add_noise_to_samples"),
			},
			outputs: Object.create(Object.prototype, {
				"samples": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"denoised_samples": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoSamplerInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["image_embeds"] === "object") {
			this.sockets.inputs["image_embeds"].connectTo(sources["image_embeds"])
		} else {
			this.sockets.inputs["image_embeds"].value = sources["image_embeds"]
		}

		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["cfg"] === "object") {
			this.sockets.inputs["cfg"].connectTo(sources["cfg"])
		} else {
			this.sockets.inputs["cfg"].value = sources["cfg"]
		}

		if (typeof sources["shift"] === "object") {
			this.sockets.inputs["shift"].connectTo(sources["shift"])
		} else {
			this.sockets.inputs["shift"].value = sources["shift"]
		}

		if (typeof sources["seed"] === "object") {
			this.sockets.inputs["seed"].connectTo(sources["seed"])
		} else {
			this.sockets.inputs["seed"].value = sources["seed"]
		}

		if (typeof sources["force_offload"] === "object") {
			this.sockets.inputs["force_offload"].connectTo(sources["force_offload"])
		} else {
			this.sockets.inputs["force_offload"].value = sources["force_offload"]
		}

		if (typeof sources["scheduler"] === "object") {
			this.sockets.inputs["scheduler"].connectTo(sources["scheduler"])
		} else {
			this.sockets.inputs["scheduler"].value = sources["scheduler"]
		}

		if (typeof sources["riflex_freq_index"] === "object") {
			this.sockets.inputs["riflex_freq_index"].connectTo(sources["riflex_freq_index"])
		} else {
			this.sockets.inputs["riflex_freq_index"].value = sources["riflex_freq_index"]
		}

		if (sources["text_embeds"] !== undefined) {
		if (typeof sources["text_embeds"] === "object") {
			this.sockets.inputs["text_embeds"].connectTo(sources["text_embeds"])
		} else {
			this.sockets.inputs["text_embeds"].value = sources["text_embeds"]
		}
		}

		if (sources["samples"] !== undefined) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}
		}

		if (sources["denoise_strength"] !== undefined) {
		if (typeof sources["denoise_strength"] === "object") {
			this.sockets.inputs["denoise_strength"].connectTo(sources["denoise_strength"])
		} else {
			this.sockets.inputs["denoise_strength"].value = sources["denoise_strength"]
		}
		}

		if (sources["feta_args"] !== undefined) {
		if (typeof sources["feta_args"] === "object") {
			this.sockets.inputs["feta_args"].connectTo(sources["feta_args"])
		} else {
			this.sockets.inputs["feta_args"].value = sources["feta_args"]
		}
		}

		if (sources["context_options"] !== undefined) {
		if (typeof sources["context_options"] === "object") {
			this.sockets.inputs["context_options"].connectTo(sources["context_options"])
		} else {
			this.sockets.inputs["context_options"].value = sources["context_options"]
		}
		}

		if (sources["cache_args"] !== undefined) {
		if (typeof sources["cache_args"] === "object") {
			this.sockets.inputs["cache_args"].connectTo(sources["cache_args"])
		} else {
			this.sockets.inputs["cache_args"].value = sources["cache_args"]
		}
		}

		if (sources["flowedit_args"] !== undefined) {
		if (typeof sources["flowedit_args"] === "object") {
			this.sockets.inputs["flowedit_args"].connectTo(sources["flowedit_args"])
		} else {
			this.sockets.inputs["flowedit_args"].value = sources["flowedit_args"]
		}
		}

		if (sources["batched_cfg"] !== undefined) {
		if (typeof sources["batched_cfg"] === "object") {
			this.sockets.inputs["batched_cfg"].connectTo(sources["batched_cfg"])
		} else {
			this.sockets.inputs["batched_cfg"].value = sources["batched_cfg"]
		}
		}

		if (sources["slg_args"] !== undefined) {
		if (typeof sources["slg_args"] === "object") {
			this.sockets.inputs["slg_args"].connectTo(sources["slg_args"])
		} else {
			this.sockets.inputs["slg_args"].value = sources["slg_args"]
		}
		}

		if (sources["rope_function"] !== undefined) {
		if (typeof sources["rope_function"] === "object") {
			this.sockets.inputs["rope_function"].connectTo(sources["rope_function"])
		} else {
			this.sockets.inputs["rope_function"].value = sources["rope_function"]
		}
		}

		if (sources["loop_args"] !== undefined) {
		if (typeof sources["loop_args"] === "object") {
			this.sockets.inputs["loop_args"].connectTo(sources["loop_args"])
		} else {
			this.sockets.inputs["loop_args"].value = sources["loop_args"]
		}
		}

		if (sources["experimental_args"] !== undefined) {
		if (typeof sources["experimental_args"] === "object") {
			this.sockets.inputs["experimental_args"].connectTo(sources["experimental_args"])
		} else {
			this.sockets.inputs["experimental_args"].value = sources["experimental_args"]
		}
		}

		if (sources["sigmas"] !== undefined) {
		if (typeof sources["sigmas"] === "object") {
			this.sockets.inputs["sigmas"].connectTo(sources["sigmas"])
		} else {
			this.sockets.inputs["sigmas"].value = sources["sigmas"]
		}
		}

		if (sources["unianimate_poses"] !== undefined) {
		if (typeof sources["unianimate_poses"] === "object") {
			this.sockets.inputs["unianimate_poses"].connectTo(sources["unianimate_poses"])
		} else {
			this.sockets.inputs["unianimate_poses"].value = sources["unianimate_poses"]
		}
		}

		if (sources["fantasytalking_embeds"] !== undefined) {
		if (typeof sources["fantasytalking_embeds"] === "object") {
			this.sockets.inputs["fantasytalking_embeds"].connectTo(sources["fantasytalking_embeds"])
		} else {
			this.sockets.inputs["fantasytalking_embeds"].value = sources["fantasytalking_embeds"]
		}
		}

		if (sources["uni3c_embeds"] !== undefined) {
		if (typeof sources["uni3c_embeds"] === "object") {
			this.sockets.inputs["uni3c_embeds"].connectTo(sources["uni3c_embeds"])
		} else {
			this.sockets.inputs["uni3c_embeds"].value = sources["uni3c_embeds"]
		}
		}

		if (sources["multitalk_embeds"] !== undefined) {
		if (typeof sources["multitalk_embeds"] === "object") {
			this.sockets.inputs["multitalk_embeds"].connectTo(sources["multitalk_embeds"])
		} else {
			this.sockets.inputs["multitalk_embeds"].value = sources["multitalk_embeds"]
		}
		}

		if (sources["freeinit_args"] !== undefined) {
		if (typeof sources["freeinit_args"] === "object") {
			this.sockets.inputs["freeinit_args"].connectTo(sources["freeinit_args"])
		} else {
			this.sockets.inputs["freeinit_args"].value = sources["freeinit_args"]
		}
		}

		if (sources["start_step"] !== undefined) {
		if (typeof sources["start_step"] === "object") {
			this.sockets.inputs["start_step"].connectTo(sources["start_step"])
		} else {
			this.sockets.inputs["start_step"].value = sources["start_step"]
		}
		}

		if (sources["end_step"] !== undefined) {
		if (typeof sources["end_step"] === "object") {
			this.sockets.inputs["end_step"].connectTo(sources["end_step"])
		} else {
			this.sockets.inputs["end_step"].value = sources["end_step"]
		}
		}

		if (sources["add_noise_to_samples"] !== undefined) {
		if (typeof sources["add_noise_to_samples"] === "object") {
			this.sockets.inputs["add_noise_to_samples"].connectTo(sources["add_noise_to_samples"])
		} else {
			this.sockets.inputs["add_noise_to_samples"].value = sources["add_noise_to_samples"]
		}
		}

	}
}

type WanVideoSamplerInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>
			"image_embeds": ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			"steps": ComfyNodeTypedInputRef<number>
			"cfg": ComfyNodeTypedInputRef<number>
			"shift": ComfyNodeTypedInputRef<number>
			"seed": ComfyNodeTypedInputRef<number>
			/** Moves the model to the offload device after sampling*/
			"force_offload": ComfyNodeTypedInputRef<boolean>
			"scheduler": ComfyNodeTypedInputRef<string>
			/** Frequency index for RIFLEX, disabled when 0, default 6. Allows for new frames to be generated after without looping*/
			"riflex_freq_index": ComfyNodeTypedInputRef<number>
			"text_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOTEXTEMBEDS>
			/** init Latents to use for video2video process*/
			"samples"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"denoise_strength"?: ComfyNodeTypedInputRef<number>
			"feta_args"?: ComfyNodeTypedInputRef<ComfyValueType_FETAARGS>
			"context_options"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDCONTEXT>
			"cache_args"?: ComfyNodeTypedInputRef<ComfyValueType_CACHEARGS>
			"flowedit_args"?: ComfyNodeTypedInputRef<ComfyValueType_FLOWEDITARGS>
			/** Batch cond and uncond for faster sampling, possibly faster on some hardware, uses more memory*/
			"batched_cfg"?: ComfyNodeTypedInputRef<boolean>
			"slg_args"?: ComfyNodeTypedInputRef<ComfyValueType_SLGARGS>
			/** Comfy's RoPE implementation doesn't use complex numbers and can thus be compiled, that should be a lot faster when using torch.compile. Chunked version has reduced peak VRAM usage when not using torch.compile*/
			"rope_function"?: ComfyNodeTypedInputRef<string>
			"loop_args"?: ComfyNodeTypedInputRef<ComfyValueType_LOOPARGS>
			"experimental_args"?: ComfyNodeTypedInputRef<ComfyValueType_EXPERIMENTALARGS>
			"sigmas"?: ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>
			"unianimate_poses"?: ComfyNodeTypedInputRef<ComfyValueType_UNIANIMATE_POSE>
			"fantasytalking_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_FANTASYTALKING_EMBEDS>
			"uni3c_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_UNI3C_EMBEDS>
			"multitalk_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_MULTITALK_EMBEDS>
			"freeinit_args"?: ComfyNodeTypedInputRef<ComfyValueType_FREEINITARGS>
			/** Start step for the sampling, 0 means full sampling, otherwise samples only from this step*/
			"start_step"?: ComfyNodeTypedInputRef<number>
			/** End step for the sampling, -1 means full sampling, otherwise samples only until this step*/
			"end_step"?: ComfyNodeTypedInputRef<number>
			/** Add noise to the samples before sampling, needed for video2video sampling when starting from clean video*/
			"add_noise_to_samples"?: ComfyNodeTypedInputRef<boolean>
}


export class WanVideoSamplerSettings extends ComfyNode {
	classType: string = "WanVideoSamplerSettings"

	sockets: {
		inputs: Required<WanVideoSamplerSettingsInputs>
		outputs: {
			sampler_inputs: ComfyNodeTypedSourceRef<ComfyValueType_SAMPLER_ARGS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>(this, "model"),
				"image_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>(this, "image_embeds"),
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"cfg": new ComfyNodeTypedInputRef<number>(this, "cfg"),
				"shift": new ComfyNodeTypedInputRef<number>(this, "shift"),
				"seed": new ComfyNodeTypedInputRef<number>(this, "seed"),
				"force_offload": new ComfyNodeTypedInputRef<boolean>(this, "force_offload"),
				"scheduler": new ComfyNodeTypedInputRef<string>(this, "scheduler"),
				"riflex_freq_index": new ComfyNodeTypedInputRef<number>(this, "riflex_freq_index"),
				"text_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOTEXTEMBEDS>(this, "text_embeds"),
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"denoise_strength": new ComfyNodeTypedInputRef<number>(this, "denoise_strength"),
				"feta_args": new ComfyNodeTypedInputRef<ComfyValueType_FETAARGS>(this, "feta_args"),
				"context_options": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDCONTEXT>(this, "context_options"),
				"cache_args": new ComfyNodeTypedInputRef<ComfyValueType_CACHEARGS>(this, "cache_args"),
				"flowedit_args": new ComfyNodeTypedInputRef<ComfyValueType_FLOWEDITARGS>(this, "flowedit_args"),
				"batched_cfg": new ComfyNodeTypedInputRef<boolean>(this, "batched_cfg"),
				"slg_args": new ComfyNodeTypedInputRef<ComfyValueType_SLGARGS>(this, "slg_args"),
				"rope_function": new ComfyNodeTypedInputRef<string>(this, "rope_function"),
				"loop_args": new ComfyNodeTypedInputRef<ComfyValueType_LOOPARGS>(this, "loop_args"),
				"experimental_args": new ComfyNodeTypedInputRef<ComfyValueType_EXPERIMENTALARGS>(this, "experimental_args"),
				"sigmas": new ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>(this, "sigmas"),
				"unianimate_poses": new ComfyNodeTypedInputRef<ComfyValueType_UNIANIMATE_POSE>(this, "unianimate_poses"),
				"fantasytalking_embeds": new ComfyNodeTypedInputRef<ComfyValueType_FANTASYTALKING_EMBEDS>(this, "fantasytalking_embeds"),
				"uni3c_embeds": new ComfyNodeTypedInputRef<ComfyValueType_UNI3C_EMBEDS>(this, "uni3c_embeds"),
				"multitalk_embeds": new ComfyNodeTypedInputRef<ComfyValueType_MULTITALK_EMBEDS>(this, "multitalk_embeds"),
				"freeinit_args": new ComfyNodeTypedInputRef<ComfyValueType_FREEINITARGS>(this, "freeinit_args"),
				"start_step": new ComfyNodeTypedInputRef<number>(this, "start_step"),
				"end_step": new ComfyNodeTypedInputRef<number>(this, "end_step"),
				"add_noise_to_samples": new ComfyNodeTypedInputRef<boolean>(this, "add_noise_to_samples"),
			},
			outputs: Object.create(Object.prototype, {
				"sampler_inputs": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoSamplerSettingsInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["image_embeds"] === "object") {
			this.sockets.inputs["image_embeds"].connectTo(sources["image_embeds"])
		} else {
			this.sockets.inputs["image_embeds"].value = sources["image_embeds"]
		}

		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["cfg"] === "object") {
			this.sockets.inputs["cfg"].connectTo(sources["cfg"])
		} else {
			this.sockets.inputs["cfg"].value = sources["cfg"]
		}

		if (typeof sources["shift"] === "object") {
			this.sockets.inputs["shift"].connectTo(sources["shift"])
		} else {
			this.sockets.inputs["shift"].value = sources["shift"]
		}

		if (typeof sources["seed"] === "object") {
			this.sockets.inputs["seed"].connectTo(sources["seed"])
		} else {
			this.sockets.inputs["seed"].value = sources["seed"]
		}

		if (typeof sources["force_offload"] === "object") {
			this.sockets.inputs["force_offload"].connectTo(sources["force_offload"])
		} else {
			this.sockets.inputs["force_offload"].value = sources["force_offload"]
		}

		if (typeof sources["scheduler"] === "object") {
			this.sockets.inputs["scheduler"].connectTo(sources["scheduler"])
		} else {
			this.sockets.inputs["scheduler"].value = sources["scheduler"]
		}

		if (typeof sources["riflex_freq_index"] === "object") {
			this.sockets.inputs["riflex_freq_index"].connectTo(sources["riflex_freq_index"])
		} else {
			this.sockets.inputs["riflex_freq_index"].value = sources["riflex_freq_index"]
		}

		if (sources["text_embeds"] !== undefined) {
		if (typeof sources["text_embeds"] === "object") {
			this.sockets.inputs["text_embeds"].connectTo(sources["text_embeds"])
		} else {
			this.sockets.inputs["text_embeds"].value = sources["text_embeds"]
		}
		}

		if (sources["samples"] !== undefined) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}
		}

		if (sources["denoise_strength"] !== undefined) {
		if (typeof sources["denoise_strength"] === "object") {
			this.sockets.inputs["denoise_strength"].connectTo(sources["denoise_strength"])
		} else {
			this.sockets.inputs["denoise_strength"].value = sources["denoise_strength"]
		}
		}

		if (sources["feta_args"] !== undefined) {
		if (typeof sources["feta_args"] === "object") {
			this.sockets.inputs["feta_args"].connectTo(sources["feta_args"])
		} else {
			this.sockets.inputs["feta_args"].value = sources["feta_args"]
		}
		}

		if (sources["context_options"] !== undefined) {
		if (typeof sources["context_options"] === "object") {
			this.sockets.inputs["context_options"].connectTo(sources["context_options"])
		} else {
			this.sockets.inputs["context_options"].value = sources["context_options"]
		}
		}

		if (sources["cache_args"] !== undefined) {
		if (typeof sources["cache_args"] === "object") {
			this.sockets.inputs["cache_args"].connectTo(sources["cache_args"])
		} else {
			this.sockets.inputs["cache_args"].value = sources["cache_args"]
		}
		}

		if (sources["flowedit_args"] !== undefined) {
		if (typeof sources["flowedit_args"] === "object") {
			this.sockets.inputs["flowedit_args"].connectTo(sources["flowedit_args"])
		} else {
			this.sockets.inputs["flowedit_args"].value = sources["flowedit_args"]
		}
		}

		if (sources["batched_cfg"] !== undefined) {
		if (typeof sources["batched_cfg"] === "object") {
			this.sockets.inputs["batched_cfg"].connectTo(sources["batched_cfg"])
		} else {
			this.sockets.inputs["batched_cfg"].value = sources["batched_cfg"]
		}
		}

		if (sources["slg_args"] !== undefined) {
		if (typeof sources["slg_args"] === "object") {
			this.sockets.inputs["slg_args"].connectTo(sources["slg_args"])
		} else {
			this.sockets.inputs["slg_args"].value = sources["slg_args"]
		}
		}

		if (sources["rope_function"] !== undefined) {
		if (typeof sources["rope_function"] === "object") {
			this.sockets.inputs["rope_function"].connectTo(sources["rope_function"])
		} else {
			this.sockets.inputs["rope_function"].value = sources["rope_function"]
		}
		}

		if (sources["loop_args"] !== undefined) {
		if (typeof sources["loop_args"] === "object") {
			this.sockets.inputs["loop_args"].connectTo(sources["loop_args"])
		} else {
			this.sockets.inputs["loop_args"].value = sources["loop_args"]
		}
		}

		if (sources["experimental_args"] !== undefined) {
		if (typeof sources["experimental_args"] === "object") {
			this.sockets.inputs["experimental_args"].connectTo(sources["experimental_args"])
		} else {
			this.sockets.inputs["experimental_args"].value = sources["experimental_args"]
		}
		}

		if (sources["sigmas"] !== undefined) {
		if (typeof sources["sigmas"] === "object") {
			this.sockets.inputs["sigmas"].connectTo(sources["sigmas"])
		} else {
			this.sockets.inputs["sigmas"].value = sources["sigmas"]
		}
		}

		if (sources["unianimate_poses"] !== undefined) {
		if (typeof sources["unianimate_poses"] === "object") {
			this.sockets.inputs["unianimate_poses"].connectTo(sources["unianimate_poses"])
		} else {
			this.sockets.inputs["unianimate_poses"].value = sources["unianimate_poses"]
		}
		}

		if (sources["fantasytalking_embeds"] !== undefined) {
		if (typeof sources["fantasytalking_embeds"] === "object") {
			this.sockets.inputs["fantasytalking_embeds"].connectTo(sources["fantasytalking_embeds"])
		} else {
			this.sockets.inputs["fantasytalking_embeds"].value = sources["fantasytalking_embeds"]
		}
		}

		if (sources["uni3c_embeds"] !== undefined) {
		if (typeof sources["uni3c_embeds"] === "object") {
			this.sockets.inputs["uni3c_embeds"].connectTo(sources["uni3c_embeds"])
		} else {
			this.sockets.inputs["uni3c_embeds"].value = sources["uni3c_embeds"]
		}
		}

		if (sources["multitalk_embeds"] !== undefined) {
		if (typeof sources["multitalk_embeds"] === "object") {
			this.sockets.inputs["multitalk_embeds"].connectTo(sources["multitalk_embeds"])
		} else {
			this.sockets.inputs["multitalk_embeds"].value = sources["multitalk_embeds"]
		}
		}

		if (sources["freeinit_args"] !== undefined) {
		if (typeof sources["freeinit_args"] === "object") {
			this.sockets.inputs["freeinit_args"].connectTo(sources["freeinit_args"])
		} else {
			this.sockets.inputs["freeinit_args"].value = sources["freeinit_args"]
		}
		}

		if (sources["start_step"] !== undefined) {
		if (typeof sources["start_step"] === "object") {
			this.sockets.inputs["start_step"].connectTo(sources["start_step"])
		} else {
			this.sockets.inputs["start_step"].value = sources["start_step"]
		}
		}

		if (sources["end_step"] !== undefined) {
		if (typeof sources["end_step"] === "object") {
			this.sockets.inputs["end_step"].connectTo(sources["end_step"])
		} else {
			this.sockets.inputs["end_step"].value = sources["end_step"]
		}
		}

		if (sources["add_noise_to_samples"] !== undefined) {
		if (typeof sources["add_noise_to_samples"] === "object") {
			this.sockets.inputs["add_noise_to_samples"].connectTo(sources["add_noise_to_samples"])
		} else {
			this.sockets.inputs["add_noise_to_samples"].value = sources["add_noise_to_samples"]
		}
		}

	}
}

type WanVideoSamplerSettingsInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>
			"image_embeds": ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			"steps": ComfyNodeTypedInputRef<number>
			"cfg": ComfyNodeTypedInputRef<number>
			"shift": ComfyNodeTypedInputRef<number>
			"seed": ComfyNodeTypedInputRef<number>
			/** Moves the model to the offload device after sampling*/
			"force_offload": ComfyNodeTypedInputRef<boolean>
			"scheduler": ComfyNodeTypedInputRef<string>
			/** Frequency index for RIFLEX, disabled when 0, default 6. Allows for new frames to be generated after without looping*/
			"riflex_freq_index": ComfyNodeTypedInputRef<number>
			"text_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOTEXTEMBEDS>
			/** init Latents to use for video2video process*/
			"samples"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"denoise_strength"?: ComfyNodeTypedInputRef<number>
			"feta_args"?: ComfyNodeTypedInputRef<ComfyValueType_FETAARGS>
			"context_options"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDCONTEXT>
			"cache_args"?: ComfyNodeTypedInputRef<ComfyValueType_CACHEARGS>
			"flowedit_args"?: ComfyNodeTypedInputRef<ComfyValueType_FLOWEDITARGS>
			/** Batch cond and uncond for faster sampling, possibly faster on some hardware, uses more memory*/
			"batched_cfg"?: ComfyNodeTypedInputRef<boolean>
			"slg_args"?: ComfyNodeTypedInputRef<ComfyValueType_SLGARGS>
			/** Comfy's RoPE implementation doesn't use complex numbers and can thus be compiled, that should be a lot faster when using torch.compile. Chunked version has reduced peak VRAM usage when not using torch.compile*/
			"rope_function"?: ComfyNodeTypedInputRef<string>
			"loop_args"?: ComfyNodeTypedInputRef<ComfyValueType_LOOPARGS>
			"experimental_args"?: ComfyNodeTypedInputRef<ComfyValueType_EXPERIMENTALARGS>
			"sigmas"?: ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>
			"unianimate_poses"?: ComfyNodeTypedInputRef<ComfyValueType_UNIANIMATE_POSE>
			"fantasytalking_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_FANTASYTALKING_EMBEDS>
			"uni3c_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_UNI3C_EMBEDS>
			"multitalk_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_MULTITALK_EMBEDS>
			"freeinit_args"?: ComfyNodeTypedInputRef<ComfyValueType_FREEINITARGS>
			/** Start step for the sampling, 0 means full sampling, otherwise samples only from this step*/
			"start_step"?: ComfyNodeTypedInputRef<number>
			/** End step for the sampling, -1 means full sampling, otherwise samples only until this step*/
			"end_step"?: ComfyNodeTypedInputRef<number>
			/** Add noise to the samples before sampling, needed for video2video sampling when starting from clean video*/
			"add_noise_to_samples"?: ComfyNodeTypedInputRef<boolean>
}


export class WanVideoSamplerFromSettings extends ComfyNode {
	classType: string = "WanVideoSamplerFromSettings"

	sockets: {
		inputs: Required<WanVideoSamplerFromSettingsInputs>
		outputs: {
			samples: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
			denoised_samples: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"sampler_inputs": new ComfyNodeTypedInputRef<ComfyValueType_SAMPLER_ARGS>(this, "sampler_inputs"),
			},
			outputs: Object.create(Object.prototype, {
				"samples": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"denoised_samples": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoSamplerFromSettingsInputs>) {
		if (typeof sources["sampler_inputs"] === "object") {
			this.sockets.inputs["sampler_inputs"].connectTo(sources["sampler_inputs"])
		} else {
			this.sockets.inputs["sampler_inputs"].value = sources["sampler_inputs"]
		}

	}
}

type WanVideoSamplerFromSettingsInputs = {
			"sampler_inputs": ComfyNodeTypedInputRef<ComfyValueType_SAMPLER_ARGS>
}


export class LoadLynxResampler extends ComfyNode {
	classType: string = "LoadLynxResampler"

	sockets: {
		inputs: Required<LoadLynxResamplerInputs>
		outputs: {
			resampler: ComfyNodeTypedSourceRef<ComfyValueType_LYNXRESAMPLER>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_name": new ComfyNodeTypedInputRef<string>(this, "model_name"),
				"precision": new ComfyNodeTypedInputRef<string>(this, "precision"),
			},
			outputs: Object.create(Object.prototype, {
				"resampler": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoadLynxResamplerInputs>) {
		if (typeof sources["model_name"] === "object") {
			this.sockets.inputs["model_name"].connectTo(sources["model_name"])
		} else {
			this.sockets.inputs["model_name"].value = sources["model_name"]
		}

		if (typeof sources["precision"] === "object") {
			this.sockets.inputs["precision"].connectTo(sources["precision"])
		} else {
			this.sockets.inputs["precision"].value = sources["precision"]
		}

	}
}

type LoadLynxResamplerInputs = {
			/** These models are loaded from 'ComfyUI/models/diffusion_models'*/
			"model_name": ComfyNodeTypedInputRef<string>
			"precision": ComfyNodeTypedInputRef<string>
}


export class LynxEncodeFaceIP extends ComfyNode {
	classType: string = "LynxEncodeFaceIP"

	sockets: {
		inputs: Required<LynxEncodeFaceIPInputs>
		outputs: {
			lynx_face_embeds: ComfyNodeTypedSourceRef<ComfyValueType_LYNXIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"resampler": new ComfyNodeTypedInputRef<ComfyValueType_LYNXRESAMPLER>(this, "resampler"),
				"ip_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "ip_image"),
			},
			outputs: Object.create(Object.prototype, {
				"lynx_face_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LynxEncodeFaceIPInputs>) {
		if (typeof sources["resampler"] === "object") {
			this.sockets.inputs["resampler"].connectTo(sources["resampler"])
		} else {
			this.sockets.inputs["resampler"].value = sources["resampler"]
		}

		if (typeof sources["ip_image"] === "object") {
			this.sockets.inputs["ip_image"].connectTo(sources["ip_image"])
		} else {
			this.sockets.inputs["ip_image"].value = sources["ip_image"]
		}

	}
}

type LynxEncodeFaceIPInputs = {
			/** lynx resampler model*/
			"resampler": ComfyNodeTypedInputRef<ComfyValueType_LYNXRESAMPLER>
			/** Input images for the model*/
			"ip_image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class DrawArcFaceLandmarks extends ComfyNode {
	classType: string = "DrawArcFaceLandmarks"

	sockets: {
		inputs: Required<DrawArcFaceLandmarksInputs>
		outputs: {
			landmarked_image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"lynx_face_embeds": new ComfyNodeTypedInputRef<ComfyValueType_LYNXIP>(this, "lynx_face_embeds"),
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
			},
			outputs: Object.create(Object.prototype, {
				"landmarked_image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DrawArcFaceLandmarksInputs>) {
		if (typeof sources["lynx_face_embeds"] === "object") {
			this.sockets.inputs["lynx_face_embeds"].connectTo(sources["lynx_face_embeds"])
		} else {
			this.sockets.inputs["lynx_face_embeds"].value = sources["lynx_face_embeds"]
		}

		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

	}
}

type DrawArcFaceLandmarksInputs = {
			/** lynx resampler model*/
			"lynx_face_embeds": ComfyNodeTypedInputRef<ComfyValueType_LYNXIP>
			/** Input images for the model*/
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class WanVideoAddLynxEmbeds extends ComfyNode {
	classType: string = "WanVideoAddLynxEmbeds"

	sockets: {
		inputs: Required<WanVideoAddLynxEmbedsInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>(this, "embeds"),
				"ip_scale": new ComfyNodeTypedInputRef<number>(this, "ip_scale"),
				"ref_scale": new ComfyNodeTypedInputRef<number>(this, "ref_scale"),
				"lynx_cfg_scale": new ComfyNodeTypedInputRef<number>(this, "lynx_cfg_scale"),
				"start_percent": new ComfyNodeTypedInputRef<number>(this, "start_percent"),
				"end_percent": new ComfyNodeTypedInputRef<number>(this, "end_percent"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_WANVAE>(this, "vae"),
				"lynx_ip_embeds": new ComfyNodeTypedInputRef<ComfyValueType_LYNXIP>(this, "lynx_ip_embeds"),
				"ref_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "ref_image"),
				"ref_text_embed": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOTEXTEMBEDS>(this, "ref_text_embed"),
				"ref_blocks_to_use": new ComfyNodeTypedInputRef<string>(this, "ref_blocks_to_use"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoAddLynxEmbedsInputs>) {
		if (typeof sources["embeds"] === "object") {
			this.sockets.inputs["embeds"].connectTo(sources["embeds"])
		} else {
			this.sockets.inputs["embeds"].value = sources["embeds"]
		}

		if (typeof sources["ip_scale"] === "object") {
			this.sockets.inputs["ip_scale"].connectTo(sources["ip_scale"])
		} else {
			this.sockets.inputs["ip_scale"].value = sources["ip_scale"]
		}

		if (typeof sources["ref_scale"] === "object") {
			this.sockets.inputs["ref_scale"].connectTo(sources["ref_scale"])
		} else {
			this.sockets.inputs["ref_scale"].value = sources["ref_scale"]
		}

		if (typeof sources["lynx_cfg_scale"] === "object") {
			this.sockets.inputs["lynx_cfg_scale"].connectTo(sources["lynx_cfg_scale"])
		} else {
			this.sockets.inputs["lynx_cfg_scale"].value = sources["lynx_cfg_scale"]
		}

		if (typeof sources["start_percent"] === "object") {
			this.sockets.inputs["start_percent"].connectTo(sources["start_percent"])
		} else {
			this.sockets.inputs["start_percent"].value = sources["start_percent"]
		}

		if (typeof sources["end_percent"] === "object") {
			this.sockets.inputs["end_percent"].connectTo(sources["end_percent"])
		} else {
			this.sockets.inputs["end_percent"].value = sources["end_percent"]
		}

		if (sources["vae"] !== undefined) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}
		}

		if (sources["lynx_ip_embeds"] !== undefined) {
		if (typeof sources["lynx_ip_embeds"] === "object") {
			this.sockets.inputs["lynx_ip_embeds"].connectTo(sources["lynx_ip_embeds"])
		} else {
			this.sockets.inputs["lynx_ip_embeds"].value = sources["lynx_ip_embeds"]
		}
		}

		if (sources["ref_image"] !== undefined) {
		if (typeof sources["ref_image"] === "object") {
			this.sockets.inputs["ref_image"].connectTo(sources["ref_image"])
		} else {
			this.sockets.inputs["ref_image"].value = sources["ref_image"]
		}
		}

		if (sources["ref_text_embed"] !== undefined) {
		if (typeof sources["ref_text_embed"] === "object") {
			this.sockets.inputs["ref_text_embed"].connectTo(sources["ref_text_embed"])
		} else {
			this.sockets.inputs["ref_text_embed"].value = sources["ref_text_embed"]
		}
		}

		if (sources["ref_blocks_to_use"] !== undefined) {
		if (typeof sources["ref_blocks_to_use"] === "object") {
			this.sockets.inputs["ref_blocks_to_use"].connectTo(sources["ref_blocks_to_use"])
		} else {
			this.sockets.inputs["ref_blocks_to_use"].value = sources["ref_blocks_to_use"]
		}
		}

	}
}

type WanVideoAddLynxEmbedsInputs = {
			"embeds": ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			/** Strength of the ip adapter face feature*/
			"ip_scale": ComfyNodeTypedInputRef<number>
			/** Strength of the reference feature*/
			"ref_scale": ComfyNodeTypedInputRef<number>
			/** If above 1.0 and main cfg_scale is above 1.0, run extra pass, default value 2.0*/
			"lynx_cfg_scale": ComfyNodeTypedInputRef<number>
			/** Start percent to apply the ref */
			"start_percent": ComfyNodeTypedInputRef<number>
			/** End percent to apply the ref */
			"end_percent": ComfyNodeTypedInputRef<number>
			/** VAE model, only needed if ref_image is provided*/
			"vae"?: ComfyNodeTypedInputRef<ComfyValueType_WANVAE>
			/** lynx face embeddings*/
			"lynx_ip_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_LYNXIP>
			"ref_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"ref_text_embed"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOTEXTEMBEDS>
			/** Comma-separated list of block indices and ranges to use for reference feature, e.g. '0-20, 25, 28, 35-39'. If empty, use all blocks.*/
			"ref_blocks_to_use"?: ComfyNodeTypedInputRef<string>
}


export class LynxInsightFaceCrop extends ComfyNode {
	classType: string = "LynxInsightFaceCrop"

	sockets: {
		inputs: Required<LynxInsightFaceCropInputs>
		outputs: {
			ip_image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			ref_image: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
			},
			outputs: Object.create(Object.prototype, {
				"ip_image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"ref_image": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LynxInsightFaceCropInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

	}
}

type LynxInsightFaceCropInputs = {
			/** Input images for the model*/
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class WanVideoAddFlashVSRInput extends ComfyNode {
	classType: string = "WanVideoAddFlashVSRInput"

	sockets: {
		inputs: Required<WanVideoAddFlashVSRInputInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>(this, "embeds"),
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoAddFlashVSRInputInputs>) {
		if (typeof sources["embeds"] === "object") {
			this.sockets.inputs["embeds"].connectTo(sources["embeds"])
		} else {
			this.sockets.inputs["embeds"].value = sources["embeds"]
		}

		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

	}
}

type WanVideoAddFlashVSRInputInputs = {
			"embeds": ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			/** Low-res video frames to enhance*/
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Strength to apply the FlashVSR latent*/
			"strength": ComfyNodeTypedInputRef<number>
}


export class WanVideoFlashVSRDecoderLoader extends ComfyNode {
	classType: string = "WanVideoFlashVSRDecoderLoader"

	sockets: {
		inputs: Required<WanVideoFlashVSRDecoderLoaderInputs>
		outputs: {
			vae: ComfyNodeTypedSourceRef<ComfyValueType_WANVAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_name": new ComfyNodeTypedInputRef<string>(this, "model_name"),
				"precision": new ComfyNodeTypedInputRef<string>(this, "precision"),
			},
			outputs: Object.create(Object.prototype, {
				"vae": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoFlashVSRDecoderLoaderInputs>) {
		if (typeof sources["model_name"] === "object") {
			this.sockets.inputs["model_name"].connectTo(sources["model_name"])
		} else {
			this.sockets.inputs["model_name"].value = sources["model_name"]
		}

		if (sources["precision"] !== undefined) {
		if (typeof sources["precision"] === "object") {
			this.sockets.inputs["precision"].connectTo(sources["precision"])
		} else {
			this.sockets.inputs["precision"].value = sources["precision"]
		}
		}

	}
}

type WanVideoFlashVSRDecoderLoaderInputs = {
			/** These models are loaded from 'ComfyUI/models/vae'*/
			"model_name": ComfyNodeTypedInputRef<string>
			"precision"?: ComfyNodeTypedInputRef<string>
}


export class MochaEmbeds extends ComfyNode {
	classType: string = "MochaEmbeds"

	sockets: {
		inputs: Required<MochaEmbedsInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_WANVAE>(this, "vae"),
				"force_offload": new ComfyNodeTypedInputRef<boolean>(this, "force_offload"),
				"input_video": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "input_video"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"ref1": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "ref1"),
				"ref2": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "ref2"),
				"tiled_vae": new ComfyNodeTypedInputRef<boolean>(this, "tiled_vae"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<MochaEmbedsInputs>) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["force_offload"] === "object") {
			this.sockets.inputs["force_offload"].connectTo(sources["force_offload"])
		} else {
			this.sockets.inputs["force_offload"].value = sources["force_offload"]
		}

		if (typeof sources["input_video"] === "object") {
			this.sockets.inputs["input_video"].connectTo(sources["input_video"])
		} else {
			this.sockets.inputs["input_video"].value = sources["input_video"]
		}

		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["ref1"] === "object") {
			this.sockets.inputs["ref1"].connectTo(sources["ref1"])
		} else {
			this.sockets.inputs["ref1"].value = sources["ref1"]
		}

		if (sources["ref2"] !== undefined) {
		if (typeof sources["ref2"] === "object") {
			this.sockets.inputs["ref2"].connectTo(sources["ref2"])
		} else {
			this.sockets.inputs["ref2"].value = sources["ref2"]
		}
		}

		if (sources["tiled_vae"] !== undefined) {
		if (typeof sources["tiled_vae"] === "object") {
			this.sockets.inputs["tiled_vae"].connectTo(sources["tiled_vae"])
		} else {
			this.sockets.inputs["tiled_vae"].value = sources["tiled_vae"]
		}
		}

	}
}

type MochaEmbedsInputs = {
			"vae": ComfyNodeTypedInputRef<ComfyValueType_WANVAE>
			"force_offload": ComfyNodeTypedInputRef<boolean>
			/** Input video to encode*/
			"input_video": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** mask*/
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			/** Image to encode*/
			"ref1": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Image to encode*/
			"ref2"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Use tiled VAE encoding for reduced memory use*/
			"tiled_vae"?: ComfyNodeTypedInputRef<boolean>
}


export class VHS_VideoCombine extends ComfyNode {
	classType: string = "VHS_VideoCombine"

	sockets: {
		inputs: Required<VHS_VideoCombineInputs>
		outputs: {
			Filenames: ComfyNodeTypedSourceRef<ComfyValueType_VHS_FILENAMES>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"frame_rate": new ComfyNodeTypedInputRef<number>(this, "frame_rate"),
				"loop_count": new ComfyNodeTypedInputRef<number>(this, "loop_count"),
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"format": new ComfyNodeTypedInputRef<string>(this, "format"),
				"pingpong": new ComfyNodeTypedInputRef<boolean>(this, "pingpong"),
				"save_output": new ComfyNodeTypedInputRef<boolean>(this, "save_output"),
				"audio": new ComfyNodeTypedInputRef<ComfyValueType_AUDIO>(this, "audio"),
				"meta_batch": new ComfyNodeTypedInputRef<ComfyValueType_VHS_BatchManager>(this, "meta_batch"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"extra_pnginfo": new ComfyNodeTypedInputRef<ComfyValueType_E>(this, "extra_pnginfo"),
				"unique_id": new ComfyNodeTypedInputRef<ComfyValueType_U>(this, "unique_id"),
			},
			outputs: Object.create(Object.prototype, {
				"Filenames": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_VideoCombineInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["frame_rate"] === "object") {
			this.sockets.inputs["frame_rate"].connectTo(sources["frame_rate"])
		} else {
			this.sockets.inputs["frame_rate"].value = sources["frame_rate"]
		}

		if (typeof sources["loop_count"] === "object") {
			this.sockets.inputs["loop_count"].connectTo(sources["loop_count"])
		} else {
			this.sockets.inputs["loop_count"].value = sources["loop_count"]
		}

		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (typeof sources["format"] === "object") {
			this.sockets.inputs["format"].connectTo(sources["format"])
		} else {
			this.sockets.inputs["format"].value = sources["format"]
		}

		if (typeof sources["pingpong"] === "object") {
			this.sockets.inputs["pingpong"].connectTo(sources["pingpong"])
		} else {
			this.sockets.inputs["pingpong"].value = sources["pingpong"]
		}

		if (typeof sources["save_output"] === "object") {
			this.sockets.inputs["save_output"].connectTo(sources["save_output"])
		} else {
			this.sockets.inputs["save_output"].value = sources["save_output"]
		}

		if (sources["audio"] !== undefined) {
		if (typeof sources["audio"] === "object") {
			this.sockets.inputs["audio"].connectTo(sources["audio"])
		} else {
			this.sockets.inputs["audio"].value = sources["audio"]
		}
		}

		if (sources["meta_batch"] !== undefined) {
		if (typeof sources["meta_batch"] === "object") {
			this.sockets.inputs["meta_batch"].connectTo(sources["meta_batch"])
		} else {
			this.sockets.inputs["meta_batch"].value = sources["meta_batch"]
		}
		}

		if (sources["vae"] !== undefined) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["extra_pnginfo"] !== undefined) {
		if (typeof sources["extra_pnginfo"] === "object") {
			this.sockets.inputs["extra_pnginfo"].connectTo(sources["extra_pnginfo"])
		} else {
			this.sockets.inputs["extra_pnginfo"].value = sources["extra_pnginfo"]
		}
		}

		if (sources["unique_id"] !== undefined) {
		if (typeof sources["unique_id"] === "object") {
			this.sockets.inputs["unique_id"].connectTo(sources["unique_id"])
		} else {
			this.sockets.inputs["unique_id"].value = sources["unique_id"]
		}
		}

	}
}

type VHS_VideoCombineInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"frame_rate": ComfyNodeTypedInputRef<number>
			"loop_count": ComfyNodeTypedInputRef<number>
			"filename_prefix": ComfyNodeTypedInputRef<string>
			"format": ComfyNodeTypedInputRef<string>
			"pingpong": ComfyNodeTypedInputRef<boolean>
			"save_output": ComfyNodeTypedInputRef<boolean>
			"audio"?: ComfyNodeTypedInputRef<ComfyValueType_AUDIO>
			"meta_batch"?: ComfyNodeTypedInputRef<ComfyValueType_VHS_BatchManager>
			"vae"?: ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"extra_pnginfo"?: ComfyNodeTypedInputRef<ComfyValueType_E>
			"unique_id"?: ComfyNodeTypedInputRef<ComfyValueType_U>
}


export class VHS_LoadVideo extends ComfyNode {
	classType: string = "VHS_LoadVideo"

	sockets: {
		inputs: Required<VHS_LoadVideoInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			frame_count: ComfyNodeTypedSourceRef<number>
			audio: ComfyNodeTypedSourceRef<ComfyValueType_AUDIO>
			video_info: ComfyNodeTypedSourceRef<ComfyValueType_VHS_VIDEOINFO>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"video": new ComfyNodeTypedInputRef<string>(this, "video"),
				"force_rate": new ComfyNodeTypedInputRef<number>(this, "force_rate"),
				"custom_width": new ComfyNodeTypedInputRef<number>(this, "custom_width"),
				"custom_height": new ComfyNodeTypedInputRef<number>(this, "custom_height"),
				"frame_load_cap": new ComfyNodeTypedInputRef<number>(this, "frame_load_cap"),
				"skip_first_frames": new ComfyNodeTypedInputRef<number>(this, "skip_first_frames"),
				"select_every_nth": new ComfyNodeTypedInputRef<number>(this, "select_every_nth"),
				"meta_batch": new ComfyNodeTypedInputRef<ComfyValueType_VHS_BatchManager>(this, "meta_batch"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"format": new ComfyNodeTypedInputRef<string>(this, "format"),
				"force_size": new ComfyNodeTypedInputRef<ComfyValueType_S>(this, "force_size"),
				"unique_id": new ComfyNodeTypedInputRef<ComfyValueType_U>(this, "unique_id"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"frame_count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"audio": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"video_info": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_LoadVideoInputs>) {
		if (typeof sources["video"] === "object") {
			this.sockets.inputs["video"].connectTo(sources["video"])
		} else {
			this.sockets.inputs["video"].value = sources["video"]
		}

		if (typeof sources["force_rate"] === "object") {
			this.sockets.inputs["force_rate"].connectTo(sources["force_rate"])
		} else {
			this.sockets.inputs["force_rate"].value = sources["force_rate"]
		}

		if (typeof sources["custom_width"] === "object") {
			this.sockets.inputs["custom_width"].connectTo(sources["custom_width"])
		} else {
			this.sockets.inputs["custom_width"].value = sources["custom_width"]
		}

		if (typeof sources["custom_height"] === "object") {
			this.sockets.inputs["custom_height"].connectTo(sources["custom_height"])
		} else {
			this.sockets.inputs["custom_height"].value = sources["custom_height"]
		}

		if (typeof sources["frame_load_cap"] === "object") {
			this.sockets.inputs["frame_load_cap"].connectTo(sources["frame_load_cap"])
		} else {
			this.sockets.inputs["frame_load_cap"].value = sources["frame_load_cap"]
		}

		if (typeof sources["skip_first_frames"] === "object") {
			this.sockets.inputs["skip_first_frames"].connectTo(sources["skip_first_frames"])
		} else {
			this.sockets.inputs["skip_first_frames"].value = sources["skip_first_frames"]
		}

		if (typeof sources["select_every_nth"] === "object") {
			this.sockets.inputs["select_every_nth"].connectTo(sources["select_every_nth"])
		} else {
			this.sockets.inputs["select_every_nth"].value = sources["select_every_nth"]
		}

		if (sources["meta_batch"] !== undefined) {
		if (typeof sources["meta_batch"] === "object") {
			this.sockets.inputs["meta_batch"].connectTo(sources["meta_batch"])
		} else {
			this.sockets.inputs["meta_batch"].value = sources["meta_batch"]
		}
		}

		if (sources["vae"] !== undefined) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}
		}

		if (sources["format"] !== undefined) {
		if (typeof sources["format"] === "object") {
			this.sockets.inputs["format"].connectTo(sources["format"])
		} else {
			this.sockets.inputs["format"].value = sources["format"]
		}
		}

		if (sources["force_size"] !== undefined) {
		if (typeof sources["force_size"] === "object") {
			this.sockets.inputs["force_size"].connectTo(sources["force_size"])
		} else {
			this.sockets.inputs["force_size"].value = sources["force_size"]
		}
		}

		if (sources["unique_id"] !== undefined) {
		if (typeof sources["unique_id"] === "object") {
			this.sockets.inputs["unique_id"].connectTo(sources["unique_id"])
		} else {
			this.sockets.inputs["unique_id"].value = sources["unique_id"]
		}
		}

	}
}

type VHS_LoadVideoInputs = {
			"video": ComfyNodeTypedInputRef<string>
			"force_rate": ComfyNodeTypedInputRef<number>
			"custom_width": ComfyNodeTypedInputRef<number>
			"custom_height": ComfyNodeTypedInputRef<number>
			"frame_load_cap": ComfyNodeTypedInputRef<number>
			"skip_first_frames": ComfyNodeTypedInputRef<number>
			"select_every_nth": ComfyNodeTypedInputRef<number>
			"meta_batch"?: ComfyNodeTypedInputRef<ComfyValueType_VHS_BatchManager>
			"vae"?: ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"format"?: ComfyNodeTypedInputRef<string>
			"force_size"?: ComfyNodeTypedInputRef<ComfyValueType_S>
			"unique_id"?: ComfyNodeTypedInputRef<ComfyValueType_U>
}


export class VHS_LoadVideoPath extends ComfyNode {
	classType: string = "VHS_LoadVideoPath"

	sockets: {
		inputs: Required<VHS_LoadVideoPathInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			frame_count: ComfyNodeTypedSourceRef<number>
			audio: ComfyNodeTypedSourceRef<ComfyValueType_AUDIO>
			video_info: ComfyNodeTypedSourceRef<ComfyValueType_VHS_VIDEOINFO>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"video": new ComfyNodeTypedInputRef<string>(this, "video"),
				"force_rate": new ComfyNodeTypedInputRef<number>(this, "force_rate"),
				"custom_width": new ComfyNodeTypedInputRef<number>(this, "custom_width"),
				"custom_height": new ComfyNodeTypedInputRef<number>(this, "custom_height"),
				"frame_load_cap": new ComfyNodeTypedInputRef<number>(this, "frame_load_cap"),
				"skip_first_frames": new ComfyNodeTypedInputRef<number>(this, "skip_first_frames"),
				"select_every_nth": new ComfyNodeTypedInputRef<number>(this, "select_every_nth"),
				"meta_batch": new ComfyNodeTypedInputRef<ComfyValueType_VHS_BatchManager>(this, "meta_batch"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"format": new ComfyNodeTypedInputRef<string>(this, "format"),
				"force_size": new ComfyNodeTypedInputRef<ComfyValueType_S>(this, "force_size"),
				"unique_id": new ComfyNodeTypedInputRef<ComfyValueType_U>(this, "unique_id"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"frame_count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"audio": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"video_info": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_LoadVideoPathInputs>) {
		if (typeof sources["video"] === "object") {
			this.sockets.inputs["video"].connectTo(sources["video"])
		} else {
			this.sockets.inputs["video"].value = sources["video"]
		}

		if (typeof sources["force_rate"] === "object") {
			this.sockets.inputs["force_rate"].connectTo(sources["force_rate"])
		} else {
			this.sockets.inputs["force_rate"].value = sources["force_rate"]
		}

		if (typeof sources["custom_width"] === "object") {
			this.sockets.inputs["custom_width"].connectTo(sources["custom_width"])
		} else {
			this.sockets.inputs["custom_width"].value = sources["custom_width"]
		}

		if (typeof sources["custom_height"] === "object") {
			this.sockets.inputs["custom_height"].connectTo(sources["custom_height"])
		} else {
			this.sockets.inputs["custom_height"].value = sources["custom_height"]
		}

		if (typeof sources["frame_load_cap"] === "object") {
			this.sockets.inputs["frame_load_cap"].connectTo(sources["frame_load_cap"])
		} else {
			this.sockets.inputs["frame_load_cap"].value = sources["frame_load_cap"]
		}

		if (typeof sources["skip_first_frames"] === "object") {
			this.sockets.inputs["skip_first_frames"].connectTo(sources["skip_first_frames"])
		} else {
			this.sockets.inputs["skip_first_frames"].value = sources["skip_first_frames"]
		}

		if (typeof sources["select_every_nth"] === "object") {
			this.sockets.inputs["select_every_nth"].connectTo(sources["select_every_nth"])
		} else {
			this.sockets.inputs["select_every_nth"].value = sources["select_every_nth"]
		}

		if (sources["meta_batch"] !== undefined) {
		if (typeof sources["meta_batch"] === "object") {
			this.sockets.inputs["meta_batch"].connectTo(sources["meta_batch"])
		} else {
			this.sockets.inputs["meta_batch"].value = sources["meta_batch"]
		}
		}

		if (sources["vae"] !== undefined) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}
		}

		if (sources["format"] !== undefined) {
		if (typeof sources["format"] === "object") {
			this.sockets.inputs["format"].connectTo(sources["format"])
		} else {
			this.sockets.inputs["format"].value = sources["format"]
		}
		}

		if (sources["force_size"] !== undefined) {
		if (typeof sources["force_size"] === "object") {
			this.sockets.inputs["force_size"].connectTo(sources["force_size"])
		} else {
			this.sockets.inputs["force_size"].value = sources["force_size"]
		}
		}

		if (sources["unique_id"] !== undefined) {
		if (typeof sources["unique_id"] === "object") {
			this.sockets.inputs["unique_id"].connectTo(sources["unique_id"])
		} else {
			this.sockets.inputs["unique_id"].value = sources["unique_id"]
		}
		}

	}
}

type VHS_LoadVideoPathInputs = {
			"video": ComfyNodeTypedInputRef<string>
			"force_rate": ComfyNodeTypedInputRef<number>
			"custom_width": ComfyNodeTypedInputRef<number>
			"custom_height": ComfyNodeTypedInputRef<number>
			"frame_load_cap": ComfyNodeTypedInputRef<number>
			"skip_first_frames": ComfyNodeTypedInputRef<number>
			"select_every_nth": ComfyNodeTypedInputRef<number>
			"meta_batch"?: ComfyNodeTypedInputRef<ComfyValueType_VHS_BatchManager>
			"vae"?: ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"format"?: ComfyNodeTypedInputRef<string>
			"force_size"?: ComfyNodeTypedInputRef<ComfyValueType_S>
			"unique_id"?: ComfyNodeTypedInputRef<ComfyValueType_U>
}


export class VHS_LoadVideoFFmpeg extends ComfyNode {
	classType: string = "VHS_LoadVideoFFmpeg"

	sockets: {
		inputs: Required<VHS_LoadVideoFFmpegInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			audio: ComfyNodeTypedSourceRef<ComfyValueType_AUDIO>
			video_info: ComfyNodeTypedSourceRef<ComfyValueType_VHS_VIDEOINFO>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"video": new ComfyNodeTypedInputRef<string>(this, "video"),
				"force_rate": new ComfyNodeTypedInputRef<number>(this, "force_rate"),
				"custom_width": new ComfyNodeTypedInputRef<number>(this, "custom_width"),
				"custom_height": new ComfyNodeTypedInputRef<number>(this, "custom_height"),
				"frame_load_cap": new ComfyNodeTypedInputRef<number>(this, "frame_load_cap"),
				"start_time": new ComfyNodeTypedInputRef<number>(this, "start_time"),
				"meta_batch": new ComfyNodeTypedInputRef<ComfyValueType_VHS_BatchManager>(this, "meta_batch"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"format": new ComfyNodeTypedInputRef<string>(this, "format"),
				"force_size": new ComfyNodeTypedInputRef<ComfyValueType_S>(this, "force_size"),
				"unique_id": new ComfyNodeTypedInputRef<ComfyValueType_U>(this, "unique_id"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"audio": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"video_info": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_LoadVideoFFmpegInputs>) {
		if (typeof sources["video"] === "object") {
			this.sockets.inputs["video"].connectTo(sources["video"])
		} else {
			this.sockets.inputs["video"].value = sources["video"]
		}

		if (typeof sources["force_rate"] === "object") {
			this.sockets.inputs["force_rate"].connectTo(sources["force_rate"])
		} else {
			this.sockets.inputs["force_rate"].value = sources["force_rate"]
		}

		if (typeof sources["custom_width"] === "object") {
			this.sockets.inputs["custom_width"].connectTo(sources["custom_width"])
		} else {
			this.sockets.inputs["custom_width"].value = sources["custom_width"]
		}

		if (typeof sources["custom_height"] === "object") {
			this.sockets.inputs["custom_height"].connectTo(sources["custom_height"])
		} else {
			this.sockets.inputs["custom_height"].value = sources["custom_height"]
		}

		if (typeof sources["frame_load_cap"] === "object") {
			this.sockets.inputs["frame_load_cap"].connectTo(sources["frame_load_cap"])
		} else {
			this.sockets.inputs["frame_load_cap"].value = sources["frame_load_cap"]
		}

		if (typeof sources["start_time"] === "object") {
			this.sockets.inputs["start_time"].connectTo(sources["start_time"])
		} else {
			this.sockets.inputs["start_time"].value = sources["start_time"]
		}

		if (sources["meta_batch"] !== undefined) {
		if (typeof sources["meta_batch"] === "object") {
			this.sockets.inputs["meta_batch"].connectTo(sources["meta_batch"])
		} else {
			this.sockets.inputs["meta_batch"].value = sources["meta_batch"]
		}
		}

		if (sources["vae"] !== undefined) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}
		}

		if (sources["format"] !== undefined) {
		if (typeof sources["format"] === "object") {
			this.sockets.inputs["format"].connectTo(sources["format"])
		} else {
			this.sockets.inputs["format"].value = sources["format"]
		}
		}

		if (sources["force_size"] !== undefined) {
		if (typeof sources["force_size"] === "object") {
			this.sockets.inputs["force_size"].connectTo(sources["force_size"])
		} else {
			this.sockets.inputs["force_size"].value = sources["force_size"]
		}
		}

		if (sources["unique_id"] !== undefined) {
		if (typeof sources["unique_id"] === "object") {
			this.sockets.inputs["unique_id"].connectTo(sources["unique_id"])
		} else {
			this.sockets.inputs["unique_id"].value = sources["unique_id"]
		}
		}

	}
}

type VHS_LoadVideoFFmpegInputs = {
			"video": ComfyNodeTypedInputRef<string>
			"force_rate": ComfyNodeTypedInputRef<number>
			"custom_width": ComfyNodeTypedInputRef<number>
			"custom_height": ComfyNodeTypedInputRef<number>
			"frame_load_cap": ComfyNodeTypedInputRef<number>
			"start_time": ComfyNodeTypedInputRef<number>
			"meta_batch"?: ComfyNodeTypedInputRef<ComfyValueType_VHS_BatchManager>
			"vae"?: ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"format"?: ComfyNodeTypedInputRef<string>
			"force_size"?: ComfyNodeTypedInputRef<ComfyValueType_S>
			"unique_id"?: ComfyNodeTypedInputRef<ComfyValueType_U>
}


export class VHS_LoadVideoFFmpegPath extends ComfyNode {
	classType: string = "VHS_LoadVideoFFmpegPath"

	sockets: {
		inputs: Required<VHS_LoadVideoFFmpegPathInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			audio: ComfyNodeTypedSourceRef<ComfyValueType_AUDIO>
			video_info: ComfyNodeTypedSourceRef<ComfyValueType_VHS_VIDEOINFO>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"video": new ComfyNodeTypedInputRef<string>(this, "video"),
				"force_rate": new ComfyNodeTypedInputRef<number>(this, "force_rate"),
				"custom_width": new ComfyNodeTypedInputRef<number>(this, "custom_width"),
				"custom_height": new ComfyNodeTypedInputRef<number>(this, "custom_height"),
				"frame_load_cap": new ComfyNodeTypedInputRef<number>(this, "frame_load_cap"),
				"start_time": new ComfyNodeTypedInputRef<number>(this, "start_time"),
				"meta_batch": new ComfyNodeTypedInputRef<ComfyValueType_VHS_BatchManager>(this, "meta_batch"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"format": new ComfyNodeTypedInputRef<string>(this, "format"),
				"force_size": new ComfyNodeTypedInputRef<ComfyValueType_S>(this, "force_size"),
				"unique_id": new ComfyNodeTypedInputRef<ComfyValueType_U>(this, "unique_id"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"audio": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"video_info": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_LoadVideoFFmpegPathInputs>) {
		if (typeof sources["video"] === "object") {
			this.sockets.inputs["video"].connectTo(sources["video"])
		} else {
			this.sockets.inputs["video"].value = sources["video"]
		}

		if (typeof sources["force_rate"] === "object") {
			this.sockets.inputs["force_rate"].connectTo(sources["force_rate"])
		} else {
			this.sockets.inputs["force_rate"].value = sources["force_rate"]
		}

		if (typeof sources["custom_width"] === "object") {
			this.sockets.inputs["custom_width"].connectTo(sources["custom_width"])
		} else {
			this.sockets.inputs["custom_width"].value = sources["custom_width"]
		}

		if (typeof sources["custom_height"] === "object") {
			this.sockets.inputs["custom_height"].connectTo(sources["custom_height"])
		} else {
			this.sockets.inputs["custom_height"].value = sources["custom_height"]
		}

		if (typeof sources["frame_load_cap"] === "object") {
			this.sockets.inputs["frame_load_cap"].connectTo(sources["frame_load_cap"])
		} else {
			this.sockets.inputs["frame_load_cap"].value = sources["frame_load_cap"]
		}

		if (typeof sources["start_time"] === "object") {
			this.sockets.inputs["start_time"].connectTo(sources["start_time"])
		} else {
			this.sockets.inputs["start_time"].value = sources["start_time"]
		}

		if (sources["meta_batch"] !== undefined) {
		if (typeof sources["meta_batch"] === "object") {
			this.sockets.inputs["meta_batch"].connectTo(sources["meta_batch"])
		} else {
			this.sockets.inputs["meta_batch"].value = sources["meta_batch"]
		}
		}

		if (sources["vae"] !== undefined) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}
		}

		if (sources["format"] !== undefined) {
		if (typeof sources["format"] === "object") {
			this.sockets.inputs["format"].connectTo(sources["format"])
		} else {
			this.sockets.inputs["format"].value = sources["format"]
		}
		}

		if (sources["force_size"] !== undefined) {
		if (typeof sources["force_size"] === "object") {
			this.sockets.inputs["force_size"].connectTo(sources["force_size"])
		} else {
			this.sockets.inputs["force_size"].value = sources["force_size"]
		}
		}

		if (sources["unique_id"] !== undefined) {
		if (typeof sources["unique_id"] === "object") {
			this.sockets.inputs["unique_id"].connectTo(sources["unique_id"])
		} else {
			this.sockets.inputs["unique_id"].value = sources["unique_id"]
		}
		}

	}
}

type VHS_LoadVideoFFmpegPathInputs = {
			"video": ComfyNodeTypedInputRef<string>
			"force_rate": ComfyNodeTypedInputRef<number>
			"custom_width": ComfyNodeTypedInputRef<number>
			"custom_height": ComfyNodeTypedInputRef<number>
			"frame_load_cap": ComfyNodeTypedInputRef<number>
			"start_time": ComfyNodeTypedInputRef<number>
			"meta_batch"?: ComfyNodeTypedInputRef<ComfyValueType_VHS_BatchManager>
			"vae"?: ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"format"?: ComfyNodeTypedInputRef<string>
			"force_size"?: ComfyNodeTypedInputRef<ComfyValueType_S>
			"unique_id"?: ComfyNodeTypedInputRef<ComfyValueType_U>
}


export class VHS_LoadImagePath extends ComfyNode {
	classType: string = "VHS_LoadImagePath"

	sockets: {
		inputs: Required<VHS_LoadImagePathInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			mask: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<string>(this, "image"),
				"custom_width": new ComfyNodeTypedInputRef<number>(this, "custom_width"),
				"custom_height": new ComfyNodeTypedInputRef<number>(this, "custom_height"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"force_size": new ComfyNodeTypedInputRef<ComfyValueType_S>(this, "force_size"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"mask": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_LoadImagePathInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["custom_width"] === "object") {
			this.sockets.inputs["custom_width"].connectTo(sources["custom_width"])
		} else {
			this.sockets.inputs["custom_width"].value = sources["custom_width"]
		}

		if (typeof sources["custom_height"] === "object") {
			this.sockets.inputs["custom_height"].connectTo(sources["custom_height"])
		} else {
			this.sockets.inputs["custom_height"].value = sources["custom_height"]
		}

		if (sources["vae"] !== undefined) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}
		}

		if (sources["force_size"] !== undefined) {
		if (typeof sources["force_size"] === "object") {
			this.sockets.inputs["force_size"].connectTo(sources["force_size"])
		} else {
			this.sockets.inputs["force_size"].value = sources["force_size"]
		}
		}

	}
}

type VHS_LoadImagePathInputs = {
			"image": ComfyNodeTypedInputRef<string>
			"custom_width": ComfyNodeTypedInputRef<number>
			"custom_height": ComfyNodeTypedInputRef<number>
			"vae"?: ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"force_size"?: ComfyNodeTypedInputRef<ComfyValueType_S>
}


export class VHS_LoadImages extends ComfyNode {
	classType: string = "VHS_LoadImages"

	sockets: {
		inputs: Required<VHS_LoadImagesInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			frame_count: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"directory": new ComfyNodeTypedInputRef<string>(this, "directory"),
				"image_load_cap": new ComfyNodeTypedInputRef<number>(this, "image_load_cap"),
				"skip_first_images": new ComfyNodeTypedInputRef<number>(this, "skip_first_images"),
				"select_every_nth": new ComfyNodeTypedInputRef<number>(this, "select_every_nth"),
				"meta_batch": new ComfyNodeTypedInputRef<ComfyValueType_VHS_BatchManager>(this, "meta_batch"),
				"unique_id": new ComfyNodeTypedInputRef<ComfyValueType_U>(this, "unique_id"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"frame_count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_LoadImagesInputs>) {
		if (typeof sources["directory"] === "object") {
			this.sockets.inputs["directory"].connectTo(sources["directory"])
		} else {
			this.sockets.inputs["directory"].value = sources["directory"]
		}

		if (sources["image_load_cap"] !== undefined) {
		if (typeof sources["image_load_cap"] === "object") {
			this.sockets.inputs["image_load_cap"].connectTo(sources["image_load_cap"])
		} else {
			this.sockets.inputs["image_load_cap"].value = sources["image_load_cap"]
		}
		}

		if (sources["skip_first_images"] !== undefined) {
		if (typeof sources["skip_first_images"] === "object") {
			this.sockets.inputs["skip_first_images"].connectTo(sources["skip_first_images"])
		} else {
			this.sockets.inputs["skip_first_images"].value = sources["skip_first_images"]
		}
		}

		if (sources["select_every_nth"] !== undefined) {
		if (typeof sources["select_every_nth"] === "object") {
			this.sockets.inputs["select_every_nth"].connectTo(sources["select_every_nth"])
		} else {
			this.sockets.inputs["select_every_nth"].value = sources["select_every_nth"]
		}
		}

		if (sources["meta_batch"] !== undefined) {
		if (typeof sources["meta_batch"] === "object") {
			this.sockets.inputs["meta_batch"].connectTo(sources["meta_batch"])
		} else {
			this.sockets.inputs["meta_batch"].value = sources["meta_batch"]
		}
		}

		if (sources["unique_id"] !== undefined) {
		if (typeof sources["unique_id"] === "object") {
			this.sockets.inputs["unique_id"].connectTo(sources["unique_id"])
		} else {
			this.sockets.inputs["unique_id"].value = sources["unique_id"]
		}
		}

	}
}

type VHS_LoadImagesInputs = {
			"directory": ComfyNodeTypedInputRef<string>
			"image_load_cap"?: ComfyNodeTypedInputRef<number>
			"skip_first_images"?: ComfyNodeTypedInputRef<number>
			"select_every_nth"?: ComfyNodeTypedInputRef<number>
			"meta_batch"?: ComfyNodeTypedInputRef<ComfyValueType_VHS_BatchManager>
			"unique_id"?: ComfyNodeTypedInputRef<ComfyValueType_U>
}


export class VHS_LoadImagesPath extends ComfyNode {
	classType: string = "VHS_LoadImagesPath"

	sockets: {
		inputs: Required<VHS_LoadImagesPathInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			frame_count: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"directory": new ComfyNodeTypedInputRef<string>(this, "directory"),
				"image_load_cap": new ComfyNodeTypedInputRef<number>(this, "image_load_cap"),
				"skip_first_images": new ComfyNodeTypedInputRef<number>(this, "skip_first_images"),
				"select_every_nth": new ComfyNodeTypedInputRef<number>(this, "select_every_nth"),
				"meta_batch": new ComfyNodeTypedInputRef<ComfyValueType_VHS_BatchManager>(this, "meta_batch"),
				"unique_id": new ComfyNodeTypedInputRef<ComfyValueType_U>(this, "unique_id"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"frame_count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_LoadImagesPathInputs>) {
		if (typeof sources["directory"] === "object") {
			this.sockets.inputs["directory"].connectTo(sources["directory"])
		} else {
			this.sockets.inputs["directory"].value = sources["directory"]
		}

		if (sources["image_load_cap"] !== undefined) {
		if (typeof sources["image_load_cap"] === "object") {
			this.sockets.inputs["image_load_cap"].connectTo(sources["image_load_cap"])
		} else {
			this.sockets.inputs["image_load_cap"].value = sources["image_load_cap"]
		}
		}

		if (sources["skip_first_images"] !== undefined) {
		if (typeof sources["skip_first_images"] === "object") {
			this.sockets.inputs["skip_first_images"].connectTo(sources["skip_first_images"])
		} else {
			this.sockets.inputs["skip_first_images"].value = sources["skip_first_images"]
		}
		}

		if (sources["select_every_nth"] !== undefined) {
		if (typeof sources["select_every_nth"] === "object") {
			this.sockets.inputs["select_every_nth"].connectTo(sources["select_every_nth"])
		} else {
			this.sockets.inputs["select_every_nth"].value = sources["select_every_nth"]
		}
		}

		if (sources["meta_batch"] !== undefined) {
		if (typeof sources["meta_batch"] === "object") {
			this.sockets.inputs["meta_batch"].connectTo(sources["meta_batch"])
		} else {
			this.sockets.inputs["meta_batch"].value = sources["meta_batch"]
		}
		}

		if (sources["unique_id"] !== undefined) {
		if (typeof sources["unique_id"] === "object") {
			this.sockets.inputs["unique_id"].connectTo(sources["unique_id"])
		} else {
			this.sockets.inputs["unique_id"].value = sources["unique_id"]
		}
		}

	}
}

type VHS_LoadImagesPathInputs = {
			"directory": ComfyNodeTypedInputRef<string>
			"image_load_cap"?: ComfyNodeTypedInputRef<number>
			"skip_first_images"?: ComfyNodeTypedInputRef<number>
			"select_every_nth"?: ComfyNodeTypedInputRef<number>
			"meta_batch"?: ComfyNodeTypedInputRef<ComfyValueType_VHS_BatchManager>
			"unique_id"?: ComfyNodeTypedInputRef<ComfyValueType_U>
}


export class VHS_LoadAudio extends ComfyNode {
	classType: string = "VHS_LoadAudio"

	sockets: {
		inputs: Required<VHS_LoadAudioInputs>
		outputs: {
			audio: ComfyNodeTypedSourceRef<ComfyValueType_AUDIO>
			duration: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"audio_file": new ComfyNodeTypedInputRef<string>(this, "audio_file"),
				"seek_seconds": new ComfyNodeTypedInputRef<number>(this, "seek_seconds"),
				"duration": new ComfyNodeTypedInputRef<number>(this, "duration"),
			},
			outputs: Object.create(Object.prototype, {
				"audio": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"duration": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_LoadAudioInputs>) {
		if (typeof sources["audio_file"] === "object") {
			this.sockets.inputs["audio_file"].connectTo(sources["audio_file"])
		} else {
			this.sockets.inputs["audio_file"].value = sources["audio_file"]
		}

		if (sources["seek_seconds"] !== undefined) {
		if (typeof sources["seek_seconds"] === "object") {
			this.sockets.inputs["seek_seconds"].connectTo(sources["seek_seconds"])
		} else {
			this.sockets.inputs["seek_seconds"].value = sources["seek_seconds"]
		}
		}

		if (sources["duration"] !== undefined) {
		if (typeof sources["duration"] === "object") {
			this.sockets.inputs["duration"].connectTo(sources["duration"])
		} else {
			this.sockets.inputs["duration"].value = sources["duration"]
		}
		}

	}
}

type VHS_LoadAudioInputs = {
			"audio_file": ComfyNodeTypedInputRef<string>
			"seek_seconds"?: ComfyNodeTypedInputRef<number>
			"duration"?: ComfyNodeTypedInputRef<number>
}


export class VHS_LoadAudioUpload extends ComfyNode {
	classType: string = "VHS_LoadAudioUpload"

	sockets: {
		inputs: Required<VHS_LoadAudioUploadInputs>
		outputs: {
			audio: ComfyNodeTypedSourceRef<ComfyValueType_AUDIO>
			duration: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"audio": new ComfyNodeTypedInputRef<string>(this, "audio"),
				"start_time": new ComfyNodeTypedInputRef<number>(this, "start_time"),
				"duration": new ComfyNodeTypedInputRef<number>(this, "duration"),
			},
			outputs: Object.create(Object.prototype, {
				"audio": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"duration": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_LoadAudioUploadInputs>) {
		if (typeof sources["audio"] === "object") {
			this.sockets.inputs["audio"].connectTo(sources["audio"])
		} else {
			this.sockets.inputs["audio"].value = sources["audio"]
		}

		if (sources["start_time"] !== undefined) {
		if (typeof sources["start_time"] === "object") {
			this.sockets.inputs["start_time"].connectTo(sources["start_time"])
		} else {
			this.sockets.inputs["start_time"].value = sources["start_time"]
		}
		}

		if (sources["duration"] !== undefined) {
		if (typeof sources["duration"] === "object") {
			this.sockets.inputs["duration"].connectTo(sources["duration"])
		} else {
			this.sockets.inputs["duration"].value = sources["duration"]
		}
		}

	}
}

type VHS_LoadAudioUploadInputs = {
			"audio": ComfyNodeTypedInputRef<string>
			"start_time"?: ComfyNodeTypedInputRef<number>
			"duration"?: ComfyNodeTypedInputRef<number>
}


export class VHS_AudioToVHSAudio extends ComfyNode {
	classType: string = "VHS_AudioToVHSAudio"

	sockets: {
		inputs: Required<VHS_AudioToVHSAudioInputs>
		outputs: {
			vhs_audio: ComfyNodeTypedSourceRef<ComfyValueType_VHS_AUDIO>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"audio": new ComfyNodeTypedInputRef<ComfyValueType_AUDIO>(this, "audio"),
			},
			outputs: Object.create(Object.prototype, {
				"vhs_audio": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_AudioToVHSAudioInputs>) {
		if (typeof sources["audio"] === "object") {
			this.sockets.inputs["audio"].connectTo(sources["audio"])
		} else {
			this.sockets.inputs["audio"].value = sources["audio"]
		}

	}
}

type VHS_AudioToVHSAudioInputs = {
			"audio": ComfyNodeTypedInputRef<ComfyValueType_AUDIO>
}


export class VHS_VHSAudioToAudio extends ComfyNode {
	classType: string = "VHS_VHSAudioToAudio"

	sockets: {
		inputs: Required<VHS_VHSAudioToAudioInputs>
		outputs: {
			audio: ComfyNodeTypedSourceRef<ComfyValueType_AUDIO>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vhs_audio": new ComfyNodeTypedInputRef<ComfyValueType_VHS_AUDIO>(this, "vhs_audio"),
			},
			outputs: Object.create(Object.prototype, {
				"audio": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_VHSAudioToAudioInputs>) {
		if (typeof sources["vhs_audio"] === "object") {
			this.sockets.inputs["vhs_audio"].connectTo(sources["vhs_audio"])
		} else {
			this.sockets.inputs["vhs_audio"].value = sources["vhs_audio"]
		}

	}
}

type VHS_VHSAudioToAudioInputs = {
			"vhs_audio": ComfyNodeTypedInputRef<ComfyValueType_VHS_AUDIO>
}


export class VHS_PruneOutputs extends ComfyNode {
	classType: string = "VHS_PruneOutputs"

	sockets: {
		inputs: Required<VHS_PruneOutputsInputs>
		outputs: {
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"filenames": new ComfyNodeTypedInputRef<ComfyValueType_VHS_FILENAMES>(this, "filenames"),
				"options": new ComfyNodeTypedInputRef<string>(this, "options"),
			},
			outputs: Object.create(Object.prototype, {
			})
		}
	}

	connectAll(sources: MappedSources<VHS_PruneOutputsInputs>) {
		if (typeof sources["filenames"] === "object") {
			this.sockets.inputs["filenames"].connectTo(sources["filenames"])
		} else {
			this.sockets.inputs["filenames"].value = sources["filenames"]
		}

		if (typeof sources["options"] === "object") {
			this.sockets.inputs["options"].connectTo(sources["options"])
		} else {
			this.sockets.inputs["options"].value = sources["options"]
		}

	}
}

type VHS_PruneOutputsInputs = {
			"filenames": ComfyNodeTypedInputRef<ComfyValueType_VHS_FILENAMES>
			"options": ComfyNodeTypedInputRef<string>
}


export class VHS_BatchManager extends ComfyNode {
	classType: string = "VHS_BatchManager"

	sockets: {
		inputs: Required<VHS_BatchManagerInputs>
		outputs: {
			meta_batch: ComfyNodeTypedSourceRef<ComfyValueType_VHS_BatchManager>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"frames_per_batch": new ComfyNodeTypedInputRef<number>(this, "frames_per_batch"),
				"prompt": new ComfyNodeTypedInputRef<ComfyValueType_P>(this, "prompt"),
				"unique_id": new ComfyNodeTypedInputRef<ComfyValueType_U>(this, "unique_id"),
			},
			outputs: Object.create(Object.prototype, {
				"meta_batch": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_BatchManagerInputs>) {
		if (typeof sources["frames_per_batch"] === "object") {
			this.sockets.inputs["frames_per_batch"].connectTo(sources["frames_per_batch"])
		} else {
			this.sockets.inputs["frames_per_batch"].value = sources["frames_per_batch"]
		}

		if (sources["prompt"] !== undefined) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}
		}

		if (sources["unique_id"] !== undefined) {
		if (typeof sources["unique_id"] === "object") {
			this.sockets.inputs["unique_id"].connectTo(sources["unique_id"])
		} else {
			this.sockets.inputs["unique_id"].value = sources["unique_id"]
		}
		}

	}
}

type VHS_BatchManagerInputs = {
			"frames_per_batch": ComfyNodeTypedInputRef<number>
			"prompt"?: ComfyNodeTypedInputRef<ComfyValueType_P>
			"unique_id"?: ComfyNodeTypedInputRef<ComfyValueType_U>
}


export class VHS_VideoInfo extends ComfyNode {
	classType: string = "VHS_VideoInfo"

	sockets: {
		inputs: Required<VHS_VideoInfoInputs>
		outputs: {
			source_fps__: ComfyNodeTypedSourceRef<number>
			source_frame_count__: ComfyNodeTypedSourceRef<number>
			source_duration__: ComfyNodeTypedSourceRef<number>
			source_width__: ComfyNodeTypedSourceRef<number>
			source_height__: ComfyNodeTypedSourceRef<number>
			loaded_fps__: ComfyNodeTypedSourceRef<number>
			loaded_frame_count__: ComfyNodeTypedSourceRef<number>
			loaded_duration__: ComfyNodeTypedSourceRef<number>
			loaded_width__: ComfyNodeTypedSourceRef<number>
			loaded_height__: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"video_info": new ComfyNodeTypedInputRef<ComfyValueType_VHS_VIDEOINFO>(this, "video_info"),
			},
			outputs: Object.create(Object.prototype, {
				"source_fps": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"source_frame_count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"source_duration": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"source_width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
				"source_height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 4 }
					}
				},
				"loaded_fps": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 5 }
					}
				},
				"loaded_frame_count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 6 }
					}
				},
				"loaded_duration": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 7 }
					}
				},
				"loaded_width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 8 }
					}
				},
				"loaded_height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 9 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_VideoInfoInputs>) {
		if (typeof sources["video_info"] === "object") {
			this.sockets.inputs["video_info"].connectTo(sources["video_info"])
		} else {
			this.sockets.inputs["video_info"].value = sources["video_info"]
		}

	}
}

type VHS_VideoInfoInputs = {
			"video_info": ComfyNodeTypedInputRef<ComfyValueType_VHS_VIDEOINFO>
}


export class VHS_VideoInfoSource extends ComfyNode {
	classType: string = "VHS_VideoInfoSource"

	sockets: {
		inputs: Required<VHS_VideoInfoSourceInputs>
		outputs: {
			fps__: ComfyNodeTypedSourceRef<number>
			frame_count__: ComfyNodeTypedSourceRef<number>
			duration__: ComfyNodeTypedSourceRef<number>
			width__: ComfyNodeTypedSourceRef<number>
			height__: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"video_info": new ComfyNodeTypedInputRef<ComfyValueType_VHS_VIDEOINFO>(this, "video_info"),
			},
			outputs: Object.create(Object.prototype, {
				"fps": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"frame_count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"duration": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
				"height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 4 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_VideoInfoSourceInputs>) {
		if (typeof sources["video_info"] === "object") {
			this.sockets.inputs["video_info"].connectTo(sources["video_info"])
		} else {
			this.sockets.inputs["video_info"].value = sources["video_info"]
		}

	}
}

type VHS_VideoInfoSourceInputs = {
			"video_info": ComfyNodeTypedInputRef<ComfyValueType_VHS_VIDEOINFO>
}


export class VHS_VideoInfoLoaded extends ComfyNode {
	classType: string = "VHS_VideoInfoLoaded"

	sockets: {
		inputs: Required<VHS_VideoInfoLoadedInputs>
		outputs: {
			fps__: ComfyNodeTypedSourceRef<number>
			frame_count__: ComfyNodeTypedSourceRef<number>
			duration__: ComfyNodeTypedSourceRef<number>
			width__: ComfyNodeTypedSourceRef<number>
			height__: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"video_info": new ComfyNodeTypedInputRef<ComfyValueType_VHS_VIDEOINFO>(this, "video_info"),
			},
			outputs: Object.create(Object.prototype, {
				"fps": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"frame_count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"duration": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"width": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
				"height": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 4 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_VideoInfoLoadedInputs>) {
		if (typeof sources["video_info"] === "object") {
			this.sockets.inputs["video_info"].connectTo(sources["video_info"])
		} else {
			this.sockets.inputs["video_info"].value = sources["video_info"]
		}

	}
}

type VHS_VideoInfoLoadedInputs = {
			"video_info": ComfyNodeTypedInputRef<ComfyValueType_VHS_VIDEOINFO>
}


export class VHS_SelectFilename extends ComfyNode {
	classType: string = "VHS_SelectFilename"

	sockets: {
		inputs: Required<VHS_SelectFilenameInputs>
		outputs: {
			Filename: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"filenames": new ComfyNodeTypedInputRef<ComfyValueType_VHS_FILENAMES>(this, "filenames"),
				"index": new ComfyNodeTypedInputRef<number>(this, "index"),
			},
			outputs: Object.create(Object.prototype, {
				"Filename": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_SelectFilenameInputs>) {
		if (typeof sources["filenames"] === "object") {
			this.sockets.inputs["filenames"].connectTo(sources["filenames"])
		} else {
			this.sockets.inputs["filenames"].value = sources["filenames"]
		}

		if (typeof sources["index"] === "object") {
			this.sockets.inputs["index"].connectTo(sources["index"])
		} else {
			this.sockets.inputs["index"].value = sources["index"]
		}

	}
}

type VHS_SelectFilenameInputs = {
			"filenames": ComfyNodeTypedInputRef<ComfyValueType_VHS_FILENAMES>
			"index": ComfyNodeTypedInputRef<number>
}


export class VHS_VAEEncodeBatched extends ComfyNode {
	classType: string = "VHS_VAEEncodeBatched"

	sockets: {
		inputs: Required<VHS_VAEEncodeBatchedInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"pixels": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "pixels"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"per_batch": new ComfyNodeTypedInputRef<number>(this, "per_batch"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_VAEEncodeBatchedInputs>) {
		if (typeof sources["pixels"] === "object") {
			this.sockets.inputs["pixels"].connectTo(sources["pixels"])
		} else {
			this.sockets.inputs["pixels"].value = sources["pixels"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["per_batch"] === "object") {
			this.sockets.inputs["per_batch"].connectTo(sources["per_batch"])
		} else {
			this.sockets.inputs["per_batch"].value = sources["per_batch"]
		}

	}
}

type VHS_VAEEncodeBatchedInputs = {
			"pixels": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"per_batch": ComfyNodeTypedInputRef<number>
}


export class VHS_VAEDecodeBatched extends ComfyNode {
	classType: string = "VHS_VAEDecodeBatched"

	sockets: {
		inputs: Required<VHS_VAEDecodeBatchedInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_VAE>(this, "vae"),
				"per_batch": new ComfyNodeTypedInputRef<number>(this, "per_batch"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_VAEDecodeBatchedInputs>) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["per_batch"] === "object") {
			this.sockets.inputs["per_batch"].connectTo(sources["per_batch"])
		} else {
			this.sockets.inputs["per_batch"].value = sources["per_batch"]
		}

	}
}

type VHS_VAEDecodeBatchedInputs = {
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"vae": ComfyNodeTypedInputRef<ComfyValueType_VAE>
			"per_batch": ComfyNodeTypedInputRef<number>
}


export class VHS_SplitLatents extends ComfyNode {
	classType: string = "VHS_SplitLatents"

	sockets: {
		inputs: Required<VHS_SplitLatentsInputs>
		outputs: {
			LATENT_A: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
			A_count: ComfyNodeTypedSourceRef<number>
			LATENT_B: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
			B_count: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latents"),
				"split_index": new ComfyNodeTypedInputRef<number>(this, "split_index"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT_A": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"A_count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"LATENT_B": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"B_count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_SplitLatentsInputs>) {
		if (typeof sources["latents"] === "object") {
			this.sockets.inputs["latents"].connectTo(sources["latents"])
		} else {
			this.sockets.inputs["latents"].value = sources["latents"]
		}

		if (typeof sources["split_index"] === "object") {
			this.sockets.inputs["split_index"].connectTo(sources["split_index"])
		} else {
			this.sockets.inputs["split_index"].value = sources["split_index"]
		}

	}
}

type VHS_SplitLatentsInputs = {
			"latents": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"split_index": ComfyNodeTypedInputRef<number>
}


export class VHS_SplitImages extends ComfyNode {
	classType: string = "VHS_SplitImages"

	sockets: {
		inputs: Required<VHS_SplitImagesInputs>
		outputs: {
			IMAGE_A: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			A_count: ComfyNodeTypedSourceRef<number>
			IMAGE_B: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			B_count: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"split_index": new ComfyNodeTypedInputRef<number>(this, "split_index"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE_A": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"A_count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"IMAGE_B": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"B_count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_SplitImagesInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["split_index"] === "object") {
			this.sockets.inputs["split_index"].connectTo(sources["split_index"])
		} else {
			this.sockets.inputs["split_index"].value = sources["split_index"]
		}

	}
}

type VHS_SplitImagesInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"split_index": ComfyNodeTypedInputRef<number>
}


export class VHS_SplitMasks extends ComfyNode {
	classType: string = "VHS_SplitMasks"

	sockets: {
		inputs: Required<VHS_SplitMasksInputs>
		outputs: {
			MASK_A: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			A_count: ComfyNodeTypedSourceRef<number>
			MASK_B: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			B_count: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"split_index": new ComfyNodeTypedInputRef<number>(this, "split_index"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK_A": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"A_count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"MASK_B": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
				"B_count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 3 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_SplitMasksInputs>) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["split_index"] === "object") {
			this.sockets.inputs["split_index"].connectTo(sources["split_index"])
		} else {
			this.sockets.inputs["split_index"].value = sources["split_index"]
		}

	}
}

type VHS_SplitMasksInputs = {
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"split_index": ComfyNodeTypedInputRef<number>
}


export class VHS_MergeLatents extends ComfyNode {
	classType: string = "VHS_MergeLatents"

	sockets: {
		inputs: Required<VHS_MergeLatentsInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
			count: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"latents_A": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latents_A"),
				"latents_B": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latents_B"),
				"merge_strategy": new ComfyNodeTypedInputRef<string>(this, "merge_strategy"),
				"scale_method": new ComfyNodeTypedInputRef<string>(this, "scale_method"),
				"crop": new ComfyNodeTypedInputRef<string>(this, "crop"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_MergeLatentsInputs>) {
		if (typeof sources["latents_A"] === "object") {
			this.sockets.inputs["latents_A"].connectTo(sources["latents_A"])
		} else {
			this.sockets.inputs["latents_A"].value = sources["latents_A"]
		}

		if (typeof sources["latents_B"] === "object") {
			this.sockets.inputs["latents_B"].connectTo(sources["latents_B"])
		} else {
			this.sockets.inputs["latents_B"].value = sources["latents_B"]
		}

		if (typeof sources["merge_strategy"] === "object") {
			this.sockets.inputs["merge_strategy"].connectTo(sources["merge_strategy"])
		} else {
			this.sockets.inputs["merge_strategy"].value = sources["merge_strategy"]
		}

		if (typeof sources["scale_method"] === "object") {
			this.sockets.inputs["scale_method"].connectTo(sources["scale_method"])
		} else {
			this.sockets.inputs["scale_method"].value = sources["scale_method"]
		}

		if (typeof sources["crop"] === "object") {
			this.sockets.inputs["crop"].connectTo(sources["crop"])
		} else {
			this.sockets.inputs["crop"].value = sources["crop"]
		}

	}
}

type VHS_MergeLatentsInputs = {
			"latents_A": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"latents_B": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"merge_strategy": ComfyNodeTypedInputRef<string>
			"scale_method": ComfyNodeTypedInputRef<string>
			"crop": ComfyNodeTypedInputRef<string>
}


export class VHS_MergeImages extends ComfyNode {
	classType: string = "VHS_MergeImages"

	sockets: {
		inputs: Required<VHS_MergeImagesInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			count: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images_A": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images_A"),
				"images_B": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images_B"),
				"merge_strategy": new ComfyNodeTypedInputRef<string>(this, "merge_strategy"),
				"scale_method": new ComfyNodeTypedInputRef<string>(this, "scale_method"),
				"crop": new ComfyNodeTypedInputRef<string>(this, "crop"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_MergeImagesInputs>) {
		if (typeof sources["images_A"] === "object") {
			this.sockets.inputs["images_A"].connectTo(sources["images_A"])
		} else {
			this.sockets.inputs["images_A"].value = sources["images_A"]
		}

		if (typeof sources["images_B"] === "object") {
			this.sockets.inputs["images_B"].connectTo(sources["images_B"])
		} else {
			this.sockets.inputs["images_B"].value = sources["images_B"]
		}

		if (typeof sources["merge_strategy"] === "object") {
			this.sockets.inputs["merge_strategy"].connectTo(sources["merge_strategy"])
		} else {
			this.sockets.inputs["merge_strategy"].value = sources["merge_strategy"]
		}

		if (typeof sources["scale_method"] === "object") {
			this.sockets.inputs["scale_method"].connectTo(sources["scale_method"])
		} else {
			this.sockets.inputs["scale_method"].value = sources["scale_method"]
		}

		if (typeof sources["crop"] === "object") {
			this.sockets.inputs["crop"].connectTo(sources["crop"])
		} else {
			this.sockets.inputs["crop"].value = sources["crop"]
		}

	}
}

type VHS_MergeImagesInputs = {
			"images_A": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"images_B": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"merge_strategy": ComfyNodeTypedInputRef<string>
			"scale_method": ComfyNodeTypedInputRef<string>
			"crop": ComfyNodeTypedInputRef<string>
}


export class VHS_MergeMasks extends ComfyNode {
	classType: string = "VHS_MergeMasks"

	sockets: {
		inputs: Required<VHS_MergeMasksInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			count: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask_A": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask_A"),
				"mask_B": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask_B"),
				"merge_strategy": new ComfyNodeTypedInputRef<string>(this, "merge_strategy"),
				"scale_method": new ComfyNodeTypedInputRef<string>(this, "scale_method"),
				"crop": new ComfyNodeTypedInputRef<string>(this, "crop"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_MergeMasksInputs>) {
		if (typeof sources["mask_A"] === "object") {
			this.sockets.inputs["mask_A"].connectTo(sources["mask_A"])
		} else {
			this.sockets.inputs["mask_A"].value = sources["mask_A"]
		}

		if (typeof sources["mask_B"] === "object") {
			this.sockets.inputs["mask_B"].connectTo(sources["mask_B"])
		} else {
			this.sockets.inputs["mask_B"].value = sources["mask_B"]
		}

		if (typeof sources["merge_strategy"] === "object") {
			this.sockets.inputs["merge_strategy"].connectTo(sources["merge_strategy"])
		} else {
			this.sockets.inputs["merge_strategy"].value = sources["merge_strategy"]
		}

		if (typeof sources["scale_method"] === "object") {
			this.sockets.inputs["scale_method"].connectTo(sources["scale_method"])
		} else {
			this.sockets.inputs["scale_method"].value = sources["scale_method"]
		}

		if (typeof sources["crop"] === "object") {
			this.sockets.inputs["crop"].connectTo(sources["crop"])
		} else {
			this.sockets.inputs["crop"].value = sources["crop"]
		}

	}
}

type VHS_MergeMasksInputs = {
			"mask_A": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"mask_B": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"merge_strategy": ComfyNodeTypedInputRef<string>
			"scale_method": ComfyNodeTypedInputRef<string>
			"crop": ComfyNodeTypedInputRef<string>
}


export class VHS_GetLatentCount extends ComfyNode {
	classType: string = "VHS_GetLatentCount"

	sockets: {
		inputs: Required<VHS_GetLatentCountInputs>
		outputs: {
			count: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latents"),
			},
			outputs: Object.create(Object.prototype, {
				"count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_GetLatentCountInputs>) {
		if (typeof sources["latents"] === "object") {
			this.sockets.inputs["latents"].connectTo(sources["latents"])
		} else {
			this.sockets.inputs["latents"].value = sources["latents"]
		}

	}
}

type VHS_GetLatentCountInputs = {
			"latents": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
}


export class VHS_GetImageCount extends ComfyNode {
	classType: string = "VHS_GetImageCount"

	sockets: {
		inputs: Required<VHS_GetImageCountInputs>
		outputs: {
			count: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
			},
			outputs: Object.create(Object.prototype, {
				"count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_GetImageCountInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

	}
}

type VHS_GetImageCountInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
}


export class VHS_GetMaskCount extends ComfyNode {
	classType: string = "VHS_GetMaskCount"

	sockets: {
		inputs: Required<VHS_GetMaskCountInputs>
		outputs: {
			count: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
			},
			outputs: Object.create(Object.prototype, {
				"count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_GetMaskCountInputs>) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

	}
}

type VHS_GetMaskCountInputs = {
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class VHS_DuplicateLatents extends ComfyNode {
	classType: string = "VHS_DuplicateLatents"

	sockets: {
		inputs: Required<VHS_DuplicateLatentsInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
			count: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latents"),
				"multiply_by": new ComfyNodeTypedInputRef<number>(this, "multiply_by"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_DuplicateLatentsInputs>) {
		if (typeof sources["latents"] === "object") {
			this.sockets.inputs["latents"].connectTo(sources["latents"])
		} else {
			this.sockets.inputs["latents"].value = sources["latents"]
		}

		if (typeof sources["multiply_by"] === "object") {
			this.sockets.inputs["multiply_by"].connectTo(sources["multiply_by"])
		} else {
			this.sockets.inputs["multiply_by"].value = sources["multiply_by"]
		}

	}
}

type VHS_DuplicateLatentsInputs = {
			"latents": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"multiply_by": ComfyNodeTypedInputRef<number>
}


export class VHS_DuplicateImages extends ComfyNode {
	classType: string = "VHS_DuplicateImages"

	sockets: {
		inputs: Required<VHS_DuplicateImagesInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			count: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"multiply_by": new ComfyNodeTypedInputRef<number>(this, "multiply_by"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_DuplicateImagesInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["multiply_by"] === "object") {
			this.sockets.inputs["multiply_by"].connectTo(sources["multiply_by"])
		} else {
			this.sockets.inputs["multiply_by"].value = sources["multiply_by"]
		}

	}
}

type VHS_DuplicateImagesInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"multiply_by": ComfyNodeTypedInputRef<number>
}


export class VHS_DuplicateMasks extends ComfyNode {
	classType: string = "VHS_DuplicateMasks"

	sockets: {
		inputs: Required<VHS_DuplicateMasksInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			count: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"multiply_by": new ComfyNodeTypedInputRef<number>(this, "multiply_by"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_DuplicateMasksInputs>) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["multiply_by"] === "object") {
			this.sockets.inputs["multiply_by"].connectTo(sources["multiply_by"])
		} else {
			this.sockets.inputs["multiply_by"].value = sources["multiply_by"]
		}

	}
}

type VHS_DuplicateMasksInputs = {
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"multiply_by": ComfyNodeTypedInputRef<number>
}


export class VHS_SelectEveryNthLatent extends ComfyNode {
	classType: string = "VHS_SelectEveryNthLatent"

	sockets: {
		inputs: Required<VHS_SelectEveryNthLatentInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
			count: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latents"),
				"select_every_nth": new ComfyNodeTypedInputRef<number>(this, "select_every_nth"),
				"skip_first_latents": new ComfyNodeTypedInputRef<number>(this, "skip_first_latents"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_SelectEveryNthLatentInputs>) {
		if (typeof sources["latents"] === "object") {
			this.sockets.inputs["latents"].connectTo(sources["latents"])
		} else {
			this.sockets.inputs["latents"].value = sources["latents"]
		}

		if (typeof sources["select_every_nth"] === "object") {
			this.sockets.inputs["select_every_nth"].connectTo(sources["select_every_nth"])
		} else {
			this.sockets.inputs["select_every_nth"].value = sources["select_every_nth"]
		}

		if (typeof sources["skip_first_latents"] === "object") {
			this.sockets.inputs["skip_first_latents"].connectTo(sources["skip_first_latents"])
		} else {
			this.sockets.inputs["skip_first_latents"].value = sources["skip_first_latents"]
		}

	}
}

type VHS_SelectEveryNthLatentInputs = {
			"latents": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"select_every_nth": ComfyNodeTypedInputRef<number>
			"skip_first_latents": ComfyNodeTypedInputRef<number>
}


export class VHS_SelectEveryNthImage extends ComfyNode {
	classType: string = "VHS_SelectEveryNthImage"

	sockets: {
		inputs: Required<VHS_SelectEveryNthImageInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
			count: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "images"),
				"select_every_nth": new ComfyNodeTypedInputRef<number>(this, "select_every_nth"),
				"skip_first_images": new ComfyNodeTypedInputRef<number>(this, "skip_first_images"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_SelectEveryNthImageInputs>) {
		if (typeof sources["images"] === "object") {
			this.sockets.inputs["images"].connectTo(sources["images"])
		} else {
			this.sockets.inputs["images"].value = sources["images"]
		}

		if (typeof sources["select_every_nth"] === "object") {
			this.sockets.inputs["select_every_nth"].connectTo(sources["select_every_nth"])
		} else {
			this.sockets.inputs["select_every_nth"].value = sources["select_every_nth"]
		}

		if (typeof sources["skip_first_images"] === "object") {
			this.sockets.inputs["skip_first_images"].connectTo(sources["skip_first_images"])
		} else {
			this.sockets.inputs["skip_first_images"].value = sources["skip_first_images"]
		}

	}
}

type VHS_SelectEveryNthImageInputs = {
			"images": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"select_every_nth": ComfyNodeTypedInputRef<number>
			"skip_first_images": ComfyNodeTypedInputRef<number>
}


export class VHS_SelectEveryNthMask extends ComfyNode {
	classType: string = "VHS_SelectEveryNthMask"

	sockets: {
		inputs: Required<VHS_SelectEveryNthMaskInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
			count: ComfyNodeTypedSourceRef<number>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"select_every_nth": new ComfyNodeTypedInputRef<number>(this, "select_every_nth"),
				"skip_first_masks": new ComfyNodeTypedInputRef<number>(this, "skip_first_masks"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"count": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_SelectEveryNthMaskInputs>) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["select_every_nth"] === "object") {
			this.sockets.inputs["select_every_nth"].connectTo(sources["select_every_nth"])
		} else {
			this.sockets.inputs["select_every_nth"].value = sources["select_every_nth"]
		}

		if (typeof sources["skip_first_masks"] === "object") {
			this.sockets.inputs["skip_first_masks"].connectTo(sources["skip_first_masks"])
		} else {
			this.sockets.inputs["skip_first_masks"].value = sources["skip_first_masks"]
		}

	}
}

type VHS_SelectEveryNthMaskInputs = {
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"select_every_nth": ComfyNodeTypedInputRef<number>
			"skip_first_masks": ComfyNodeTypedInputRef<number>
}


export class VHS_SelectLatents extends ComfyNode {
	classType: string = "VHS_SelectLatents"

	sockets: {
		inputs: Required<VHS_SelectLatentsInputs>
		outputs: {
			LATENT: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"latent": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "latent"),
				"indexes": new ComfyNodeTypedInputRef<string>(this, "indexes"),
				"err_if_missing": new ComfyNodeTypedInputRef<boolean>(this, "err_if_missing"),
				"err_if_empty": new ComfyNodeTypedInputRef<boolean>(this, "err_if_empty"),
			},
			outputs: Object.create(Object.prototype, {
				"LATENT": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_SelectLatentsInputs>) {
		if (typeof sources["latent"] === "object") {
			this.sockets.inputs["latent"].connectTo(sources["latent"])
		} else {
			this.sockets.inputs["latent"].value = sources["latent"]
		}

		if (typeof sources["indexes"] === "object") {
			this.sockets.inputs["indexes"].connectTo(sources["indexes"])
		} else {
			this.sockets.inputs["indexes"].value = sources["indexes"]
		}

		if (typeof sources["err_if_missing"] === "object") {
			this.sockets.inputs["err_if_missing"].connectTo(sources["err_if_missing"])
		} else {
			this.sockets.inputs["err_if_missing"].value = sources["err_if_missing"]
		}

		if (typeof sources["err_if_empty"] === "object") {
			this.sockets.inputs["err_if_empty"].connectTo(sources["err_if_empty"])
		} else {
			this.sockets.inputs["err_if_empty"].value = sources["err_if_empty"]
		}

	}
}

type VHS_SelectLatentsInputs = {
			"latent": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"indexes": ComfyNodeTypedInputRef<string>
			"err_if_missing": ComfyNodeTypedInputRef<boolean>
			"err_if_empty": ComfyNodeTypedInputRef<boolean>
}


export class VHS_SelectImages extends ComfyNode {
	classType: string = "VHS_SelectImages"

	sockets: {
		inputs: Required<VHS_SelectImagesInputs>
		outputs: {
			IMAGE: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"indexes": new ComfyNodeTypedInputRef<string>(this, "indexes"),
				"err_if_missing": new ComfyNodeTypedInputRef<boolean>(this, "err_if_missing"),
				"err_if_empty": new ComfyNodeTypedInputRef<boolean>(this, "err_if_empty"),
			},
			outputs: Object.create(Object.prototype, {
				"IMAGE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_SelectImagesInputs>) {
		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["indexes"] === "object") {
			this.sockets.inputs["indexes"].connectTo(sources["indexes"])
		} else {
			this.sockets.inputs["indexes"].value = sources["indexes"]
		}

		if (typeof sources["err_if_missing"] === "object") {
			this.sockets.inputs["err_if_missing"].connectTo(sources["err_if_missing"])
		} else {
			this.sockets.inputs["err_if_missing"].value = sources["err_if_missing"]
		}

		if (typeof sources["err_if_empty"] === "object") {
			this.sockets.inputs["err_if_empty"].connectTo(sources["err_if_empty"])
		} else {
			this.sockets.inputs["err_if_empty"].value = sources["err_if_empty"]
		}

	}
}

type VHS_SelectImagesInputs = {
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"indexes": ComfyNodeTypedInputRef<string>
			"err_if_missing": ComfyNodeTypedInputRef<boolean>
			"err_if_empty": ComfyNodeTypedInputRef<boolean>
}


export class VHS_SelectMasks extends ComfyNode {
	classType: string = "VHS_SelectMasks"

	sockets: {
		inputs: Required<VHS_SelectMasksInputs>
		outputs: {
			MASK: ComfyNodeTypedSourceRef<ComfyValueType_MASK>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
				"indexes": new ComfyNodeTypedInputRef<string>(this, "indexes"),
				"err_if_missing": new ComfyNodeTypedInputRef<boolean>(this, "err_if_missing"),
				"err_if_empty": new ComfyNodeTypedInputRef<boolean>(this, "err_if_empty"),
			},
			outputs: Object.create(Object.prototype, {
				"MASK": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_SelectMasksInputs>) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}

		if (typeof sources["indexes"] === "object") {
			this.sockets.inputs["indexes"].connectTo(sources["indexes"])
		} else {
			this.sockets.inputs["indexes"].value = sources["indexes"]
		}

		if (typeof sources["err_if_missing"] === "object") {
			this.sockets.inputs["err_if_missing"].connectTo(sources["err_if_missing"])
		} else {
			this.sockets.inputs["err_if_missing"].value = sources["err_if_missing"]
		}

		if (typeof sources["err_if_empty"] === "object") {
			this.sockets.inputs["err_if_empty"].connectTo(sources["err_if_empty"])
		} else {
			this.sockets.inputs["err_if_empty"].value = sources["err_if_empty"]
		}

	}
}

type VHS_SelectMasksInputs = {
			"mask": ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"indexes": ComfyNodeTypedInputRef<string>
			"err_if_missing": ComfyNodeTypedInputRef<boolean>
			"err_if_empty": ComfyNodeTypedInputRef<boolean>
}


export class VHS_Unbatch extends ComfyNode {
	classType: string = "VHS_Unbatch"

	sockets: {
		inputs: Required<VHS_UnbatchInputs>
		outputs: {
			unbatched: ComfyNodeTypedSourceRef<ComfyValueType_$STAR>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"batched": new ComfyNodeTypedInputRef<ComfyValueType_$STAR>(this, "batched"),
			},
			outputs: Object.create(Object.prototype, {
				"unbatched": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_UnbatchInputs>) {
		if (typeof sources["batched"] === "object") {
			this.sockets.inputs["batched"].connectTo(sources["batched"])
		} else {
			this.sockets.inputs["batched"].value = sources["batched"]
		}

	}
}

type VHS_UnbatchInputs = {
			"batched": ComfyNodeTypedInputRef<ComfyValueType_$STAR>
}


export class VHS_SelectLatest extends ComfyNode {
	classType: string = "VHS_SelectLatest"

	sockets: {
		inputs: Required<VHS_SelectLatestInputs>
		outputs: {
			Filename: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"filename_prefix": new ComfyNodeTypedInputRef<string>(this, "filename_prefix"),
				"filename_postfix": new ComfyNodeTypedInputRef<string>(this, "filename_postfix"),
			},
			outputs: Object.create(Object.prototype, {
				"Filename": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VHS_SelectLatestInputs>) {
		if (typeof sources["filename_prefix"] === "object") {
			this.sockets.inputs["filename_prefix"].connectTo(sources["filename_prefix"])
		} else {
			this.sockets.inputs["filename_prefix"].value = sources["filename_prefix"]
		}

		if (typeof sources["filename_postfix"] === "object") {
			this.sockets.inputs["filename_postfix"].connectTo(sources["filename_postfix"])
		} else {
			this.sockets.inputs["filename_postfix"].value = sources["filename_postfix"]
		}

	}
}

type VHS_SelectLatestInputs = {
			"filename_prefix": ComfyNodeTypedInputRef<string>
			"filename_postfix": ComfyNodeTypedInputRef<string>
}


export class UnetLoaderGGUF extends ComfyNode {
	classType: string = "UnetLoaderGGUF"

	sockets: {
		inputs: Required<UnetLoaderGGUFInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"unet_name": new ComfyNodeTypedInputRef<string>(this, "unet_name"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<UnetLoaderGGUFInputs>) {
		if (typeof sources["unet_name"] === "object") {
			this.sockets.inputs["unet_name"].connectTo(sources["unet_name"])
		} else {
			this.sockets.inputs["unet_name"].value = sources["unet_name"]
		}

	}
}

type UnetLoaderGGUFInputs = {
			"unet_name": ComfyNodeTypedInputRef<string>
}


export class CLIPLoaderGGUF extends ComfyNode {
	classType: string = "CLIPLoaderGGUF"

	sockets: {
		inputs: Required<CLIPLoaderGGUFInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name": new ComfyNodeTypedInputRef<string>(this, "clip_name"),
				"type": new ComfyNodeTypedInputRef<string>(this, "type"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPLoaderGGUFInputs>) {
		if (typeof sources["clip_name"] === "object") {
			this.sockets.inputs["clip_name"].connectTo(sources["clip_name"])
		} else {
			this.sockets.inputs["clip_name"].value = sources["clip_name"]
		}

		if (typeof sources["type"] === "object") {
			this.sockets.inputs["type"].connectTo(sources["type"])
		} else {
			this.sockets.inputs["type"].value = sources["type"]
		}

	}
}

type CLIPLoaderGGUFInputs = {
			"clip_name": ComfyNodeTypedInputRef<string>
			"type": ComfyNodeTypedInputRef<string>
}


export class DualCLIPLoaderGGUF extends ComfyNode {
	classType: string = "DualCLIPLoaderGGUF"

	sockets: {
		inputs: Required<DualCLIPLoaderGGUFInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<string>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<string>(this, "clip_name2"),
				"type": new ComfyNodeTypedInputRef<string>(this, "type"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DualCLIPLoaderGGUFInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["type"] === "object") {
			this.sockets.inputs["type"].connectTo(sources["type"])
		} else {
			this.sockets.inputs["type"].value = sources["type"]
		}

	}
}

type DualCLIPLoaderGGUFInputs = {
			"clip_name1": ComfyNodeTypedInputRef<string>
			"clip_name2": ComfyNodeTypedInputRef<string>
			"type": ComfyNodeTypedInputRef<string>
}


export class TripleCLIPLoaderGGUF extends ComfyNode {
	classType: string = "TripleCLIPLoaderGGUF"

	sockets: {
		inputs: Required<TripleCLIPLoaderGGUFInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<string>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<string>(this, "clip_name2"),
				"clip_name3": new ComfyNodeTypedInputRef<string>(this, "clip_name3"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TripleCLIPLoaderGGUFInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["clip_name3"] === "object") {
			this.sockets.inputs["clip_name3"].connectTo(sources["clip_name3"])
		} else {
			this.sockets.inputs["clip_name3"].value = sources["clip_name3"]
		}

	}
}

type TripleCLIPLoaderGGUFInputs = {
			"clip_name1": ComfyNodeTypedInputRef<string>
			"clip_name2": ComfyNodeTypedInputRef<string>
			"clip_name3": ComfyNodeTypedInputRef<string>
}


export class QuadrupleCLIPLoaderGGUF extends ComfyNode {
	classType: string = "QuadrupleCLIPLoaderGGUF"

	sockets: {
		inputs: Required<QuadrupleCLIPLoaderGGUFInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<string>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<string>(this, "clip_name2"),
				"clip_name3": new ComfyNodeTypedInputRef<string>(this, "clip_name3"),
				"clip_name4": new ComfyNodeTypedInputRef<string>(this, "clip_name4"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<QuadrupleCLIPLoaderGGUFInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["clip_name3"] === "object") {
			this.sockets.inputs["clip_name3"].connectTo(sources["clip_name3"])
		} else {
			this.sockets.inputs["clip_name3"].value = sources["clip_name3"]
		}

		if (typeof sources["clip_name4"] === "object") {
			this.sockets.inputs["clip_name4"].connectTo(sources["clip_name4"])
		} else {
			this.sockets.inputs["clip_name4"].value = sources["clip_name4"]
		}

	}
}

type QuadrupleCLIPLoaderGGUFInputs = {
			"clip_name1": ComfyNodeTypedInputRef<string>
			"clip_name2": ComfyNodeTypedInputRef<string>
			"clip_name3": ComfyNodeTypedInputRef<string>
			"clip_name4": ComfyNodeTypedInputRef<string>
}


export class UnetLoaderGGUFAdvanced extends ComfyNode {
	classType: string = "UnetLoaderGGUFAdvanced"

	sockets: {
		inputs: Required<UnetLoaderGGUFAdvancedInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"unet_name": new ComfyNodeTypedInputRef<string>(this, "unet_name"),
				"dequant_dtype": new ComfyNodeTypedInputRef<string>(this, "dequant_dtype"),
				"patch_dtype": new ComfyNodeTypedInputRef<string>(this, "patch_dtype"),
				"patch_on_device": new ComfyNodeTypedInputRef<boolean>(this, "patch_on_device"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<UnetLoaderGGUFAdvancedInputs>) {
		if (typeof sources["unet_name"] === "object") {
			this.sockets.inputs["unet_name"].connectTo(sources["unet_name"])
		} else {
			this.sockets.inputs["unet_name"].value = sources["unet_name"]
		}

		if (typeof sources["dequant_dtype"] === "object") {
			this.sockets.inputs["dequant_dtype"].connectTo(sources["dequant_dtype"])
		} else {
			this.sockets.inputs["dequant_dtype"].value = sources["dequant_dtype"]
		}

		if (typeof sources["patch_dtype"] === "object") {
			this.sockets.inputs["patch_dtype"].connectTo(sources["patch_dtype"])
		} else {
			this.sockets.inputs["patch_dtype"].value = sources["patch_dtype"]
		}

		if (typeof sources["patch_on_device"] === "object") {
			this.sockets.inputs["patch_on_device"].connectTo(sources["patch_on_device"])
		} else {
			this.sockets.inputs["patch_on_device"].value = sources["patch_on_device"]
		}

	}
}

type UnetLoaderGGUFAdvancedInputs = {
			"unet_name": ComfyNodeTypedInputRef<string>
			"dequant_dtype": ComfyNodeTypedInputRef<string>
			"patch_dtype": ComfyNodeTypedInputRef<string>
			"patch_on_device": ComfyNodeTypedInputRef<boolean>
}


export class ApplyFBCacheOnModel extends ComfyNode {
	classType: string = "ApplyFBCacheOnModel"

	sockets: {
		inputs: Required<ApplyFBCacheOnModelInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"object_to_patch": new ComfyNodeTypedInputRef<string>(this, "object_to_patch"),
				"residual_diff_threshold": new ComfyNodeTypedInputRef<number>(this, "residual_diff_threshold"),
				"start": new ComfyNodeTypedInputRef<number>(this, "start"),
				"end": new ComfyNodeTypedInputRef<number>(this, "end"),
				"max_consecutive_cache_hits": new ComfyNodeTypedInputRef<number>(this, "max_consecutive_cache_hits"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ApplyFBCacheOnModelInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["object_to_patch"] === "object") {
			this.sockets.inputs["object_to_patch"].connectTo(sources["object_to_patch"])
		} else {
			this.sockets.inputs["object_to_patch"].value = sources["object_to_patch"]
		}

		if (typeof sources["residual_diff_threshold"] === "object") {
			this.sockets.inputs["residual_diff_threshold"].connectTo(sources["residual_diff_threshold"])
		} else {
			this.sockets.inputs["residual_diff_threshold"].value = sources["residual_diff_threshold"]
		}

		if (typeof sources["start"] === "object") {
			this.sockets.inputs["start"].connectTo(sources["start"])
		} else {
			this.sockets.inputs["start"].value = sources["start"]
		}

		if (typeof sources["end"] === "object") {
			this.sockets.inputs["end"].connectTo(sources["end"])
		} else {
			this.sockets.inputs["end"].value = sources["end"]
		}

		if (typeof sources["max_consecutive_cache_hits"] === "object") {
			this.sockets.inputs["max_consecutive_cache_hits"].connectTo(sources["max_consecutive_cache_hits"])
		} else {
			this.sockets.inputs["max_consecutive_cache_hits"].value = sources["max_consecutive_cache_hits"]
		}

	}
}

type ApplyFBCacheOnModelInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"object_to_patch": ComfyNodeTypedInputRef<string>
			/** Controls the tolerance for caching with lower values being more strict. Setting this to 0 disables the FBCache effect.*/
			"residual_diff_threshold": ComfyNodeTypedInputRef<number>
			/** Start time as a percentage of sampling where the FBCache effect can apply. Example: 0.0 would signify 0% (the beginning of sampling), 0.5 would signify 50%.*/
			"start": ComfyNodeTypedInputRef<number>
			/** End time as a percentage of sampling where the FBCache effect can apply. Example: 1.0 would signify 100% (the end of sampling), 0.5 would signify 50%.*/
			"end": ComfyNodeTypedInputRef<number>
			/** Allows limiting how many cached results can be used in a row. For example, setting this to 1 will mean there will be at least one full model call after each cached result. Set to 0 to disable FBCache effect, or -1 to allow unlimited consecutive cache hits.*/
			"max_consecutive_cache_hits": ComfyNodeTypedInputRef<number>
}


export class EnhancedLoadDiffusionModel extends ComfyNode {
	classType: string = "EnhancedLoadDiffusionModel"

	sockets: {
		inputs: Required<EnhancedLoadDiffusionModelInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"unet_name": new ComfyNodeTypedInputRef<string>(this, "unet_name"),
				"weight_dtype": new ComfyNodeTypedInputRef<string>(this, "weight_dtype"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<EnhancedLoadDiffusionModelInputs>) {
		if (typeof sources["unet_name"] === "object") {
			this.sockets.inputs["unet_name"].connectTo(sources["unet_name"])
		} else {
			this.sockets.inputs["unet_name"].value = sources["unet_name"]
		}

		if (typeof sources["weight_dtype"] === "object") {
			this.sockets.inputs["weight_dtype"].connectTo(sources["weight_dtype"])
		} else {
			this.sockets.inputs["weight_dtype"].value = sources["weight_dtype"]
		}

	}
}

type EnhancedLoadDiffusionModelInputs = {
			"unet_name": ComfyNodeTypedInputRef<string>
			"weight_dtype": ComfyNodeTypedInputRef<string>
}


export class EnhancedCompileModel extends ComfyNode {
	classType: string = "EnhancedCompileModel"

	sockets: {
		inputs: Required<EnhancedCompileModelInputs>
		outputs: {
			_: ComfyNodeTypedSourceRef<ComfyValueType_$STAR>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_$STAR>(this, "model"),
				"is_patcher": new ComfyNodeTypedInputRef<boolean>(this, "is_patcher"),
				"object_to_patch": new ComfyNodeTypedInputRef<string>(this, "object_to_patch"),
				"compiler": new ComfyNodeTypedInputRef<string>(this, "compiler"),
				"fullgraph": new ComfyNodeTypedInputRef<boolean>(this, "fullgraph"),
				"dynamic": new ComfyNodeTypedInputRef<boolean>(this, "dynamic"),
				"mode": new ComfyNodeTypedInputRef<string>(this, "mode"),
				"options": new ComfyNodeTypedInputRef<string>(this, "options"),
				"disable": new ComfyNodeTypedInputRef<boolean>(this, "disable"),
				"backend": new ComfyNodeTypedInputRef<string>(this, "backend"),
			},
			outputs: Object.create(Object.prototype, {
				"*": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<EnhancedCompileModelInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["is_patcher"] === "object") {
			this.sockets.inputs["is_patcher"].connectTo(sources["is_patcher"])
		} else {
			this.sockets.inputs["is_patcher"].value = sources["is_patcher"]
		}

		if (typeof sources["object_to_patch"] === "object") {
			this.sockets.inputs["object_to_patch"].connectTo(sources["object_to_patch"])
		} else {
			this.sockets.inputs["object_to_patch"].value = sources["object_to_patch"]
		}

		if (typeof sources["compiler"] === "object") {
			this.sockets.inputs["compiler"].connectTo(sources["compiler"])
		} else {
			this.sockets.inputs["compiler"].value = sources["compiler"]
		}

		if (typeof sources["fullgraph"] === "object") {
			this.sockets.inputs["fullgraph"].connectTo(sources["fullgraph"])
		} else {
			this.sockets.inputs["fullgraph"].value = sources["fullgraph"]
		}

		if (typeof sources["dynamic"] === "object") {
			this.sockets.inputs["dynamic"].connectTo(sources["dynamic"])
		} else {
			this.sockets.inputs["dynamic"].value = sources["dynamic"]
		}

		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}

		if (typeof sources["options"] === "object") {
			this.sockets.inputs["options"].connectTo(sources["options"])
		} else {
			this.sockets.inputs["options"].value = sources["options"]
		}

		if (typeof sources["disable"] === "object") {
			this.sockets.inputs["disable"].connectTo(sources["disable"])
		} else {
			this.sockets.inputs["disable"].value = sources["disable"]
		}

		if (typeof sources["backend"] === "object") {
			this.sockets.inputs["backend"].connectTo(sources["backend"])
		} else {
			this.sockets.inputs["backend"].value = sources["backend"]
		}

	}
}

type EnhancedCompileModelInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_$STAR>
			"is_patcher": ComfyNodeTypedInputRef<boolean>
			"object_to_patch": ComfyNodeTypedInputRef<string>
			"compiler": ComfyNodeTypedInputRef<string>
			"fullgraph": ComfyNodeTypedInputRef<boolean>
			"dynamic": ComfyNodeTypedInputRef<boolean>
			"mode": ComfyNodeTypedInputRef<string>
			"options": ComfyNodeTypedInputRef<string>
			"disable": ComfyNodeTypedInputRef<boolean>
			"backend": ComfyNodeTypedInputRef<string>
}


export class VelocatorLoadAndQuantizeDiffusionModel extends ComfyNode {
	classType: string = "VelocatorLoadAndQuantizeDiffusionModel"

	sockets: {
		inputs: Required<VelocatorLoadAndQuantizeDiffusionModelInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"unet_name": new ComfyNodeTypedInputRef<string>(this, "unet_name"),
				"weight_dtype": new ComfyNodeTypedInputRef<string>(this, "weight_dtype"),
				"lowvram": new ComfyNodeTypedInputRef<boolean>(this, "lowvram"),
				"full_load": new ComfyNodeTypedInputRef<boolean>(this, "full_load"),
				"quantize": new ComfyNodeTypedInputRef<boolean>(this, "quantize"),
				"quantize_on_load_device": new ComfyNodeTypedInputRef<boolean>(this, "quantize_on_load_device"),
				"quant_type": new ComfyNodeTypedInputRef<string>(this, "quant_type"),
				"filter_fn": new ComfyNodeTypedInputRef<string>(this, "filter_fn"),
				"filter_fn_kwargs": new ComfyNodeTypedInputRef<string>(this, "filter_fn_kwargs"),
				"kwargs": new ComfyNodeTypedInputRef<string>(this, "kwargs"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VelocatorLoadAndQuantizeDiffusionModelInputs>) {
		if (typeof sources["unet_name"] === "object") {
			this.sockets.inputs["unet_name"].connectTo(sources["unet_name"])
		} else {
			this.sockets.inputs["unet_name"].value = sources["unet_name"]
		}

		if (typeof sources["weight_dtype"] === "object") {
			this.sockets.inputs["weight_dtype"].connectTo(sources["weight_dtype"])
		} else {
			this.sockets.inputs["weight_dtype"].value = sources["weight_dtype"]
		}

		if (typeof sources["lowvram"] === "object") {
			this.sockets.inputs["lowvram"].connectTo(sources["lowvram"])
		} else {
			this.sockets.inputs["lowvram"].value = sources["lowvram"]
		}

		if (typeof sources["full_load"] === "object") {
			this.sockets.inputs["full_load"].connectTo(sources["full_load"])
		} else {
			this.sockets.inputs["full_load"].value = sources["full_load"]
		}

		if (typeof sources["quantize"] === "object") {
			this.sockets.inputs["quantize"].connectTo(sources["quantize"])
		} else {
			this.sockets.inputs["quantize"].value = sources["quantize"]
		}

		if (typeof sources["quantize_on_load_device"] === "object") {
			this.sockets.inputs["quantize_on_load_device"].connectTo(sources["quantize_on_load_device"])
		} else {
			this.sockets.inputs["quantize_on_load_device"].value = sources["quantize_on_load_device"]
		}

		if (typeof sources["quant_type"] === "object") {
			this.sockets.inputs["quant_type"].connectTo(sources["quant_type"])
		} else {
			this.sockets.inputs["quant_type"].value = sources["quant_type"]
		}

		if (typeof sources["filter_fn"] === "object") {
			this.sockets.inputs["filter_fn"].connectTo(sources["filter_fn"])
		} else {
			this.sockets.inputs["filter_fn"].value = sources["filter_fn"]
		}

		if (typeof sources["filter_fn_kwargs"] === "object") {
			this.sockets.inputs["filter_fn_kwargs"].connectTo(sources["filter_fn_kwargs"])
		} else {
			this.sockets.inputs["filter_fn_kwargs"].value = sources["filter_fn_kwargs"]
		}

		if (typeof sources["kwargs"] === "object") {
			this.sockets.inputs["kwargs"].connectTo(sources["kwargs"])
		} else {
			this.sockets.inputs["kwargs"].value = sources["kwargs"]
		}

	}
}

type VelocatorLoadAndQuantizeDiffusionModelInputs = {
			"unet_name": ComfyNodeTypedInputRef<string>
			"weight_dtype": ComfyNodeTypedInputRef<string>
			"lowvram": ComfyNodeTypedInputRef<boolean>
			"full_load": ComfyNodeTypedInputRef<boolean>
			"quantize": ComfyNodeTypedInputRef<boolean>
			"quantize_on_load_device": ComfyNodeTypedInputRef<boolean>
			"quant_type": ComfyNodeTypedInputRef<string>
			"filter_fn": ComfyNodeTypedInputRef<string>
			"filter_fn_kwargs": ComfyNodeTypedInputRef<string>
			"kwargs": ComfyNodeTypedInputRef<string>
}


export class VelocatorLoadAndQuantizeClip extends ComfyNode {
	classType: string = "VelocatorLoadAndQuantizeClip"

	sockets: {
		inputs: Required<VelocatorLoadAndQuantizeClipInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<string>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<string>(this, "clip_name2"),
				"clip_name3": new ComfyNodeTypedInputRef<string>(this, "clip_name3"),
				"type": new ComfyNodeTypedInputRef<string>(this, "type"),
				"weight_dtype": new ComfyNodeTypedInputRef<string>(this, "weight_dtype"),
				"lowvram": new ComfyNodeTypedInputRef<boolean>(this, "lowvram"),
				"full_load": new ComfyNodeTypedInputRef<boolean>(this, "full_load"),
				"quantize": new ComfyNodeTypedInputRef<boolean>(this, "quantize"),
				"quantize_on_load_device": new ComfyNodeTypedInputRef<boolean>(this, "quantize_on_load_device"),
				"quant_type": new ComfyNodeTypedInputRef<string>(this, "quant_type"),
				"filter_fn": new ComfyNodeTypedInputRef<string>(this, "filter_fn"),
				"filter_fn_kwargs": new ComfyNodeTypedInputRef<string>(this, "filter_fn_kwargs"),
				"kwargs": new ComfyNodeTypedInputRef<string>(this, "kwargs"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VelocatorLoadAndQuantizeClipInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["clip_name3"] === "object") {
			this.sockets.inputs["clip_name3"].connectTo(sources["clip_name3"])
		} else {
			this.sockets.inputs["clip_name3"].value = sources["clip_name3"]
		}

		if (typeof sources["type"] === "object") {
			this.sockets.inputs["type"].connectTo(sources["type"])
		} else {
			this.sockets.inputs["type"].value = sources["type"]
		}

		if (typeof sources["weight_dtype"] === "object") {
			this.sockets.inputs["weight_dtype"].connectTo(sources["weight_dtype"])
		} else {
			this.sockets.inputs["weight_dtype"].value = sources["weight_dtype"]
		}

		if (typeof sources["lowvram"] === "object") {
			this.sockets.inputs["lowvram"].connectTo(sources["lowvram"])
		} else {
			this.sockets.inputs["lowvram"].value = sources["lowvram"]
		}

		if (typeof sources["full_load"] === "object") {
			this.sockets.inputs["full_load"].connectTo(sources["full_load"])
		} else {
			this.sockets.inputs["full_load"].value = sources["full_load"]
		}

		if (typeof sources["quantize"] === "object") {
			this.sockets.inputs["quantize"].connectTo(sources["quantize"])
		} else {
			this.sockets.inputs["quantize"].value = sources["quantize"]
		}

		if (typeof sources["quantize_on_load_device"] === "object") {
			this.sockets.inputs["quantize_on_load_device"].connectTo(sources["quantize_on_load_device"])
		} else {
			this.sockets.inputs["quantize_on_load_device"].value = sources["quantize_on_load_device"]
		}

		if (typeof sources["quant_type"] === "object") {
			this.sockets.inputs["quant_type"].connectTo(sources["quant_type"])
		} else {
			this.sockets.inputs["quant_type"].value = sources["quant_type"]
		}

		if (typeof sources["filter_fn"] === "object") {
			this.sockets.inputs["filter_fn"].connectTo(sources["filter_fn"])
		} else {
			this.sockets.inputs["filter_fn"].value = sources["filter_fn"]
		}

		if (typeof sources["filter_fn_kwargs"] === "object") {
			this.sockets.inputs["filter_fn_kwargs"].connectTo(sources["filter_fn_kwargs"])
		} else {
			this.sockets.inputs["filter_fn_kwargs"].value = sources["filter_fn_kwargs"]
		}

		if (typeof sources["kwargs"] === "object") {
			this.sockets.inputs["kwargs"].connectTo(sources["kwargs"])
		} else {
			this.sockets.inputs["kwargs"].value = sources["kwargs"]
		}

	}
}

type VelocatorLoadAndQuantizeClipInputs = {
			"clip_name1": ComfyNodeTypedInputRef<string>
			"clip_name2": ComfyNodeTypedInputRef<string>
			"clip_name3": ComfyNodeTypedInputRef<string>
			"type": ComfyNodeTypedInputRef<string>
			"weight_dtype": ComfyNodeTypedInputRef<string>
			"lowvram": ComfyNodeTypedInputRef<boolean>
			"full_load": ComfyNodeTypedInputRef<boolean>
			"quantize": ComfyNodeTypedInputRef<boolean>
			"quantize_on_load_device": ComfyNodeTypedInputRef<boolean>
			"quant_type": ComfyNodeTypedInputRef<string>
			"filter_fn": ComfyNodeTypedInputRef<string>
			"filter_fn_kwargs": ComfyNodeTypedInputRef<string>
			"kwargs": ComfyNodeTypedInputRef<string>
}


export class VelocatorQuantizeModel extends ComfyNode {
	classType: string = "VelocatorQuantizeModel"

	sockets: {
		inputs: Required<VelocatorQuantizeModelInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"object_to_patch": new ComfyNodeTypedInputRef<string>(this, "object_to_patch"),
				"quant_type": new ComfyNodeTypedInputRef<string>(this, "quant_type"),
				"filter_fn": new ComfyNodeTypedInputRef<string>(this, "filter_fn"),
				"filter_fn_kwargs": new ComfyNodeTypedInputRef<string>(this, "filter_fn_kwargs"),
				"kwargs": new ComfyNodeTypedInputRef<string>(this, "kwargs"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VelocatorQuantizeModelInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["object_to_patch"] === "object") {
			this.sockets.inputs["object_to_patch"].connectTo(sources["object_to_patch"])
		} else {
			this.sockets.inputs["object_to_patch"].value = sources["object_to_patch"]
		}

		if (typeof sources["quant_type"] === "object") {
			this.sockets.inputs["quant_type"].connectTo(sources["quant_type"])
		} else {
			this.sockets.inputs["quant_type"].value = sources["quant_type"]
		}

		if (typeof sources["filter_fn"] === "object") {
			this.sockets.inputs["filter_fn"].connectTo(sources["filter_fn"])
		} else {
			this.sockets.inputs["filter_fn"].value = sources["filter_fn"]
		}

		if (typeof sources["filter_fn_kwargs"] === "object") {
			this.sockets.inputs["filter_fn_kwargs"].connectTo(sources["filter_fn_kwargs"])
		} else {
			this.sockets.inputs["filter_fn_kwargs"].value = sources["filter_fn_kwargs"]
		}

		if (typeof sources["kwargs"] === "object") {
			this.sockets.inputs["kwargs"].connectTo(sources["kwargs"])
		} else {
			this.sockets.inputs["kwargs"].value = sources["kwargs"]
		}

	}
}

type VelocatorQuantizeModelInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"object_to_patch": ComfyNodeTypedInputRef<string>
			"quant_type": ComfyNodeTypedInputRef<string>
			"filter_fn": ComfyNodeTypedInputRef<string>
			"filter_fn_kwargs": ComfyNodeTypedInputRef<string>
			"kwargs": ComfyNodeTypedInputRef<string>
}


export class VelocatorCompileModel extends ComfyNode {
	classType: string = "VelocatorCompileModel"

	sockets: {
		inputs: Required<VelocatorCompileModelInputs>
		outputs: {
			_: ComfyNodeTypedSourceRef<ComfyValueType_$STAR>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_$STAR>(this, "model"),
				"is_patcher": new ComfyNodeTypedInputRef<boolean>(this, "is_patcher"),
				"object_to_patch": new ComfyNodeTypedInputRef<string>(this, "object_to_patch"),
				"memory_format": new ComfyNodeTypedInputRef<string>(this, "memory_format"),
				"fullgraph": new ComfyNodeTypedInputRef<boolean>(this, "fullgraph"),
				"dynamic": new ComfyNodeTypedInputRef<boolean>(this, "dynamic"),
				"mode": new ComfyNodeTypedInputRef<string>(this, "mode"),
				"options": new ComfyNodeTypedInputRef<string>(this, "options"),
				"disable": new ComfyNodeTypedInputRef<boolean>(this, "disable"),
				"backend": new ComfyNodeTypedInputRef<string>(this, "backend"),
			},
			outputs: Object.create(Object.prototype, {
				"*": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VelocatorCompileModelInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["is_patcher"] === "object") {
			this.sockets.inputs["is_patcher"].connectTo(sources["is_patcher"])
		} else {
			this.sockets.inputs["is_patcher"].value = sources["is_patcher"]
		}

		if (typeof sources["object_to_patch"] === "object") {
			this.sockets.inputs["object_to_patch"].connectTo(sources["object_to_patch"])
		} else {
			this.sockets.inputs["object_to_patch"].value = sources["object_to_patch"]
		}

		if (typeof sources["memory_format"] === "object") {
			this.sockets.inputs["memory_format"].connectTo(sources["memory_format"])
		} else {
			this.sockets.inputs["memory_format"].value = sources["memory_format"]
		}

		if (typeof sources["fullgraph"] === "object") {
			this.sockets.inputs["fullgraph"].connectTo(sources["fullgraph"])
		} else {
			this.sockets.inputs["fullgraph"].value = sources["fullgraph"]
		}

		if (typeof sources["dynamic"] === "object") {
			this.sockets.inputs["dynamic"].connectTo(sources["dynamic"])
		} else {
			this.sockets.inputs["dynamic"].value = sources["dynamic"]
		}

		if (typeof sources["mode"] === "object") {
			this.sockets.inputs["mode"].connectTo(sources["mode"])
		} else {
			this.sockets.inputs["mode"].value = sources["mode"]
		}

		if (typeof sources["options"] === "object") {
			this.sockets.inputs["options"].connectTo(sources["options"])
		} else {
			this.sockets.inputs["options"].value = sources["options"]
		}

		if (typeof sources["disable"] === "object") {
			this.sockets.inputs["disable"].connectTo(sources["disable"])
		} else {
			this.sockets.inputs["disable"].value = sources["disable"]
		}

		if (typeof sources["backend"] === "object") {
			this.sockets.inputs["backend"].connectTo(sources["backend"])
		} else {
			this.sockets.inputs["backend"].value = sources["backend"]
		}

	}
}

type VelocatorCompileModelInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_$STAR>
			"is_patcher": ComfyNodeTypedInputRef<boolean>
			"object_to_patch": ComfyNodeTypedInputRef<string>
			"memory_format": ComfyNodeTypedInputRef<string>
			"fullgraph": ComfyNodeTypedInputRef<boolean>
			"dynamic": ComfyNodeTypedInputRef<boolean>
			"mode": ComfyNodeTypedInputRef<string>
			"options": ComfyNodeTypedInputRef<string>
			"disable": ComfyNodeTypedInputRef<boolean>
			"backend": ComfyNodeTypedInputRef<string>
}


export class CheckpointLoaderAdvancedMultiGPU extends ComfyNode {
	classType: string = "CheckpointLoaderAdvancedMultiGPU"

	sockets: {
		inputs: Required<CheckpointLoaderAdvancedMultiGPUInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
			VAE: ComfyNodeTypedSourceRef<ComfyValueType_VAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"ckpt_name": new ComfyNodeTypedInputRef<string>(this, "ckpt_name"),
				"unet_device": new ComfyNodeTypedInputRef<string>(this, "unet_device"),
				"clip_device": new ComfyNodeTypedInputRef<string>(this, "clip_device"),
				"vae_device": new ComfyNodeTypedInputRef<string>(this, "vae_device"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"VAE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CheckpointLoaderAdvancedMultiGPUInputs>) {
		if (typeof sources["ckpt_name"] === "object") {
			this.sockets.inputs["ckpt_name"].connectTo(sources["ckpt_name"])
		} else {
			this.sockets.inputs["ckpt_name"].value = sources["ckpt_name"]
		}

		if (typeof sources["unet_device"] === "object") {
			this.sockets.inputs["unet_device"].connectTo(sources["unet_device"])
		} else {
			this.sockets.inputs["unet_device"].value = sources["unet_device"]
		}

		if (typeof sources["clip_device"] === "object") {
			this.sockets.inputs["clip_device"].connectTo(sources["clip_device"])
		} else {
			this.sockets.inputs["clip_device"].value = sources["clip_device"]
		}

		if (typeof sources["vae_device"] === "object") {
			this.sockets.inputs["vae_device"].connectTo(sources["vae_device"])
		} else {
			this.sockets.inputs["vae_device"].value = sources["vae_device"]
		}

	}
}

type CheckpointLoaderAdvancedMultiGPUInputs = {
			"ckpt_name": ComfyNodeTypedInputRef<string>
			"unet_device": ComfyNodeTypedInputRef<string>
			"clip_device": ComfyNodeTypedInputRef<string>
			"vae_device": ComfyNodeTypedInputRef<string>
}


export class CheckpointLoaderAdvancedDisTorch2MultiGPU extends ComfyNode {
	classType: string = "CheckpointLoaderAdvancedDisTorch2MultiGPU"

	sockets: {
		inputs: Required<CheckpointLoaderAdvancedDisTorch2MultiGPUInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
			VAE: ComfyNodeTypedSourceRef<ComfyValueType_VAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"ckpt_name": new ComfyNodeTypedInputRef<string>(this, "ckpt_name"),
				"unet_compute_device": new ComfyNodeTypedInputRef<string>(this, "unet_compute_device"),
				"unet_virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "unet_virtual_vram_gb"),
				"unet_donor_device": new ComfyNodeTypedInputRef<string>(this, "unet_donor_device"),
				"clip_compute_device": new ComfyNodeTypedInputRef<string>(this, "clip_compute_device"),
				"clip_virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "clip_virtual_vram_gb"),
				"clip_donor_device": new ComfyNodeTypedInputRef<string>(this, "clip_donor_device"),
				"vae_device": new ComfyNodeTypedInputRef<string>(this, "vae_device"),
				"unet_expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "unet_expert_mode_allocations"),
				"clip_expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "clip_expert_mode_allocations"),
				"high_precision_loras": new ComfyNodeTypedInputRef<boolean>(this, "high_precision_loras"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"VAE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CheckpointLoaderAdvancedDisTorch2MultiGPUInputs>) {
		if (typeof sources["ckpt_name"] === "object") {
			this.sockets.inputs["ckpt_name"].connectTo(sources["ckpt_name"])
		} else {
			this.sockets.inputs["ckpt_name"].value = sources["ckpt_name"]
		}

		if (typeof sources["unet_compute_device"] === "object") {
			this.sockets.inputs["unet_compute_device"].connectTo(sources["unet_compute_device"])
		} else {
			this.sockets.inputs["unet_compute_device"].value = sources["unet_compute_device"]
		}

		if (typeof sources["unet_virtual_vram_gb"] === "object") {
			this.sockets.inputs["unet_virtual_vram_gb"].connectTo(sources["unet_virtual_vram_gb"])
		} else {
			this.sockets.inputs["unet_virtual_vram_gb"].value = sources["unet_virtual_vram_gb"]
		}

		if (typeof sources["unet_donor_device"] === "object") {
			this.sockets.inputs["unet_donor_device"].connectTo(sources["unet_donor_device"])
		} else {
			this.sockets.inputs["unet_donor_device"].value = sources["unet_donor_device"]
		}

		if (typeof sources["clip_compute_device"] === "object") {
			this.sockets.inputs["clip_compute_device"].connectTo(sources["clip_compute_device"])
		} else {
			this.sockets.inputs["clip_compute_device"].value = sources["clip_compute_device"]
		}

		if (typeof sources["clip_virtual_vram_gb"] === "object") {
			this.sockets.inputs["clip_virtual_vram_gb"].connectTo(sources["clip_virtual_vram_gb"])
		} else {
			this.sockets.inputs["clip_virtual_vram_gb"].value = sources["clip_virtual_vram_gb"]
		}

		if (typeof sources["clip_donor_device"] === "object") {
			this.sockets.inputs["clip_donor_device"].connectTo(sources["clip_donor_device"])
		} else {
			this.sockets.inputs["clip_donor_device"].value = sources["clip_donor_device"]
		}

		if (typeof sources["vae_device"] === "object") {
			this.sockets.inputs["vae_device"].connectTo(sources["vae_device"])
		} else {
			this.sockets.inputs["vae_device"].value = sources["vae_device"]
		}

		if (sources["unet_expert_mode_allocations"] !== undefined) {
		if (typeof sources["unet_expert_mode_allocations"] === "object") {
			this.sockets.inputs["unet_expert_mode_allocations"].connectTo(sources["unet_expert_mode_allocations"])
		} else {
			this.sockets.inputs["unet_expert_mode_allocations"].value = sources["unet_expert_mode_allocations"]
		}
		}

		if (sources["clip_expert_mode_allocations"] !== undefined) {
		if (typeof sources["clip_expert_mode_allocations"] === "object") {
			this.sockets.inputs["clip_expert_mode_allocations"].connectTo(sources["clip_expert_mode_allocations"])
		} else {
			this.sockets.inputs["clip_expert_mode_allocations"].value = sources["clip_expert_mode_allocations"]
		}
		}

		if (sources["high_precision_loras"] !== undefined) {
		if (typeof sources["high_precision_loras"] === "object") {
			this.sockets.inputs["high_precision_loras"].connectTo(sources["high_precision_loras"])
		} else {
			this.sockets.inputs["high_precision_loras"].value = sources["high_precision_loras"]
		}
		}

	}
}

type CheckpointLoaderAdvancedDisTorch2MultiGPUInputs = {
			"ckpt_name": ComfyNodeTypedInputRef<string>
			"unet_compute_device": ComfyNodeTypedInputRef<string>
			"unet_virtual_vram_gb": ComfyNodeTypedInputRef<number>
			"unet_donor_device": ComfyNodeTypedInputRef<string>
			"clip_compute_device": ComfyNodeTypedInputRef<string>
			"clip_virtual_vram_gb": ComfyNodeTypedInputRef<number>
			"clip_donor_device": ComfyNodeTypedInputRef<string>
			"vae_device": ComfyNodeTypedInputRef<string>
			"unet_expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
			"clip_expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
			"high_precision_loras"?: ComfyNodeTypedInputRef<boolean>
}


export class UNetLoaderLP extends ComfyNode {
	classType: string = "UNetLoaderLP"

	sockets: {
		inputs: Required<UNetLoaderLPInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"unet_name": new ComfyNodeTypedInputRef<string>(this, "unet_name"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<UNetLoaderLPInputs>) {
		if (typeof sources["unet_name"] === "object") {
			this.sockets.inputs["unet_name"].connectTo(sources["unet_name"])
		} else {
			this.sockets.inputs["unet_name"].value = sources["unet_name"]
		}

	}
}

type UNetLoaderLPInputs = {
			"unet_name": ComfyNodeTypedInputRef<string>
}


export class UNETLoaderMultiGPU extends ComfyNode {
	classType: string = "UNETLoaderMultiGPU"

	sockets: {
		inputs: Required<UNETLoaderMultiGPUInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"unet_name": new ComfyNodeTypedInputRef<string>(this, "unet_name"),
				"weight_dtype": new ComfyNodeTypedInputRef<string>(this, "weight_dtype"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<UNETLoaderMultiGPUInputs>) {
		if (typeof sources["unet_name"] === "object") {
			this.sockets.inputs["unet_name"].connectTo(sources["unet_name"])
		} else {
			this.sockets.inputs["unet_name"].value = sources["unet_name"]
		}

		if (typeof sources["weight_dtype"] === "object") {
			this.sockets.inputs["weight_dtype"].connectTo(sources["weight_dtype"])
		} else {
			this.sockets.inputs["weight_dtype"].value = sources["weight_dtype"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type UNETLoaderMultiGPUInputs = {
			"unet_name": ComfyNodeTypedInputRef<string>
			"weight_dtype": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
}


export class VAELoaderMultiGPU extends ComfyNode {
	classType: string = "VAELoaderMultiGPU"

	sockets: {
		inputs: Required<VAELoaderMultiGPUInputs>
		outputs: {
			VAE: ComfyNodeTypedSourceRef<ComfyValueType_VAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vae_name": new ComfyNodeTypedInputRef<string>(this, "vae_name"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"VAE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VAELoaderMultiGPUInputs>) {
		if (typeof sources["vae_name"] === "object") {
			this.sockets.inputs["vae_name"].connectTo(sources["vae_name"])
		} else {
			this.sockets.inputs["vae_name"].value = sources["vae_name"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type VAELoaderMultiGPUInputs = {
			"vae_name": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
}


export class CLIPLoaderMultiGPU extends ComfyNode {
	classType: string = "CLIPLoaderMultiGPU"

	sockets: {
		inputs: Required<CLIPLoaderMultiGPUInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name": new ComfyNodeTypedInputRef<string>(this, "clip_name"),
				"type": new ComfyNodeTypedInputRef<string>(this, "type"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPLoaderMultiGPUInputs>) {
		if (typeof sources["clip_name"] === "object") {
			this.sockets.inputs["clip_name"].connectTo(sources["clip_name"])
		} else {
			this.sockets.inputs["clip_name"].value = sources["clip_name"]
		}

		if (typeof sources["type"] === "object") {
			this.sockets.inputs["type"].connectTo(sources["type"])
		} else {
			this.sockets.inputs["type"].value = sources["type"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type CLIPLoaderMultiGPUInputs = {
			"clip_name": ComfyNodeTypedInputRef<string>
			"type": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
}


export class DualCLIPLoaderMultiGPU extends ComfyNode {
	classType: string = "DualCLIPLoaderMultiGPU"

	sockets: {
		inputs: Required<DualCLIPLoaderMultiGPUInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<string>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<string>(this, "clip_name2"),
				"type": new ComfyNodeTypedInputRef<string>(this, "type"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DualCLIPLoaderMultiGPUInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["type"] === "object") {
			this.sockets.inputs["type"].connectTo(sources["type"])
		} else {
			this.sockets.inputs["type"].value = sources["type"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type DualCLIPLoaderMultiGPUInputs = {
			"clip_name1": ComfyNodeTypedInputRef<string>
			"clip_name2": ComfyNodeTypedInputRef<string>
			"type": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
}


export class CLIPVisionLoaderMultiGPU extends ComfyNode {
	classType: string = "CLIPVisionLoaderMultiGPU"

	sockets: {
		inputs: Required<CLIPVisionLoaderMultiGPUInputs>
		outputs: {
			CLIP_VISION: ComfyNodeTypedSourceRef<ComfyValueType_CLIP_VISION>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name": new ComfyNodeTypedInputRef<string>(this, "clip_name"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP_VISION": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPVisionLoaderMultiGPUInputs>) {
		if (typeof sources["clip_name"] === "object") {
			this.sockets.inputs["clip_name"].connectTo(sources["clip_name"])
		} else {
			this.sockets.inputs["clip_name"].value = sources["clip_name"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type CLIPVisionLoaderMultiGPUInputs = {
			"clip_name": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
}


export class CheckpointLoaderSimpleMultiGPU extends ComfyNode {
	classType: string = "CheckpointLoaderSimpleMultiGPU"

	sockets: {
		inputs: Required<CheckpointLoaderSimpleMultiGPUInputs>
		outputs: {
			/** The model used for denoising latents.*/
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
			/** The CLIP model used for encoding text prompts.*/
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
			/** The VAE model used for encoding and decoding images to and from latent space.*/
			VAE: ComfyNodeTypedSourceRef<ComfyValueType_VAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"ckpt_name": new ComfyNodeTypedInputRef<string>(this, "ckpt_name"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"VAE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CheckpointLoaderSimpleMultiGPUInputs>) {
		if (typeof sources["ckpt_name"] === "object") {
			this.sockets.inputs["ckpt_name"].connectTo(sources["ckpt_name"])
		} else {
			this.sockets.inputs["ckpt_name"].value = sources["ckpt_name"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type CheckpointLoaderSimpleMultiGPUInputs = {
			/** The name of the checkpoint (model) to load.*/
			"ckpt_name": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
}


export class ControlNetLoaderMultiGPU extends ComfyNode {
	classType: string = "ControlNetLoaderMultiGPU"

	sockets: {
		inputs: Required<ControlNetLoaderMultiGPUInputs>
		outputs: {
			CONTROL_NET: ComfyNodeTypedSourceRef<ComfyValueType_CONTROL_NET>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"control_net_name": new ComfyNodeTypedInputRef<void>(this, "control_net_name"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"CONTROL_NET": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ControlNetLoaderMultiGPUInputs>) {
		if (typeof sources["control_net_name"] === "object") {
			this.sockets.inputs["control_net_name"].connectTo(sources["control_net_name"])
		} else {
			this.sockets.inputs["control_net_name"].value = sources["control_net_name"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type ControlNetLoaderMultiGPUInputs = {
			"control_net_name": ComfyNodeTypedInputRef<void>
			"device"?: ComfyNodeTypedInputRef<string>
}


export class DiffusersLoaderMultiGPU extends ComfyNode {
	classType: string = "DiffusersLoaderMultiGPU"

	sockets: {
		inputs: Required<DiffusersLoaderMultiGPUInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
			VAE: ComfyNodeTypedSourceRef<ComfyValueType_VAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_path": new ComfyNodeTypedInputRef<void>(this, "model_path"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"VAE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DiffusersLoaderMultiGPUInputs>) {
		if (typeof sources["model_path"] === "object") {
			this.sockets.inputs["model_path"].connectTo(sources["model_path"])
		} else {
			this.sockets.inputs["model_path"].value = sources["model_path"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type DiffusersLoaderMultiGPUInputs = {
			"model_path": ComfyNodeTypedInputRef<void>
			"device"?: ComfyNodeTypedInputRef<string>
}


export class DiffControlNetLoaderMultiGPU extends ComfyNode {
	classType: string = "DiffControlNetLoaderMultiGPU"

	sockets: {
		inputs: Required<DiffControlNetLoaderMultiGPUInputs>
		outputs: {
			CONTROL_NET: ComfyNodeTypedSourceRef<ComfyValueType_CONTROL_NET>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"control_net_name": new ComfyNodeTypedInputRef<void>(this, "control_net_name"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"CONTROL_NET": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DiffControlNetLoaderMultiGPUInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["control_net_name"] === "object") {
			this.sockets.inputs["control_net_name"].connectTo(sources["control_net_name"])
		} else {
			this.sockets.inputs["control_net_name"].value = sources["control_net_name"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type DiffControlNetLoaderMultiGPUInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"control_net_name": ComfyNodeTypedInputRef<void>
			"device"?: ComfyNodeTypedInputRef<string>
}


export class UNETLoaderDisTorch2MultiGPU extends ComfyNode {
	classType: string = "UNETLoaderDisTorch2MultiGPU"

	sockets: {
		inputs: Required<UNETLoaderDisTorch2MultiGPUInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"unet_name": new ComfyNodeTypedInputRef<string>(this, "unet_name"),
				"weight_dtype": new ComfyNodeTypedInputRef<string>(this, "weight_dtype"),
				"compute_device": new ComfyNodeTypedInputRef<string>(this, "compute_device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"donor_device": new ComfyNodeTypedInputRef<string>(this, "donor_device"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
				"eject_models": new ComfyNodeTypedInputRef<boolean>(this, "eject_models"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<UNETLoaderDisTorch2MultiGPUInputs>) {
		if (typeof sources["unet_name"] === "object") {
			this.sockets.inputs["unet_name"].connectTo(sources["unet_name"])
		} else {
			this.sockets.inputs["unet_name"].value = sources["unet_name"]
		}

		if (typeof sources["weight_dtype"] === "object") {
			this.sockets.inputs["weight_dtype"].connectTo(sources["weight_dtype"])
		} else {
			this.sockets.inputs["weight_dtype"].value = sources["weight_dtype"]
		}

		if (sources["compute_device"] !== undefined) {
		if (typeof sources["compute_device"] === "object") {
			this.sockets.inputs["compute_device"].connectTo(sources["compute_device"])
		} else {
			this.sockets.inputs["compute_device"].value = sources["compute_device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["donor_device"] !== undefined) {
		if (typeof sources["donor_device"] === "object") {
			this.sockets.inputs["donor_device"].connectTo(sources["donor_device"])
		} else {
			this.sockets.inputs["donor_device"].value = sources["donor_device"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

		if (sources["eject_models"] !== undefined) {
		if (typeof sources["eject_models"] === "object") {
			this.sockets.inputs["eject_models"].connectTo(sources["eject_models"])
		} else {
			this.sockets.inputs["eject_models"].value = sources["eject_models"]
		}
		}

	}
}

type UNETLoaderDisTorch2MultiGPUInputs = {
			"unet_name": ComfyNodeTypedInputRef<string>
			"weight_dtype": ComfyNodeTypedInputRef<string>
			"compute_device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"donor_device"?: ComfyNodeTypedInputRef<string>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
			"eject_models"?: ComfyNodeTypedInputRef<boolean>
}


export class VAELoaderDisTorch2MultiGPU extends ComfyNode {
	classType: string = "VAELoaderDisTorch2MultiGPU"

	sockets: {
		inputs: Required<VAELoaderDisTorch2MultiGPUInputs>
		outputs: {
			VAE: ComfyNodeTypedSourceRef<ComfyValueType_VAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vae_name": new ComfyNodeTypedInputRef<string>(this, "vae_name"),
				"compute_device": new ComfyNodeTypedInputRef<string>(this, "compute_device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"donor_device": new ComfyNodeTypedInputRef<string>(this, "donor_device"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
				"eject_models": new ComfyNodeTypedInputRef<boolean>(this, "eject_models"),
			},
			outputs: Object.create(Object.prototype, {
				"VAE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<VAELoaderDisTorch2MultiGPUInputs>) {
		if (typeof sources["vae_name"] === "object") {
			this.sockets.inputs["vae_name"].connectTo(sources["vae_name"])
		} else {
			this.sockets.inputs["vae_name"].value = sources["vae_name"]
		}

		if (sources["compute_device"] !== undefined) {
		if (typeof sources["compute_device"] === "object") {
			this.sockets.inputs["compute_device"].connectTo(sources["compute_device"])
		} else {
			this.sockets.inputs["compute_device"].value = sources["compute_device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["donor_device"] !== undefined) {
		if (typeof sources["donor_device"] === "object") {
			this.sockets.inputs["donor_device"].connectTo(sources["donor_device"])
		} else {
			this.sockets.inputs["donor_device"].value = sources["donor_device"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

		if (sources["eject_models"] !== undefined) {
		if (typeof sources["eject_models"] === "object") {
			this.sockets.inputs["eject_models"].connectTo(sources["eject_models"])
		} else {
			this.sockets.inputs["eject_models"].value = sources["eject_models"]
		}
		}

	}
}

type VAELoaderDisTorch2MultiGPUInputs = {
			"vae_name": ComfyNodeTypedInputRef<string>
			"compute_device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"donor_device"?: ComfyNodeTypedInputRef<string>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
			"eject_models"?: ComfyNodeTypedInputRef<boolean>
}


export class CLIPLoaderDisTorch2MultiGPU extends ComfyNode {
	classType: string = "CLIPLoaderDisTorch2MultiGPU"

	sockets: {
		inputs: Required<CLIPLoaderDisTorch2MultiGPUInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name": new ComfyNodeTypedInputRef<string>(this, "clip_name"),
				"type": new ComfyNodeTypedInputRef<string>(this, "type"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"donor_device": new ComfyNodeTypedInputRef<string>(this, "donor_device"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
				"eject_models": new ComfyNodeTypedInputRef<boolean>(this, "eject_models"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPLoaderDisTorch2MultiGPUInputs>) {
		if (typeof sources["clip_name"] === "object") {
			this.sockets.inputs["clip_name"].connectTo(sources["clip_name"])
		} else {
			this.sockets.inputs["clip_name"].value = sources["clip_name"]
		}

		if (typeof sources["type"] === "object") {
			this.sockets.inputs["type"].connectTo(sources["type"])
		} else {
			this.sockets.inputs["type"].value = sources["type"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["donor_device"] !== undefined) {
		if (typeof sources["donor_device"] === "object") {
			this.sockets.inputs["donor_device"].connectTo(sources["donor_device"])
		} else {
			this.sockets.inputs["donor_device"].value = sources["donor_device"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

		if (sources["eject_models"] !== undefined) {
		if (typeof sources["eject_models"] === "object") {
			this.sockets.inputs["eject_models"].connectTo(sources["eject_models"])
		} else {
			this.sockets.inputs["eject_models"].value = sources["eject_models"]
		}
		}

	}
}

type CLIPLoaderDisTorch2MultiGPUInputs = {
			"clip_name": ComfyNodeTypedInputRef<string>
			"type": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"donor_device"?: ComfyNodeTypedInputRef<string>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
			"eject_models"?: ComfyNodeTypedInputRef<boolean>
}


export class DualCLIPLoaderDisTorch2MultiGPU extends ComfyNode {
	classType: string = "DualCLIPLoaderDisTorch2MultiGPU"

	sockets: {
		inputs: Required<DualCLIPLoaderDisTorch2MultiGPUInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<string>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<string>(this, "clip_name2"),
				"type": new ComfyNodeTypedInputRef<string>(this, "type"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"donor_device": new ComfyNodeTypedInputRef<string>(this, "donor_device"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
				"eject_models": new ComfyNodeTypedInputRef<boolean>(this, "eject_models"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DualCLIPLoaderDisTorch2MultiGPUInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["type"] === "object") {
			this.sockets.inputs["type"].connectTo(sources["type"])
		} else {
			this.sockets.inputs["type"].value = sources["type"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["donor_device"] !== undefined) {
		if (typeof sources["donor_device"] === "object") {
			this.sockets.inputs["donor_device"].connectTo(sources["donor_device"])
		} else {
			this.sockets.inputs["donor_device"].value = sources["donor_device"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

		if (sources["eject_models"] !== undefined) {
		if (typeof sources["eject_models"] === "object") {
			this.sockets.inputs["eject_models"].connectTo(sources["eject_models"])
		} else {
			this.sockets.inputs["eject_models"].value = sources["eject_models"]
		}
		}

	}
}

type DualCLIPLoaderDisTorch2MultiGPUInputs = {
			"clip_name1": ComfyNodeTypedInputRef<string>
			"clip_name2": ComfyNodeTypedInputRef<string>
			"type": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"donor_device"?: ComfyNodeTypedInputRef<string>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
			"eject_models"?: ComfyNodeTypedInputRef<boolean>
}


export class CLIPVisionLoaderDisTorch2MultiGPU extends ComfyNode {
	classType: string = "CLIPVisionLoaderDisTorch2MultiGPU"

	sockets: {
		inputs: Required<CLIPVisionLoaderDisTorch2MultiGPUInputs>
		outputs: {
			CLIP_VISION: ComfyNodeTypedSourceRef<ComfyValueType_CLIP_VISION>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name": new ComfyNodeTypedInputRef<string>(this, "clip_name"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"donor_device": new ComfyNodeTypedInputRef<string>(this, "donor_device"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
				"eject_models": new ComfyNodeTypedInputRef<boolean>(this, "eject_models"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP_VISION": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPVisionLoaderDisTorch2MultiGPUInputs>) {
		if (typeof sources["clip_name"] === "object") {
			this.sockets.inputs["clip_name"].connectTo(sources["clip_name"])
		} else {
			this.sockets.inputs["clip_name"].value = sources["clip_name"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["donor_device"] !== undefined) {
		if (typeof sources["donor_device"] === "object") {
			this.sockets.inputs["donor_device"].connectTo(sources["donor_device"])
		} else {
			this.sockets.inputs["donor_device"].value = sources["donor_device"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

		if (sources["eject_models"] !== undefined) {
		if (typeof sources["eject_models"] === "object") {
			this.sockets.inputs["eject_models"].connectTo(sources["eject_models"])
		} else {
			this.sockets.inputs["eject_models"].value = sources["eject_models"]
		}
		}

	}
}

type CLIPVisionLoaderDisTorch2MultiGPUInputs = {
			"clip_name": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"donor_device"?: ComfyNodeTypedInputRef<string>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
			"eject_models"?: ComfyNodeTypedInputRef<boolean>
}


export class CheckpointLoaderSimpleDisTorch2MultiGPU extends ComfyNode {
	classType: string = "CheckpointLoaderSimpleDisTorch2MultiGPU"

	sockets: {
		inputs: Required<CheckpointLoaderSimpleDisTorch2MultiGPUInputs>
		outputs: {
			/** The model used for denoising latents.*/
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
			/** The CLIP model used for encoding text prompts.*/
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
			/** The VAE model used for encoding and decoding images to and from latent space.*/
			VAE: ComfyNodeTypedSourceRef<ComfyValueType_VAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"ckpt_name": new ComfyNodeTypedInputRef<string>(this, "ckpt_name"),
				"compute_device": new ComfyNodeTypedInputRef<string>(this, "compute_device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"donor_device": new ComfyNodeTypedInputRef<string>(this, "donor_device"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
				"eject_models": new ComfyNodeTypedInputRef<boolean>(this, "eject_models"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"VAE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CheckpointLoaderSimpleDisTorch2MultiGPUInputs>) {
		if (typeof sources["ckpt_name"] === "object") {
			this.sockets.inputs["ckpt_name"].connectTo(sources["ckpt_name"])
		} else {
			this.sockets.inputs["ckpt_name"].value = sources["ckpt_name"]
		}

		if (sources["compute_device"] !== undefined) {
		if (typeof sources["compute_device"] === "object") {
			this.sockets.inputs["compute_device"].connectTo(sources["compute_device"])
		} else {
			this.sockets.inputs["compute_device"].value = sources["compute_device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["donor_device"] !== undefined) {
		if (typeof sources["donor_device"] === "object") {
			this.sockets.inputs["donor_device"].connectTo(sources["donor_device"])
		} else {
			this.sockets.inputs["donor_device"].value = sources["donor_device"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

		if (sources["eject_models"] !== undefined) {
		if (typeof sources["eject_models"] === "object") {
			this.sockets.inputs["eject_models"].connectTo(sources["eject_models"])
		} else {
			this.sockets.inputs["eject_models"].value = sources["eject_models"]
		}
		}

	}
}

type CheckpointLoaderSimpleDisTorch2MultiGPUInputs = {
			/** The name of the checkpoint (model) to load.*/
			"ckpt_name": ComfyNodeTypedInputRef<string>
			"compute_device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"donor_device"?: ComfyNodeTypedInputRef<string>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
			"eject_models"?: ComfyNodeTypedInputRef<boolean>
}


export class ControlNetLoaderDisTorch2MultiGPU extends ComfyNode {
	classType: string = "ControlNetLoaderDisTorch2MultiGPU"

	sockets: {
		inputs: Required<ControlNetLoaderDisTorch2MultiGPUInputs>
		outputs: {
			CONTROL_NET: ComfyNodeTypedSourceRef<ComfyValueType_CONTROL_NET>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"control_net_name": new ComfyNodeTypedInputRef<void>(this, "control_net_name"),
				"compute_device": new ComfyNodeTypedInputRef<string>(this, "compute_device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"donor_device": new ComfyNodeTypedInputRef<string>(this, "donor_device"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
				"eject_models": new ComfyNodeTypedInputRef<boolean>(this, "eject_models"),
			},
			outputs: Object.create(Object.prototype, {
				"CONTROL_NET": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<ControlNetLoaderDisTorch2MultiGPUInputs>) {
		if (typeof sources["control_net_name"] === "object") {
			this.sockets.inputs["control_net_name"].connectTo(sources["control_net_name"])
		} else {
			this.sockets.inputs["control_net_name"].value = sources["control_net_name"]
		}

		if (sources["compute_device"] !== undefined) {
		if (typeof sources["compute_device"] === "object") {
			this.sockets.inputs["compute_device"].connectTo(sources["compute_device"])
		} else {
			this.sockets.inputs["compute_device"].value = sources["compute_device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["donor_device"] !== undefined) {
		if (typeof sources["donor_device"] === "object") {
			this.sockets.inputs["donor_device"].connectTo(sources["donor_device"])
		} else {
			this.sockets.inputs["donor_device"].value = sources["donor_device"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

		if (sources["eject_models"] !== undefined) {
		if (typeof sources["eject_models"] === "object") {
			this.sockets.inputs["eject_models"].connectTo(sources["eject_models"])
		} else {
			this.sockets.inputs["eject_models"].value = sources["eject_models"]
		}
		}

	}
}

type ControlNetLoaderDisTorch2MultiGPUInputs = {
			"control_net_name": ComfyNodeTypedInputRef<void>
			"compute_device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"donor_device"?: ComfyNodeTypedInputRef<string>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
			"eject_models"?: ComfyNodeTypedInputRef<boolean>
}


export class DiffusersLoaderDisTorch2MultiGPU extends ComfyNode {
	classType: string = "DiffusersLoaderDisTorch2MultiGPU"

	sockets: {
		inputs: Required<DiffusersLoaderDisTorch2MultiGPUInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
			VAE: ComfyNodeTypedSourceRef<ComfyValueType_VAE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_path": new ComfyNodeTypedInputRef<void>(this, "model_path"),
				"compute_device": new ComfyNodeTypedInputRef<string>(this, "compute_device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"donor_device": new ComfyNodeTypedInputRef<string>(this, "donor_device"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
				"eject_models": new ComfyNodeTypedInputRef<boolean>(this, "eject_models"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"VAE": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DiffusersLoaderDisTorch2MultiGPUInputs>) {
		if (typeof sources["model_path"] === "object") {
			this.sockets.inputs["model_path"].connectTo(sources["model_path"])
		} else {
			this.sockets.inputs["model_path"].value = sources["model_path"]
		}

		if (sources["compute_device"] !== undefined) {
		if (typeof sources["compute_device"] === "object") {
			this.sockets.inputs["compute_device"].connectTo(sources["compute_device"])
		} else {
			this.sockets.inputs["compute_device"].value = sources["compute_device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["donor_device"] !== undefined) {
		if (typeof sources["donor_device"] === "object") {
			this.sockets.inputs["donor_device"].connectTo(sources["donor_device"])
		} else {
			this.sockets.inputs["donor_device"].value = sources["donor_device"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

		if (sources["eject_models"] !== undefined) {
		if (typeof sources["eject_models"] === "object") {
			this.sockets.inputs["eject_models"].connectTo(sources["eject_models"])
		} else {
			this.sockets.inputs["eject_models"].value = sources["eject_models"]
		}
		}

	}
}

type DiffusersLoaderDisTorch2MultiGPUInputs = {
			"model_path": ComfyNodeTypedInputRef<void>
			"compute_device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"donor_device"?: ComfyNodeTypedInputRef<string>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
			"eject_models"?: ComfyNodeTypedInputRef<boolean>
}


export class DiffControlNetLoaderDisTorch2MultiGPU extends ComfyNode {
	classType: string = "DiffControlNetLoaderDisTorch2MultiGPU"

	sockets: {
		inputs: Required<DiffControlNetLoaderDisTorch2MultiGPUInputs>
		outputs: {
			CONTROL_NET: ComfyNodeTypedSourceRef<ComfyValueType_CONTROL_NET>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_MODEL>(this, "model"),
				"control_net_name": new ComfyNodeTypedInputRef<void>(this, "control_net_name"),
				"compute_device": new ComfyNodeTypedInputRef<string>(this, "compute_device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"donor_device": new ComfyNodeTypedInputRef<string>(this, "donor_device"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
				"eject_models": new ComfyNodeTypedInputRef<boolean>(this, "eject_models"),
			},
			outputs: Object.create(Object.prototype, {
				"CONTROL_NET": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DiffControlNetLoaderDisTorch2MultiGPUInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["control_net_name"] === "object") {
			this.sockets.inputs["control_net_name"].connectTo(sources["control_net_name"])
		} else {
			this.sockets.inputs["control_net_name"].value = sources["control_net_name"]
		}

		if (sources["compute_device"] !== undefined) {
		if (typeof sources["compute_device"] === "object") {
			this.sockets.inputs["compute_device"].connectTo(sources["compute_device"])
		} else {
			this.sockets.inputs["compute_device"].value = sources["compute_device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["donor_device"] !== undefined) {
		if (typeof sources["donor_device"] === "object") {
			this.sockets.inputs["donor_device"].connectTo(sources["donor_device"])
		} else {
			this.sockets.inputs["donor_device"].value = sources["donor_device"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

		if (sources["eject_models"] !== undefined) {
		if (typeof sources["eject_models"] === "object") {
			this.sockets.inputs["eject_models"].connectTo(sources["eject_models"])
		} else {
			this.sockets.inputs["eject_models"].value = sources["eject_models"]
		}
		}

	}
}

type DiffControlNetLoaderDisTorch2MultiGPUInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_MODEL>
			"control_net_name": ComfyNodeTypedInputRef<void>
			"compute_device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"donor_device"?: ComfyNodeTypedInputRef<string>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
			"eject_models"?: ComfyNodeTypedInputRef<boolean>
}


export class UnetLoaderGGUFDisTorchMultiGPU extends ComfyNode {
	classType: string = "UnetLoaderGGUFDisTorchMultiGPU"

	sockets: {
		inputs: Required<UnetLoaderGGUFDisTorchMultiGPUInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"unet_name": new ComfyNodeTypedInputRef<string>(this, "unet_name"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"use_other_vram": new ComfyNodeTypedInputRef<boolean>(this, "use_other_vram"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<UnetLoaderGGUFDisTorchMultiGPUInputs>) {
		if (typeof sources["unet_name"] === "object") {
			this.sockets.inputs["unet_name"].connectTo(sources["unet_name"])
		} else {
			this.sockets.inputs["unet_name"].value = sources["unet_name"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["use_other_vram"] !== undefined) {
		if (typeof sources["use_other_vram"] === "object") {
			this.sockets.inputs["use_other_vram"].connectTo(sources["use_other_vram"])
		} else {
			this.sockets.inputs["use_other_vram"].value = sources["use_other_vram"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

	}
}

type UnetLoaderGGUFDisTorchMultiGPUInputs = {
			"unet_name": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"use_other_vram"?: ComfyNodeTypedInputRef<boolean>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
}


export class UnetLoaderGGUFAdvancedDisTorchMultiGPU extends ComfyNode {
	classType: string = "UnetLoaderGGUFAdvancedDisTorchMultiGPU"

	sockets: {
		inputs: Required<UnetLoaderGGUFAdvancedDisTorchMultiGPUInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"unet_name": new ComfyNodeTypedInputRef<string>(this, "unet_name"),
				"dequant_dtype": new ComfyNodeTypedInputRef<string>(this, "dequant_dtype"),
				"patch_dtype": new ComfyNodeTypedInputRef<string>(this, "patch_dtype"),
				"patch_on_device": new ComfyNodeTypedInputRef<boolean>(this, "patch_on_device"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"use_other_vram": new ComfyNodeTypedInputRef<boolean>(this, "use_other_vram"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<UnetLoaderGGUFAdvancedDisTorchMultiGPUInputs>) {
		if (typeof sources["unet_name"] === "object") {
			this.sockets.inputs["unet_name"].connectTo(sources["unet_name"])
		} else {
			this.sockets.inputs["unet_name"].value = sources["unet_name"]
		}

		if (typeof sources["dequant_dtype"] === "object") {
			this.sockets.inputs["dequant_dtype"].connectTo(sources["dequant_dtype"])
		} else {
			this.sockets.inputs["dequant_dtype"].value = sources["dequant_dtype"]
		}

		if (typeof sources["patch_dtype"] === "object") {
			this.sockets.inputs["patch_dtype"].connectTo(sources["patch_dtype"])
		} else {
			this.sockets.inputs["patch_dtype"].value = sources["patch_dtype"]
		}

		if (typeof sources["patch_on_device"] === "object") {
			this.sockets.inputs["patch_on_device"].connectTo(sources["patch_on_device"])
		} else {
			this.sockets.inputs["patch_on_device"].value = sources["patch_on_device"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["use_other_vram"] !== undefined) {
		if (typeof sources["use_other_vram"] === "object") {
			this.sockets.inputs["use_other_vram"].connectTo(sources["use_other_vram"])
		} else {
			this.sockets.inputs["use_other_vram"].value = sources["use_other_vram"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

	}
}

type UnetLoaderGGUFAdvancedDisTorchMultiGPUInputs = {
			"unet_name": ComfyNodeTypedInputRef<string>
			"dequant_dtype": ComfyNodeTypedInputRef<string>
			"patch_dtype": ComfyNodeTypedInputRef<string>
			"patch_on_device": ComfyNodeTypedInputRef<boolean>
			"device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"use_other_vram"?: ComfyNodeTypedInputRef<boolean>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
}


export class CLIPLoaderGGUFDisTorchMultiGPU extends ComfyNode {
	classType: string = "CLIPLoaderGGUFDisTorchMultiGPU"

	sockets: {
		inputs: Required<CLIPLoaderGGUFDisTorchMultiGPUInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name": new ComfyNodeTypedInputRef<string>(this, "clip_name"),
				"type": new ComfyNodeTypedInputRef<string>(this, "type"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"use_other_vram": new ComfyNodeTypedInputRef<boolean>(this, "use_other_vram"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPLoaderGGUFDisTorchMultiGPUInputs>) {
		if (typeof sources["clip_name"] === "object") {
			this.sockets.inputs["clip_name"].connectTo(sources["clip_name"])
		} else {
			this.sockets.inputs["clip_name"].value = sources["clip_name"]
		}

		if (typeof sources["type"] === "object") {
			this.sockets.inputs["type"].connectTo(sources["type"])
		} else {
			this.sockets.inputs["type"].value = sources["type"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["use_other_vram"] !== undefined) {
		if (typeof sources["use_other_vram"] === "object") {
			this.sockets.inputs["use_other_vram"].connectTo(sources["use_other_vram"])
		} else {
			this.sockets.inputs["use_other_vram"].value = sources["use_other_vram"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

	}
}

type CLIPLoaderGGUFDisTorchMultiGPUInputs = {
			"clip_name": ComfyNodeTypedInputRef<string>
			"type": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"use_other_vram"?: ComfyNodeTypedInputRef<boolean>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
}


export class DualCLIPLoaderGGUFDisTorchMultiGPU extends ComfyNode {
	classType: string = "DualCLIPLoaderGGUFDisTorchMultiGPU"

	sockets: {
		inputs: Required<DualCLIPLoaderGGUFDisTorchMultiGPUInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<string>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<string>(this, "clip_name2"),
				"type": new ComfyNodeTypedInputRef<string>(this, "type"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"use_other_vram": new ComfyNodeTypedInputRef<boolean>(this, "use_other_vram"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DualCLIPLoaderGGUFDisTorchMultiGPUInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["type"] === "object") {
			this.sockets.inputs["type"].connectTo(sources["type"])
		} else {
			this.sockets.inputs["type"].value = sources["type"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["use_other_vram"] !== undefined) {
		if (typeof sources["use_other_vram"] === "object") {
			this.sockets.inputs["use_other_vram"].connectTo(sources["use_other_vram"])
		} else {
			this.sockets.inputs["use_other_vram"].value = sources["use_other_vram"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

	}
}

type DualCLIPLoaderGGUFDisTorchMultiGPUInputs = {
			"clip_name1": ComfyNodeTypedInputRef<string>
			"clip_name2": ComfyNodeTypedInputRef<string>
			"type": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"use_other_vram"?: ComfyNodeTypedInputRef<boolean>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
}


export class TripleCLIPLoaderGGUFDisTorchMultiGPU extends ComfyNode {
	classType: string = "TripleCLIPLoaderGGUFDisTorchMultiGPU"

	sockets: {
		inputs: Required<TripleCLIPLoaderGGUFDisTorchMultiGPUInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<string>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<string>(this, "clip_name2"),
				"clip_name3": new ComfyNodeTypedInputRef<string>(this, "clip_name3"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"use_other_vram": new ComfyNodeTypedInputRef<boolean>(this, "use_other_vram"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TripleCLIPLoaderGGUFDisTorchMultiGPUInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["clip_name3"] === "object") {
			this.sockets.inputs["clip_name3"].connectTo(sources["clip_name3"])
		} else {
			this.sockets.inputs["clip_name3"].value = sources["clip_name3"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["use_other_vram"] !== undefined) {
		if (typeof sources["use_other_vram"] === "object") {
			this.sockets.inputs["use_other_vram"].connectTo(sources["use_other_vram"])
		} else {
			this.sockets.inputs["use_other_vram"].value = sources["use_other_vram"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

	}
}

type TripleCLIPLoaderGGUFDisTorchMultiGPUInputs = {
			"clip_name1": ComfyNodeTypedInputRef<string>
			"clip_name2": ComfyNodeTypedInputRef<string>
			"clip_name3": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"use_other_vram"?: ComfyNodeTypedInputRef<boolean>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
}


export class QuadrupleCLIPLoaderGGUFDisTorchMultiGPU extends ComfyNode {
	classType: string = "QuadrupleCLIPLoaderGGUFDisTorchMultiGPU"

	sockets: {
		inputs: Required<QuadrupleCLIPLoaderGGUFDisTorchMultiGPUInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<string>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<string>(this, "clip_name2"),
				"clip_name3": new ComfyNodeTypedInputRef<string>(this, "clip_name3"),
				"clip_name4": new ComfyNodeTypedInputRef<string>(this, "clip_name4"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"use_other_vram": new ComfyNodeTypedInputRef<boolean>(this, "use_other_vram"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<QuadrupleCLIPLoaderGGUFDisTorchMultiGPUInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["clip_name3"] === "object") {
			this.sockets.inputs["clip_name3"].connectTo(sources["clip_name3"])
		} else {
			this.sockets.inputs["clip_name3"].value = sources["clip_name3"]
		}

		if (typeof sources["clip_name4"] === "object") {
			this.sockets.inputs["clip_name4"].connectTo(sources["clip_name4"])
		} else {
			this.sockets.inputs["clip_name4"].value = sources["clip_name4"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["use_other_vram"] !== undefined) {
		if (typeof sources["use_other_vram"] === "object") {
			this.sockets.inputs["use_other_vram"].connectTo(sources["use_other_vram"])
		} else {
			this.sockets.inputs["use_other_vram"].value = sources["use_other_vram"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

	}
}

type QuadrupleCLIPLoaderGGUFDisTorchMultiGPUInputs = {
			"clip_name1": ComfyNodeTypedInputRef<string>
			"clip_name2": ComfyNodeTypedInputRef<string>
			"clip_name3": ComfyNodeTypedInputRef<string>
			"clip_name4": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"use_other_vram"?: ComfyNodeTypedInputRef<boolean>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
}


export class UnetLoaderGGUFDisTorch2MultiGPU extends ComfyNode {
	classType: string = "UnetLoaderGGUFDisTorch2MultiGPU"

	sockets: {
		inputs: Required<UnetLoaderGGUFDisTorch2MultiGPUInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"unet_name": new ComfyNodeTypedInputRef<string>(this, "unet_name"),
				"compute_device": new ComfyNodeTypedInputRef<string>(this, "compute_device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"donor_device": new ComfyNodeTypedInputRef<string>(this, "donor_device"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
				"eject_models": new ComfyNodeTypedInputRef<boolean>(this, "eject_models"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<UnetLoaderGGUFDisTorch2MultiGPUInputs>) {
		if (typeof sources["unet_name"] === "object") {
			this.sockets.inputs["unet_name"].connectTo(sources["unet_name"])
		} else {
			this.sockets.inputs["unet_name"].value = sources["unet_name"]
		}

		if (sources["compute_device"] !== undefined) {
		if (typeof sources["compute_device"] === "object") {
			this.sockets.inputs["compute_device"].connectTo(sources["compute_device"])
		} else {
			this.sockets.inputs["compute_device"].value = sources["compute_device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["donor_device"] !== undefined) {
		if (typeof sources["donor_device"] === "object") {
			this.sockets.inputs["donor_device"].connectTo(sources["donor_device"])
		} else {
			this.sockets.inputs["donor_device"].value = sources["donor_device"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

		if (sources["eject_models"] !== undefined) {
		if (typeof sources["eject_models"] === "object") {
			this.sockets.inputs["eject_models"].connectTo(sources["eject_models"])
		} else {
			this.sockets.inputs["eject_models"].value = sources["eject_models"]
		}
		}

	}
}

type UnetLoaderGGUFDisTorch2MultiGPUInputs = {
			"unet_name": ComfyNodeTypedInputRef<string>
			"compute_device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"donor_device"?: ComfyNodeTypedInputRef<string>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
			"eject_models"?: ComfyNodeTypedInputRef<boolean>
}


export class UnetLoaderGGUFAdvancedDisTorch2MultiGPU extends ComfyNode {
	classType: string = "UnetLoaderGGUFAdvancedDisTorch2MultiGPU"

	sockets: {
		inputs: Required<UnetLoaderGGUFAdvancedDisTorch2MultiGPUInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"unet_name": new ComfyNodeTypedInputRef<string>(this, "unet_name"),
				"dequant_dtype": new ComfyNodeTypedInputRef<string>(this, "dequant_dtype"),
				"patch_dtype": new ComfyNodeTypedInputRef<string>(this, "patch_dtype"),
				"patch_on_device": new ComfyNodeTypedInputRef<boolean>(this, "patch_on_device"),
				"compute_device": new ComfyNodeTypedInputRef<string>(this, "compute_device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"donor_device": new ComfyNodeTypedInputRef<string>(this, "donor_device"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
				"eject_models": new ComfyNodeTypedInputRef<boolean>(this, "eject_models"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<UnetLoaderGGUFAdvancedDisTorch2MultiGPUInputs>) {
		if (typeof sources["unet_name"] === "object") {
			this.sockets.inputs["unet_name"].connectTo(sources["unet_name"])
		} else {
			this.sockets.inputs["unet_name"].value = sources["unet_name"]
		}

		if (typeof sources["dequant_dtype"] === "object") {
			this.sockets.inputs["dequant_dtype"].connectTo(sources["dequant_dtype"])
		} else {
			this.sockets.inputs["dequant_dtype"].value = sources["dequant_dtype"]
		}

		if (typeof sources["patch_dtype"] === "object") {
			this.sockets.inputs["patch_dtype"].connectTo(sources["patch_dtype"])
		} else {
			this.sockets.inputs["patch_dtype"].value = sources["patch_dtype"]
		}

		if (typeof sources["patch_on_device"] === "object") {
			this.sockets.inputs["patch_on_device"].connectTo(sources["patch_on_device"])
		} else {
			this.sockets.inputs["patch_on_device"].value = sources["patch_on_device"]
		}

		if (sources["compute_device"] !== undefined) {
		if (typeof sources["compute_device"] === "object") {
			this.sockets.inputs["compute_device"].connectTo(sources["compute_device"])
		} else {
			this.sockets.inputs["compute_device"].value = sources["compute_device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["donor_device"] !== undefined) {
		if (typeof sources["donor_device"] === "object") {
			this.sockets.inputs["donor_device"].connectTo(sources["donor_device"])
		} else {
			this.sockets.inputs["donor_device"].value = sources["donor_device"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

		if (sources["eject_models"] !== undefined) {
		if (typeof sources["eject_models"] === "object") {
			this.sockets.inputs["eject_models"].connectTo(sources["eject_models"])
		} else {
			this.sockets.inputs["eject_models"].value = sources["eject_models"]
		}
		}

	}
}

type UnetLoaderGGUFAdvancedDisTorch2MultiGPUInputs = {
			"unet_name": ComfyNodeTypedInputRef<string>
			"dequant_dtype": ComfyNodeTypedInputRef<string>
			"patch_dtype": ComfyNodeTypedInputRef<string>
			"patch_on_device": ComfyNodeTypedInputRef<boolean>
			"compute_device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"donor_device"?: ComfyNodeTypedInputRef<string>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
			"eject_models"?: ComfyNodeTypedInputRef<boolean>
}


export class CLIPLoaderGGUFDisTorch2MultiGPU extends ComfyNode {
	classType: string = "CLIPLoaderGGUFDisTorch2MultiGPU"

	sockets: {
		inputs: Required<CLIPLoaderGGUFDisTorch2MultiGPUInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name": new ComfyNodeTypedInputRef<string>(this, "clip_name"),
				"type": new ComfyNodeTypedInputRef<string>(this, "type"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"donor_device": new ComfyNodeTypedInputRef<string>(this, "donor_device"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
				"eject_models": new ComfyNodeTypedInputRef<boolean>(this, "eject_models"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPLoaderGGUFDisTorch2MultiGPUInputs>) {
		if (typeof sources["clip_name"] === "object") {
			this.sockets.inputs["clip_name"].connectTo(sources["clip_name"])
		} else {
			this.sockets.inputs["clip_name"].value = sources["clip_name"]
		}

		if (typeof sources["type"] === "object") {
			this.sockets.inputs["type"].connectTo(sources["type"])
		} else {
			this.sockets.inputs["type"].value = sources["type"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["donor_device"] !== undefined) {
		if (typeof sources["donor_device"] === "object") {
			this.sockets.inputs["donor_device"].connectTo(sources["donor_device"])
		} else {
			this.sockets.inputs["donor_device"].value = sources["donor_device"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

		if (sources["eject_models"] !== undefined) {
		if (typeof sources["eject_models"] === "object") {
			this.sockets.inputs["eject_models"].connectTo(sources["eject_models"])
		} else {
			this.sockets.inputs["eject_models"].value = sources["eject_models"]
		}
		}

	}
}

type CLIPLoaderGGUFDisTorch2MultiGPUInputs = {
			"clip_name": ComfyNodeTypedInputRef<string>
			"type": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"donor_device"?: ComfyNodeTypedInputRef<string>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
			"eject_models"?: ComfyNodeTypedInputRef<boolean>
}


export class DualCLIPLoaderGGUFDisTorch2MultiGPU extends ComfyNode {
	classType: string = "DualCLIPLoaderGGUFDisTorch2MultiGPU"

	sockets: {
		inputs: Required<DualCLIPLoaderGGUFDisTorch2MultiGPUInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<string>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<string>(this, "clip_name2"),
				"type": new ComfyNodeTypedInputRef<string>(this, "type"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"donor_device": new ComfyNodeTypedInputRef<string>(this, "donor_device"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
				"eject_models": new ComfyNodeTypedInputRef<boolean>(this, "eject_models"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DualCLIPLoaderGGUFDisTorch2MultiGPUInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["type"] === "object") {
			this.sockets.inputs["type"].connectTo(sources["type"])
		} else {
			this.sockets.inputs["type"].value = sources["type"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["donor_device"] !== undefined) {
		if (typeof sources["donor_device"] === "object") {
			this.sockets.inputs["donor_device"].connectTo(sources["donor_device"])
		} else {
			this.sockets.inputs["donor_device"].value = sources["donor_device"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

		if (sources["eject_models"] !== undefined) {
		if (typeof sources["eject_models"] === "object") {
			this.sockets.inputs["eject_models"].connectTo(sources["eject_models"])
		} else {
			this.sockets.inputs["eject_models"].value = sources["eject_models"]
		}
		}

	}
}

type DualCLIPLoaderGGUFDisTorch2MultiGPUInputs = {
			"clip_name1": ComfyNodeTypedInputRef<string>
			"clip_name2": ComfyNodeTypedInputRef<string>
			"type": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"donor_device"?: ComfyNodeTypedInputRef<string>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
			"eject_models"?: ComfyNodeTypedInputRef<boolean>
}


export class TripleCLIPLoaderGGUFDisTorch2MultiGPU extends ComfyNode {
	classType: string = "TripleCLIPLoaderGGUFDisTorch2MultiGPU"

	sockets: {
		inputs: Required<TripleCLIPLoaderGGUFDisTorch2MultiGPUInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<string>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<string>(this, "clip_name2"),
				"clip_name3": new ComfyNodeTypedInputRef<string>(this, "clip_name3"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"donor_device": new ComfyNodeTypedInputRef<string>(this, "donor_device"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
				"eject_models": new ComfyNodeTypedInputRef<boolean>(this, "eject_models"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TripleCLIPLoaderGGUFDisTorch2MultiGPUInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["clip_name3"] === "object") {
			this.sockets.inputs["clip_name3"].connectTo(sources["clip_name3"])
		} else {
			this.sockets.inputs["clip_name3"].value = sources["clip_name3"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["donor_device"] !== undefined) {
		if (typeof sources["donor_device"] === "object") {
			this.sockets.inputs["donor_device"].connectTo(sources["donor_device"])
		} else {
			this.sockets.inputs["donor_device"].value = sources["donor_device"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

		if (sources["eject_models"] !== undefined) {
		if (typeof sources["eject_models"] === "object") {
			this.sockets.inputs["eject_models"].connectTo(sources["eject_models"])
		} else {
			this.sockets.inputs["eject_models"].value = sources["eject_models"]
		}
		}

	}
}

type TripleCLIPLoaderGGUFDisTorch2MultiGPUInputs = {
			"clip_name1": ComfyNodeTypedInputRef<string>
			"clip_name2": ComfyNodeTypedInputRef<string>
			"clip_name3": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"donor_device"?: ComfyNodeTypedInputRef<string>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
			"eject_models"?: ComfyNodeTypedInputRef<boolean>
}


export class QuadrupleCLIPLoaderGGUFDisTorch2MultiGPU extends ComfyNode {
	classType: string = "QuadrupleCLIPLoaderGGUFDisTorch2MultiGPU"

	sockets: {
		inputs: Required<QuadrupleCLIPLoaderGGUFDisTorch2MultiGPUInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<string>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<string>(this, "clip_name2"),
				"clip_name3": new ComfyNodeTypedInputRef<string>(this, "clip_name3"),
				"clip_name4": new ComfyNodeTypedInputRef<string>(this, "clip_name4"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
				"virtual_vram_gb": new ComfyNodeTypedInputRef<number>(this, "virtual_vram_gb"),
				"donor_device": new ComfyNodeTypedInputRef<string>(this, "donor_device"),
				"expert_mode_allocations": new ComfyNodeTypedInputRef<string>(this, "expert_mode_allocations"),
				"eject_models": new ComfyNodeTypedInputRef<boolean>(this, "eject_models"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<QuadrupleCLIPLoaderGGUFDisTorch2MultiGPUInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["clip_name3"] === "object") {
			this.sockets.inputs["clip_name3"].connectTo(sources["clip_name3"])
		} else {
			this.sockets.inputs["clip_name3"].value = sources["clip_name3"]
		}

		if (typeof sources["clip_name4"] === "object") {
			this.sockets.inputs["clip_name4"].connectTo(sources["clip_name4"])
		} else {
			this.sockets.inputs["clip_name4"].value = sources["clip_name4"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

		if (sources["virtual_vram_gb"] !== undefined) {
		if (typeof sources["virtual_vram_gb"] === "object") {
			this.sockets.inputs["virtual_vram_gb"].connectTo(sources["virtual_vram_gb"])
		} else {
			this.sockets.inputs["virtual_vram_gb"].value = sources["virtual_vram_gb"]
		}
		}

		if (sources["donor_device"] !== undefined) {
		if (typeof sources["donor_device"] === "object") {
			this.sockets.inputs["donor_device"].connectTo(sources["donor_device"])
		} else {
			this.sockets.inputs["donor_device"].value = sources["donor_device"]
		}
		}

		if (sources["expert_mode_allocations"] !== undefined) {
		if (typeof sources["expert_mode_allocations"] === "object") {
			this.sockets.inputs["expert_mode_allocations"].connectTo(sources["expert_mode_allocations"])
		} else {
			this.sockets.inputs["expert_mode_allocations"].value = sources["expert_mode_allocations"]
		}
		}

		if (sources["eject_models"] !== undefined) {
		if (typeof sources["eject_models"] === "object") {
			this.sockets.inputs["eject_models"].connectTo(sources["eject_models"])
		} else {
			this.sockets.inputs["eject_models"].value = sources["eject_models"]
		}
		}

	}
}

type QuadrupleCLIPLoaderGGUFDisTorch2MultiGPUInputs = {
			"clip_name1": ComfyNodeTypedInputRef<string>
			"clip_name2": ComfyNodeTypedInputRef<string>
			"clip_name3": ComfyNodeTypedInputRef<string>
			"clip_name4": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
			"virtual_vram_gb"?: ComfyNodeTypedInputRef<number>
			"donor_device"?: ComfyNodeTypedInputRef<string>
			"expert_mode_allocations"?: ComfyNodeTypedInputRef<string>
			"eject_models"?: ComfyNodeTypedInputRef<boolean>
}


export class UnetLoaderGGUFMultiGPU extends ComfyNode {
	classType: string = "UnetLoaderGGUFMultiGPU"

	sockets: {
		inputs: Required<UnetLoaderGGUFMultiGPUInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"unet_name": new ComfyNodeTypedInputRef<string>(this, "unet_name"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<UnetLoaderGGUFMultiGPUInputs>) {
		if (typeof sources["unet_name"] === "object") {
			this.sockets.inputs["unet_name"].connectTo(sources["unet_name"])
		} else {
			this.sockets.inputs["unet_name"].value = sources["unet_name"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type UnetLoaderGGUFMultiGPUInputs = {
			"unet_name": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
}


export class UnetLoaderGGUFAdvancedMultiGPU extends ComfyNode {
	classType: string = "UnetLoaderGGUFAdvancedMultiGPU"

	sockets: {
		inputs: Required<UnetLoaderGGUFAdvancedMultiGPUInputs>
		outputs: {
			MODEL: ComfyNodeTypedSourceRef<ComfyValueType_MODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"unet_name": new ComfyNodeTypedInputRef<string>(this, "unet_name"),
				"dequant_dtype": new ComfyNodeTypedInputRef<string>(this, "dequant_dtype"),
				"patch_dtype": new ComfyNodeTypedInputRef<string>(this, "patch_dtype"),
				"patch_on_device": new ComfyNodeTypedInputRef<boolean>(this, "patch_on_device"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"MODEL": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<UnetLoaderGGUFAdvancedMultiGPUInputs>) {
		if (typeof sources["unet_name"] === "object") {
			this.sockets.inputs["unet_name"].connectTo(sources["unet_name"])
		} else {
			this.sockets.inputs["unet_name"].value = sources["unet_name"]
		}

		if (typeof sources["dequant_dtype"] === "object") {
			this.sockets.inputs["dequant_dtype"].connectTo(sources["dequant_dtype"])
		} else {
			this.sockets.inputs["dequant_dtype"].value = sources["dequant_dtype"]
		}

		if (typeof sources["patch_dtype"] === "object") {
			this.sockets.inputs["patch_dtype"].connectTo(sources["patch_dtype"])
		} else {
			this.sockets.inputs["patch_dtype"].value = sources["patch_dtype"]
		}

		if (typeof sources["patch_on_device"] === "object") {
			this.sockets.inputs["patch_on_device"].connectTo(sources["patch_on_device"])
		} else {
			this.sockets.inputs["patch_on_device"].value = sources["patch_on_device"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type UnetLoaderGGUFAdvancedMultiGPUInputs = {
			"unet_name": ComfyNodeTypedInputRef<string>
			"dequant_dtype": ComfyNodeTypedInputRef<string>
			"patch_dtype": ComfyNodeTypedInputRef<string>
			"patch_on_device": ComfyNodeTypedInputRef<boolean>
			"device"?: ComfyNodeTypedInputRef<string>
}


export class CLIPLoaderGGUFMultiGPU extends ComfyNode {
	classType: string = "CLIPLoaderGGUFMultiGPU"

	sockets: {
		inputs: Required<CLIPLoaderGGUFMultiGPUInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name": new ComfyNodeTypedInputRef<string>(this, "clip_name"),
				"type": new ComfyNodeTypedInputRef<string>(this, "type"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<CLIPLoaderGGUFMultiGPUInputs>) {
		if (typeof sources["clip_name"] === "object") {
			this.sockets.inputs["clip_name"].connectTo(sources["clip_name"])
		} else {
			this.sockets.inputs["clip_name"].value = sources["clip_name"]
		}

		if (typeof sources["type"] === "object") {
			this.sockets.inputs["type"].connectTo(sources["type"])
		} else {
			this.sockets.inputs["type"].value = sources["type"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type CLIPLoaderGGUFMultiGPUInputs = {
			"clip_name": ComfyNodeTypedInputRef<string>
			"type": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
}


export class DualCLIPLoaderGGUFMultiGPU extends ComfyNode {
	classType: string = "DualCLIPLoaderGGUFMultiGPU"

	sockets: {
		inputs: Required<DualCLIPLoaderGGUFMultiGPUInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<string>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<string>(this, "clip_name2"),
				"type": new ComfyNodeTypedInputRef<string>(this, "type"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DualCLIPLoaderGGUFMultiGPUInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["type"] === "object") {
			this.sockets.inputs["type"].connectTo(sources["type"])
		} else {
			this.sockets.inputs["type"].value = sources["type"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type DualCLIPLoaderGGUFMultiGPUInputs = {
			"clip_name1": ComfyNodeTypedInputRef<string>
			"clip_name2": ComfyNodeTypedInputRef<string>
			"type": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
}


export class TripleCLIPLoaderGGUFMultiGPU extends ComfyNode {
	classType: string = "TripleCLIPLoaderGGUFMultiGPU"

	sockets: {
		inputs: Required<TripleCLIPLoaderGGUFMultiGPUInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<string>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<string>(this, "clip_name2"),
				"clip_name3": new ComfyNodeTypedInputRef<string>(this, "clip_name3"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<TripleCLIPLoaderGGUFMultiGPUInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["clip_name3"] === "object") {
			this.sockets.inputs["clip_name3"].connectTo(sources["clip_name3"])
		} else {
			this.sockets.inputs["clip_name3"].value = sources["clip_name3"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type TripleCLIPLoaderGGUFMultiGPUInputs = {
			"clip_name1": ComfyNodeTypedInputRef<string>
			"clip_name2": ComfyNodeTypedInputRef<string>
			"clip_name3": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
}


export class QuadrupleCLIPLoaderGGUFMultiGPU extends ComfyNode {
	classType: string = "QuadrupleCLIPLoaderGGUFMultiGPU"

	sockets: {
		inputs: Required<QuadrupleCLIPLoaderGGUFMultiGPUInputs>
		outputs: {
			CLIP: ComfyNodeTypedSourceRef<ComfyValueType_CLIP>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_name1": new ComfyNodeTypedInputRef<string>(this, "clip_name1"),
				"clip_name2": new ComfyNodeTypedInputRef<string>(this, "clip_name2"),
				"clip_name3": new ComfyNodeTypedInputRef<string>(this, "clip_name3"),
				"clip_name4": new ComfyNodeTypedInputRef<string>(this, "clip_name4"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"CLIP": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<QuadrupleCLIPLoaderGGUFMultiGPUInputs>) {
		if (typeof sources["clip_name1"] === "object") {
			this.sockets.inputs["clip_name1"].connectTo(sources["clip_name1"])
		} else {
			this.sockets.inputs["clip_name1"].value = sources["clip_name1"]
		}

		if (typeof sources["clip_name2"] === "object") {
			this.sockets.inputs["clip_name2"].connectTo(sources["clip_name2"])
		} else {
			this.sockets.inputs["clip_name2"].value = sources["clip_name2"]
		}

		if (typeof sources["clip_name3"] === "object") {
			this.sockets.inputs["clip_name3"].connectTo(sources["clip_name3"])
		} else {
			this.sockets.inputs["clip_name3"].value = sources["clip_name3"]
		}

		if (typeof sources["clip_name4"] === "object") {
			this.sockets.inputs["clip_name4"].connectTo(sources["clip_name4"])
		} else {
			this.sockets.inputs["clip_name4"].value = sources["clip_name4"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type QuadrupleCLIPLoaderGGUFMultiGPUInputs = {
			"clip_name1": ComfyNodeTypedInputRef<string>
			"clip_name2": ComfyNodeTypedInputRef<string>
			"clip_name3": ComfyNodeTypedInputRef<string>
			"clip_name4": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
}


export class LoadWanVideoT5TextEncoderMultiGPU extends ComfyNode {
	classType: string = "LoadWanVideoT5TextEncoderMultiGPU"

	sockets: {
		inputs: Required<LoadWanVideoT5TextEncoderMultiGPUInputs>
		outputs: {
			wan_t5_model: ComfyNodeTypedSourceRef<ComfyValueType_WANTEXTENCODER>
			load_device: ComfyNodeTypedSourceRef<ComfyValueType_MULTIGPUDEVICE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_name": new ComfyNodeTypedInputRef<string>(this, "model_name"),
				"precision": new ComfyNodeTypedInputRef<string>(this, "precision"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
				"quantization": new ComfyNodeTypedInputRef<string>(this, "quantization"),
			},
			outputs: Object.create(Object.prototype, {
				"wan_t5_model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"load_device": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoadWanVideoT5TextEncoderMultiGPUInputs>) {
		if (typeof sources["model_name"] === "object") {
			this.sockets.inputs["model_name"].connectTo(sources["model_name"])
		} else {
			this.sockets.inputs["model_name"].value = sources["model_name"]
		}

		if (typeof sources["precision"] === "object") {
			this.sockets.inputs["precision"].connectTo(sources["precision"])
		} else {
			this.sockets.inputs["precision"].value = sources["precision"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

		if (sources["quantization"] !== undefined) {
		if (typeof sources["quantization"] === "object") {
			this.sockets.inputs["quantization"].connectTo(sources["quantization"])
		} else {
			this.sockets.inputs["quantization"].value = sources["quantization"]
		}
		}

	}
}

type LoadWanVideoT5TextEncoderMultiGPUInputs = {
			/** These models are loaded from 'ComfyUI/models/text_encoders'*/
			"model_name": ComfyNodeTypedInputRef<string>
			"precision": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
			/** optional quantization method*/
			"quantization"?: ComfyNodeTypedInputRef<string>
}


export class WanVideoTextEncodeMultiGPU extends ComfyNode {
	classType: string = "WanVideoTextEncodeMultiGPU"

	sockets: {
		inputs: Required<WanVideoTextEncodeMultiGPUInputs>
		outputs: {
			text_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOTEXTEMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"positive_prompt": new ComfyNodeTypedInputRef<string>(this, "positive_prompt"),
				"negative_prompt": new ComfyNodeTypedInputRef<string>(this, "negative_prompt"),
				"t5": new ComfyNodeTypedInputRef<ComfyValueType_WANTEXTENCODER>(this, "t5"),
				"load_device": new ComfyNodeTypedInputRef<ComfyValueType_MULTIGPUDEVICE>(this, "load_device"),
				"force_offload": new ComfyNodeTypedInputRef<boolean>(this, "force_offload"),
				"model_to_offload": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>(this, "model_to_offload"),
				"use_disk_cache": new ComfyNodeTypedInputRef<boolean>(this, "use_disk_cache"),
			},
			outputs: Object.create(Object.prototype, {
				"text_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoTextEncodeMultiGPUInputs>) {
		if (typeof sources["positive_prompt"] === "object") {
			this.sockets.inputs["positive_prompt"].connectTo(sources["positive_prompt"])
		} else {
			this.sockets.inputs["positive_prompt"].value = sources["positive_prompt"]
		}

		if (typeof sources["negative_prompt"] === "object") {
			this.sockets.inputs["negative_prompt"].connectTo(sources["negative_prompt"])
		} else {
			this.sockets.inputs["negative_prompt"].value = sources["negative_prompt"]
		}

		if (sources["t5"] !== undefined) {
		if (typeof sources["t5"] === "object") {
			this.sockets.inputs["t5"].connectTo(sources["t5"])
		} else {
			this.sockets.inputs["t5"].value = sources["t5"]
		}
		}

		if (sources["load_device"] !== undefined) {
		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}
		}

		if (sources["force_offload"] !== undefined) {
		if (typeof sources["force_offload"] === "object") {
			this.sockets.inputs["force_offload"].connectTo(sources["force_offload"])
		} else {
			this.sockets.inputs["force_offload"].value = sources["force_offload"]
		}
		}

		if (sources["model_to_offload"] !== undefined) {
		if (typeof sources["model_to_offload"] === "object") {
			this.sockets.inputs["model_to_offload"].connectTo(sources["model_to_offload"])
		} else {
			this.sockets.inputs["model_to_offload"].value = sources["model_to_offload"]
		}
		}

		if (sources["use_disk_cache"] !== undefined) {
		if (typeof sources["use_disk_cache"] === "object") {
			this.sockets.inputs["use_disk_cache"].connectTo(sources["use_disk_cache"])
		} else {
			this.sockets.inputs["use_disk_cache"].value = sources["use_disk_cache"]
		}
		}

	}
}

type WanVideoTextEncodeMultiGPUInputs = {
			"positive_prompt": ComfyNodeTypedInputRef<string>
			"negative_prompt": ComfyNodeTypedInputRef<string>
			"t5"?: ComfyNodeTypedInputRef<ComfyValueType_WANTEXTENCODER>
			"load_device"?: ComfyNodeTypedInputRef<ComfyValueType_MULTIGPUDEVICE>
			"force_offload"?: ComfyNodeTypedInputRef<boolean>
			/** Model to move to offload_device before encoding*/
			"model_to_offload"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>
			/** Cache the text embeddings to disk for faster re-use, under the custom_nodes/ComfyUI-WanVideoWrapper/text_embed_cache directory*/
			"use_disk_cache"?: ComfyNodeTypedInputRef<boolean>
}


export class WanVideoTextEncodeCachedMultiGPU extends ComfyNode {
	classType: string = "WanVideoTextEncodeCachedMultiGPU"

	sockets: {
		inputs: Required<WanVideoTextEncodeCachedMultiGPUInputs>
		outputs: {
			/** The text embeddings for both prompts*/
			text_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOTEXTEMBEDS>
			/** The text embeddings for the negative prompt only (for NAG)*/
			negative_text_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOTEXTEMBEDS>
			/** Positive prompt to display prompt extender results*/
			positive_prompt: ComfyNodeTypedSourceRef<string>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_name": new ComfyNodeTypedInputRef<string>(this, "model_name"),
				"precision": new ComfyNodeTypedInputRef<string>(this, "precision"),
				"positive_prompt": new ComfyNodeTypedInputRef<string>(this, "positive_prompt"),
				"negative_prompt": new ComfyNodeTypedInputRef<string>(this, "negative_prompt"),
				"quantization": new ComfyNodeTypedInputRef<string>(this, "quantization"),
				"use_disk_cache": new ComfyNodeTypedInputRef<boolean>(this, "use_disk_cache"),
				"load_device": new ComfyNodeTypedInputRef<string>(this, "load_device"),
				"extender_args": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOPROMPTEXTENDER_ARGS>(this, "extender_args"),
			},
			outputs: Object.create(Object.prototype, {
				"text_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"negative_text_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
				"positive_prompt": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 2 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoTextEncodeCachedMultiGPUInputs>) {
		if (typeof sources["model_name"] === "object") {
			this.sockets.inputs["model_name"].connectTo(sources["model_name"])
		} else {
			this.sockets.inputs["model_name"].value = sources["model_name"]
		}

		if (typeof sources["precision"] === "object") {
			this.sockets.inputs["precision"].connectTo(sources["precision"])
		} else {
			this.sockets.inputs["precision"].value = sources["precision"]
		}

		if (typeof sources["positive_prompt"] === "object") {
			this.sockets.inputs["positive_prompt"].connectTo(sources["positive_prompt"])
		} else {
			this.sockets.inputs["positive_prompt"].value = sources["positive_prompt"]
		}

		if (typeof sources["negative_prompt"] === "object") {
			this.sockets.inputs["negative_prompt"].connectTo(sources["negative_prompt"])
		} else {
			this.sockets.inputs["negative_prompt"].value = sources["negative_prompt"]
		}

		if (typeof sources["quantization"] === "object") {
			this.sockets.inputs["quantization"].connectTo(sources["quantization"])
		} else {
			this.sockets.inputs["quantization"].value = sources["quantization"]
		}

		if (typeof sources["use_disk_cache"] === "object") {
			this.sockets.inputs["use_disk_cache"].connectTo(sources["use_disk_cache"])
		} else {
			this.sockets.inputs["use_disk_cache"].value = sources["use_disk_cache"]
		}

		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}

		if (sources["extender_args"] !== undefined) {
		if (typeof sources["extender_args"] === "object") {
			this.sockets.inputs["extender_args"].connectTo(sources["extender_args"])
		} else {
			this.sockets.inputs["extender_args"].value = sources["extender_args"]
		}
		}

	}
}

type WanVideoTextEncodeCachedMultiGPUInputs = {
			/** These models are loaded from 'ComfyUI/models/text_encoders'*/
			"model_name": ComfyNodeTypedInputRef<string>
			"precision": ComfyNodeTypedInputRef<string>
			"positive_prompt": ComfyNodeTypedInputRef<string>
			"negative_prompt": ComfyNodeTypedInputRef<string>
			/** optional quantization method*/
			"quantization": ComfyNodeTypedInputRef<string>
			/** Cache the text embeddings to disk for faster re-use, under the custom_nodes/ComfyUI-WanVideoWrapper/text_embed_cache directory*/
			"use_disk_cache": ComfyNodeTypedInputRef<boolean>
			"load_device": ComfyNodeTypedInputRef<string>
			/** Use this node to extend the prompt with additional text.*/
			"extender_args"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOPROMPTEXTENDER_ARGS>
}


export class WanVideoTextEncodeSingleMultiGPU extends ComfyNode {
	classType: string = "WanVideoTextEncodeSingleMultiGPU"

	sockets: {
		inputs: Required<WanVideoTextEncodeSingleMultiGPUInputs>
		outputs: {
			text_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOTEXTEMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"prompt": new ComfyNodeTypedInputRef<string>(this, "prompt"),
				"t5": new ComfyNodeTypedInputRef<ComfyValueType_WANTEXTENCODER>(this, "t5"),
				"load_device": new ComfyNodeTypedInputRef<ComfyValueType_MULTIGPUDEVICE>(this, "load_device"),
				"force_offload": new ComfyNodeTypedInputRef<boolean>(this, "force_offload"),
				"model_to_offload": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>(this, "model_to_offload"),
				"use_disk_cache": new ComfyNodeTypedInputRef<boolean>(this, "use_disk_cache"),
			},
			outputs: Object.create(Object.prototype, {
				"text_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoTextEncodeSingleMultiGPUInputs>) {
		if (typeof sources["prompt"] === "object") {
			this.sockets.inputs["prompt"].connectTo(sources["prompt"])
		} else {
			this.sockets.inputs["prompt"].value = sources["prompt"]
		}

		if (sources["t5"] !== undefined) {
		if (typeof sources["t5"] === "object") {
			this.sockets.inputs["t5"].connectTo(sources["t5"])
		} else {
			this.sockets.inputs["t5"].value = sources["t5"]
		}
		}

		if (sources["load_device"] !== undefined) {
		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}
		}

		if (sources["force_offload"] !== undefined) {
		if (typeof sources["force_offload"] === "object") {
			this.sockets.inputs["force_offload"].connectTo(sources["force_offload"])
		} else {
			this.sockets.inputs["force_offload"].value = sources["force_offload"]
		}
		}

		if (sources["model_to_offload"] !== undefined) {
		if (typeof sources["model_to_offload"] === "object") {
			this.sockets.inputs["model_to_offload"].connectTo(sources["model_to_offload"])
		} else {
			this.sockets.inputs["model_to_offload"].value = sources["model_to_offload"]
		}
		}

		if (sources["use_disk_cache"] !== undefined) {
		if (typeof sources["use_disk_cache"] === "object") {
			this.sockets.inputs["use_disk_cache"].connectTo(sources["use_disk_cache"])
		} else {
			this.sockets.inputs["use_disk_cache"].value = sources["use_disk_cache"]
		}
		}

	}
}

type WanVideoTextEncodeSingleMultiGPUInputs = {
			"prompt": ComfyNodeTypedInputRef<string>
			"t5"?: ComfyNodeTypedInputRef<ComfyValueType_WANTEXTENCODER>
			"load_device"?: ComfyNodeTypedInputRef<ComfyValueType_MULTIGPUDEVICE>
			"force_offload"?: ComfyNodeTypedInputRef<boolean>
			/** Model to move to offload_device before encoding*/
			"model_to_offload"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>
			/** Cache the text embeddings to disk for faster re-use, under the custom_nodes/ComfyUI-WanVideoWrapper/text_embed_cache directory*/
			"use_disk_cache"?: ComfyNodeTypedInputRef<boolean>
}


export class WanVideoVAELoaderMultiGPU extends ComfyNode {
	classType: string = "WanVideoVAELoaderMultiGPU"

	sockets: {
		inputs: Required<WanVideoVAELoaderMultiGPUInputs>
		outputs: {
			vae: ComfyNodeTypedSourceRef<ComfyValueType_WANVAE>
			load_device: ComfyNodeTypedSourceRef<ComfyValueType_MULTIGPUDEVICE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_name": new ComfyNodeTypedInputRef<string>(this, "model_name"),
				"load_device": new ComfyNodeTypedInputRef<string>(this, "load_device"),
				"precision": new ComfyNodeTypedInputRef<string>(this, "precision"),
				"compile_args": new ComfyNodeTypedInputRef<ComfyValueType_WANCOMPILEARGS>(this, "compile_args"),
			},
			outputs: Object.create(Object.prototype, {
				"vae": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"load_device": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoVAELoaderMultiGPUInputs>) {
		if (typeof sources["model_name"] === "object") {
			this.sockets.inputs["model_name"].connectTo(sources["model_name"])
		} else {
			this.sockets.inputs["model_name"].value = sources["model_name"]
		}

		if (sources["load_device"] !== undefined) {
		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}
		}

		if (sources["precision"] !== undefined) {
		if (typeof sources["precision"] === "object") {
			this.sockets.inputs["precision"].connectTo(sources["precision"])
		} else {
			this.sockets.inputs["precision"].value = sources["precision"]
		}
		}

		if (sources["compile_args"] !== undefined) {
		if (typeof sources["compile_args"] === "object") {
			this.sockets.inputs["compile_args"].connectTo(sources["compile_args"])
		} else {
			this.sockets.inputs["compile_args"].value = sources["compile_args"]
		}
		}

	}
}

type WanVideoVAELoaderMultiGPUInputs = {
			/** These models are loaded from 'ComfyUI/models/vae'*/
			"model_name": ComfyNodeTypedInputRef<string>
			"load_device"?: ComfyNodeTypedInputRef<string>
			"precision"?: ComfyNodeTypedInputRef<string>
			"compile_args"?: ComfyNodeTypedInputRef<ComfyValueType_WANCOMPILEARGS>
}


export class WanVideoTinyVAELoaderMultiGPU extends ComfyNode {
	classType: string = "WanVideoTinyVAELoaderMultiGPU"

	sockets: {
		inputs: Required<WanVideoTinyVAELoaderMultiGPUInputs>
		outputs: {
			vae: ComfyNodeTypedSourceRef<ComfyValueType_WANVAE>
			load_device: ComfyNodeTypedSourceRef<ComfyValueType_MULTIGPUDEVICE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_name": new ComfyNodeTypedInputRef<void>(this, "model_name"),
				"load_device": new ComfyNodeTypedInputRef<string>(this, "load_device"),
				"precision": new ComfyNodeTypedInputRef<string>(this, "precision"),
				"parallel": new ComfyNodeTypedInputRef<boolean>(this, "parallel"),
			},
			outputs: Object.create(Object.prototype, {
				"vae": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"load_device": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoTinyVAELoaderMultiGPUInputs>) {
		if (typeof sources["model_name"] === "object") {
			this.sockets.inputs["model_name"].connectTo(sources["model_name"])
		} else {
			this.sockets.inputs["model_name"].value = sources["model_name"]
		}

		if (sources["load_device"] !== undefined) {
		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}
		}

		if (sources["precision"] !== undefined) {
		if (typeof sources["precision"] === "object") {
			this.sockets.inputs["precision"].connectTo(sources["precision"])
		} else {
			this.sockets.inputs["precision"].value = sources["precision"]
		}
		}

		if (sources["parallel"] !== undefined) {
		if (typeof sources["parallel"] === "object") {
			this.sockets.inputs["parallel"].connectTo(sources["parallel"])
		} else {
			this.sockets.inputs["parallel"].value = sources["parallel"]
		}
		}

	}
}

type WanVideoTinyVAELoaderMultiGPUInputs = {
			/** These models are loaded from 'ComfyUI/models/vae_approx'*/
			"model_name": ComfyNodeTypedInputRef<void>
			"load_device"?: ComfyNodeTypedInputRef<string>
			"precision"?: ComfyNodeTypedInputRef<string>
			/** uses more memory but is faster*/
			"parallel"?: ComfyNodeTypedInputRef<boolean>
}


export class WanVideoBlockSwapMultiGPU extends ComfyNode {
	classType: string = "WanVideoBlockSwapMultiGPU"

	sockets: {
		inputs: Required<WanVideoBlockSwapMultiGPUInputs>
		outputs: {
			block_swap_args: ComfyNodeTypedSourceRef<ComfyValueType_BLOCKSWAPARGS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"blocks_to_swap": new ComfyNodeTypedInputRef<number>(this, "blocks_to_swap"),
				"offload_img_emb": new ComfyNodeTypedInputRef<boolean>(this, "offload_img_emb"),
				"offload_txt_emb": new ComfyNodeTypedInputRef<boolean>(this, "offload_txt_emb"),
				"use_non_blocking": new ComfyNodeTypedInputRef<boolean>(this, "use_non_blocking"),
				"vace_blocks_to_swap": new ComfyNodeTypedInputRef<number>(this, "vace_blocks_to_swap"),
				"prefetch_blocks": new ComfyNodeTypedInputRef<number>(this, "prefetch_blocks"),
				"block_swap_debug": new ComfyNodeTypedInputRef<boolean>(this, "block_swap_debug"),
				"swap_device": new ComfyNodeTypedInputRef<string>(this, "swap_device"),
			},
			outputs: Object.create(Object.prototype, {
				"block_swap_args": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoBlockSwapMultiGPUInputs>) {
		if (typeof sources["blocks_to_swap"] === "object") {
			this.sockets.inputs["blocks_to_swap"].connectTo(sources["blocks_to_swap"])
		} else {
			this.sockets.inputs["blocks_to_swap"].value = sources["blocks_to_swap"]
		}

		if (typeof sources["offload_img_emb"] === "object") {
			this.sockets.inputs["offload_img_emb"].connectTo(sources["offload_img_emb"])
		} else {
			this.sockets.inputs["offload_img_emb"].value = sources["offload_img_emb"]
		}

		if (typeof sources["offload_txt_emb"] === "object") {
			this.sockets.inputs["offload_txt_emb"].connectTo(sources["offload_txt_emb"])
		} else {
			this.sockets.inputs["offload_txt_emb"].value = sources["offload_txt_emb"]
		}

		if (sources["use_non_blocking"] !== undefined) {
		if (typeof sources["use_non_blocking"] === "object") {
			this.sockets.inputs["use_non_blocking"].connectTo(sources["use_non_blocking"])
		} else {
			this.sockets.inputs["use_non_blocking"].value = sources["use_non_blocking"]
		}
		}

		if (sources["vace_blocks_to_swap"] !== undefined) {
		if (typeof sources["vace_blocks_to_swap"] === "object") {
			this.sockets.inputs["vace_blocks_to_swap"].connectTo(sources["vace_blocks_to_swap"])
		} else {
			this.sockets.inputs["vace_blocks_to_swap"].value = sources["vace_blocks_to_swap"]
		}
		}

		if (sources["prefetch_blocks"] !== undefined) {
		if (typeof sources["prefetch_blocks"] === "object") {
			this.sockets.inputs["prefetch_blocks"].connectTo(sources["prefetch_blocks"])
		} else {
			this.sockets.inputs["prefetch_blocks"].value = sources["prefetch_blocks"]
		}
		}

		if (sources["block_swap_debug"] !== undefined) {
		if (typeof sources["block_swap_debug"] === "object") {
			this.sockets.inputs["block_swap_debug"].connectTo(sources["block_swap_debug"])
		} else {
			this.sockets.inputs["block_swap_debug"].value = sources["block_swap_debug"]
		}
		}

		if (sources["swap_device"] !== undefined) {
		if (typeof sources["swap_device"] === "object") {
			this.sockets.inputs["swap_device"].connectTo(sources["swap_device"])
		} else {
			this.sockets.inputs["swap_device"].value = sources["swap_device"]
		}
		}

	}
}

type WanVideoBlockSwapMultiGPUInputs = {
			/** Number of transformer blocks to swap, the 14B model has 40, while the 1.3B and 5B models have 30 blocks. LongCat-video has 48*/
			"blocks_to_swap": ComfyNodeTypedInputRef<number>
			/** Offload img_emb to offload_device*/
			"offload_img_emb": ComfyNodeTypedInputRef<boolean>
			/** Offload time_emb to offload_device*/
			"offload_txt_emb": ComfyNodeTypedInputRef<boolean>
			/** Use non-blocking memory transfer for offloading, reserves more RAM but is faster*/
			"use_non_blocking"?: ComfyNodeTypedInputRef<boolean>
			/** Number of VACE blocks to swap, the VACE model has 15 blocks*/
			"vace_blocks_to_swap"?: ComfyNodeTypedInputRef<number>
			/** Number of blocks to prefetch ahead, can speed up processing but increases memory usage. 1 is usually enough to offset speed loss from block swapping, use the debug option to confirm it for your system*/
			"prefetch_blocks"?: ComfyNodeTypedInputRef<number>
			/** Enable debug logging for block swapping*/
			"block_swap_debug"?: ComfyNodeTypedInputRef<boolean>
			/** Device that receives swapped transformer blocks*/
			"swap_device"?: ComfyNodeTypedInputRef<string>
}


export class WanVideoImageToVideoEncodeMultiGPU extends ComfyNode {
	classType: string = "WanVideoImageToVideoEncodeMultiGPU"

	sockets: {
		inputs: Required<WanVideoImageToVideoEncodeMultiGPUInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"num_frames": new ComfyNodeTypedInputRef<number>(this, "num_frames"),
				"noise_aug_strength": new ComfyNodeTypedInputRef<number>(this, "noise_aug_strength"),
				"start_latent_strength": new ComfyNodeTypedInputRef<number>(this, "start_latent_strength"),
				"end_latent_strength": new ComfyNodeTypedInputRef<number>(this, "end_latent_strength"),
				"force_offload": new ComfyNodeTypedInputRef<boolean>(this, "force_offload"),
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_WANVAE>(this, "vae"),
				"load_device": new ComfyNodeTypedInputRef<ComfyValueType_MULTIGPUDEVICE>(this, "load_device"),
				"clip_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_CLIPEMBEDS>(this, "clip_embeds"),
				"start_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "start_image"),
				"end_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "end_image"),
				"control_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>(this, "control_embeds"),
				"fun_or_fl2v_model": new ComfyNodeTypedInputRef<boolean>(this, "fun_or_fl2v_model"),
				"temporal_mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "temporal_mask"),
				"extra_latents": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "extra_latents"),
				"tiled_vae": new ComfyNodeTypedInputRef<boolean>(this, "tiled_vae"),
				"add_cond_latents": new ComfyNodeTypedInputRef<ComfyValueType_ADD_COND_LATENTS>(this, "add_cond_latents"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoImageToVideoEncodeMultiGPUInputs>) {
		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["num_frames"] === "object") {
			this.sockets.inputs["num_frames"].connectTo(sources["num_frames"])
		} else {
			this.sockets.inputs["num_frames"].value = sources["num_frames"]
		}

		if (typeof sources["noise_aug_strength"] === "object") {
			this.sockets.inputs["noise_aug_strength"].connectTo(sources["noise_aug_strength"])
		} else {
			this.sockets.inputs["noise_aug_strength"].value = sources["noise_aug_strength"]
		}

		if (typeof sources["start_latent_strength"] === "object") {
			this.sockets.inputs["start_latent_strength"].connectTo(sources["start_latent_strength"])
		} else {
			this.sockets.inputs["start_latent_strength"].value = sources["start_latent_strength"]
		}

		if (typeof sources["end_latent_strength"] === "object") {
			this.sockets.inputs["end_latent_strength"].connectTo(sources["end_latent_strength"])
		} else {
			this.sockets.inputs["end_latent_strength"].value = sources["end_latent_strength"]
		}

		if (typeof sources["force_offload"] === "object") {
			this.sockets.inputs["force_offload"].connectTo(sources["force_offload"])
		} else {
			this.sockets.inputs["force_offload"].value = sources["force_offload"]
		}

		if (sources["vae"] !== undefined) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}
		}

		if (sources["load_device"] !== undefined) {
		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}
		}

		if (sources["clip_embeds"] !== undefined) {
		if (typeof sources["clip_embeds"] === "object") {
			this.sockets.inputs["clip_embeds"].connectTo(sources["clip_embeds"])
		} else {
			this.sockets.inputs["clip_embeds"].value = sources["clip_embeds"]
		}
		}

		if (sources["start_image"] !== undefined) {
		if (typeof sources["start_image"] === "object") {
			this.sockets.inputs["start_image"].connectTo(sources["start_image"])
		} else {
			this.sockets.inputs["start_image"].value = sources["start_image"]
		}
		}

		if (sources["end_image"] !== undefined) {
		if (typeof sources["end_image"] === "object") {
			this.sockets.inputs["end_image"].connectTo(sources["end_image"])
		} else {
			this.sockets.inputs["end_image"].value = sources["end_image"]
		}
		}

		if (sources["control_embeds"] !== undefined) {
		if (typeof sources["control_embeds"] === "object") {
			this.sockets.inputs["control_embeds"].connectTo(sources["control_embeds"])
		} else {
			this.sockets.inputs["control_embeds"].value = sources["control_embeds"]
		}
		}

		if (sources["fun_or_fl2v_model"] !== undefined) {
		if (typeof sources["fun_or_fl2v_model"] === "object") {
			this.sockets.inputs["fun_or_fl2v_model"].connectTo(sources["fun_or_fl2v_model"])
		} else {
			this.sockets.inputs["fun_or_fl2v_model"].value = sources["fun_or_fl2v_model"]
		}
		}

		if (sources["temporal_mask"] !== undefined) {
		if (typeof sources["temporal_mask"] === "object") {
			this.sockets.inputs["temporal_mask"].connectTo(sources["temporal_mask"])
		} else {
			this.sockets.inputs["temporal_mask"].value = sources["temporal_mask"]
		}
		}

		if (sources["extra_latents"] !== undefined) {
		if (typeof sources["extra_latents"] === "object") {
			this.sockets.inputs["extra_latents"].connectTo(sources["extra_latents"])
		} else {
			this.sockets.inputs["extra_latents"].value = sources["extra_latents"]
		}
		}

		if (sources["tiled_vae"] !== undefined) {
		if (typeof sources["tiled_vae"] === "object") {
			this.sockets.inputs["tiled_vae"].connectTo(sources["tiled_vae"])
		} else {
			this.sockets.inputs["tiled_vae"].value = sources["tiled_vae"]
		}
		}

		if (sources["add_cond_latents"] !== undefined) {
		if (typeof sources["add_cond_latents"] === "object") {
			this.sockets.inputs["add_cond_latents"].connectTo(sources["add_cond_latents"])
		} else {
			this.sockets.inputs["add_cond_latents"].value = sources["add_cond_latents"]
		}
		}

	}
}

type WanVideoImageToVideoEncodeMultiGPUInputs = {
			/** Width of the image to encode*/
			"width": ComfyNodeTypedInputRef<number>
			/** Height of the image to encode*/
			"height": ComfyNodeTypedInputRef<number>
			/** Number of frames to encode*/
			"num_frames": ComfyNodeTypedInputRef<number>
			/** Strength of noise augmentation, helpful for I2V where some noise can add motion and give sharper results*/
			"noise_aug_strength": ComfyNodeTypedInputRef<number>
			/** Additional latent multiplier, helpful for I2V where lower values allow for more motion*/
			"start_latent_strength": ComfyNodeTypedInputRef<number>
			/** Additional latent multiplier, helpful for I2V where lower values allow for more motion*/
			"end_latent_strength": ComfyNodeTypedInputRef<number>
			"force_offload": ComfyNodeTypedInputRef<boolean>
			"vae"?: ComfyNodeTypedInputRef<ComfyValueType_WANVAE>
			"load_device"?: ComfyNodeTypedInputRef<ComfyValueType_MULTIGPUDEVICE>
			/** Clip vision encoded image*/
			"clip_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_CLIPEMBEDS>
			/** Image to encode*/
			"start_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** end frame*/
			"end_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Control signal for the Fun -model*/
			"control_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			/** Enable when using official FLF2V or Fun model*/
			"fun_or_fl2v_model"?: ComfyNodeTypedInputRef<boolean>
			/** mask*/
			"temporal_mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
			/** Extra latents to add to the input front, used for Skyreels A2 reference images*/
			"extra_latents"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** Use tiled VAE encoding for reduced memory use*/
			"tiled_vae"?: ComfyNodeTypedInputRef<boolean>
			/** Additional cond latents WIP*/
			"add_cond_latents"?: ComfyNodeTypedInputRef<ComfyValueType_ADD_COND_LATENTS>
}


export class WanVideoDecodeMultiGPU extends ComfyNode {
	classType: string = "WanVideoDecodeMultiGPU"

	sockets: {
		inputs: Required<WanVideoDecodeMultiGPUInputs>
		outputs: {
			images: ComfyNodeTypedSourceRef<ComfyValueType_IMAGE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_WANVAE>(this, "vae"),
				"load_device": new ComfyNodeTypedInputRef<ComfyValueType_MULTIGPUDEVICE>(this, "load_device"),
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"enable_vae_tiling": new ComfyNodeTypedInputRef<boolean>(this, "enable_vae_tiling"),
				"tile_x": new ComfyNodeTypedInputRef<number>(this, "tile_x"),
				"tile_y": new ComfyNodeTypedInputRef<number>(this, "tile_y"),
				"tile_stride_x": new ComfyNodeTypedInputRef<number>(this, "tile_stride_x"),
				"tile_stride_y": new ComfyNodeTypedInputRef<number>(this, "tile_stride_y"),
				"normalization": new ComfyNodeTypedInputRef<string>(this, "normalization"),
			},
			outputs: Object.create(Object.prototype, {
				"images": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoDecodeMultiGPUInputs>) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}

		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}

		if (typeof sources["enable_vae_tiling"] === "object") {
			this.sockets.inputs["enable_vae_tiling"].connectTo(sources["enable_vae_tiling"])
		} else {
			this.sockets.inputs["enable_vae_tiling"].value = sources["enable_vae_tiling"]
		}

		if (typeof sources["tile_x"] === "object") {
			this.sockets.inputs["tile_x"].connectTo(sources["tile_x"])
		} else {
			this.sockets.inputs["tile_x"].value = sources["tile_x"]
		}

		if (typeof sources["tile_y"] === "object") {
			this.sockets.inputs["tile_y"].connectTo(sources["tile_y"])
		} else {
			this.sockets.inputs["tile_y"].value = sources["tile_y"]
		}

		if (typeof sources["tile_stride_x"] === "object") {
			this.sockets.inputs["tile_stride_x"].connectTo(sources["tile_stride_x"])
		} else {
			this.sockets.inputs["tile_stride_x"].value = sources["tile_stride_x"]
		}

		if (typeof sources["tile_stride_y"] === "object") {
			this.sockets.inputs["tile_stride_y"].connectTo(sources["tile_stride_y"])
		} else {
			this.sockets.inputs["tile_stride_y"].value = sources["tile_stride_y"]
		}

		if (sources["normalization"] !== undefined) {
		if (typeof sources["normalization"] === "object") {
			this.sockets.inputs["normalization"].connectTo(sources["normalization"])
		} else {
			this.sockets.inputs["normalization"].value = sources["normalization"]
		}
		}

	}
}

type WanVideoDecodeMultiGPUInputs = {
			"vae": ComfyNodeTypedInputRef<ComfyValueType_WANVAE>
			"load_device": ComfyNodeTypedInputRef<ComfyValueType_MULTIGPUDEVICE>
			"samples": ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			/** Drastically reduces memory use but will introduce seams at tile stride boundaries. The location and number of seams is dictated by the tile stride size. The visibility of seams can be controlled by increasing the tile size. Seams become less obvious at 1.5x stride and are barely noticeable at 2x stride size. Which is to say if you use a stride width of 160, the seams are barely noticeable with a tile width of 320.*/
			"enable_vae_tiling": ComfyNodeTypedInputRef<boolean>
			/** Tile width in pixels. Smaller values use less VRAM but will make seams more obvious.*/
			"tile_x": ComfyNodeTypedInputRef<number>
			/** Tile height in pixels. Smaller values use less VRAM but will make seams more obvious.*/
			"tile_y": ComfyNodeTypedInputRef<number>
			/** Tile stride width in pixels. Smaller values use less VRAM but will introduce more seams.*/
			"tile_stride_x": ComfyNodeTypedInputRef<number>
			/** Tile stride height in pixels. Smaller values use less VRAM but will introduce more seams.*/
			"tile_stride_y": ComfyNodeTypedInputRef<number>
			"normalization"?: ComfyNodeTypedInputRef<string>
}


export class WanVideoModelLoaderMultiGPU extends ComfyNode {
	classType: string = "WanVideoModelLoaderMultiGPU"

	sockets: {
		inputs: Required<WanVideoModelLoaderMultiGPUInputs>
		outputs: {
			model: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOMODEL>
			compute_device: ComfyNodeTypedSourceRef<ComfyValueType_MULTIGPUDEVICE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<string>(this, "model"),
				"base_precision": new ComfyNodeTypedInputRef<string>(this, "base_precision"),
				"quantization": new ComfyNodeTypedInputRef<string>(this, "quantization"),
				"load_device": new ComfyNodeTypedInputRef<string>(this, "load_device"),
				"compute_device": new ComfyNodeTypedInputRef<string>(this, "compute_device"),
				"attention_mode": new ComfyNodeTypedInputRef<string>(this, "attention_mode"),
				"compile_args": new ComfyNodeTypedInputRef<ComfyValueType_WANCOMPILEARGS>(this, "compile_args"),
				"block_swap_args": new ComfyNodeTypedInputRef<ComfyValueType_BLOCKSWAPARGS>(this, "block_swap_args"),
				"lora": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDLORA>(this, "lora"),
				"vram_management_args": new ComfyNodeTypedInputRef<ComfyValueType_VRAM_MANAGEMENTARGS>(this, "vram_management_args"),
				"extra_model": new ComfyNodeTypedInputRef<ComfyValueType_VACEPATH>(this, "extra_model"),
				"fantasytalking_model": new ComfyNodeTypedInputRef<ComfyValueType_FANTASYTALKINGMODEL>(this, "fantasytalking_model"),
				"multitalk_model": new ComfyNodeTypedInputRef<ComfyValueType_MULTITALKMODEL>(this, "multitalk_model"),
				"fantasyportrait_model": new ComfyNodeTypedInputRef<ComfyValueType_FANTASYPORTRAITMODEL>(this, "fantasyportrait_model"),
				"rms_norm_function": new ComfyNodeTypedInputRef<string>(this, "rms_norm_function"),
			},
			outputs: Object.create(Object.prototype, {
				"model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"compute_device": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoModelLoaderMultiGPUInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["base_precision"] === "object") {
			this.sockets.inputs["base_precision"].connectTo(sources["base_precision"])
		} else {
			this.sockets.inputs["base_precision"].value = sources["base_precision"]
		}

		if (typeof sources["quantization"] === "object") {
			this.sockets.inputs["quantization"].connectTo(sources["quantization"])
		} else {
			this.sockets.inputs["quantization"].value = sources["quantization"]
		}

		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}

		if (typeof sources["compute_device"] === "object") {
			this.sockets.inputs["compute_device"].connectTo(sources["compute_device"])
		} else {
			this.sockets.inputs["compute_device"].value = sources["compute_device"]
		}

		if (sources["attention_mode"] !== undefined) {
		if (typeof sources["attention_mode"] === "object") {
			this.sockets.inputs["attention_mode"].connectTo(sources["attention_mode"])
		} else {
			this.sockets.inputs["attention_mode"].value = sources["attention_mode"]
		}
		}

		if (sources["compile_args"] !== undefined) {
		if (typeof sources["compile_args"] === "object") {
			this.sockets.inputs["compile_args"].connectTo(sources["compile_args"])
		} else {
			this.sockets.inputs["compile_args"].value = sources["compile_args"]
		}
		}

		if (sources["block_swap_args"] !== undefined) {
		if (typeof sources["block_swap_args"] === "object") {
			this.sockets.inputs["block_swap_args"].connectTo(sources["block_swap_args"])
		} else {
			this.sockets.inputs["block_swap_args"].value = sources["block_swap_args"]
		}
		}

		if (sources["lora"] !== undefined) {
		if (typeof sources["lora"] === "object") {
			this.sockets.inputs["lora"].connectTo(sources["lora"])
		} else {
			this.sockets.inputs["lora"].value = sources["lora"]
		}
		}

		if (sources["vram_management_args"] !== undefined) {
		if (typeof sources["vram_management_args"] === "object") {
			this.sockets.inputs["vram_management_args"].connectTo(sources["vram_management_args"])
		} else {
			this.sockets.inputs["vram_management_args"].value = sources["vram_management_args"]
		}
		}

		if (sources["extra_model"] !== undefined) {
		if (typeof sources["extra_model"] === "object") {
			this.sockets.inputs["extra_model"].connectTo(sources["extra_model"])
		} else {
			this.sockets.inputs["extra_model"].value = sources["extra_model"]
		}
		}

		if (sources["fantasytalking_model"] !== undefined) {
		if (typeof sources["fantasytalking_model"] === "object") {
			this.sockets.inputs["fantasytalking_model"].connectTo(sources["fantasytalking_model"])
		} else {
			this.sockets.inputs["fantasytalking_model"].value = sources["fantasytalking_model"]
		}
		}

		if (sources["multitalk_model"] !== undefined) {
		if (typeof sources["multitalk_model"] === "object") {
			this.sockets.inputs["multitalk_model"].connectTo(sources["multitalk_model"])
		} else {
			this.sockets.inputs["multitalk_model"].value = sources["multitalk_model"]
		}
		}

		if (sources["fantasyportrait_model"] !== undefined) {
		if (typeof sources["fantasyportrait_model"] === "object") {
			this.sockets.inputs["fantasyportrait_model"].connectTo(sources["fantasyportrait_model"])
		} else {
			this.sockets.inputs["fantasyportrait_model"].value = sources["fantasyportrait_model"]
		}
		}

		if (sources["rms_norm_function"] !== undefined) {
		if (typeof sources["rms_norm_function"] === "object") {
			this.sockets.inputs["rms_norm_function"].connectTo(sources["rms_norm_function"])
		} else {
			this.sockets.inputs["rms_norm_function"].value = sources["rms_norm_function"]
		}
		}

	}
}

type WanVideoModelLoaderMultiGPUInputs = {
			/** These models are loaded from the 'ComfyUI/models/diffusion_models' -folder*/
			"model": ComfyNodeTypedInputRef<string>
			"base_precision": ComfyNodeTypedInputRef<string>
			/** Optional quantization method, 'disabled' acts as autoselect based by weights. Scaled modes only work with matching weights, _fast modes (fp8 matmul) require CUDA compute capability >= 8.9 (NVIDIA 4000 series and up), e4m3fn generally can not be torch.compiled on compute capability < 8.9 (3000 series and under)*/
			"quantization": ComfyNodeTypedInputRef<string>
			/** Initial device to load the model to, NOT recommended with the larger models unless you have 48GB+ VRAM*/
			"load_device": ComfyNodeTypedInputRef<string>
			"compute_device": ComfyNodeTypedInputRef<string>
			"attention_mode"?: ComfyNodeTypedInputRef<string>
			"compile_args"?: ComfyNodeTypedInputRef<ComfyValueType_WANCOMPILEARGS>
			"block_swap_args"?: ComfyNodeTypedInputRef<ComfyValueType_BLOCKSWAPARGS>
			"lora"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDLORA>
			/** Alternative offloading method from DiffSynth-Studio, more aggressive in reducing memory use than block swapping, but can be slower*/
			"vram_management_args"?: ComfyNodeTypedInputRef<ComfyValueType_VRAM_MANAGEMENTARGS>
			/** Extra model to add to the main model, ie. VACE or MTV Crafter*/
			"extra_model"?: ComfyNodeTypedInputRef<ComfyValueType_VACEPATH>
			/** FantasyTalking model https://github.com/Fantasy-AMAP*/
			"fantasytalking_model"?: ComfyNodeTypedInputRef<ComfyValueType_FANTASYTALKINGMODEL>
			/** Multitalk model*/
			"multitalk_model"?: ComfyNodeTypedInputRef<ComfyValueType_MULTITALKMODEL>
			/** FantasyPortrait model*/
			"fantasyportrait_model"?: ComfyNodeTypedInputRef<ComfyValueType_FANTASYPORTRAITMODEL>
			/** RMSNorm function to use, 'pytorch' is the new native torch RMSNorm, which is faster (when not using torch.compile mostly) but changes results slightly. 'default' is the original WanRMSNorm*/
			"rms_norm_function"?: ComfyNodeTypedInputRef<string>
}


export class WanVideoSamplerMultiGPU extends ComfyNode {
	classType: string = "WanVideoSamplerMultiGPU"

	sockets: {
		inputs: Required<WanVideoSamplerMultiGPUInputs>
		outputs: {
			samples: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
			denoised_samples: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>(this, "model"),
				"compute_device": new ComfyNodeTypedInputRef<ComfyValueType_MULTIGPUDEVICE>(this, "compute_device"),
				"image_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>(this, "image_embeds"),
				"steps": new ComfyNodeTypedInputRef<number>(this, "steps"),
				"cfg": new ComfyNodeTypedInputRef<number>(this, "cfg"),
				"shift": new ComfyNodeTypedInputRef<number>(this, "shift"),
				"seed": new ComfyNodeTypedInputRef<number>(this, "seed"),
				"force_offload": new ComfyNodeTypedInputRef<boolean>(this, "force_offload"),
				"scheduler": new ComfyNodeTypedInputRef<string>(this, "scheduler"),
				"riflex_freq_index": new ComfyNodeTypedInputRef<number>(this, "riflex_freq_index"),
				"text_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOTEXTEMBEDS>(this, "text_embeds"),
				"samples": new ComfyNodeTypedInputRef<ComfyValueType_LATENT>(this, "samples"),
				"denoise_strength": new ComfyNodeTypedInputRef<number>(this, "denoise_strength"),
				"feta_args": new ComfyNodeTypedInputRef<ComfyValueType_FETAARGS>(this, "feta_args"),
				"context_options": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDCONTEXT>(this, "context_options"),
				"cache_args": new ComfyNodeTypedInputRef<ComfyValueType_CACHEARGS>(this, "cache_args"),
				"flowedit_args": new ComfyNodeTypedInputRef<ComfyValueType_FLOWEDITARGS>(this, "flowedit_args"),
				"batched_cfg": new ComfyNodeTypedInputRef<boolean>(this, "batched_cfg"),
				"slg_args": new ComfyNodeTypedInputRef<ComfyValueType_SLGARGS>(this, "slg_args"),
				"rope_function": new ComfyNodeTypedInputRef<string>(this, "rope_function"),
				"loop_args": new ComfyNodeTypedInputRef<ComfyValueType_LOOPARGS>(this, "loop_args"),
				"experimental_args": new ComfyNodeTypedInputRef<ComfyValueType_EXPERIMENTALARGS>(this, "experimental_args"),
				"sigmas": new ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>(this, "sigmas"),
				"unianimate_poses": new ComfyNodeTypedInputRef<ComfyValueType_UNIANIMATE_POSE>(this, "unianimate_poses"),
				"fantasytalking_embeds": new ComfyNodeTypedInputRef<ComfyValueType_FANTASYTALKING_EMBEDS>(this, "fantasytalking_embeds"),
				"uni3c_embeds": new ComfyNodeTypedInputRef<ComfyValueType_UNI3C_EMBEDS>(this, "uni3c_embeds"),
				"multitalk_embeds": new ComfyNodeTypedInputRef<ComfyValueType_MULTITALK_EMBEDS>(this, "multitalk_embeds"),
				"freeinit_args": new ComfyNodeTypedInputRef<ComfyValueType_FREEINITARGS>(this, "freeinit_args"),
				"start_step": new ComfyNodeTypedInputRef<number>(this, "start_step"),
				"end_step": new ComfyNodeTypedInputRef<number>(this, "end_step"),
				"add_noise_to_samples": new ComfyNodeTypedInputRef<boolean>(this, "add_noise_to_samples"),
			},
			outputs: Object.create(Object.prototype, {
				"samples": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"denoised_samples": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoSamplerMultiGPUInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["compute_device"] === "object") {
			this.sockets.inputs["compute_device"].connectTo(sources["compute_device"])
		} else {
			this.sockets.inputs["compute_device"].value = sources["compute_device"]
		}

		if (typeof sources["image_embeds"] === "object") {
			this.sockets.inputs["image_embeds"].connectTo(sources["image_embeds"])
		} else {
			this.sockets.inputs["image_embeds"].value = sources["image_embeds"]
		}

		if (typeof sources["steps"] === "object") {
			this.sockets.inputs["steps"].connectTo(sources["steps"])
		} else {
			this.sockets.inputs["steps"].value = sources["steps"]
		}

		if (typeof sources["cfg"] === "object") {
			this.sockets.inputs["cfg"].connectTo(sources["cfg"])
		} else {
			this.sockets.inputs["cfg"].value = sources["cfg"]
		}

		if (typeof sources["shift"] === "object") {
			this.sockets.inputs["shift"].connectTo(sources["shift"])
		} else {
			this.sockets.inputs["shift"].value = sources["shift"]
		}

		if (typeof sources["seed"] === "object") {
			this.sockets.inputs["seed"].connectTo(sources["seed"])
		} else {
			this.sockets.inputs["seed"].value = sources["seed"]
		}

		if (typeof sources["force_offload"] === "object") {
			this.sockets.inputs["force_offload"].connectTo(sources["force_offload"])
		} else {
			this.sockets.inputs["force_offload"].value = sources["force_offload"]
		}

		if (typeof sources["scheduler"] === "object") {
			this.sockets.inputs["scheduler"].connectTo(sources["scheduler"])
		} else {
			this.sockets.inputs["scheduler"].value = sources["scheduler"]
		}

		if (typeof sources["riflex_freq_index"] === "object") {
			this.sockets.inputs["riflex_freq_index"].connectTo(sources["riflex_freq_index"])
		} else {
			this.sockets.inputs["riflex_freq_index"].value = sources["riflex_freq_index"]
		}

		if (sources["text_embeds"] !== undefined) {
		if (typeof sources["text_embeds"] === "object") {
			this.sockets.inputs["text_embeds"].connectTo(sources["text_embeds"])
		} else {
			this.sockets.inputs["text_embeds"].value = sources["text_embeds"]
		}
		}

		if (sources["samples"] !== undefined) {
		if (typeof sources["samples"] === "object") {
			this.sockets.inputs["samples"].connectTo(sources["samples"])
		} else {
			this.sockets.inputs["samples"].value = sources["samples"]
		}
		}

		if (sources["denoise_strength"] !== undefined) {
		if (typeof sources["denoise_strength"] === "object") {
			this.sockets.inputs["denoise_strength"].connectTo(sources["denoise_strength"])
		} else {
			this.sockets.inputs["denoise_strength"].value = sources["denoise_strength"]
		}
		}

		if (sources["feta_args"] !== undefined) {
		if (typeof sources["feta_args"] === "object") {
			this.sockets.inputs["feta_args"].connectTo(sources["feta_args"])
		} else {
			this.sockets.inputs["feta_args"].value = sources["feta_args"]
		}
		}

		if (sources["context_options"] !== undefined) {
		if (typeof sources["context_options"] === "object") {
			this.sockets.inputs["context_options"].connectTo(sources["context_options"])
		} else {
			this.sockets.inputs["context_options"].value = sources["context_options"]
		}
		}

		if (sources["cache_args"] !== undefined) {
		if (typeof sources["cache_args"] === "object") {
			this.sockets.inputs["cache_args"].connectTo(sources["cache_args"])
		} else {
			this.sockets.inputs["cache_args"].value = sources["cache_args"]
		}
		}

		if (sources["flowedit_args"] !== undefined) {
		if (typeof sources["flowedit_args"] === "object") {
			this.sockets.inputs["flowedit_args"].connectTo(sources["flowedit_args"])
		} else {
			this.sockets.inputs["flowedit_args"].value = sources["flowedit_args"]
		}
		}

		if (sources["batched_cfg"] !== undefined) {
		if (typeof sources["batched_cfg"] === "object") {
			this.sockets.inputs["batched_cfg"].connectTo(sources["batched_cfg"])
		} else {
			this.sockets.inputs["batched_cfg"].value = sources["batched_cfg"]
		}
		}

		if (sources["slg_args"] !== undefined) {
		if (typeof sources["slg_args"] === "object") {
			this.sockets.inputs["slg_args"].connectTo(sources["slg_args"])
		} else {
			this.sockets.inputs["slg_args"].value = sources["slg_args"]
		}
		}

		if (sources["rope_function"] !== undefined) {
		if (typeof sources["rope_function"] === "object") {
			this.sockets.inputs["rope_function"].connectTo(sources["rope_function"])
		} else {
			this.sockets.inputs["rope_function"].value = sources["rope_function"]
		}
		}

		if (sources["loop_args"] !== undefined) {
		if (typeof sources["loop_args"] === "object") {
			this.sockets.inputs["loop_args"].connectTo(sources["loop_args"])
		} else {
			this.sockets.inputs["loop_args"].value = sources["loop_args"]
		}
		}

		if (sources["experimental_args"] !== undefined) {
		if (typeof sources["experimental_args"] === "object") {
			this.sockets.inputs["experimental_args"].connectTo(sources["experimental_args"])
		} else {
			this.sockets.inputs["experimental_args"].value = sources["experimental_args"]
		}
		}

		if (sources["sigmas"] !== undefined) {
		if (typeof sources["sigmas"] === "object") {
			this.sockets.inputs["sigmas"].connectTo(sources["sigmas"])
		} else {
			this.sockets.inputs["sigmas"].value = sources["sigmas"]
		}
		}

		if (sources["unianimate_poses"] !== undefined) {
		if (typeof sources["unianimate_poses"] === "object") {
			this.sockets.inputs["unianimate_poses"].connectTo(sources["unianimate_poses"])
		} else {
			this.sockets.inputs["unianimate_poses"].value = sources["unianimate_poses"]
		}
		}

		if (sources["fantasytalking_embeds"] !== undefined) {
		if (typeof sources["fantasytalking_embeds"] === "object") {
			this.sockets.inputs["fantasytalking_embeds"].connectTo(sources["fantasytalking_embeds"])
		} else {
			this.sockets.inputs["fantasytalking_embeds"].value = sources["fantasytalking_embeds"]
		}
		}

		if (sources["uni3c_embeds"] !== undefined) {
		if (typeof sources["uni3c_embeds"] === "object") {
			this.sockets.inputs["uni3c_embeds"].connectTo(sources["uni3c_embeds"])
		} else {
			this.sockets.inputs["uni3c_embeds"].value = sources["uni3c_embeds"]
		}
		}

		if (sources["multitalk_embeds"] !== undefined) {
		if (typeof sources["multitalk_embeds"] === "object") {
			this.sockets.inputs["multitalk_embeds"].connectTo(sources["multitalk_embeds"])
		} else {
			this.sockets.inputs["multitalk_embeds"].value = sources["multitalk_embeds"]
		}
		}

		if (sources["freeinit_args"] !== undefined) {
		if (typeof sources["freeinit_args"] === "object") {
			this.sockets.inputs["freeinit_args"].connectTo(sources["freeinit_args"])
		} else {
			this.sockets.inputs["freeinit_args"].value = sources["freeinit_args"]
		}
		}

		if (sources["start_step"] !== undefined) {
		if (typeof sources["start_step"] === "object") {
			this.sockets.inputs["start_step"].connectTo(sources["start_step"])
		} else {
			this.sockets.inputs["start_step"].value = sources["start_step"]
		}
		}

		if (sources["end_step"] !== undefined) {
		if (typeof sources["end_step"] === "object") {
			this.sockets.inputs["end_step"].connectTo(sources["end_step"])
		} else {
			this.sockets.inputs["end_step"].value = sources["end_step"]
		}
		}

		if (sources["add_noise_to_samples"] !== undefined) {
		if (typeof sources["add_noise_to_samples"] === "object") {
			this.sockets.inputs["add_noise_to_samples"].connectTo(sources["add_noise_to_samples"])
		} else {
			this.sockets.inputs["add_noise_to_samples"].value = sources["add_noise_to_samples"]
		}
		}

	}
}

type WanVideoSamplerMultiGPUInputs = {
			"model": ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOMODEL>
			"compute_device": ComfyNodeTypedInputRef<ComfyValueType_MULTIGPUDEVICE>
			"image_embeds": ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			"steps": ComfyNodeTypedInputRef<number>
			"cfg": ComfyNodeTypedInputRef<number>
			"shift": ComfyNodeTypedInputRef<number>
			"seed": ComfyNodeTypedInputRef<number>
			/** Moves the model to the offload device after sampling*/
			"force_offload": ComfyNodeTypedInputRef<boolean>
			"scheduler": ComfyNodeTypedInputRef<string>
			/** Frequency index for RIFLEX, disabled when 0, default 6. Allows for new frames to be generated after without looping*/
			"riflex_freq_index": ComfyNodeTypedInputRef<number>
			"text_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDEOTEXTEMBEDS>
			/** init Latents to use for video2video process*/
			"samples"?: ComfyNodeTypedInputRef<ComfyValueType_LATENT>
			"denoise_strength"?: ComfyNodeTypedInputRef<number>
			"feta_args"?: ComfyNodeTypedInputRef<ComfyValueType_FETAARGS>
			"context_options"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDCONTEXT>
			"cache_args"?: ComfyNodeTypedInputRef<ComfyValueType_CACHEARGS>
			"flowedit_args"?: ComfyNodeTypedInputRef<ComfyValueType_FLOWEDITARGS>
			/** Batch cond and uncond for faster sampling, possibly faster on some hardware, uses more memory*/
			"batched_cfg"?: ComfyNodeTypedInputRef<boolean>
			"slg_args"?: ComfyNodeTypedInputRef<ComfyValueType_SLGARGS>
			/** Comfy's RoPE implementation doesn't use complex numbers and can thus be compiled, that should be a lot faster when using torch.compile. Chunked version has reduced peak VRAM usage when not using torch.compile*/
			"rope_function"?: ComfyNodeTypedInputRef<string>
			"loop_args"?: ComfyNodeTypedInputRef<ComfyValueType_LOOPARGS>
			"experimental_args"?: ComfyNodeTypedInputRef<ComfyValueType_EXPERIMENTALARGS>
			"sigmas"?: ComfyNodeTypedInputRef<ComfyValueType_SIGMAS>
			"unianimate_poses"?: ComfyNodeTypedInputRef<ComfyValueType_UNIANIMATE_POSE>
			"fantasytalking_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_FANTASYTALKING_EMBEDS>
			"uni3c_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_UNI3C_EMBEDS>
			"multitalk_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_MULTITALK_EMBEDS>
			"freeinit_args"?: ComfyNodeTypedInputRef<ComfyValueType_FREEINITARGS>
			/** Start step for the sampling, 0 means full sampling, otherwise samples only from this step*/
			"start_step"?: ComfyNodeTypedInputRef<number>
			/** End step for the sampling, -1 means full sampling, otherwise samples only until this step*/
			"end_step"?: ComfyNodeTypedInputRef<number>
			/** Add noise to the samples before sampling, needed for video2video sampling when starting from clean video*/
			"add_noise_to_samples"?: ComfyNodeTypedInputRef<boolean>
}


export class WanVideoVACEEncodeMultiGPU extends ComfyNode {
	classType: string = "WanVideoVACEEncodeMultiGPU"

	sockets: {
		inputs: Required<WanVideoVACEEncodeMultiGPUInputs>
		outputs: {
			vace_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_WANVAE>(this, "vae"),
				"load_device": new ComfyNodeTypedInputRef<ComfyValueType_MULTIGPUDEVICE>(this, "load_device"),
				"width": new ComfyNodeTypedInputRef<number>(this, "width"),
				"height": new ComfyNodeTypedInputRef<number>(this, "height"),
				"num_frames": new ComfyNodeTypedInputRef<number>(this, "num_frames"),
				"strength": new ComfyNodeTypedInputRef<number>(this, "strength"),
				"vace_start_percent": new ComfyNodeTypedInputRef<number>(this, "vace_start_percent"),
				"vace_end_percent": new ComfyNodeTypedInputRef<number>(this, "vace_end_percent"),
				"input_frames": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "input_frames"),
				"ref_images": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "ref_images"),
				"input_masks": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "input_masks"),
				"prev_vace_embeds": new ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>(this, "prev_vace_embeds"),
				"tiled_vae": new ComfyNodeTypedInputRef<boolean>(this, "tiled_vae"),
			},
			outputs: Object.create(Object.prototype, {
				"vace_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoVACEEncodeMultiGPUInputs>) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}

		if (typeof sources["width"] === "object") {
			this.sockets.inputs["width"].connectTo(sources["width"])
		} else {
			this.sockets.inputs["width"].value = sources["width"]
		}

		if (typeof sources["height"] === "object") {
			this.sockets.inputs["height"].connectTo(sources["height"])
		} else {
			this.sockets.inputs["height"].value = sources["height"]
		}

		if (typeof sources["num_frames"] === "object") {
			this.sockets.inputs["num_frames"].connectTo(sources["num_frames"])
		} else {
			this.sockets.inputs["num_frames"].value = sources["num_frames"]
		}

		if (typeof sources["strength"] === "object") {
			this.sockets.inputs["strength"].connectTo(sources["strength"])
		} else {
			this.sockets.inputs["strength"].value = sources["strength"]
		}

		if (typeof sources["vace_start_percent"] === "object") {
			this.sockets.inputs["vace_start_percent"].connectTo(sources["vace_start_percent"])
		} else {
			this.sockets.inputs["vace_start_percent"].value = sources["vace_start_percent"]
		}

		if (typeof sources["vace_end_percent"] === "object") {
			this.sockets.inputs["vace_end_percent"].connectTo(sources["vace_end_percent"])
		} else {
			this.sockets.inputs["vace_end_percent"].value = sources["vace_end_percent"]
		}

		if (sources["input_frames"] !== undefined) {
		if (typeof sources["input_frames"] === "object") {
			this.sockets.inputs["input_frames"].connectTo(sources["input_frames"])
		} else {
			this.sockets.inputs["input_frames"].value = sources["input_frames"]
		}
		}

		if (sources["ref_images"] !== undefined) {
		if (typeof sources["ref_images"] === "object") {
			this.sockets.inputs["ref_images"].connectTo(sources["ref_images"])
		} else {
			this.sockets.inputs["ref_images"].value = sources["ref_images"]
		}
		}

		if (sources["input_masks"] !== undefined) {
		if (typeof sources["input_masks"] === "object") {
			this.sockets.inputs["input_masks"].connectTo(sources["input_masks"])
		} else {
			this.sockets.inputs["input_masks"].value = sources["input_masks"]
		}
		}

		if (sources["prev_vace_embeds"] !== undefined) {
		if (typeof sources["prev_vace_embeds"] === "object") {
			this.sockets.inputs["prev_vace_embeds"].connectTo(sources["prev_vace_embeds"])
		} else {
			this.sockets.inputs["prev_vace_embeds"].value = sources["prev_vace_embeds"]
		}
		}

		if (sources["tiled_vae"] !== undefined) {
		if (typeof sources["tiled_vae"] === "object") {
			this.sockets.inputs["tiled_vae"].connectTo(sources["tiled_vae"])
		} else {
			this.sockets.inputs["tiled_vae"].value = sources["tiled_vae"]
		}
		}

	}
}

type WanVideoVACEEncodeMultiGPUInputs = {
			"vae": ComfyNodeTypedInputRef<ComfyValueType_WANVAE>
			"load_device": ComfyNodeTypedInputRef<ComfyValueType_MULTIGPUDEVICE>
			/** Width of the image to encode*/
			"width": ComfyNodeTypedInputRef<number>
			/** Height of the image to encode*/
			"height": ComfyNodeTypedInputRef<number>
			/** Number of frames to encode*/
			"num_frames": ComfyNodeTypedInputRef<number>
			"strength": ComfyNodeTypedInputRef<number>
			/** Start percent of the steps to apply VACE*/
			"vace_start_percent": ComfyNodeTypedInputRef<number>
			/** End percent of the steps to apply VACE*/
			"vace_end_percent": ComfyNodeTypedInputRef<number>
			"input_frames"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"ref_images"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			"input_masks"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
			"prev_vace_embeds"?: ComfyNodeTypedInputRef<ComfyValueType_WANVIDIMAGE_EMBEDS>
			/** Use tiled VAE encoding for reduced memory use*/
			"tiled_vae"?: ComfyNodeTypedInputRef<boolean>
}


export class WanVideoEncodeMultiGPU extends ComfyNode {
	classType: string = "WanVideoEncodeMultiGPU"

	sockets: {
		inputs: Required<WanVideoEncodeMultiGPUInputs>
		outputs: {
			samples: ComfyNodeTypedSourceRef<ComfyValueType_LATENT>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"vae": new ComfyNodeTypedInputRef<ComfyValueType_WANVAE>(this, "vae"),
				"load_device": new ComfyNodeTypedInputRef<ComfyValueType_MULTIGPUDEVICE>(this, "load_device"),
				"image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image"),
				"enable_vae_tiling": new ComfyNodeTypedInputRef<boolean>(this, "enable_vae_tiling"),
				"tile_x": new ComfyNodeTypedInputRef<number>(this, "tile_x"),
				"tile_y": new ComfyNodeTypedInputRef<number>(this, "tile_y"),
				"tile_stride_x": new ComfyNodeTypedInputRef<number>(this, "tile_stride_x"),
				"tile_stride_y": new ComfyNodeTypedInputRef<number>(this, "tile_stride_y"),
				"noise_aug_strength": new ComfyNodeTypedInputRef<number>(this, "noise_aug_strength"),
				"latent_strength": new ComfyNodeTypedInputRef<number>(this, "latent_strength"),
				"mask": new ComfyNodeTypedInputRef<ComfyValueType_MASK>(this, "mask"),
			},
			outputs: Object.create(Object.prototype, {
				"samples": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoEncodeMultiGPUInputs>) {
		if (typeof sources["vae"] === "object") {
			this.sockets.inputs["vae"].connectTo(sources["vae"])
		} else {
			this.sockets.inputs["vae"].value = sources["vae"]
		}

		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}

		if (typeof sources["image"] === "object") {
			this.sockets.inputs["image"].connectTo(sources["image"])
		} else {
			this.sockets.inputs["image"].value = sources["image"]
		}

		if (typeof sources["enable_vae_tiling"] === "object") {
			this.sockets.inputs["enable_vae_tiling"].connectTo(sources["enable_vae_tiling"])
		} else {
			this.sockets.inputs["enable_vae_tiling"].value = sources["enable_vae_tiling"]
		}

		if (typeof sources["tile_x"] === "object") {
			this.sockets.inputs["tile_x"].connectTo(sources["tile_x"])
		} else {
			this.sockets.inputs["tile_x"].value = sources["tile_x"]
		}

		if (typeof sources["tile_y"] === "object") {
			this.sockets.inputs["tile_y"].connectTo(sources["tile_y"])
		} else {
			this.sockets.inputs["tile_y"].value = sources["tile_y"]
		}

		if (typeof sources["tile_stride_x"] === "object") {
			this.sockets.inputs["tile_stride_x"].connectTo(sources["tile_stride_x"])
		} else {
			this.sockets.inputs["tile_stride_x"].value = sources["tile_stride_x"]
		}

		if (typeof sources["tile_stride_y"] === "object") {
			this.sockets.inputs["tile_stride_y"].connectTo(sources["tile_stride_y"])
		} else {
			this.sockets.inputs["tile_stride_y"].value = sources["tile_stride_y"]
		}

		if (sources["noise_aug_strength"] !== undefined) {
		if (typeof sources["noise_aug_strength"] === "object") {
			this.sockets.inputs["noise_aug_strength"].connectTo(sources["noise_aug_strength"])
		} else {
			this.sockets.inputs["noise_aug_strength"].value = sources["noise_aug_strength"]
		}
		}

		if (sources["latent_strength"] !== undefined) {
		if (typeof sources["latent_strength"] === "object") {
			this.sockets.inputs["latent_strength"].connectTo(sources["latent_strength"])
		} else {
			this.sockets.inputs["latent_strength"].value = sources["latent_strength"]
		}
		}

		if (sources["mask"] !== undefined) {
		if (typeof sources["mask"] === "object") {
			this.sockets.inputs["mask"].connectTo(sources["mask"])
		} else {
			this.sockets.inputs["mask"].value = sources["mask"]
		}
		}

	}
}

type WanVideoEncodeMultiGPUInputs = {
			"vae": ComfyNodeTypedInputRef<ComfyValueType_WANVAE>
			"load_device": ComfyNodeTypedInputRef<ComfyValueType_MULTIGPUDEVICE>
			"image": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Drastically reduces memory use but may introduce seams*/
			"enable_vae_tiling": ComfyNodeTypedInputRef<boolean>
			/** Tile size in pixels, smaller values use less VRAM, may introduce more seams*/
			"tile_x": ComfyNodeTypedInputRef<number>
			/** Tile size in pixels, smaller values use less VRAM, may introduce more seams*/
			"tile_y": ComfyNodeTypedInputRef<number>
			/** Tile stride in pixels, smaller values use less VRAM, may introduce more seams*/
			"tile_stride_x": ComfyNodeTypedInputRef<number>
			/** Tile stride height in pixels, smaller values use less VRAM, may introduce more seams*/
			"tile_stride_y": ComfyNodeTypedInputRef<number>
			/** Strength of noise augmentation, helpful for leapfusion I2V where some noise can add motion and give sharper results*/
			"noise_aug_strength"?: ComfyNodeTypedInputRef<number>
			/** Additional latent multiplier, helpful for leapfusion I2V where lower values allow for more motion*/
			"latent_strength"?: ComfyNodeTypedInputRef<number>
			"mask"?: ComfyNodeTypedInputRef<ComfyValueType_MASK>
}


export class LoadWanVideoClipTextEncoderMultiGPU extends ComfyNode {
	classType: string = "LoadWanVideoClipTextEncoderMultiGPU"

	sockets: {
		inputs: Required<LoadWanVideoClipTextEncoderMultiGPUInputs>
		outputs: {
			wan_clip_vision: ComfyNodeTypedSourceRef<ComfyValueType_CLIP_VISION>
			load_device: ComfyNodeTypedSourceRef<ComfyValueType_MULTIGPUDEVICE>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model_name": new ComfyNodeTypedInputRef<string>(this, "model_name"),
				"precision": new ComfyNodeTypedInputRef<string>(this, "precision"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"wan_clip_vision": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
				"load_device": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 1 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<LoadWanVideoClipTextEncoderMultiGPUInputs>) {
		if (typeof sources["model_name"] === "object") {
			this.sockets.inputs["model_name"].connectTo(sources["model_name"])
		} else {
			this.sockets.inputs["model_name"].value = sources["model_name"]
		}

		if (typeof sources["precision"] === "object") {
			this.sockets.inputs["precision"].connectTo(sources["precision"])
		} else {
			this.sockets.inputs["precision"].value = sources["precision"]
		}

		if (sources["device"] !== undefined) {
		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}
		}

	}
}

type LoadWanVideoClipTextEncoderMultiGPUInputs = {
			/** These models are loaded from 'ComfyUI/models/clip_vision'*/
			"model_name": ComfyNodeTypedInputRef<string>
			"precision": ComfyNodeTypedInputRef<string>
			"device"?: ComfyNodeTypedInputRef<string>
}


export class WanVideoClipVisionEncodeMultiGPU extends ComfyNode {
	classType: string = "WanVideoClipVisionEncodeMultiGPU"

	sockets: {
		inputs: Required<WanVideoClipVisionEncodeMultiGPUInputs>
		outputs: {
			image_embeds: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDIMAGE_CLIPEMBEDS>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"clip_vision": new ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>(this, "clip_vision"),
				"load_device": new ComfyNodeTypedInputRef<ComfyValueType_MULTIGPUDEVICE>(this, "load_device"),
				"image_1": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image_1"),
				"strength_1": new ComfyNodeTypedInputRef<number>(this, "strength_1"),
				"strength_2": new ComfyNodeTypedInputRef<number>(this, "strength_2"),
				"crop": new ComfyNodeTypedInputRef<string>(this, "crop"),
				"combine_embeds": new ComfyNodeTypedInputRef<string>(this, "combine_embeds"),
				"force_offload": new ComfyNodeTypedInputRef<boolean>(this, "force_offload"),
				"image_2": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "image_2"),
				"negative_image": new ComfyNodeTypedInputRef<ComfyValueType_IMAGE>(this, "negative_image"),
				"tiles": new ComfyNodeTypedInputRef<number>(this, "tiles"),
				"ratio": new ComfyNodeTypedInputRef<number>(this, "ratio"),
			},
			outputs: Object.create(Object.prototype, {
				"image_embeds": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoClipVisionEncodeMultiGPUInputs>) {
		if (typeof sources["clip_vision"] === "object") {
			this.sockets.inputs["clip_vision"].connectTo(sources["clip_vision"])
		} else {
			this.sockets.inputs["clip_vision"].value = sources["clip_vision"]
		}

		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}

		if (typeof sources["image_1"] === "object") {
			this.sockets.inputs["image_1"].connectTo(sources["image_1"])
		} else {
			this.sockets.inputs["image_1"].value = sources["image_1"]
		}

		if (typeof sources["strength_1"] === "object") {
			this.sockets.inputs["strength_1"].connectTo(sources["strength_1"])
		} else {
			this.sockets.inputs["strength_1"].value = sources["strength_1"]
		}

		if (typeof sources["strength_2"] === "object") {
			this.sockets.inputs["strength_2"].connectTo(sources["strength_2"])
		} else {
			this.sockets.inputs["strength_2"].value = sources["strength_2"]
		}

		if (typeof sources["crop"] === "object") {
			this.sockets.inputs["crop"].connectTo(sources["crop"])
		} else {
			this.sockets.inputs["crop"].value = sources["crop"]
		}

		if (typeof sources["combine_embeds"] === "object") {
			this.sockets.inputs["combine_embeds"].connectTo(sources["combine_embeds"])
		} else {
			this.sockets.inputs["combine_embeds"].value = sources["combine_embeds"]
		}

		if (typeof sources["force_offload"] === "object") {
			this.sockets.inputs["force_offload"].connectTo(sources["force_offload"])
		} else {
			this.sockets.inputs["force_offload"].value = sources["force_offload"]
		}

		if (sources["image_2"] !== undefined) {
		if (typeof sources["image_2"] === "object") {
			this.sockets.inputs["image_2"].connectTo(sources["image_2"])
		} else {
			this.sockets.inputs["image_2"].value = sources["image_2"]
		}
		}

		if (sources["negative_image"] !== undefined) {
		if (typeof sources["negative_image"] === "object") {
			this.sockets.inputs["negative_image"].connectTo(sources["negative_image"])
		} else {
			this.sockets.inputs["negative_image"].value = sources["negative_image"]
		}
		}

		if (sources["tiles"] !== undefined) {
		if (typeof sources["tiles"] === "object") {
			this.sockets.inputs["tiles"].connectTo(sources["tiles"])
		} else {
			this.sockets.inputs["tiles"].value = sources["tiles"]
		}
		}

		if (sources["ratio"] !== undefined) {
		if (typeof sources["ratio"] === "object") {
			this.sockets.inputs["ratio"].connectTo(sources["ratio"])
		} else {
			this.sockets.inputs["ratio"].value = sources["ratio"]
		}
		}

	}
}

type WanVideoClipVisionEncodeMultiGPUInputs = {
			"clip_vision": ComfyNodeTypedInputRef<ComfyValueType_CLIP_VISION>
			"load_device": ComfyNodeTypedInputRef<ComfyValueType_MULTIGPUDEVICE>
			/** Image to encode*/
			"image_1": ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Additional clip embed multiplier*/
			"strength_1": ComfyNodeTypedInputRef<number>
			/** Additional clip embed multiplier*/
			"strength_2": ComfyNodeTypedInputRef<number>
			/** Crop image to 224x224 before encoding*/
			"crop": ComfyNodeTypedInputRef<string>
			/** Method to combine multiple clip embeds*/
			"combine_embeds": ComfyNodeTypedInputRef<string>
			"force_offload": ComfyNodeTypedInputRef<boolean>
			"image_2"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** image to use for uncond*/
			"negative_image"?: ComfyNodeTypedInputRef<ComfyValueType_IMAGE>
			/** Use matteo's tiled image encoding for improved accuracy*/
			"tiles"?: ComfyNodeTypedInputRef<number>
			/** Ratio of the tile average*/
			"ratio"?: ComfyNodeTypedInputRef<number>
}


export class WanVideoControlnetLoaderMultiGPU extends ComfyNode {
	classType: string = "WanVideoControlnetLoaderMultiGPU"

	sockets: {
		inputs: Required<WanVideoControlnetLoaderMultiGPUInputs>
		outputs: {
			controlnet: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOCONTROLNET>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<void>(this, "model"),
				"base_precision": new ComfyNodeTypedInputRef<string>(this, "base_precision"),
				"quantization": new ComfyNodeTypedInputRef<string>(this, "quantization"),
				"load_device": new ComfyNodeTypedInputRef<string>(this, "load_device"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"controlnet": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoControlnetLoaderMultiGPUInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["base_precision"] === "object") {
			this.sockets.inputs["base_precision"].connectTo(sources["base_precision"])
		} else {
			this.sockets.inputs["base_precision"].value = sources["base_precision"]
		}

		if (typeof sources["quantization"] === "object") {
			this.sockets.inputs["quantization"].connectTo(sources["quantization"])
		} else {
			this.sockets.inputs["quantization"].value = sources["quantization"]
		}

		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}

		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}

	}
}

type WanVideoControlnetLoaderMultiGPUInputs = {
			/** These models are loaded from the 'ComfyUI/models/controlnet' -folder*/
			"model": ComfyNodeTypedInputRef<void>
			"base_precision": ComfyNodeTypedInputRef<string>
			/** optional quantization method*/
			"quantization": ComfyNodeTypedInputRef<string>
			/** Initial device to load the model to, NOT recommended with the larger models unless you have 48GB+ VRAM*/
			"load_device": ComfyNodeTypedInputRef<string>
			"device": ComfyNodeTypedInputRef<string>
}


export class FantasyTalkingModelLoaderMultiGPU extends ComfyNode {
	classType: string = "FantasyTalkingModelLoaderMultiGPU"

	sockets: {
		inputs: Required<FantasyTalkingModelLoaderMultiGPUInputs>
		outputs: {
			model: ComfyNodeTypedSourceRef<ComfyValueType_FANTASYTALKINGMODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<string>(this, "model"),
				"base_precision": new ComfyNodeTypedInputRef<string>(this, "base_precision"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<FantasyTalkingModelLoaderMultiGPUInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["base_precision"] === "object") {
			this.sockets.inputs["base_precision"].connectTo(sources["base_precision"])
		} else {
			this.sockets.inputs["base_precision"].value = sources["base_precision"]
		}

		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}

	}
}

type FantasyTalkingModelLoaderMultiGPUInputs = {
			/** These models are loaded from the 'ComfyUI/models/diffusion_models' -folder*/
			"model": ComfyNodeTypedInputRef<string>
			"base_precision": ComfyNodeTypedInputRef<string>
			"device": ComfyNodeTypedInputRef<string>
}


export class Wav2VecModelLoaderMultiGPU extends ComfyNode {
	classType: string = "Wav2VecModelLoaderMultiGPU"

	sockets: {
		inputs: Required<Wav2VecModelLoaderMultiGPUInputs>
		outputs: {
			wav2vec_model: ComfyNodeTypedSourceRef<ComfyValueType_WAV2VECMODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<void>(this, "model"),
				"base_precision": new ComfyNodeTypedInputRef<string>(this, "base_precision"),
				"load_device": new ComfyNodeTypedInputRef<string>(this, "load_device"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"wav2vec_model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<Wav2VecModelLoaderMultiGPUInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["base_precision"] === "object") {
			this.sockets.inputs["base_precision"].connectTo(sources["base_precision"])
		} else {
			this.sockets.inputs["base_precision"].value = sources["base_precision"]
		}

		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}

		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}

	}
}

type Wav2VecModelLoaderMultiGPUInputs = {
			/** These models are loaded from the 'ComfyUI/models/wav2vec2' -folder*/
			"model": ComfyNodeTypedInputRef<void>
			"base_precision": ComfyNodeTypedInputRef<string>
			/** Initial device to load the model to, NOT recommended with the larger models unless you have 48GB+ VRAM*/
			"load_device": ComfyNodeTypedInputRef<string>
			"device": ComfyNodeTypedInputRef<string>
}


export class WanVideoUni3C_ControlnetLoaderMultiGPU extends ComfyNode {
	classType: string = "WanVideoUni3C_ControlnetLoaderMultiGPU"

	sockets: {
		inputs: Required<WanVideoUni3C_ControlnetLoaderMultiGPUInputs>
		outputs: {
			controlnet: ComfyNodeTypedSourceRef<ComfyValueType_WANVIDEOCONTROLNET>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<void>(this, "model"),
				"base_precision": new ComfyNodeTypedInputRef<string>(this, "base_precision"),
				"quantization": new ComfyNodeTypedInputRef<string>(this, "quantization"),
				"load_device": new ComfyNodeTypedInputRef<string>(this, "load_device"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
				"attention_mode": new ComfyNodeTypedInputRef<string>(this, "attention_mode"),
				"compile_args": new ComfyNodeTypedInputRef<ComfyValueType_WANCOMPILEARGS>(this, "compile_args"),
			},
			outputs: Object.create(Object.prototype, {
				"controlnet": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<WanVideoUni3C_ControlnetLoaderMultiGPUInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["base_precision"] === "object") {
			this.sockets.inputs["base_precision"].connectTo(sources["base_precision"])
		} else {
			this.sockets.inputs["base_precision"].value = sources["base_precision"]
		}

		if (typeof sources["quantization"] === "object") {
			this.sockets.inputs["quantization"].connectTo(sources["quantization"])
		} else {
			this.sockets.inputs["quantization"].value = sources["quantization"]
		}

		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}

		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}

		if (typeof sources["attention_mode"] === "object") {
			this.sockets.inputs["attention_mode"].connectTo(sources["attention_mode"])
		} else {
			this.sockets.inputs["attention_mode"].value = sources["attention_mode"]
		}

		if (sources["compile_args"] !== undefined) {
		if (typeof sources["compile_args"] === "object") {
			this.sockets.inputs["compile_args"].connectTo(sources["compile_args"])
		} else {
			this.sockets.inputs["compile_args"].value = sources["compile_args"]
		}
		}

	}
}

type WanVideoUni3C_ControlnetLoaderMultiGPUInputs = {
			/** These models are loaded from the 'ComfyUI/models/controlnet' -folder*/
			"model": ComfyNodeTypedInputRef<void>
			"base_precision": ComfyNodeTypedInputRef<string>
			/** optional quantization method*/
			"quantization": ComfyNodeTypedInputRef<string>
			/** Initial device to load the model to, NOT recommended with the larger models unless you have 48GB+ VRAM*/
			"load_device": ComfyNodeTypedInputRef<string>
			"device": ComfyNodeTypedInputRef<string>
			"attention_mode": ComfyNodeTypedInputRef<string>
			"compile_args"?: ComfyNodeTypedInputRef<ComfyValueType_WANCOMPILEARGS>
}


export class DownloadAndLoadWav2VecModelMultiGPU extends ComfyNode {
	classType: string = "DownloadAndLoadWav2VecModelMultiGPU"

	sockets: {
		inputs: Required<DownloadAndLoadWav2VecModelMultiGPUInputs>
		outputs: {
			wav2vec_model: ComfyNodeTypedSourceRef<ComfyValueType_WAV2VECMODEL>
		}
	}

	constructor() {
		super()
		const $node = this
		this.sockets = {
			inputs: {
				"model": new ComfyNodeTypedInputRef<string>(this, "model"),
				"base_precision": new ComfyNodeTypedInputRef<string>(this, "base_precision"),
				"load_device": new ComfyNodeTypedInputRef<string>(this, "load_device"),
				"device": new ComfyNodeTypedInputRef<string>(this, "device"),
			},
			outputs: Object.create(Object.prototype, {
				"wav2vec_model": {
					configurable: false,
					get: function () {
						return { sourceNodeId: $node.id, sourceNodeOutputIndex: 0 }
					}
				},
			})
		}
	}

	connectAll(sources: MappedSources<DownloadAndLoadWav2VecModelMultiGPUInputs>) {
		if (typeof sources["model"] === "object") {
			this.sockets.inputs["model"].connectTo(sources["model"])
		} else {
			this.sockets.inputs["model"].value = sources["model"]
		}

		if (typeof sources["base_precision"] === "object") {
			this.sockets.inputs["base_precision"].connectTo(sources["base_precision"])
		} else {
			this.sockets.inputs["base_precision"].value = sources["base_precision"]
		}

		if (typeof sources["load_device"] === "object") {
			this.sockets.inputs["load_device"].connectTo(sources["load_device"])
		} else {
			this.sockets.inputs["load_device"].value = sources["load_device"]
		}

		if (typeof sources["device"] === "object") {
			this.sockets.inputs["device"].connectTo(sources["device"])
		} else {
			this.sockets.inputs["device"].value = sources["device"]
		}

	}
}

type DownloadAndLoadWav2VecModelMultiGPUInputs = {
			"model": ComfyNodeTypedInputRef<string>
			"base_precision": ComfyNodeTypedInputRef<string>
			/** Initial device to load the model to, NOT recommended with the larger models unless you have 48GB+ VRAM*/
			"load_device": ComfyNodeTypedInputRef<string>
			"device": ComfyNodeTypedInputRef<string>
}


